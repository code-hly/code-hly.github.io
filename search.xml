<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++虚继承下的内存模型]]></title>
    <url>%2F2019%2F05%2F25%2FC%2B%2B%E8%99%9A%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[简单的面向对象，只有单继承或多继承的情况下，内存模型很好理解，编译器实现起来也容易，C++ 的效率和 C 的效率不相上下。一旦和 virtual 关键字扯上关系，使用到虚继承或虚函数，内存模型就变得混乱起来，各种编译器的实现也不一致，让人抓狂。 虚继承下的内存模型​ 这是因为 C++ 标准仅对 C++ 的实现做了框架‘性的概述，并没有规定细节如何实现，所以不同厂商的编译器在具体实现方案上会有所差异。​​ 对于普通继承，基类子对象始终位于派生类对象的前面（也即基类成员变量始终在派生类成员变量的前面），而且不管继承层次有多深，它相对于派生类对象顶部的偏移量是固定的。请看下面的例子： 1234567891011121314151617181920212223242526272829303132class A&#123;protected: int m_a1; int m_a2;&#125;;class B: public A&#123;protected: int b1; int b2;&#125;;class C: public B&#123;protected: int c1; int c2;&#125;;class D: public C&#123;protected: int d1; int d2;&#125;;int main()&#123; A obj_a; B obj_b; C obj_c; D obj_d; return 0;&#125; ​ obj_a、obj_b、obj_c、obj_d 的内存模型如下所示： A 是最顶层的基类，在派生类 B、C、D 的对象中，A 类子对象始终位于最前面，偏移量是固定的，为 0。`b1`、`b2` 是派生类 B 的新增成员变量，它们的偏移量也是固定的，分别为 8 和 12。`c1`、`c2`、`d1`、`d2` 也是同样的道理。 ​ 前面我们说过，编译器在知道对象首地址的情况下，通过计算偏移来存取成员变量。对于普通继承，基类成员变量的偏移是固定的，不会随着继承层级的增加而改变，存取起来非常方便。 ​ 而对于虚继承，恰恰和普通继承相反，大部分编译器会把基类成员变量放在派生类成员变量的后面，这样随着继承层级的增加，基类成员变量的偏移就会改变，就得通过其他方案来计算偏移量。 ​ 下面我们来一步一步地分析虚继承时的对象内存模型。 1) 修改上面的代码，使得 A 是 B 的虚基类：1class B: virtual public A 此时 obj_b、obj_c、obj_d 的内存模型就会发生变化，如下图所示： **不管是虚基类的直接派生类还是间接派生类，虚基类的子对象始终位于派生类对象的最后面**。 2) 再假设 A 是 B 的虚基类，B 又是 C 的虚基类，那么各个对象的内存模型如下图所示： 从上面的两张图中可以发现，虚继承时的派生类对象被分成了两部分： 不带阴影的一部分偏移量固定，不会随着继承层次的增加而改变，称为固定部分； 带有阴影的一部分是虚基类的子对象，偏移量会随着继承层次的增加而改变，称为共享部分。 ​ 当要访问对象的成员变量时，需要知道对象的首地址和变量的偏移，对象的首地址很好获得，关键是变量的偏移。对于固定部分，偏移是不变的，很好计算；而对于共享部分，偏移会随着继承层次的增加而改变，这就需要设计一种方案，在偏移不断变化的过程中准确地计算偏移。各个编译器正是在设计这一方案时出现了分歧，不同的编译器设计了不同的方案来计算共享部分的偏移。 对于虚继承，将派生类分为**固定部分**和**共享部分**，并把共享部分放在最后，几乎所有的编译器都在这一点上达成了共识。主要的分歧就是如何计算共享部分的偏移，可谓是百花齐放，没有统一标准。 cfront解决方案​ 早期的 cfront 编译器会在派生类对象中安插一些指针，每个指针指向一个虚基类的子对象，要存取继承来的成员变量，可以使用指针间接完成。 1) 如果 A 是 B 的虚基类，那么各个对象的实际内存模型如下所示： ​ 编译器会在直接派生类的对象 obj_b 中安插一个指针，指向虚基类 A 的起始位置，并且这个指针的偏移是固定的，不会随着继承层次的增加而改变。当要访问 a1、a2 时，要先通过对象指针找到 pa，再通过 pa 找到 a1、a2，这样一来就比没有虚继承时多了一层间接。 ​ 假设 p 是obj_d 的指针，现在要访问成员变量 a2：1int member_a2 = p -&gt; a2; 那么编译器内部会进行类似下面的转换： 12A *pa = (A*)( *(int*)( (int)p + sizeof(int)*2 ) );int member_a2 = *(int*)( (int)pa + sizeof(int) ); 2) 如果 A 是 B 的虚基类，同时 B 也是 C 的虚基类，那么各个对象的实际内存模型如下所示： ​ 当要访问 a1、a2 时，要先通过对象指针找到 pb，再通过 pb 找到 pa，最后才能通过 pa 找到 a1、a2，这样一来就比没有虚继承时多了两层间接。 ​ 通过上面的分析可以发现，这种方案的一个缺点就是，随着虚继承层次的增加，访问顶层基类需要的间接转换会越来越多，效率越来越低。 ​ 这种方案另外的一个缺点是：当有多个虚基类时，派生类要为每个虚基类都安插一个指针，会增加对象的体积。 ​ 例如，假设 A、B、C、D 类的继承关系为： ​ obj_d 的内存模型如下图所示： D 有三个虚基类，所以 obj_d 对象要额外背负三个指针 pa、pab、pc。 VC解决方案​ cfront 的后来者 VC 尝试对上面的方案进行了改进，一定程度上弥补了它的不足。 ​ VC 引入了虚基类表，如果某个派生类有一个或多个虚基类，编译器就会在派生类对象中安插一个指针，指向虚基类表。虚基类表其实就是一个数组，数组中的元素存放的是各个虚基类的偏移。 ​ 假设 A 是 B 的虚基类，那么各对象的内存模型如下图所示： 假设 A 是 B 的虚基类，同时 B 又是 C 的虚基类，那么各对象的内存模型如下图所示： ​ 虚继承表中保存的是所有虚基类（包括直接继承和间接继承到的）相对于当前对象的偏移，这样通过派生类指针访问虚基类的成员变量时，不管继承层次都多深，只需要一次间接转换就可以。 ​ 另外，这种方案还可以避免有多个虚基类时让派生类对象额外背负过多的指针。例如，假设 A、B、C、D 类的继承关系为： 那么 obj_d 的内存模型如下图所示： 如此一来，D 类虽然有三个虚基类，但它的对象 obj_d 只需要额外背负一个指针。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象内存分布和编译实现]]></title>
    <url>%2F2019%2F05%2F25%2FC%2B%2B%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%92%8C%E7%BC%96%E8%AF%91%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[类是创建对象的模板，不占用内存空间，不存在于编译后的可执行文件中；而对象是实实在在的数据，需要内存来存储。对象被创建时会在栈区或者堆区分配内存。 C++对象内存分布​ 直观的认识是，如果创建了 10 个对象，就要分别为这 10 个对象的成员变量和成员函数分配内存，如下图所示： ​ 不同对象的成员变量的值可能不同，需要单独分配内存来存储。但是不同对象的成员函数的代码是一样的，上面的内存模型保存了 10 分相同的代码片段，浪费了不少空间，可以将这些代码片段压缩成一份。 ​ 事实上编译器也是这样做的，编译器会将成员变量和成员函数分开存储：分别为每个对象的成员变量分配内存，但是所有对象都共享同一段函数代码。 如下图所示： ​ 成员变量在堆区或栈区分配内存，成员函数在代码区分配内存。 【示例】使用 sizeof 获取对象所占内存的大小： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;class Student&#123;private: char *m_name; int m_age; float m_score;public: void setname(char *name); void setage(int age); void setscore(float score); void show();&#125;;void Student::setname(char *name)&#123; m_name = name;&#125;void Student::setage(int age)&#123; m_age = age;&#125;void Student::setscore(float score)&#123; m_score = score;&#125;void Student::show()&#123; cout&lt;&lt;m_name&lt;&lt;"的年龄是"&lt;&lt;m_age&lt;&lt;"，成绩是"&lt;&lt;m_score&lt;&lt;endl;&#125;int main()&#123; //在栈上创建对象 Student stu; cout&lt;&lt;sizeof(stu)&lt;&lt;endl; //在堆上创建对象 Student *pstu = new Student(); cout&lt;&lt;sizeof(*pstu)&lt;&lt;endl; //类的大小 cout&lt;&lt;sizeof(Student)&lt;&lt;endl; return 0;&#125; 运行结果：123121212 ​ Student 类包含三个成员变量，它们的类型分别是char *、int、float，都占用 4 个字节的内存，加起来共占用 12 个字节的内存。通过 sizeof 求得的结果等于 12，恰好说明对象所占用的内存仅仅包含了成员变量。 ​ 类可以看做是一种复杂的数据类型，也可以使用 sizeof 求得该类型的大小。从运行结果可以看出，在计算类这种类型的大小时，只计算了成员变量的大小，并没有把成员函数也包含在内。 ​ 对象的大小只受成员变量的影响，和成员函数没有关系。 ​ 假设 stu 的起始地址为 0X1000，那么该对象的内存分布如下图所示： ​ m_name、m_age、m_score 按照声明的顺序依次排列，和结构体非常类似，也会有内存对齐的问题。 ​ 从上节的分析中可以看出，对象的内存中只保留了成员变量，除此之外没有任何其他信息，程序运行时不知道 stu 的类型为 Student，也不知道它还有四个成员函数 setname()、setage()、setscore()、show()，C++ 究竟是如何通过对象调用成员函数的呢？ C++函数的编译​ C++和C语言的编译方式不同。C语言中的函数在编译时名字不变，或者只是简单的加一个下划线_（不同的编译器有不同的实现），例如，func() 编译后为 func() 或_func()。 ​ 而C++中的函数在编译时会根据它所在的命名空间、它所属的类、以及它的参数列表（也叫参数签名）等信息进行重新命名，形成一个新的函数名。这个新的函数名只有编译器知道，对用户是不可见的。对函数重命名的过程叫做名字编码（Name Mangling），是通过一种特殊的算法来实现的。 ​ Name Mangling 的算法是可逆的，既可以通过现有函数名计算出新函数名，也可以通过新函数名逆向推演出原有函数名。Name Mangling 可以确保新函数名的唯一性，只要函数所在的命名空间、所属的类、包含的参数列表等有一个不同，最后产生的新函数名也不同。 ​ 如果你希望看到经 Name Mangling 产生的新函数名，可以只声明而不定义函数，这样调用函数时就会产生链接错误，从报错信息中就可以看到新函数名。请看下面的代码： 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;void display();void display(int);namespace ns&#123; void display();&#125;class Demo&#123;public: void display();&#125;;int main()&#123; display(); display(1); ns::display(); Demo obj; obj.display(); return 0;&#125; ​ 该例中声明了四个同名函数，包括两个具有重载关系的全局函数，一个位于命名空间 ns下的函数，以及一个属于类 Demo 的函数。它们都是只声明而未定义的函数。 ​ 在 VS 下编译源代码可以看到类似下面的错误信息： ​ 小括号中就是经 Name Mangling 产生的新函数名，它们都以?开始，以区别C语言中的_。 ​ 上图是 VS2010 产生的错误信息，不同的编译器有不同的 Name Mangling 算法，产生的函数名也不一样。 __thiscall、cdecl 是函数调用惯例。 ​ 除了函数，某些变量也会经 Name Mangling 算法产生新名字，这里不再赘述。 成员函数的调用​ 从上图可以看出，成员函数最终被编译成与对象无关的全局函数，如果函数体中没有成员变量，那问题就很简单，不用对函数做任何处理，直接调用即可。 ​ 如果成员函数中使用到了成员变量该怎么办呢？成员变量的作用域不是全局，不经任何处理就无法在函数内部访问。 ​ C++规定，编译成员函数时要额外添加一个参数，把当前对象的指针传递进去，通过指针来访问成员变量。 ​ 假设 Demo 类有两个 int 型的成员变量，分别是 a 和 b，并且在成员函数 display() 中使用到了，如下所示： 1234void Demo::display()&#123; cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;b&lt;&lt;endl;&#125; ​ 那么编译后的代码类似于： 12345void new_function_name(Demo * const p)&#123; //通过指针p来访问a、b cout&lt;&lt;p-&gt;a&lt;&lt;endl; cout&lt;&lt;p-&gt;b&lt;&lt;endl;&#125; ​ 使用obj.display()调用函数时，也会被编译成类似下面的形式： 1new_function_name(&amp;obj); ​ 这样通过传递对象指针就完成了成员函数和成员变量的关联。这与我们从表明上看到的刚好相反，通过对象调用成员函数时，不是通过对象找函数，而是通过函数找对象。 ​ 这一切都是隐式完成的，对程序员来说完全透明，就好像这个额外的参数不存在一样。 ​ 最后需要提醒的是，Demo * const p中的 const表示指针不能被修改，p 只能指向当前对象，不能指向其他对象。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++虚继承和虚基类]]></title>
    <url>%2F2019%2F05%2F25%2Fc%2B%2B%E8%99%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[多继承（Multiple Inheritance）是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。 多继承（Multiple Inheritance）​ 多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是菱形继承，如下图所示： ​ 类 A 派生出类 B 和类 C，类 D 继承自类 B 和类 C，这个时候类 A 中的成员变量和成员函数继承到类 D 中变成了两份，一份来自 A--&gt;B--&gt;D 这条路径，另一份来自A--&gt;C--&gt;D 这条路径。 ​ 在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A --&gt;B--&gt;D 这条路径，还是来自 A--&gt;C--&gt;D 这条路径。下面是菱形继承的具体实现：123456789101112131415161718192021222324252627282930313233//间接基类Aclass A&#123;protected: int m_a;&#125;;//直接基类Bclass B: public A&#123;protected: int m_b;&#125;;//直接基类Cclass C: public A&#123;protected: int m_c;&#125;;//派生类Dclass D: public B, public C&#123;public: void seta(int a)&#123; m_a = a; &#125; //命名冲突 void setb(int b)&#123; m_b = b; &#125; //正确 void setc(int c)&#123; m_c = c; &#125; //正确 void setd(int d)&#123; m_d = d; &#125; //正确private: int m_d;&#125;;int main()&#123; D d; return 0;&#125; ​ 这段代码实现了上图所示的菱形继承，第 25 行代码试图直接访问成员变量 m_a，结果发生了错误，因为类 B 和类 C 中都有成员变量 m_a（从 A 类继承而来），编译器不知道选用哪一个，所以产生了歧义。 ​ 为了消除歧义，我们可以在 m_a 的前面指明它具体来自哪个类：1void seta(int a)&#123; B::m_a = a; &#125; ​ 这样表示使用 B 类的 m_a。当然也可以使用 C 类的：1void seta(int a)&#123; C::m_a = a; &#125; 虚继承（Virtual Inheritance）​ 为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。1234567891011121314151617181920212223242526272829303132333435在继承方式前面加上 virtual 关键字就是虚继承，请看下面的例子：//间接基类Aclass A&#123;protected: int m_a;&#125;;//直接基类Bclass B: virtual public A&#123; //虚继承protected: int m_b;&#125;;//直接基类Cclass C: virtual public A&#123; //虚继承protected: int m_c;&#125;;//派生类Dclass D: public B, public C&#123;public: void seta(int a)&#123; m_a = a; &#125; //正确 void setb(int b)&#123; m_b = b; &#125; //正确 void setc(int c)&#123; m_c = c; &#125; //正确 void setd(int d)&#123; m_d = d; &#125; //正确private: int m_d;&#125;;int main()&#123; D d; return 0;&#125; ​ 这段代码使用虚继承重新实现了上图所示的菱形继承，这样在派生类 D 中就只保留了一份成员变量 m_a，直接访问就不会再有歧义了。 ​ 虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。 ​ 现在让我们重新梳理一下本例的继承关系，如下图所示： ​ 观察这个新的继承体系，我们会发现虚继承的一个不太直观的特征：必须在虚派生的真实需求出现前就已经完成虚派生的操作。在上图中，当定义 D 类时才出现了对虚派生的需求，但是如果 B 类和 C 类不是从 A 类虚派生得到的，那么 D 类还是会保留 A 类的两份成员。 ​ 换个角度讲，虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。 ​ 在实际开发中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题。通常情况下，使用虚继承的类层次是由一个人或者一个项目组一次性设计完成的。对于一个独立开发的类来说，很少需要基类中的某一个类是虚基类，况且新类的开发者也无法改变已经存在的类体系。 ​ C++标准库中的 iostream 类就是一个虚继承的实际应用案例。iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。此时istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员。 虚基类成员的可见性​ 因为在虚继承的最终派生类中只保留了一份虚基类的成员，所以该成员可以被直接访问，不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，那么仍然可以直接访问这个被覆盖的成员。但是如果该成员被两条或多条路径覆盖了，那就不能直接访问了，此时必须指明该成员属于哪个类。 ​ 以图2中的菱形继承为例，假设 B 定义了一个名为 x 的成员变量，当我们在 D 中直接访问 x 时，会有三种可能性： 如果 B 和 C 中都没有 x 的定义，那么 x 将被解析为 B 的成员，此时不存在二义性。如果 B 或 C 其中的一个类定义了 x，也不会有二义性，派生类的 x 比虚基类的 x 优先级更高。如果 B 和 C 中都定义了 x，那么直接访问 x 将产生二义性问题。 ​ 可以看到，使用多继承经常会出现二义性问题，必须十分小心。上面的例子是简单的，如果继承的层次再多一些，关系更复杂一些，程序员就很容易陷人迷魂阵，程序的编写、调试和维护工作都会变得更加困难，因此我不提倡在程序中使用多继承，只有在比较简单和不易出现二义性的情况或实在必要时才使用多继承，能用单一继承解决的问题就不要使用多继承。也正是由于这个原因，C++ 之后的很多面向对象的编程语言，例如 Java、C#、PHP 等，都不支持多继承。 虚继承时的构造函数​ 在虚继承中，虚基类是由最终的派生类初始化的，换句话说，最终派生类的构造函数必须要调用虚基类的构造函数。对最终的派生类来说，虚基类是间接基类，而不是直接基类。这跟普通继承不同，在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。 下面我们以菱形继承为例来演示构造函数的调用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;//虚基类Aclass A&#123;public: A(int a);protected: int m_a;&#125;;A::A(int a): m_a(a)&#123; &#125;//直接派生类Bclass B: virtual public A&#123;public: B(int a, int b);public: void display();protected: int m_b;&#125;;B::B(int a, int b): A(a), m_b(b)&#123; &#125;void B::display()&#123; cout&lt;&lt;"m_a="&lt;&lt;m_a&lt;&lt;", m_b="&lt;&lt;m_b&lt;&lt;endl;&#125;//直接派生类Cclass C: virtual public A&#123;public: C(int a, int c);public: void display();protected: int m_c;&#125;;C::C(int a, int c): A(a), m_c(c)&#123; &#125;void C::display()&#123; cout&lt;&lt;"m_a="&lt;&lt;m_a&lt;&lt;", m_c="&lt;&lt;m_c&lt;&lt;endl;&#125;//间接派生类Dclass D: public B, public C&#123;public: D(int a, int b, int c, int d);public: void display();private: int m_d;&#125;;D::D(int a, int b, int c, int d): A(a), B(90, b), C(100, c), m_d(d)&#123; &#125;void D::display()&#123; cout&lt;&lt;"m_a="&lt;&lt;m_a&lt;&lt;", m_b="&lt;&lt;m_b&lt;&lt;", m_c="&lt;&lt;m_c&lt;&lt;", m_d="&lt;&lt;m_d&lt;&lt;endl;&#125;int main()&#123; B b(10, 20); b.display(); C c(30, 40); c.display(); D d(50, 60, 70, 80); d.display(); return 0;&#125; 运行结果：123m_a=10, m_b=20m_a=30, m_c=40m_a=50, m_b=60, m_c=70, m_d=80 ​ 请注意第 50 行代码，在最终派生类 D 的构造函数中，除了调用 B 和 C 的构造函数，还调用了 A 的构造函数，这说明 D 不但要负责初始化直接基类 B 和 C，还要负责初始化间接基类 A。而在以往的普通继承中，派生类的构造函数只负责初始化它的直接基类，再由直接基类的构造函数初始化间接基类，用户尝试调用间接基类的构造函数将导致错误。 ​ 现在采用了虚继承，虚基类 A 在最终派生类 D 中只保留了一份成员变量 m_a，如果由 B 和 C 初始化 m_a，那么 B 和 C 在调用 A 的构造函数时很有可能给出不同的实参，这个时候编译器就会犯迷糊，不知道使用哪个实参初始化 m_a。 ​ 为了避免出现这种矛盾的情况，C++ 干脆规定必须由最终的派生类 D 来初始化虚基类 A，直接派生类 B 和 C 对 A 的构造函数的调用是无效的。在第 50 行代码中，调用 B 的构造函数时试图将 m_a 初始化为 90，调用 C 的构造函数时试图将 m_a 初始化为 100，但是输出结果有力地证明了这些都是无效的，m_a 最终被初始化为 50，这正是在 D 中直接调用 A 的构造函数的结果。 ​ 另外需要关注的是构造函数的执行顺序。虚继承时构造函数的执行顺序与普通继承时不同：在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何，编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数；而对于普通继承，就是按照构造函数出现的顺序依次调用的。 修改本例中第 50 行代码，改变构造函数出现的顺序： 1D::D(int a, int b, int c, int d): B(90, b), C(100, c), A(a), m_d(d)&#123; &#125; ​ 虽然我们将 A() 放在了最后，但是编译器仍然会先调用 A()，然后再调用 B()、C()，因为 A() 是虚基类的构造函数，比其他构造函数优先级高。如果没有使用虚继承的话，那么编译器将按照出现的顺序依次调用 B()、C()、A()。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++拷贝控制操作]]></title>
    <url>%2F2019%2F05%2F25%2Fc%2B%2B%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[当定义一个类时，我们显式地或隐式地指定了此类型的对象在拷贝、赋值和销毁时做什么。一个类通过定义三种特殊的成员函数来控制这些操作，分别是拷贝构造函数、赋值运算符和析构函数。 拷贝构造函数定义了当用同类型的另一个对象初始化新对象时做什么，赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么，析构函数定义了此类型的对象销毁时做什么。我们将这些操作称为拷贝控制操作。 拷贝控制操作 由于拷贝控制操作是由三个特殊的成员函数来完成的，所以我们称此为“C++三法则”。在较新的 C++11 标准中，为了支持移动语义，又增加了移动构造函数和移动赋值运算符，这样共有五个特殊的成员函数，所以又称为“C++五法则”。也就是说，“三法则”是针对较旧的 C++89 标准说的，“五法则”是针对较新的 C++11 标准说的。为了统一称呼，后来人们干把它叫做“C++ 三/五法则”。 ​ 如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义默认的操作，因此很多类会忽略这些拷贝控制操作。但是，对于一些持有其他资源（例如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等）的类来说，依赖这些默认的操作会导致灾难，我们必须显式的定义这些操作。 ​ C++ 并不要求我们定义所有的这些操作，你可以只定义其中的一个或两个。但是，这些操作通常应该被看做一个整体，只需要定义其中一个操作，而不需要定义其他操作的情况很少见。 需要析构函数的类也需要拷贝和赋值操作​ 当我们决定是否要为一个类显式地定义拷贝构造函数和赋值运算符时，一个基本原则是首先确定这个类是否需要一个析构函数。通常，对析构函数的需求要比拷贝构造函数和赋值运算符的需求更加明显。如果一个类需要定义析构函数，那么几乎可以肯定这个类也需要一个拷贝构造函数和一个赋值运算符。 ​ 我们在前面几节中使用过的 Array 类就是一个典型的例子。这个类在构造函数中动态地分配了一块内存，并用一个成员变量（指针变量）指向它，默认的析构函数不会释放这块内存，所以我们需要显式地定义一个析构函数来释放内存。 ​ 「应该怎么做」可能还是有点不清晰，但基本原则告诉我们，Array 类也需要一个拷贝构造函数和一个赋值运算符。 ​ 如果我们为 Array 定义了一个析构函数，但却使用默认的拷贝构造函数和赋值运算符，那么将导致不同对象之间相互干扰，修改一个对象的数据会影响另外的对象。此外还可能会导致内存操作错误，请看下面的代码： 1234Array func(Array arr)&#123; //按值传递，将发生拷贝 Array ret = arr; //发生拷贝 return ret; //ret和arr将被销毁&#125; ​ 当 func()返回时，arr 和 ret `都会被销毁，在两个对象上都会调用析构函数，此析构函数会 free()掉 m_p 成员所指向的动态内存。但是，这两个对象的 m_p 成员指向的是同一块内存，所以该内存会被free()` 两次，这显然是一个错误，将要发生什么是未知的。 ​ 此外，func()的调用者还会继续使用传递给func()的对象： 123Array arr1(10);func(arr1); //当 func() 调用结束时，arr1.m_p 指向的内存被释放Array arr2 = arr1; //现在 arr2 和 arr1 都指向无效内存 ​ arr2（以及 arr1）指向的内存不再有效，在arr（以及 ret）被销毁时系统已经归还给操作系统了。 ​ 总之，如果一个类需要定义析构函数，那么几乎可以肯定它也需要定义拷贝构造函数和赋值运算符。 需要拷贝操作的类也需要赋值操作，反之亦然​ 虽然很多类需要定义所有（或是不需要定义任何）拷贝控制成员，但某些类所要完成的工作，只需要拷贝或者赋值操作，不需要析构操作。 ​ 作为一个例子，考虑一个类为每个对象分配一个独有的、唯一的编号。这个类除了需要一个拷贝构造函数为每个新创建的对象生成一个新的编号，还需要一个赋值运算符来避免将一个对象的编号赋值给另外一个对象。但是，这个类并不需要析构函数。 ​ 这个例子引出了第二个基本原则：如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个赋值运算符；反之亦然。然而，无论需要拷贝构造函数还是需要复制运算符，都不必然意味着也需要析构函数。 ​ 在 C/C++ 中，不同的数据类型之间可以相互转换。无需用户指明如何转换的称为自动类型转换（隐式类型转换），需要用户显式地指明如何转换的称为强制类型转换。 自动类型转换示例： 12int a = 6;a = 7.5 + a; ​ 编译器对 7.5 是作为 double 类型处理的，在求解表达式时，先将 a 转换为 double 类型，然后与 7.5 相加，得到和为 13.5。在向整型变量 a 赋值时，将 13.5 转换为整数 13，然后赋给 a。整个过程中，我们并没有告诉编译器如何去做，编译器使用内置的规则完成数据类型的转换。 ​ 强制类型转换示例： 123int n = 100;int *p1 = &amp;n;float *p2 = (float*)p1; ​ p1 是int *类型，它指向的内存里面保存的是整数，p2 是float *类型，将 p1 赋值给 p2后，p2 也指向了这块内存，并把这块内存中的数据作为小数处理。我们知道，整数和小数的存储格式大相径庭，将整数作为小数处理非常荒诞，可能会引发莫名其妙的错误，所以编译器默认不允许将 p1赋值给p2。但是，使用强制类型转换后，编译器就认为我们知道这种风险的存在，并进行了适当的权衡，所以最终还是允许了这种行为。 ​ 不管是自动类型转换还是强制类型转换，前提必须是编译器知道如何转换，例如，将小数转换为整数会抹掉小数点后面的数字，将int *转换为float *只是简单地复制指针的值，这些规则都是编译器内置的，我们并没有告诉编译器。 ​ 换句话说，如果编译器不知道转换规则就不能转换，使用强制类型也无用，请看下面的例子： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;//复数类class Complex&#123;public: Complex(): m_real(0.0), m_imag(0.0)&#123; &#125; Complex(double real, double imag): m_real(real), m_imag(imag)&#123; &#125;public: friend ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c); //友元函数private: double m_real; //实部 double m_imag; //虚部&#125;;//重载&gt;&gt;运算符ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123; out &lt;&lt; c.m_real &lt;&lt;" + "&lt;&lt; c.m_imag &lt;&lt;"i";; return out;&#125;int main()&#123; Complex a(10.0, 20.0); a = (Complex)25.5; //错误，转换失败 return 0;&#125; ​ 25.5 是实数，a 是复数，将 25.5 赋值给 a 后，我们期望 a 的实部变为 25.5，而虚部为 0。但是，编译器并不知道这个转换规则，这超出了编译器的处理能力，所以转换失败，即使加上强制类型转换也无用。 ​ 幸运的是，C++ 允许我们自定义类型转换规则，用户可以将其它类型转换为当前类类型，也可以将当前类类型转换为其它类型。这种自定义的类型转换规则只能以类的成员函数的形式出现，换句话说，这种转换规则只适用于类。 ​ 本节我们先讲解如何将其它类型转换为当前类类型，下节再讲解如何将当前类类型转换为其它类型。 转换构造函数​ 将其它类型转换为当前类类型需要借助转换构造函数（Conversion constructor）。 ​ 转换构造函数也是一种构造函数，它遵循构造函数的一般规则。转换构造函数只有一个参数。 ​ 仍然以 Complex 类为例，我们为它添加转换构造函数： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;//复数类class Complex&#123;public: Complex(): m_real(0.0), m_imag(0.0)&#123; &#125; Complex(double real, double imag): m_real(real), m_imag(imag)&#123; &#125; Complex(double real): m_real(real), m_imag(0.0)&#123; &#125; //转换构造函数public: friend ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c); //友元函数private: double m_real; //实部 double m_imag; //虚部&#125;;//重载&gt;&gt;运算符ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123; out &lt;&lt; c.m_real &lt;&lt;" + "&lt;&lt; c.m_imag &lt;&lt;"i";; return out;&#125;int main()&#123; Complex a(10.0, 20.0); cout&lt;&lt;a&lt;&lt;endl; a = 25.5; //调用转换构造函数 cout&lt;&lt;a&lt;&lt;endl; return 0;&#125; 运行结果： 12310 + 20i25.5 + 0i ​ Complex(double real);就是转换构造函数，它的作用是将 double 类型的参数 real 转换成 Complex 类的对象，并将 real 作为复数的实部，将 0 作为复数的虚部。这样一来，a = 25.5;整体上的效果相当于：1a.Complex(25.5); ​ 将赋值的过程转换成了函数调用的过程。 ​ 在进行数学运算、赋值、拷贝等操作时，如果遇到类型不兼容、需要将 double 类型转换为 Complex 类型时，编译器会检索当前的类是否定义了转换构造函数，如果没有定义的话就转换失败，如果定义了的话就调用转换构造函数。 ​ 转换构造函数也是构造函数的一种，它除了可以用来将其它类型转换为当前类类型，还可以用来初始化对象，这是构造函数本来的意义。下面创建对象的方式是正确的： 1234Complex c1(26.4); //创建具名对象Complex c2 = 240.3; //以拷贝的方式初始化对象Complex(15.9); //创建匿名对象c1 = Complex(46.9); //创建一个匿名对象并将它赋值给 c1 ​ 在以拷贝的方式初始化对象时，编译器先调用转换构造函数，将 240.3 转换为 Complex 类型（创建一个 Complex 类的匿名对象），然后再拷贝给 c2。 ​ 如果已经对+运算符进行了重载，使之能进行两个 Complex 类对象的相加，那么下面的语句也是正确的： 1234Complex c1(15.6, 89.9);Complex c2;c2 = c1 + 29.6;cout&lt;&lt;c2&lt;&lt;endl; ​ 在进行加法运算符时，编译器先将 29.6 转换为 Complex 类型（创建一个 Complex 类的匿名对象）再相加。 ​ 需要注意的是，为了获得目标类型，编译器会“不择手段”，会综合使用内置的转换规则和用户自定义的转换规则，并且会进行多级类型转换，例如： 编译器会根据内置规则先将 int 转换为 double，再根据用户自定义规则将 double 转换为 Complex（int --&gt; double --&gt; Complex）； 编译器会根据内置规则先将 char 转换为 int，再将 int 转换为 double，最后根据用户自定义规则将 double 转换为 Complex（char --&gt; int --&gt; double --&gt; Complex）。 ​ 从本例看，只要一个类型能转换为 double 类型，就能转换为 Complex 类型。请看下面的例子： 1234567891011121314151617int main()&#123; Complex c1 = 100; //int --&gt; double --&gt; Complex cout&lt;&lt;c1&lt;&lt;endl; c1 = 'A'; //char --&gt; int --&gt; double --&gt; Complex cout&lt;&lt;c1&lt;&lt;endl; c1 = true; //bool --&gt; int --&gt; double --&gt; Complex cout&lt;&lt;c1&lt;&lt;endl; Complex c2(25.8, 0.7); //假设已经重载了+运算符 c1 = c2 + 'H' + true + 15; //将char、bool、int都转换为Complex类型再运算 cout&lt;&lt;c1&lt;&lt;endl; return 0;&#125; ​ 运行结果：1234100 + 0i65 + 0i1 + 0i113.8 + 0.7i 再谈构造函数​ 构造函数的本意是在创建对象的时候初始化对象，编译器会根据传递的实参来匹配不同的（重载的）构造函数。回顾一下以前的章节，到目前为止我们已经学习了以下几种构造函数。 ​ 1) 默认构造函数。就是编译器自动生成的构造函数。以 Complex 类为例，它的原型为：1Complex(); //没有参数 ​ 2) 普通构造函数。就是用户自定义的构造函数。以 Complex 类为例，它的原型为：1Complex(double real, double imag); //两个参数 ​ 3) 拷贝构造函数。在以拷贝的方式初始化对象时调用。以 Complex 类为例，它的原型为：1Complex(const Complex &amp;c); ​ 4) 转换构造函数。将其它类型转换为当前类类型时调用。以 Complex 为例，它的原型为：1Complex(double real); ​ 不管哪一种构造函数，都能够用来初始化对象，这是构造函数的本意。假设 Complex 类定义了以上所有的构造函数，那么下面创建对象的方式都是正确的： 1234Complex c1(); //调用Complex()Complex c2(10, 20); //调用Complex(double real, double imag)Complex c3(c2); //调用Complex(const Complex &amp;c)Complex c4(25.7); //调用Complex(double real) ​ 这些代码都体现了构造函数的本意——在创建对象时初始化对象。 ​ 除了在创建对象时初始化对象，其他情况下也会调用构造函数，例如，以拷贝的的方式初始化对象时会调用拷贝构造函数，将其它类型转换为当前类类型时会调用转换构造函数。这些在其他情况下调用的构造函数，就成了特殊的构造函数了。特殊的构造函数并不一定能体现出构造函数的本意。 对 Complex 类的进一步精简​ 上面的 Complex 类中我们定义了三个构造函数，其中包括两个普通的构造函数和一个转换构造函数。其实，借助函数的默认参数，我们可以将这三个构造函数简化为一个，请看下面的代码： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;//复数类class Complex&#123;public: Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag)&#123; &#125;public: friend ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c); //友元函数private: double m_real; //实部 double m_imag; //虚部&#125;;//重载&gt;&gt;运算符ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123; out &lt;&lt; c.m_real &lt;&lt;" + "&lt;&lt; c.m_imag &lt;&lt;"i";; return out;&#125;int main()&#123; Complex a(10.0, 20.0); //向构造函数传递 2 个实参，不使用默认参数 Complex b(89.5); //向构造函数传递 1 个实参，使用 1 个默认参数 Complex c; //不向构造函数传递实参，使用全部默认参数 a = 25.5; //调用转换构造函数（向构造函数传递 1 个实参，使用 1 个默认参数） return 0;&#125; ​ 精简后的构造函数包含了两个默认参数，在调用它时可以省略部分或者全部实参，也就是可以向它传递 0 个、1 个、2 个实参。转换构造函数就是包含了一个参数的构造函数，恰好能够和其他两个普通的构造函数“融合”在一起。 类型转换函数​ 转换构造函数能够将其它类型转换为当前类类型（例如将 double 类型转换为 Complex 类型），但是不能反过来将当前类类型转换为其它类型（例如将 Complex 类型转换为 double 类型）。 ​ C++ 提供了类型转换函数（Type conversion function）来解决这个问题。类型转换函数的作用就是将当前类类型转换为其它类型，它只能以成员函数的形式出现，也就是只能出现在类中。 ​ 类型转换函数的语法格式为：1234operator type()&#123; //TODO: return data;&#125; ​ operator 是 C++ 关键字，type 是要转换的目标类型，data 是要返回的 type 类型的数据。 ​ 因为要转换的目标类型是 type，所以返回值 data 也必须是 type 类型。既然已经知道了要返回 type 类型的数据，所以没有必要再像普通函数一样明确地给出返回值类型。这样做导致的结果是：类型转换函数看起来没有返回值类型，其实是隐式地指明了返回值类型。 ​ 类型转换函数也没有参数，因为要将当前类的对象转换为其它类型，所以参数不言而喻。实际上编译器会把当前对象的地址赋值给 this 指针，这样在函数体内就可以操作当前对象了。 ​ 【示例】为 Complex 类添加类型转换函数，使得 Complex 类型能够转换为 double 类型。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;//复数类class Complex&#123;public: Complex(): m_real(0.0), m_imag(0.0)&#123; &#125; Complex(double real, double imag): m_real(real), m_imag(imag)&#123; &#125;public: friend ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c); friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2); operator double() const &#123; return m_real; &#125; //类型转换函数private: double m_real; //实部 double m_imag; //虚部&#125;;//重载&gt;&gt;运算符ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123; out &lt;&lt; c.m_real &lt;&lt;" + "&lt;&lt; c.m_imag &lt;&lt;"i";; return out;&#125;//重载+运算符Complex operator+(const Complex &amp;c1, const Complex &amp;c2)&#123; Complex c; c.m_real = c1.m_real + c2.m_real; c.m_imag = c1.m_imag + c2.m_imag; return c;&#125;int main()&#123; Complex c1(24.6, 100); double f = c1; //相当于 double f = Complex::operator double(&amp;c1); cout&lt;&lt;"f = "&lt;&lt;f&lt;&lt;endl; f = 12.5 + c1 + 6; //相当于 f = 12.5 + Complex::operator double(&amp;c1) + 6; cout&lt;&lt;"f = "&lt;&lt;f&lt;&lt;endl; int n = Complex(43.2, 9.3); //先转换为 double，再转换为 int cout&lt;&lt;"n = "&lt;&lt;n&lt;&lt;endl; return 0;&#125; ​ 运行结果：123f = 24.6f = 43.1n = 43 ​ 本例中，类型转换函数非常简单，就是返回成员变量 m_real 的值，所以建议写成 inline 的形式。 ​ 类型转换函数和运算符的重载非常相似，都使用 operator 关键字，因此也把类型转换函数称为类型转换运算符。 关于类型转换函数的说明​ 1) type 可以是内置类型、类类型以及由 typedef 定义的类型别名，任何可作为函数返回类型的类型（void 除外）都能够被支持。一般而言，不允许转换为数组或函数类型，转换为指针类型或引用类型是可以的。 ​ 2) 类型转换函数一般不会更改被转换的对象，所以通常被定义为 const 成员。 ​ 3) 类型转换函数可以被继承，可以是虚函数。 ​ 4) 一个类虽然可以有多个类型转换函数（类似于函数重载），但是如果多个类型转换函数要转换的目标类型本身又可以相互转换（类型相近），那么有时候就会产生二义性。以 Complex 类为例，假设它有两个类型转换函数：12operator double() const &#123; return m_real; &#125; //转换为double类型operator int() const &#123; return (int)m_real; &#125; //转换为int类型 ​ 那么下面的写法就会引发二义性：12Complex c1(24.6, 100);float f = 12.5 + c1; ​ 编译器可以调用 operator double() 将 c1转换为 double 类型，也可以调用 operator int() 将c1转换为 int 类型，这两种类型都可以跟 12.5 进行加法运算，并且从 Complex 转换为 double 与从 Complex 转化为 int 是平级的，没有谁的优先级更高，所以这个时候编译器就不知道该调用哪个函数了，干脆抛出一个二义性错误，让用户解决。 转换构造函数和类型转换函数异同​ 转换构造函数和类型转换函数的作用是相反的：转换构造函数会将其它类型转换为当前类类型，类型转换函数会将当前类类型转换为其它类型。如果没有这两个函数，Complex 类和 int、double、bool等基本类型的四则运算、逻辑运算都将变得非常复杂，要编写大量的运算符重载函数。 ​ 但是，如果一个类同时存在这两个函数，就有可能产生二义性。下面以 Complex 类为例来演示：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;//复数类class Complex&#123;public: Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag)&#123; &#125; //包含了转换构造函数public: friend ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c); friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2); operator double() const &#123; return m_real; &#125; //类型转换函数private: double m_real; //实部 double m_imag; //虚部&#125;;//重载&gt;&gt;运算符ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123; out &lt;&lt; c.m_real &lt;&lt;" + "&lt;&lt; c.m_imag &lt;&lt;"i";; return out;&#125;//重载+运算符Complex operator+(const Complex &amp;c1, const Complex &amp;c2)&#123; Complex c; c.m_real = c1.m_real + c2.m_real; c.m_imag = c1.m_imag + c2.m_imag; return c;&#125;int main()&#123; Complex c1(24.6, 100); double f = c1; //①正确，调用类型转换函数 c1 = 78.4; //②正确，调用转换构造函数 f = 12.5 + c1; //③错误，产生二义性 Complex c2 = c1 + 46.7; //④错误，产生二义性 return 0;&#125; ​ ①和②是正确的，相信大家很容易理解。 ​ 对于③，进行加法运算时，有两种转换方案： 第一种方案是先将 12.5 转换为 Complex 类型再运算，这样得到的结果也是 Complex 类型，再调用类型转换函数就可以赋值给 f 了。 第二种方案是先将 c1 转换为 double 类型再运算，这样得到的结果也是 double 类型，可以直接赋值给 f。 ​ 很多人会认为，既然=左边是 double 类型，很显然应该选择第二种方案，这样才符合“常理”。其实不然，编译器不会根据=左边的数据类型来选择转换方案，编译器只关注12.5 + c1这个表达式本身，站在这个角度考虑，上面的两种转换方案都可以，编译器不知道选择哪一种，所以会抛出二义性错误，让用户自己去解决。 ​ 当然，你也可以认为编译器不够智能，没有足够强大的上下文（周边环境）推导能力。反过来说，即使我们假设编译器会根据=左边的数据类型来选择解决方案，那仍然会存在二义性问题，下面就是一个例子：12Complex c1(24.6, 100);cout&lt;&lt;c1 + 46.7&lt;&lt;endl; ​ 该语句没有将c1 + 46.7的结果赋值给其他变量，而是直接输出，这种情况应该将c1 转换成 double 类型呢，还是应该将46.7转换成 Complex 类型呢？很明显都可以，因为转换构造函数和类型转换函数是平级的，没有谁的优先级更高，所以该语句也会产生二义性错误。 ​ 解决二义性问题的办法也很简单粗暴，要么只使用转换构造函数，要么只使用类型转换函数。实践证明，用户对转换构造函数的需求往往更加强烈，这样能增加编码的灵活性，例如，可以将一个字符串字面量或者一个字符数组直接赋值给 string 类的对象，可以将一个int、double、bool 等基本类型的数据直接赋值给 Complex 类的对象。 ​ 那么，如果我们想把当前类类型转换为其它类型怎么办呢？很简单，增加一个普通的成员函数即可，例如，string 类使用c_str()函数转换为 C 风格的字符串，complex 类使用 real() 和imag()函数来获取复数的实部和虚部。 ​ complex 是 C++ 标准库中的复数类，c是小写的，使用时需要引入complex头文件。Complex 是我们为了教学而自定义的复数类，C是大写的，Complex 类尽量模拟 complex 类。 ​ 下面是重新编写的 Complex 类，该类只使用了转换构造函数，没有使用类型转换函数，取而代之的是 real() 和imag()两个普通成员函数。一个实用的 Complex 类能够进行四则运算和关系运算，需要重载 +、-、、/、+=、-=、=、/=、==、!= 这些运算符，不过作为教学演示，这里仅仅重载了 +、+=、==、!= 运算符，其它运算符的重载与此类似。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;using namespace std;//复数类class Complex&#123;public: //构造函数 Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag)&#123; &#125; //包含了转换构造函数public: //运算符重载 //以全局函数的形式重载 friend ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c); friend istream &amp; operator&gt;&gt;(istream &amp;in, Complex &amp;c); friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2); friend bool operator==(const Complex &amp;c1, const Complex &amp;c2); friend bool operator!=(const Complex &amp;c1, const Complex &amp;c2); //以成员函数的形式重载 Complex &amp; operator+=(const Complex &amp;c);public: //成员函数 double real() const&#123; return m_real; &#125; double imag() const&#123; return m_imag; &#125;private: double m_real; //实部 double m_imag; //虚部&#125;;//重载&gt;&gt;运算符ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123; out &lt;&lt; c.m_real &lt;&lt;" + "&lt;&lt; c.m_imag &lt;&lt;"i";; return out;&#125;//重载&lt;&lt;运算符istream &amp; operator&gt;&gt;(istream &amp;in, Complex &amp;c)&#123; in &gt;&gt; c.m_real &gt;&gt; c.m_imag; return in;&#125;//重载+运算符Complex operator+(const Complex &amp;c1, const Complex &amp;c2)&#123; Complex c; c.m_real = c1.m_real + c2.m_real; c.m_imag = c1.m_imag + c2.m_imag; return c;&#125;//重载+=运算符Complex &amp; Complex::operator+=(const Complex &amp;c)&#123; this-&gt;m_real += c.m_real; this-&gt;m_imag += c.m_imag; return *this;&#125;//重载==运算符bool operator==(const Complex &amp;c1, const Complex &amp;c2)&#123; if( c1.m_real == c2.m_real &amp;&amp; c1.m_imag == c2.m_imag )&#123; return true; &#125;else&#123; return false; &#125;&#125;//重载!=运算符bool operator!=(const Complex &amp;c1, const Complex &amp;c2)&#123; if( c1.m_real != c2.m_real || c1.m_imag != c2.m_imag )&#123; return true; &#125;else&#123; return false; &#125;&#125;int main()&#123; Complex c1(12, 60); cout&lt;&lt;"c1 = "&lt;&lt;c1&lt;&lt;endl; //先调用转换构造函数将 22.8 转换为 Complex 类型，再调用重载过的 + 运算符 Complex c2 = c1 + 22.8; cout&lt;&lt;"c2 = "&lt;&lt;c2&lt;&lt;endl; //同上 Complex c3 = 8.3 + c1; cout&lt;&lt;"c3 = "&lt;&lt;c3&lt;&lt;endl; //先调用转换构造函数将 73 转换为 Complex 类型，再调用重载过的 += 运算符 Complex c4(4, 19); c4 += 73; cout&lt;&lt;"c4 = "&lt;&lt;c4&lt;&lt;endl; //调用重载过的 += 运算符 Complex c5(14.6, 26.2); c5 += c1; cout&lt;&lt;"c5 = "&lt;&lt;c5&lt;&lt;endl; //调用重载过的 == 运算符 if(c1 == c2)&#123; cout&lt;&lt;"c1 == c2"&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;"c1 != c2"&lt;&lt;endl; &#125; //先调用转换构造函数将 77 转换为 Complex 类型，再调用重载过的 != 运算符 if(c4 != 77)&#123; cout&lt;&lt;"c4 != 77"&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;"c4 == 77"&lt;&lt;endl; &#125; //将 Complex 转换为 double，没有调用类型转换函数，而是调用了 real() 这个普通的成员函数 double f = c5.real(); cout&lt;&lt;"f = "&lt;&lt;f&lt;&lt;endl; return 0;&#125; ​ 运行结果： 12345678c1 = 12 + 60ic2 = 34.8 + 60ic3 = 20.3 + 60ic4 = 77 + 19ic5 = 26.6 + 86.2ic1 != c2c4 != 77f = 26.6 类型转换的本质​ 在 C/C++ 中，不同的数据类型之间可以相互转换：无需用户指明如何转换的称为自动类型转换（隐式类型转换），需要用户显式地指明如何转换的称为强制类型转换（显式类型转换）。 ​ 隐式类型转换利用的是编译器内置的转换规则，或者用户自定义的转换构造函数以及类型转换函数（这些都可以认为是已知的转换规则），例如从 int 到 double、从派生类到基类、从type *到void *、从 double 到 Complex 等。 ​ type *是一个具体类型的指针，例如int 、double 、Student 等，它们都可以直接赋值给void 指针。而反过来是不行的，必须使用强制类型转换才能将void *转换为type *，例如，malloc() 分配内存后返回的就是一个void *指针，我们必须进行强制类型转换后才能赋值给指针变量。 ​ 当隐式转换不能完成类型转换工作时，我们就必须使用强制类型转换了。强制类型转换的语法也很简单，只需要在表达式的前面增加新类型的名称，格式为：1(new_type) expression 本质​ 我们知道，数据是放在内存中的，变量（以及指针、引用）是给这块内存起的名字，有了变量就可以找到并使用这份数据。但问题是，该如何使用呢？ ​ 诸如数字、文字、符号、图形、音频、视频等数据都是以二进制形式存储在内存中的，它们并没有本质上的区别，那么，00010000 该理解为数字 16 呢，还是图像中某个像素的颜色呢，还是要发出某个声音呢？如果没有特别指明，我们并不知道。也就是说，内存中的数据有多种解释方式，使用之前必须要确定。这种「确定数据的解释方式」的工作就是由数据类型（Data Type）来完成的。例如int a;表明，a 这份数据是整数，不能理解为像素、声音、视频等。 ​ 顾名思义，数据类型用来说明数据的类型，确定了数据的解释方式，让计算机和程序员不会产生歧义。C/C++ 支持多种数据类型，包括内置类型（例如 int、double、bool 等）和自定义类型（结构体类型和类类型）。 ​ 所谓数据类型转换，就是对数据所占用的二进制位做出重新解释。如果有必要，在重新解释的同时还会修改数据，改变它的二进制位。对于隐式类型转换，编译器可以根据已知的转换规则来决定是否需要修改数据的二进制位；而对于强制类型转换，由于没有对应的转换规则，所以能做的事情仅仅是重新解释数据的二进制位，但无法对数据的二进制位做出修正。这就是隐式类型转换和强制类型转换最根本的区别。 ​ 这里说的修改数据并不是修改原有的数据，而是修改它的副本（先将原有数据拷贝到另外一个地方再修改）。 ​ 修改数据的二进制位非常重要，它能把转换后的数据调整到正确的值，所以这种修改时常会发生，例如：​ 1) 整数和浮点数在内存中的存储形式大相径庭，将浮点数 f 赋值给整数 i 时，不能原样拷贝 f 的二进制位，也不能截取部分二进制位，必须先将 f 的二进制位读取出来，以浮点数的形式呈现，然后直接截掉小数部分，把剩下的整数部分再转换成二进制形式，拷贝到 i 所在的内存中。 ​ 2) short 一般占用两个字节，int 一般占用四个字节，将 short 类型的 s 赋值给 int 类型的 i 时，如果仅仅是将 s 的二进制位拷贝给 i，那么 i 最后的两个字节会原样保留，这样会导致赋值结束后 i 的值并不等于 s 的值，所以这样做是错误的。正确的做法是，先给 s 添加 16 个二进制位（两个字节）并全部置为 0，然后再拷贝给 i 所在的内存。 ​ 3) 当存在多重继承时，如果把派生类指针 pd 赋值给基类指针 pb，就必须考虑基类子对象在派生类对象中的偏移，偏移不为 0 时就要调整 pd 的值，让它加上或减去偏移量，这样赋值后才能让 pb 恰好指向基类子对象。更多细节请猛击《将派生类指针赋值给基类指针时到底发生了什么》。 ​ 4) Complex 类型占用 16 个字节，double 类型占用 8 个字节，将 double 类型的数据赋值给 Complex 类型的变量（对象）时，必须调用转换构造函数，否则剩下的 8 个字节就不知道如何填充了。 ​ 以上这些都是隐式类型转换，它对数据的调整都是有益的，能够让程序更加安全稳健地运行。 ​ 隐式类型转换必须使用已知的转换规则，虽然灵活性受到了限制，但是由于能够对数据进行恰当地调整，所以更加安全（几乎没有风险）。强制类型转换能够在更大范围的数据类型之间进行转换，例如不同类型指针（引用）之间的转换、从 const到非const的转换、从 int 到指针的转换（有些编译器也允许反过来）等，这虽然增加了灵活性，但是由于不能恰当地调整数据，所以也充满了风险，程序员要小心使用。 ​ 下面的代码演示了不同类型指针之间的转换所带来的风险：1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;class Base&#123;public: Base(int a = 0, int b = 0): m_a(a), m_b(b)&#123; &#125;private: int m_a; int m_b;&#125;;int main()&#123; //风险①：破坏类的封装性 Base *pb = new Base(10, 20); int n = *((int*)pb + 1); cout&lt;&lt;n&lt;&lt;endl; //风险②：进行无意义的操作 float f = 56.2; int *pi = (int*)&amp;f; *pi = -23; cout&lt;&lt;f&lt;&lt;endl; return 0;&#125; ​ 运行结果：1220NaN NaN 是“not a number”的缩写，意思是“不是一个数字”。 ​ Base 类有两个 private 属性的成员变量，原则上讲它们不能在类的外部访问，但是当把对象指针进行强制类型转换后，就突破了这种限制，破坏了类的封装性。更多内容请猛击《借助指针突破访问权限的限制》一文。 ​ f 是 float 类型的变量，用来存储浮点数，但是我们通过指针将一个整数直接放到了 f 所在的内存，由于整数和浮点数的存储格式不一样，所以直接放入一个整数毫无意义。关于整数和浮点数在内存中的存储请猛击《整数在内存中是如何存储的》和《小数在内存中是如何存储的》。 为什么会有隐式类型转换和强制类型转换之分？​ 隐式类型转换和显式类型转换最根本的区别是：隐式类型转换除了会重新解释数据的二进制位，还会利用已知的转换规则对数据进行恰当地调整；而显式类型转换只能简单粗暴地重新解释二进制位，不能对数据进行任何调整。 ​ 其实，能不能对数据进行调整是显而易见地事情，有转换规则就可以调整，没有转换规则就不能调整，当进行数据类型转换时，编译器明摆着是知道有没有转换规则的。站在这个角度考虑，强制类型转换的语法就是多此一举，编译器完全可以自行判断是否需要调整数据。例如从int 转换到float ，加不加强制类型转换的语法都不能对数据进行调整。 ​ C/C++ 之所以增加强制类型转换的语法，是为了提醒程序员这样做存在风险，一定要谨慎小心。说得通俗一点，你现在的类型转换存在风险，你自己一定要知道。 强制类型转换也不是万能的​ 类型转换只能发生在相关类型或者相近类型之间，两个毫不相干的类型不能相互转换，即使使用强制类型转换也不行。例如，两个没有继承关系的类不能相互转换，基类不能向派生类转换（向下转型），类类型不能向基本类型转换，指针和类类型之间不能相互转换。 ​ 下面的代码演示了不相干类型之间的转换：123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;class A&#123;&#125;;class B&#123;&#125;;class Base&#123; &#125;;class Derived: public Base&#123; &#125;;int main()&#123; A a; B b; Base obj1; Derived obj2; a = (A)b; //Error: 两个没有继承关系的类不能相互转换 int n = (int)a; //Error: 类类型不能向基本类型转换 int *p = (int*)b; //Error: 指针和类类型之间不能相互转换 obj2 = (Derived)obj1; //Error: 向下转型 obj1 = obj2; //Correct: 向上转型 return 0;&#125;]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言-小数在内存的存储]]></title>
    <url>%2F2019%2F05%2F25%2Fc%E8%AF%AD%E8%A8%80-%E5%B0%8F%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[小数在内存中是以浮点数的形式存储的。浮点数并不是一种数值分类，它和整数、小数、实数等不是一个层面的概念。 浮点数是数字（或者说数值）在内存中的一种存储格式，它和定点数是相对的。 小数在内存的存储​ C语言使用定点数格式来存储 short、int、long 类型的整数，使用浮点数格式来存储 float、double 类型的小数。整数和小数在内存中的存储格式不一样。 ​ 我们在学习C语言时，通常认为浮点数和小数是等价的，并没有严格区分它们的概念，这也并没有影响到我们的学习，原因就是浮点数和小数是绑定在一起的，只有小数才使用浮点格式来存储。 ​ 其实，整数和小数可以都使用定点格式来存储，也可以都使用浮点格式来存储，但实际情况却是，C语言使用定点格式存储整数，使用浮点格式存储小数，这是在“数值范围”和“数值精度”两项重要指标之间追求平衡的结果，稍后我会给大家带来深入的剖析。 计算机的设计是一门艺术，很多实用技术都是权衡和妥协的结果。 ​ 浮点数和定点数中的“点”指的就是小数点！ ​ 对于整数，可以认为小数点后面都是零，小数部分是否存在并不影响整个数字的值，所以干脆将小数部分省略，只保留整数部分。 定点数​ 所谓定点数，就是指小数点的位置是固定的，不会向前或者向后移动。 ​ 假设我们用4个字节（32位）来存储无符号的定点数，并且约定，前16位表示整数部分，后16位表示小数部分，如下图所示： ​ 如此一来，小数点就永远在第16位之后，整数部分和小数部分一目了然，不管什么时候，整数部分始终占用16位（不足16位前置补0），小数部分也始终占用16位（不足16位后置补0）。例如，在内存中存储了 10101111 00110001 01011100 11000011，那么对应的小数就是 10101111 00110001 . 01011100 11000011，非常直观。 精度​ 小数部分的最后一位可能是精确数字，也可能是近似数字（由四舍五入、向零舍入等不同方式得到）；除此以外，剩余的31位都是精确数字。从二进制的角度看，这种定点格式的小数，最多有 32 位有效数字，但是能保证的是 31 位；也就是说，整体的精度为 31~32 位。 数值范围​ 将内存中的所有位（Bit）都置为 1，小数的值最大，为 $2^{16}$ - $2^{-16}$，极其接近$2^{16}$，换算成十进制为 65 536。将内存中最后一位（第32位）置1，其它位都置0，小数的值最小，为$2^{-16}$。 这里所说的最小值不是 0 值，而是最接近 0 的那个值。 综述​ 用定点格式来存储小数，优点是精度高，因为所有的位都用来存储有效数字了，缺点是取值范围太小，不能表示很大或者很小的数字。 反面例子​ 在科学计算中，小数的取值范围很大，最大值和最小值的差距有上百个数量级，使用定点数来存储将变得非常困难。 ​ 例如，电子的质量为：10000000000000000000000000000.9 克 = 9 × 10^(-28) 克 ​ 太阳的质量为：12000000000000000000000000000000000 克 = 2 × 10^33 克 ​ 如果使用定点数，那么只能按照=前面的格式来存储，这将需要很大的一块内存，大到需要几十个字节。更加科学的方案是按照=后面的指数形式来存储，这样不但节省内存，也非常直观。这种以指数的形式来存储小数的解决方案就叫做浮点数。 ​ 浮点数是对定点数的升级和优化，克服了定点数取值范围太小的缺点。 浮点数​ C语言标准规定，小数在内存中以科学计数法的形式来存储，具体形式为：1flt = (-1)sign × mantissa × baseexponent ​ 对各个部分的说明： flt 是要表示的小数。 sign 用来表示 flt 的正负号，它的取值只能是 0 或 1：取值为 0 表示 flt 是正数，取值为 1 表示 flt 是负数。 base 是基数，或者说进制，它的取值大于等于 2（例如，2 表示二进制、10 表示十进制、16 表示十六进制……）。数学中常见的科学计数法是基于十进制的，例如 6.93 × 1013；计算机中的科学计数法可以基于其它进制，例如 1.001 × 27 就是基于二进制的，它等价于 1001 0000。 mantissa 为尾数，或者说精度，是 base 进制的小数，并且 1 ≤ mantissa ＜ base，这意味着，小数点前面只能有一位数字； exponent 为指数，是一个整数，可正可负，并且为了直观一般采用十进制表示。 下面我们以 19.625 为例来演示如何将小数转换为浮点格式。 ​ 当 base 取值为 10 时，19.625 的浮点形式为：119.625 = 1.9625 × 101 ​ 当 base 取值为 2 时，将 19.625 转换成二进制为 10011.101，用浮点形式来表示为：119.625 = 10011.101 = 1.0011101×24 19.625 整数部分的二进制形式为： 19 = 1×24 + 0×23 + 0×22 + 1×21 + 1×20 = 10011 小数部分的二进制形式为： 0.625 = 1×2-1 + 0×2-2 + 1×2-3 = 101 将整数部分和小数部分合并在一起： 19.625 = 10011.101 可以看出，当基数（进制）base 确定以后，指数 exponent 实际上就成了小数点的移动位数： exponent 大于零，mantissa 中的小数点右移 exponent 位即可还原小数的值； exponent 小于零，mantissa 中的小数点左移 exponent 位即可还原小数的值。 ​ 换句话说，将小数转换成浮点格式后，小数点的位置发生了浮动（移动），并且浮动的位数和方向由 exponent 决定，所以我们将这种表示小数的方式称为浮点数。 二进制形式的浮点数的存储​ 虽然C语言标准没有规定 base 使用哪种进制，但是在实际应用中，各种编译器都将 base 实现为二进制，这样不仅贴近计算机硬件（任何数据在计算机底层都以二进制形式表示），还能减少转换次数。 ​ 接下来我们就讨论一下如何将二进制形式的浮点数放入内存中。 ​ 原则上讲，上面的科学计数法公式中，符号 sign、尾数 mantissa、基数 base 和指数 exponent 都是不确定因素，都需要在内存中体现出来。但是现在基数 base 已经确定是二进制了，就不用在内存中体现出来了，这样只需要在内存中存储符号 sign、尾数 mantissa、指数 exponent 这三个不确定的元素就可以了。 ​ 仍然以 19.625 为例，将它转换成二进制形式的浮点数格式：119.625 = 1.0011101×24 ​ 此时符号 sign 为 0，尾数 mantissa 为 1.0011101，指数 exponent 为 4。 1) 符号的存储​ 符号的存储很容易，就像存储 short、int 等普通整数一样，单独分配出一个位（Bit）来，用 0 表示正数，用 1 表示负数。对于 19.625，这一位的值是 0。 2) 尾数的存储​ 当采用二进制形式后，尾数部分的取值范围为 1 ≤ mantissa ＜ 2，这意味着：尾数的整数部分一定为 1，是一个恒定的值，这样就无需在内存中提现出来，可以将其直接截掉，只要把小数点后面的二进制数字放入内存中即可。对于 1.0011101，就是把 0011101 放入内存。 ​ 我们不妨将真实的尾数命名为 mantissa，将内存中存储的尾数命名为 mant，那么它们之间的关系为：1mantissa = 1.mant ​ 如果 base 采用其它进制，那么尾数的整数部分就不是固定的，它有多种取值的可能，以十进制为例，尾数的整数部分可能是 1~9 之间的任何一个值，这样一来尾数的整数部分就不能省略了，必须在内存中体现出来。而将 base 设置为二进制就可以节省掉一个位（Bit）的内存，这也算是采用二进制的一点点优势。 3) 指数的存储​ 指数是一个整数，并且有正负之分，不但需要存储它的值，还得能区分出正负号来。 ​ short、int、long 等类型的整数在内存中的存储采用的是补码加符号位的形式，数值在写入内存之前必须先进行转换，读取以后还要再转换一次。但是为了提高效率，避免繁琐的转换，指数的存储并没有采用补码加符号位的形式，而是设计了一套巧妙的解决方案，稍等我会为您解开谜团。 为二进制浮点数分配内存​ C语言中常用的浮点数类型为 float 和 double；float 始终占用 4 个字节，double 始终占用 8 个字节。 ​ 下图演示了 float 和 double 的存储格式： ​ 浮点数的内存被分成了三部分，分别用来存储符号 sign、尾数 mantissa 和指数 exponent ，当浮点数的类型确定后，每一部分的位数就是固定的。 ​ 符号 sign 可以不加修改直接放入内存中，尾数 mantissa 只需要将小数部分放入内存中，最让人疑惑的是指数 exponent 如何放入内存中，这也是我们在前面留下的一个谜团，下面我们以 float 为例来揭开谜底。 ​ float 的指数部分占用 8 Bits，能表示从 0~255 的值，取其中间值 127，指数在写入内存前先加上127，读取时再减去127，正数负数就显而易见了。19.625 转换后的指数为 4，4+127 = 131，131 换算成二进制为 1000 0011，这就是 19.626 的指数部分在 float 中的最终存储形式。 ​ 先确定内存中指数部分的取值范围，得到一个中间值，写入指数时加上这个中间值，读取指数时减去这个中间值，这样符号和值就都能确定下来了。 ​ 中间值的求取有固定的公式。设中间值为 median，指数部分占用的内存为 n 位，那么中间值为：1median = 2n-1 - 1 ​ 对于 float，中间值为 $2^{8-1}$ - 1 = 127；对于 double，中间值为 $2^{11-1}$ -1 = 1023。 ​ 我们不妨将真实的指数命名为 exponent，将内存中存储的指数命名为 exp，那么它们之间的关系为：1exponent = exp - median ​ 也可以写作：1exp = exponent + median 为了方便后续文章的编写，这里我强调一下命名： mantissa 表示真实的尾数，包括整数部分和小数部分；mant 表示内存中存储的尾数，只有小数部分，省略了整数部分。 exponent 表示真实的指数，exp 表示内存中存储的指数，exponent 和 exp 并不相等，exponent 加上中间数 median 才等于 exp。 用代码验证 float 的存储​ 19.625 转换成二进制的指数形式为：119.625 = 1.0011101×24 ​ 此时符号为0；尾数为1.0011101，截掉整数部分后为 0011101，补齐到 23 Bits 后为 001 1101 0000 0000 0000 0000；指数为 4，4+127 = 131，131 换算成二进制为 1000 0011。 ​ 综上所述，float 类型的 19.625 在内存中的值为：0 - 10000011 - 001 1101 0000 0000 0000 0000。 ​ 下面我们通过代码来验证一下： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//浮点数结构体typedef struct &#123; unsigned int nMant : 23; //尾数部分 unsigned int nExp : 8; //指数部分 unsigned int nSign : 1; //符号位&#125; FP_SINGLE;int main()&#123; char strBin[33] = &#123; 0 &#125;; float f = 19.625; FP_SINGLE *p = (FP_SINGLE*)&amp;f; itoa(p-&gt;nSign, strBin, 2); printf("sign: %s\n", strBin); itoa(p-&gt;nExp, strBin, 2); printf("exp: %s\n", strBin); itoa(p-&gt;nMant, strBin, 2); printf("mant: %s\n", strBin); return 0;&#125; ​ 运行结果：12345sign: 0exp: 10000011mant: 111010000000000000000 mant 的位数不足，在前面补齐两个 0 即可。 printf() 不能直接输出二进制形式，这里我们借助 itoa() 函数将十进制数转换成二进制的字符串，再使用`%s`输出。itoa() 虽然不是标准函数，但是大部分编译器都支持。不过 itoa() 在 C99 标准中已经被指定为不可用函数，在一些严格遵循 C99 标准的编译器下会失效，甚至会引发错误，例如在 Xcode（使用 LLVM 编译器）下就会编译失败。如果 itoa() 无效，请使用`%X`输出十六进制形式，十六进制能够很方便地转换成二进制。 精度问题​ 对于十进制小数，整数部分转换成二进制使用“展除法”（就是不断除以 2，直到余数为 0），一个有限位数的整数一定能转换成有限位数的二进制。但是小数部分就不一定了，小数部分转换成二进制使用“乘二取整法”（就是不断乘以 2，直到小数部分为 0），一个有限位数的小数并不一定能转换成有限位数的二进制，只有末位是 5 的小数才有可能转换成有限位数的二进制，其它的小数都不行。 ​ float 和 double 的尾数部分是有限的，固然不能容纳无限的二进制；即使小数能够转换成有限的二进制，也有可能会超出尾数部分的长度，此时也不能容纳。这样就必须“四舍五入”，将多余的二进制“处理掉”，只保留有效长度的二进制，这就涉及到了精度的问题。 ​ 也就是说，浮点数不一定能保存真实的小数，很有可能保存的是一个近似值。 ​ 对于 float，尾数部分有 23 位，再加上一个隐含的整数 1，一共是 24 位。最后一位可能是精确数字，也可能是近似数字（由四舍五入、向零舍入等不同方式得到）；除此以外，剩余的23位都是精确数字。从二进制的角度看，这种浮点格式的小数，最多有 24 位有效数字，但是能保证的是 23 位；也就是说，整体的精度为 23~24 位。如果转换成十进制，$2^{24}$ = 16 777 216，一共8位；也就是说，最多有 8 位有效数字，但是能保证的是 7 位，从而得出整体精度为 7~8 位。 ​ 对于 double，同理可得，二进制形式的精度为 52~53 位，十进制形式的精度为 15~16 位。 IEEE 754 标准​ 浮点数的存储以及加减乘除运算是一个比较复杂的问题，很多小的处理器在硬件指令方面甚至不支持浮点运算，其他的则需要一个独立的协处理器来处理这种运算，只有最复杂的处理器才会在硬件指令集中支持浮点运算。省略浮点运算，可以将处理器的复杂度减半！如果硬件不支持浮点运算，那么只能通过软件来实现，代价就是需要容忍不良的性能。 PC 和智能手机上的处理器就是最复杂的处理器了，它们都能很好地支持浮点运算。 ​ 在六七十年代，计算机界对浮点数的处理比较混乱，各家厂商都有自己的一套规则，缺少统一的业界标准，这给数据交换、计算机协同工作带来了很大不便。 ​ 作为处理器行业的老大，Intel 早就意识到了这个问题，并打算一统浮点数的世界。Intel 在研发 8087 浮点数协处理器时，聘请到加州大学伯克利分校的 William Kahan 教授（最优秀的数值分析专家之一）以及他的两个伙伴，来为 8087 协处理器设计浮点数格式，他们的工作完成地如此出色，设计的浮点数格式具有足够的合理性和先进性，被 IEEE 组织采用为浮点数的业界标准，并于 1985 年正式发布，这就是 IEEE 754 标准，它等同于国际标准 ISO/IEC/IEEE 60559。 IEEE 是 Institute of Electrical and Electronics Engineers 的简写，中文意思是“电气和电子工程师协会”。 ​ IEEE 754 简直是天才一般的设计，William Kahan 教授也因此获得了 1987 年的图灵奖。图灵奖是计算机界的“诺贝尔奖”。 ​ 目前，几乎所有的计算机都支持 IEEE 754 标准，大大改善了科学应用程序的可移植性，C语言编译器在实现浮点数时也采用了该标准。 ​ 不过，IEEE 754 标准的出现晚于C语言标准（最早的 ANSI C 标准于 1983 年发布），C语言标准并没有强制编译器采用 IEEE 754 格式，只是说要使用科学计数法的形式来表示浮点数，但是编译器在实现浮点数时，都采用了 IEEE 754 格式，这既符合C语言标准，又符合 IEEE 标准，何乐而不为。 特殊值​ IEEE 754 标准规定，当指数 exp 的所有位都为 1 时，不再作为“正常”的浮点数对待，而是作为特殊值处理： 如果此时尾数 mant 的二进制位都为 0，则表示无穷大： 如果符号 sign 为 1，则表示负无穷大； 如果符号 sign 为 0，则表示正无穷大。 如果此时尾数 mant 的二进制位不全为 0，则表示 NaN（Not a Number），也即这是一个无效的数字，或者该数字未经初始化。 非规格化浮点数​ 当指数 exp 的所有二进制位都为 0 时，情况也比较特殊。 ​ 对于“正常”的浮点数，尾数 mant 隐含的整数部分为 1，并且在读取浮点数时，内存中的指数 exp 要减去中间值 median 才能还原真实的指数 exponent，也即：12mantissa = 1.mantexponent = exp - median ​ 但是当指数 exp 的所有二进制位都为 0 时，一切都变了！尾数 mant 隐含的整数部分变成了 0，并且用 1 减去内存中的指数 exp 才能还原真实的指数 exponent，也即：12mantissa = 0.mantexponent = 1 - exp ​ 对于 float，exponent = 1 - 127 = -126，指数 exponent 的值恒为 -126；对于 double，exponent = 1 - 1023 = -1022，指数 exponent 的值恒为 -1022。 ​ 当指数 exp 的所有二进制位都是 0 时，我们将这样的浮点数称为“非规格化浮点数”；当指数 exp 的所有二进制位既不全为 0 也不全为 1 时，我们称之为“规格化浮点数”；当指数 exp 的所有二进制位都是 1 时，作为特殊值对待。 ​ 也就是说，究竟是规格化浮点数，还是非规格化浮点数，还是特殊值，完全看指数 exp。 +0 和 -0 的表示​ 对于非规格化浮点数，当尾数 mant 的所有二进制位都为 0 时，整个浮点数的值就为 0： 如果符号 sign 为 0，则表示 +0； 如果符号 sign 为 1，则表示 -0。 IEEE 754 为什么增加非规格化浮点数​ 我们以 float 类型为例来说明。 ​ 对于规格化浮点数，当尾数 mant 的所有位都为 0、指数 exp 的最低位为 1 时，浮点数的绝对值最小（符号 sign 的取值不影响绝对值），为 1.0 × $2^{-126}$，也即 $2^{-126}$。 ​ 对于一般的计算，这个值已经很小了，非常接近 0 值了，但是对于科学计算，它或许还不够小，距离 0 值还不够近，非规格化浮点数就是来弥补这一缺点的：非规格化浮点数可以让最小值更小，更加接近 0 值。 ​ 对于非规格化浮点数，当尾数的最低位为 1 时，浮点数的绝对值最小，为 $2^{-23}$ × $2^{-126}$ = $2^{-149}$，这个值比 $2^{-126}$小了 23 个数量级，更加即接近 0 值。 ​ 上表演示了正数时的情形，负数与此类似。请读者注意观察最大非规格化数和最小规格化数，它们是连在一起的，是平滑过渡的。 舍入模式​ 浮点数的尾数部分 mant 所包含的二进制位有限，不可能表示太长的数字，如果尾数部分过长，在放入内存时就必须将多余的位丢掉，取一个近似值。究竟该如何来取这个近似值，IEEE 754 列出了四种不同的舍入模式。 1) 舍入到最接近的值​ 就是将结果舍入为最接近且可以表示的值，这是默认的舍入模式。最近舍入模式和我们平时所见的“四舍五入”非常类似，但有一个细节不同。 ​ 对于最近舍入模式，IEEE 754 规定，当有两个最接近的可表示的值时首选“偶数”值；而对于四舍五入模式，当有两个最接近的可表示的值时要选较大的值。以十进制为例，就是对.5的舍入上采用偶数的方式，请看下面的例子。 最近舍入模式：Round(0.5) = 0、Round(1.5) = 2、Round(2.5) = 2 四舍五入模式：Round(0.5) = 1、Round(1.5) = 2、Round(2.5) = 3 2) 向 +∞ 方向舍入（向上舍入）​ 会将结果朝正无穷大的方向舍入。标准库函数 ceil() 使用的就是这种舍入模式，例如，ceil(1.324) = 2，Ceil(-1.324) = -1。 3) 向 -∞ 方向舍入（向下舍入）​ 会将结果朝负无穷大的方向舍入。标准库函数 floor() 使用的就是这种舍入模式，例如，floor(1.324) = 1，floor(-1.324) = -2。 4) 向 0 舍入（直接截断）​ 会将结果朝接近 0 的方向舍入，也就是将多余的位数直接丢掉。C语言中的类型转换使用的就是这种舍入模式，例如，(int)1.324 = 1，(int) -1.324 = -1。 总结​ 与定点数相比，浮点数在精度方面损失不小，但是在取值范围方面增大很多。牺牲精度，换来取值范围，这就是浮点数的整体思想。 ​ IEEE 754 标准其实还规定了浮点数的加减乘除运算，不过本文的重点是讲解浮点数的存储，所以对于浮点数的运算不再展开讨论。 答疑解惑​ 上节我们还留下了一个疑问，就是用 %f 输出 128.101 时得到的是一个近似值，而不是一个精确值，这是因为，128.101 转换为浮点格式后，尾数部分过长，被丢掉了，不能“真实”地存储了。 ​ 128.101 转换成二进制为：110000000.0001100111011011001000101101……（无限循环） ​ 向左移动 7 位后为：11.00000000001100111011011001000101101…… ​ 由此可见，尾数部分为：1000 0000 0001 1001 1101 1011 001000101101…… ​ 将多出的二进制丢掉后为：1000 0000 0001 1001 1101 1011 ​ 使用 printf 输出时，还需要进行还原，还原后的二进制为：110000000.0001100111011011 ​ 转换成十进制为 128.1009979248046875，按照四舍五入的原则取 6 位小数，就是128.100998]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++多态与虚函数]]></title>
    <url>%2F2019%2F05%2F25%2Fc%2B%2B%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）。 虚函数实现多态​ 基类的指针也可以指向派生类对象，请看下面的例子： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;//基类Peopleclass People&#123;public: People(char *name, int age); void display();protected: char *m_name; int m_age;&#125;;People::People(char *name, int age): m_name(name), m_age(age)&#123;&#125;void People::display()&#123; cout&lt;&lt;m_name&lt;&lt;"今年"&lt;&lt;m_age&lt;&lt;"岁了，是个无业游民。"&lt;&lt;endl;&#125;//派生类Teacherclass Teacher: public People&#123;public: Teacher(char *name, int age, int salary); void display();private: int m_salary;&#125;;Teacher::Teacher(char *name, int age, int salary): People(name, age), m_salary(salary)&#123;&#125;void Teacher::display()&#123; cout&lt;&lt;m_name&lt;&lt;"今年"&lt;&lt;m_age&lt;&lt;"岁了，是一名教师，每月有"&lt;&lt;m_salary&lt;&lt;"元的收入。"&lt;&lt;endl;&#125;int main()&#123; People *p = new People("王志刚", 23); p -&gt; display(); p = new Teacher("赵宏佳", 45, 8200); p -&gt; display(); return 0;&#125; 运行结果：12王志刚今年23岁了，是个无业游民。赵宏佳今年45岁了，是个无业游民。 ​ 我们直观上认为，如果指针指向了派生类对象，那么就应该使用派生类的成员变量和成员函数，这符合人们的思维习惯。但是本例的运行结果却告诉我们，当基类指针 p 指向派生类 Teacher 的对象时，虽然使用了 Teacher 的成员变量，但是却没有使用它的成员函数，导致输出结果不伦不类（赵宏佳本来是一名老师，输出结果却显示人家是个无业游民），不符合我们的预期。 ​ 换句话说，通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。 ​ 为了消除这种尴尬，让基类指针能够访问派生类的成员函数，C++ 增加了虚函数（Virtual Function）。使用虚函数非常简单，只需要在函数声明前面增加virtual关键字。 ​ 更改上面的代码，将 display() 声明为虚函数： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;//基类Peopleclass People&#123;public: People(char *name, int age); virtual void display(); //声明为虚函数protected: char *m_name; int m_age;&#125;;People::People(char *name, int age): m_name(name), m_age(age)&#123;&#125;void People::display()&#123; cout&lt;&lt;m_name&lt;&lt;"今年"&lt;&lt;m_age&lt;&lt;"岁了，是个无业游民。"&lt;&lt;endl;&#125;//派生类Teacherclass Teacher: public People&#123;public: Teacher(char *name, int age, int salary); virtual void display(); //声明为虚函数private: int m_salary;&#125;;Teacher::Teacher(char *name, int age, int salary): People(name, age), m_salary(salary)&#123;&#125;void Teacher::display()&#123; cout&lt;&lt;m_name&lt;&lt;"今年"&lt;&lt;m_age&lt;&lt;"岁了，是一名教师，每月有"&lt;&lt;m_salary&lt;&lt;"元的收入。"&lt;&lt;endl;&#125;int main()&#123; People *p = new People("王志刚", 23); p -&gt; display(); p = new Teacher("赵宏佳", 45, 8200); p -&gt; display(); return 0;&#125; 运行结果： 12王志刚今年23岁了，是个无业游民。赵宏佳今年45岁了，是一名教师，每月有8200元的收入。 ​ 和前面的例子相比，本例仅仅是在 display() 函数声明前加了一个virtual关键字，将成员函数声明为了虚函数（Virtual Function），这样就可以通过 p 指针调用 Teacher 类的成员函数了，运行结果也证明了这一点（赵宏佳已经是一名老师了，不再是无业游民了）。 ​ 有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）。 ​ 上面的代码中，同样是p-&gt;display();这条语句，当 p 指向不同的对象时，它执行的操作是不一样的。同一条语句可以执行不同的操作，看起来有不同表现方式，这就是多态。 多态是面向对象编程的主要特征之一，C++中虚函数的唯一用处就是构成多态。 ​ C++提供多态的目的是：可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问，尤其是成员函数。如果没有多态，我们只能访问成员变量。 ​ 前面我们说过，通过指针调用普通的成员函数时会根据指针的类型（通过哪个类定义的指针）来判断调用哪个类的成员函数，但是通过本节的分析可以发现，这种说法并不适用于虚函数，虚函数是根据指针的指向来调用的，指针指向哪个类的对象就调用哪个类的虚函数。 引用实现多态​ 引用在本质上是通过指针的方式实现的，既然借助指针可以实现多态，那么我们就有理由推断：借助引用也可以实现多态。 ​ 修改上例中 main() 函数内部的代码，用引用取代指针： 123456789101112int main()&#123; People p("王志刚", 23); Teacher t("赵宏佳", 45, 8200); People &amp;rp = p; People &amp;rt = t; rp.display(); rt.display(); return 0;&#125; 运行结果：12王志刚今年23岁了，是个无业游民。赵宏佳今年45岁了，是一名教师，每月有8200元的收入。 ​ 由于引用类似于常量，只能在定义的同时初始化，并且以后也要从一而终，不能再引用其他数据，所以本例中必须要定义两个引用变量，一个用来引用基类对象，一个用来引用派生类对象。从运行结果可以看出，当基类的引用指代基类对象时，调用的是基类的成员，而指代派生类对象时，调用的是派生类的成员。 ​ 不过引用不像指针灵活，指针可以随时改变指向，而引用只能指代固定的对象，在多态性方面缺乏表现力，所以以后我们再谈及多态时一般是说指针。 ​ 本例的主要目的是让读者知道，除了指针，引用也可以实现多态。 多态的用途​ 通过上面的例子读者可能还未发现多态的用途，不过确实也是，多态在小项目中鲜有有用武之地。 ​ 接下来的例子中，我们假设你正在玩一款军事游戏，敌人突然发动了地面战争，于是你命令陆军、空军及其所有现役装备进入作战状态。具体的代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;//军队class Troops&#123;public: virtual void fight()&#123; cout&lt;&lt;"Strike back!"&lt;&lt;endl; &#125;&#125;;//陆军class Army: public Troops&#123;public: void fight()&#123; cout&lt;&lt;"--Army is fighting!"&lt;&lt;endl; &#125;&#125;;//99A主战坦克class _99A: public Army&#123;public: void fight()&#123; cout&lt;&lt;"----99A(Tank) is fighting!"&lt;&lt;endl; &#125;&#125;;//武直10武装直升机class WZ_10: public Army&#123;public: void fight()&#123; cout&lt;&lt;"----WZ-10(Helicopter) is fighting!"&lt;&lt;endl; &#125;&#125;;//长剑10巡航导弹class CJ_10: public Army&#123;public: void fight()&#123; cout&lt;&lt;"----CJ-10(Missile) is fighting!"&lt;&lt;endl; &#125;&#125;;//空军class AirForce: public Troops&#123;public: void fight()&#123; cout&lt;&lt;"--AirForce is fighting!"&lt;&lt;endl; &#125;&#125;;//J-20隐形歼击机class J_20: public AirForce&#123;public: void fight()&#123; cout&lt;&lt;"----J-20(Fighter Plane) is fighting!"&lt;&lt;endl; &#125;&#125;;//CH5无人机class CH_5: public AirForce&#123;public: void fight()&#123; cout&lt;&lt;"----CH-5(UAV) is fighting!"&lt;&lt;endl; &#125;&#125;;//轰6K轰炸机class H_6K: public AirForce&#123;public: void fight()&#123; cout&lt;&lt;"----H-6K(Bomber) is fighting!"&lt;&lt;endl; &#125;&#125;;int main()&#123; Troops *p = new Troops; p -&gt;fight(); //陆军 p = new Army; p -&gt;fight(); p = new _99A; p -&gt; fight(); p = new WZ_10; p -&gt; fight(); p = new CJ_10; p -&gt; fight(); //空军 p = new AirForce; p -&gt; fight(); p = new J_20; p -&gt; fight(); p = new CH_5; p -&gt; fight(); p = new H_6K; p -&gt; fight(); return 0;&#125; 运行结果：123456789Strike back!--Army is fighting!----99A(Tank) is fighting!----WZ-10(Helicopter) is fighting!----CJ-10(Missile) is fighting!--AirForce is fighting!----J-20(Fighter Plane) is fighting!----CH-5(UAV) is fighting!----H-6K(Bomber) is fighting! ​ 这个例子中的派生类比较多，如果不使用多态，那么就需要定义多个指针变量，很容易造成混乱；而有了多态，只需要一个指针变量 p 就可以调用所有派生类的虚函数。 ​ 从这个例子中也可以发现，对于具有复杂继承关系的大中型程序，多态可以增加其灵活性，让代码更具有表现力。 虚函数注意事项​ 虚函数对于多态具有决定性的作用，有虚函数才能构成多态，这节我们来重点说一下虚函数的注意事项。 1) 只需要在虚函数的声明处加上 virtual 关键字，函数定义处可以加也可以不加。 2) 为了方便，你可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽（覆盖）关系的同名函数都将自动成为虚函数。 3) 当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。 4) 只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）。例如基类虚函数的原型为virtual void func();，派生类虚函数的原型为virtual void func(int);，那么当基类指针 p 指向派生类对象时，语句p -&gt; func(100);将会出错，而语句p -&gt; func();将调用基类的函数。 5) 构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。 6) 析构函数可以声明为虚函数，而且有时候必须要声明为虚函数，这点我们将在下节中讲解。 构成多态的条件​ 站在“学院派”的角度讲，封装、继承和多态是面向对象的三大特征，多态是指通过基类的指针既可以访问基类的成员，也可以访问派生类的成员。 下面是构成多态的条件： 必须存在继承关系； 继承关系中必须有同名的虚函数，并且它们是遮蔽（覆盖）关系。 存在基类的指针，通过该指针调用虚函数。 下面的例子对各种混乱情形进行了演示： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;//基类Baseclass Base&#123;public: virtual void func(); virtual void func(int);&#125;;void Base::func()&#123; cout&lt;&lt;"void Base::func()"&lt;&lt;endl;&#125;void Base::func(int n)&#123; cout&lt;&lt;"void Base::func(int)"&lt;&lt;endl;&#125;//派生类Derivedclass Derived: public Base&#123;public: void func(); void func(char *);&#125;;void Derived::func()&#123; cout&lt;&lt;"void Derived::func()"&lt;&lt;endl;&#125;void Derived::func(char *str)&#123; cout&lt;&lt;"void Derived::func(char *)"&lt;&lt;endl;&#125;int main()&#123; Base *p = new Derived(); p -&gt; func(); //输出void Derived::func() p -&gt; func(10); //输出void Base::func(int) p -&gt; func("http://c.biancheng.net"); //compile error return 0;&#125; ​ 在基类 Base 中我们将void func()声明为虚函数，这样派生类 Derived 中的void func()就会自动成为虚函数。p 是基类 Base 的指针，但是指向了派生类 Derived 的对象。语句p -&gt; func();调用的是派生类的虚函数，构成了多态。语句p -&gt; func(10);调用的是基类的虚函数，因为派生类中没有函数遮蔽它。语句p -&gt; func(&quot;http://c.biancheng.net&quot;);出现编译错误，因为通过基类的指针只能访问从基类继承过去的成员，不能访问派生类新增的成员。 什么时候声明虚函数​ 首先看成员函数所在的类是否会作为基类。然后看成员函数在类的继承后有无可能被更改功能，如果希望更改其功能的，一般应该将它声明为虚函数。如果成员函数在类被继承后功能不需修改，或派生类用不到该函数，则不要把它声明为虚函数。 虚析构函数​ 上节我们讲到，构造函数不能是虚函数，因为派生类不能继承基类的构造函数，将构造函数声明为虚函数没有意义。 ​ 这是原因之一，另外还有一个原因：C++ 中的构造函数用于在创建对象时进行初始化工作，在执行构造函数之前对象尚未创建完成，虚函数表尚不存在，也没有指向虚函数表的指针，所以此时无法查询虚函数表，也就不知道要调用哪一个构造函数。 ​ 析构函数用于在销毁对象时进行清理工作，可以声明为虚函数，而且有时候必须要声明为虚函数。 ​ 为了说明虚析构函数的必要性，请大家先看下面一个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;//基类class Base&#123;public: Base(); ~Base();protected: char *str;&#125;;Base::Base()&#123; str = new char[100]; cout&lt;&lt;"Base constructor"&lt;&lt;endl;&#125;Base::~Base()&#123; delete[] str; cout&lt;&lt;"Base destructor"&lt;&lt;endl;&#125;//派生类class Derived: public Base&#123;public: Derived(); ~Derived();private: char *name;&#125;;Derived::Derived()&#123; name = new char[100]; cout&lt;&lt;"Derived constructor"&lt;&lt;endl;&#125;Derived::~Derived()&#123; delete[] name; cout&lt;&lt;"Derived destructor"&lt;&lt;endl;&#125;int main()&#123; Base *pb = new Derived(); delete pb; cout&lt;&lt;"-------------------"&lt;&lt;endl; Derived *pd = new Derived(); delete pd; return 0;&#125; 运行结果：12345678Base constructorDerived constructorBase destructor\-------------------Base constructorDerived constructorDerived destructorBase destructor ​ 本例中定义了两个类，基类 Base 和派生类 Derived，它们都有自己的构造函数和析构函数。在构造函数中，会分配 100 个 char 类型的内存空间；在析构函数中，会把这些内存释放掉。 ​ pb、pd分别是基类指针和派生类指针，它们都指向派生类对象，最后使用 delete 销毁 pb、pd 所指向的对象。 ​ 从运行结果可以看出，语句delete pb;只调用了基类的析构函数，没有调用派生类的析构函数；而语句delete pd;同时调用了派生类和基类的析构函数。 ​ 在本例中，不调用派生类的析构函数会导致 name 指向的 100 个 char 类型的内存空间得不到释放；除非程序运行结束由操作系统回收，否则就再也没有机会释放这些内存。这是典型的内存泄露。 1) 为什么delete pb;不会调用派生类的析构函数呢？ ​ 因为这里的析构函数是非虚函数，通过指针访问非虚函数时，编译器会根据指针的类型来确定要调用的函数；也就是说，指针是哪个类就调用哪个类的函数，这在前面的章节中已经多次强调过。pb 是基类的指针，所以不管它指向基类的对象还是派生类的对象，始终都是调用基类的析构函数。 2) 为什么delete pd;会同时调用派生类和基类的析构函数呢？ ​ pd是派生类的指针，编译器会根据它的类型匹配到派生类的析构函数，在执行派生类的析构函数的过程中，又会调用基类的析构函数。派生类析构函数始终会调用基类的析构函数，并且这个过程是隐式完成的， ​ 更改上面的代码，将基类的析构函数声明为虚函数： 1234567class Base&#123;public: Base(); virtual ~Base();protected: char *str;&#125;; 运行结果：123456789Base constructorDerived constructorDerived destructorBase destructor\-------------------Base constructorDerived constructorDerived destructorBase destructor ​ 将基类的析构函数声明为虚函数后，派生类的析构函数也会自动成为虚函数。这个时候编译器会忽略指针的类型，而根据指针的指向来选择函数；也就是说，指针指向哪个类的对象就调用哪个类的函数。pb、pd 都指向了派生类的对象，所以会调用派生类的析构函数，继而再调用基类的析构函数。如此一来也就解决了内存泄露的问题。 ​ 在实际开发中，一旦我们自己定义了析构函数，就是希望在对象销毁时用它来进行清理工作，比如释放内存、关闭文件等，如果这个类又是一个基类，那么我们就必须将该析构函数声明为虚函数，否则就有内存泄露的风险。 也就是说，大部分情况下都应该将基类的析构函数声明为虚函数。 注意，这里强调的是基类，如果一个类是最终的类，那就没必要再声明为虚函数了。 纯虚函数​ 在C++中，可以将虚函数声明为纯虚函数，语法格式为： virtual 返回值类型 函数名 (函数参数) = 0; ​ 纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上=0，表明此函数为纯虚函数。 最后的=0并不表示函数返回值为0，它只起形式上的作用，告诉编译系统“这是纯虚函数”。 ​ 包含纯虚函数的类称为抽象类（Abstract Class）。之所以说它抽象，是因为它无法实例化，也就是无法创建对象。原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。 ​ 抽象类通常是作为基类，让派生类去实现纯虚函数。派生类必须实现纯虚函数才能被实例化。 纯虚函数使用举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;using namespace std;//线class Line&#123;public: Line(float len); virtual float area() = 0; virtual float volume() = 0;protected: float m_len;&#125;;Line::Line(float len): m_len(len)&#123; &#125;//矩形class Rec: public Line&#123;public: Rec(float len, float width); float area();protected: float m_width;&#125;;Rec::Rec(float len, float width): Line(len), m_width(width)&#123; &#125;float Rec::area()&#123; return m_len * m_width; &#125;//长方体class Cuboid: public Rec&#123;public: Cuboid(float len, float width, float height); float area(); float volume();protected: float m_height;&#125;;Cuboid::Cuboid(float len, float width, float height): Rec(len, width), m_height(height)&#123; &#125;float Cuboid::area()&#123; return 2 * ( m_len*m_width + m_len*m_height + m_width*m_height); &#125;float Cuboid::volume()&#123; return m_len * m_width * m_height; &#125;//正方体class Cube: public Cuboid&#123;public: Cube(float len); float area(); float volume();&#125;;Cube::Cube(float len): Cuboid(len, len, len)&#123; &#125;float Cube::area()&#123; return 6 * m_len * m_len; &#125;float Cube::volume()&#123; return m_len * m_len * m_len; &#125;int main()&#123; Line *p = new Cuboid(10, 20, 30); cout&lt;&lt;"The area of Cuboid is "&lt;&lt;p-&gt;area()&lt;&lt;endl; cout&lt;&lt;"The volume of Cuboid is "&lt;&lt;p-&gt;volume()&lt;&lt;endl; p = new Cube(15); cout&lt;&lt;"The area of Cube is "&lt;&lt;p-&gt;area()&lt;&lt;endl; cout&lt;&lt;"The volume of Cube is "&lt;&lt;p-&gt;volume()&lt;&lt;endl; return 0;&#125; 运行结果：1234The area of Cuboid is 2200The volume of Cuboid is 6000The area of Cube is 1350The volume of Cube is 3375 ​ 本例中定义了四个类，它们的继承关系为：Line --&gt; Rec --&gt; Cuboid --&gt; Cube。 ​ Line 是一个抽象类，也是最顶层的基类，在 Line 类中定义了两个纯虚函数 area() 和 volume()。 ​ 在 Rec 类中，实现了 area() 函数；所谓实现，就是定义了纯虚函数的函数体。但这时 Rec 仍不能被实例化，因为它没有实现继承来的 volume() 函数，volume() 仍然是纯虚函数，所以 Rec 也仍然是抽象类。 ​ 直到 Cuboid 类，才实现了 volume() 函数，才是一个完整的类，才可以被实例化。 ​ 可以发现，Line 类表示“线”，没有面积和体积，但它仍然定义了 area() 和 volume() 两个纯虚函数。这样的用意很明显：Line 类不需要被实例化，但是它为派生类提供了“约束条件”，派生类必须要实现这两个函数，完成计算面积和体积的功能，否则就不能实例化。 ​ 在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现（谁派生谁实现）。这部分未完成的功能，往往是基类不需要的，或者在基类中无法实现的。虽然抽象基类没有完成，但是却强制要求派生类完成，这就是抽象基类的“霸王条款”。 ​ 抽象基类除了约束派生类的功能，还可以实现多态。请注意第 51 行代码，指针 p 的类型是 Line，但是它却可以访问派生类中的 area() 和 volume() 函数，正是由于在 Line 类中将这两个函数定义为纯虚函数；如果不这样做，51 行后面的代码都是错误的。我想，这或许才是C++提供纯虚函数的主要目的。 纯虚函数的说明 1) 一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。 2) 只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。如下例所示： 12345678//顶层函数不能被声明为纯虚函数void fun() = 0; //compile errorclass base&#123;public : //普通成员函数不能被声明为纯虚函数 void display() = 0; //compile error&#125;; 前面我们一再强调，当通过指针访问类的成员函数时： 如果该函数是非虚函数，那么编译器会根据指针的类型找到该函数；也就是说，指针是哪个类的类型就调用哪个类的函数。 如果该函数是虚函数，并且派生类有同名的函数遮蔽它，那么编译器会根据指针的指向找到该函数；也就是说，指针指向的对象属于哪个类就调用哪个类的函数。这就是多态。 ​ 虚函数表​ 编译器之所以能通过指针指向的对象找到虚函数，是因为在创建对象时额外地增加了虚函数表。 ​ 如果一个类包含了虚函数，那么在创建该类的对象时就会额外地增加一个数组，数组中的每一个元素都是虚函数的入口地址。不过数组和对象是分开存储的，为了将对象和数组关联起来，编译器还要在对象中安插一个指针，指向数组的起始位置。 ​ 这里的数组就是虚函数表（Virtual function table），简写为vtable。 ​ 我们以下面的继承关系为例进行讲解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//People类class People&#123;public: People(string name, int age);public: virtual void display(); virtual void eating();protected: string m_name; int m_age;&#125;;People::People(string name, int age): m_name(name), m_age(age)&#123; &#125;void People::display()&#123; cout&lt;&lt;"Class People："&lt;&lt;m_name&lt;&lt;"今年"&lt;&lt;m_age&lt;&lt;"岁了。"&lt;&lt;endl;&#125;void People::eating()&#123; cout&lt;&lt;"Class People：我正在吃饭，请不要跟我说话..."&lt;&lt;endl;&#125;//Student类class Student: public People&#123;public: Student(string name, int age, float score);public: virtual void display(); virtual void examing();protected: float m_score;&#125;;Student::Student(string name, int age, float score): People(name, age), m_score(score)&#123; &#125;void Student::display()&#123; cout&lt;&lt;"Class Student："&lt;&lt;m_name&lt;&lt;"今年"&lt;&lt;m_age&lt;&lt;"岁了，考了"&lt;&lt;m_score&lt;&lt;"分。"&lt;&lt;endl;&#125;void Student::examing()&#123; cout&lt;&lt;"Class Student："&lt;&lt;m_name&lt;&lt;"正在考试，请不要打扰T啊！"&lt;&lt;endl;&#125;//Senior类class Senior: public Student&#123;public: Senior(string name, int age, float score, bool hasJob);public: virtual void display(); virtual void partying();private: bool m_hasJob;&#125;;Senior::Senior(string name, int age, float score, bool hasJob): Student(name, age, score), m_hasJob(hasJob)&#123; &#125;void Senior::display()&#123; if(m_hasJob)&#123; cout&lt;&lt;"Class Senior："&lt;&lt;m_name&lt;&lt;"以"&lt;&lt;m_score&lt;&lt;"的成绩从大学毕业了，并且顺利找到了工作，Ta今年"&lt;&lt;m_age&lt;&lt;"岁。"&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;"Class Senior："&lt;&lt;m_name&lt;&lt;"以"&lt;&lt;m_score&lt;&lt;"的成绩从大学毕业了，不过找工作不顺利，Ta今年"&lt;&lt;m_age&lt;&lt;"岁。"&lt;&lt;endl; &#125;&#125;void Senior::partying()&#123; cout&lt;&lt;"Class Senior：快毕业了，大家都在吃散伙饭..."&lt;&lt;endl;&#125;int main()&#123; People *p = new People("赵红", 29); p -&gt; display(); p = new Student("王刚", 16, 84.5); p -&gt; display(); p = new Senior("李智", 22, 92.0, true); p -&gt; display(); return 0;&#125; 运行结果：123Class People：赵红今年29岁了。Class Student：王刚今年16岁了，考了84.5分。Class Senior：李智以92的成绩从大学毕业了，并且顺利找到了工作，Ta今年22岁。 各个类的对象内存模型如下所示： ​ 图中左半部分是对象占用的内存，右半部分是虚函数表 vtable。在对象的开头位置有一个指针 vfptr，指向虚函数表，并且这个指针始终位于对象的开头位置。 ​ 仔细观察虚函数表，可以发现基类的虚函数在 vtable 中的索引（下标）是固定的，不会随着继承层次的增加而改变，派生类新增的虚函数放在 vtable 的最后。如果派生类有同名的虚函数遮蔽（覆盖）了基类的虚函数，那么将使用派生类的虚函数替换基类的虚函数，这样具有遮蔽关系的虚函数在 vtable 中只会出现一次。 ​ 当通过指针调用虚函数时，先根据指针找到 vfptr，再根据 vfptr 找到虚函数的入口地址。以虚函数 display() 为例，它在 vtable 中的索引为 0，通过 p 调用时：1p -&gt; display(); 编译器内部会发生类似下面的转换： 1( *( *(p+0) + 0 ) )(p); 下面我们一步一步来分析这个表达式： 0是 vfptr 在对象中的偏移，p+0是 vfptr 的地址； *(p+0)是 vfptr 的值，而 vfptr 是指向 vtable 的指针，所以*(p+0)也就是 vtable 的地址； display() 在 vtable 中的索引（下标）是 0，所以( *(p+0) + 0 )也就是 display() 的地址； 知道了 display() 的地址，( *( *(p+0) + 0 ) )(p)也就是对 display() 的调用了，这里的 p 就是传递的实参，它会赋值给 this 指针。 ​ 可以看到，转换后的表达式是固定的，只要调用 display() 函数，不管它是哪个类的，都会使用这个表达式。换句话说，编译器不管 p 指向哪里，一律转换为相同的表达式。 ​ 转换后的表达式没有用到与 p 的类型有关的信息，只要知道 p 的指向就可以调用函数，这跟名字编码（Name Mangling）算法有着本质上的区别。 ​ 再来看一下 eating() 函数，它在 vtable 中的索引为 1，通过 p 调用时：1p -&gt; eating(); 编译器内部会发生类似下面的转换： 1( *( *(p+0) + 1 ) )(p); ​ 对于不同的虚函数，仅仅改变索引（下标）即可。 ​ 以上是针对单继承进行的讲解。当存在多继承时，虚函数表的结构就会变得复杂，尤其是有虚继承时，还会增加虚基类表，更加让人抓狂，这里我们就不分析了，有兴趣的读者可以自行研究。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++向上转型]]></title>
    <url>%2F2019%2F05%2F25%2FC%2B%2B%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在 C/C++ 中经常会发生数据类型的转换，例如将 int 类型的数据赋值给 float 类型的变量时，编译器会先把 int 类型的数据转换为 float 类型再赋值；反过来，float 类型的数据在经过类型转换后也可以赋值给 int 类型的变量。 数据类型转换的前提是，编译器知道如何对数据进行取舍。例如： 12int a = 10.9;printf("%d\n", a); 输出结果为 10，编译器会将小数部分直接丢掉（不是四舍五入）。再如： 12float b = 10;printf("%f\n", b); 输出结果为 10.000000，编译器会自动添加小数部分。 ​ 类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为向上转型（Upcasting）。相应地，将基类赋值给派生类称为向下转型（Downcasting）。 ​ 向上转型非常安全，可以由编译器自动完成；向下转型有风险，需要程序员手动干预。 向上转型和向下转型是面向对象编程的一种通用概念，它们也存在于 Java、C# 等编程语言中。 将派生类对象赋值给基类对象下面的例子演示了如何将派生类对象赋值给基类对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;//基类class A&#123;public: A(int a);public: void display();public: int m_a;&#125;;A::A(int a): m_a(a)&#123; &#125;void A::display()&#123; cout&lt;&lt;"Class A: m_a="&lt;&lt;m_a&lt;&lt;endl;&#125;//派生类class B: public A&#123;public: B(int a, int b);public: void display();public: int m_b;&#125;;B::B(int a, int b): A(a), m_b(b)&#123; &#125;void B::display()&#123; cout&lt;&lt;"Class B: m_a="&lt;&lt;m_a&lt;&lt;", m_b="&lt;&lt;m_b&lt;&lt;endl;&#125;int main()&#123; A a(10); B b(66, 99); //赋值前 a.display(); b.display(); cout&lt;&lt;"--------------"&lt;&lt;endl; //赋值后 a = b; a.display(); b.display(); return 0;&#125; 运行结果：12345Class A: m_a=10Class B: m_a=66, m_b=99\----------------------------Class A: m_a=66Class B: m_a=66, m_b=99 ​ 本例中 A 是基类， B 是派生类，a、b 分别是它们的对象，由于派生类 B 包含了从基类 A 继承来的成员，因此可以将派生类对象 b 赋值给基类对象 a。通过运行结果也可以发现，赋值后 a 所包含的成员变量的值已经发生了变化。 ​ 赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了成员变量，所以对象之间的赋值是成员变量的赋值，成员函数不存在赋值问题。 ​ 运行结果也有力地证明了这一点，虽然有a=b;这样的赋值过程，但是 a.display() 始终调用的都是 A 类的 display()函数。换句话说，对象之间的赋值不会影响成员函数，也不会影响 this 指针。 ​ 将派生类对象赋值给基类对象时，会舍弃派生类新增的成员，也就是“大材小用”，如下图所示： ​ 可以发现，即使将派生类对象赋值给基类对象，基类对象也不会包含派生类的成员，所以依然不同通过基类对象来访问派生类的成员。对于上面的例子，a.m_a 是正确的，但 a.m_b 就是错误的，因为 a 不包含成员 m_b。 ​ 这种转换关系是不可逆的，只能用派生类对象给基类对象赋值，而不能用基类对象给派生类对象赋值。 ​ 理由很简单，基类不包含派生类的成员变量，无法对派生类的成员变量赋值。同理，同一基类的不同派生类对象之间也不能赋值。 ​ 要理解这个问题，还得从赋值的本质入手。赋值实际上是向内存填充数据，当数据较多时很好处理，舍弃即可；本例中将 b 赋值给 a 时（执行a=b;语句），成员 m_b 是多余的，会被直接丢掉，所以不会发生赋值错误。但当数据较少时，问题就很棘手，编译器不知道如何填充剩下的内存；如果本例中有 1b= a; ​ 这样的语句，编译器就不知道该如何给变量 m_b 赋值，所以会发生错误。 将派生类指针赋值给基类指针​ 除了可以将派生类对象赋值给基类对象（对象变量之间的赋值），还可以将派生类指针赋值给基类指针（对象指针之间的赋值）。我们先来看一个多继承的例子，继承关系为： 下面的代码实现了这种继承关系： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;using namespace std;//基类Aclass A&#123;public: A(int a);public: void display();protected: int m_a;&#125;;A::A(int a): m_a(a)&#123; &#125;void A::display()&#123; cout&lt;&lt;"Class A: m_a="&lt;&lt;m_a&lt;&lt;endl;&#125;//中间派生类Bclass B: public A&#123;public: B(int a, int b);public: void display();protected: int m_b;&#125;;B::B(int a, int b): A(a), m_b(b)&#123; &#125;void B::display()&#123; cout&lt;&lt;"Class B: m_a="&lt;&lt;m_a&lt;&lt;", m_b="&lt;&lt;m_b&lt;&lt;endl;&#125;//基类Cclass C&#123;public: C(int c);public: void display();protected: int m_c;&#125;;C::C(int c): m_c(c)&#123; &#125;void C::display()&#123; cout&lt;&lt;"Class C: m_c="&lt;&lt;m_c&lt;&lt;endl;&#125;//最终派生类Dclass D: public B, public C&#123;public: D(int a, int b, int c, int d);public: void display();private: int m_d;&#125;;D::D(int a, int b, int c, int d): B(a, b), C(c), m_d(d)&#123; &#125;void D::display()&#123; cout&lt;&lt;"Class D: m_a="&lt;&lt;m_a&lt;&lt;", m_b="&lt;&lt;m_b&lt;&lt;", m_c="&lt;&lt;m_c&lt;&lt;", m_d="&lt;&lt;m_d&lt;&lt;endl;&#125;int main()&#123; A *pa = new A(1); B *pb = new B(2, 20); C *pc = new C(3); D *pd = new D(4, 40, 400, 4000); pa = pd; pa -&gt; display(); pb = pd; pb -&gt; display(); pc = pd; pc -&gt; display(); cout&lt;&lt;"-----------------------"&lt;&lt;endl; cout&lt;&lt;"pa="&lt;&lt;pa&lt;&lt;endl; cout&lt;&lt;"pb="&lt;&lt;pb&lt;&lt;endl; cout&lt;&lt;"pc="&lt;&lt;pc&lt;&lt;endl; cout&lt;&lt;"pd="&lt;&lt;pd&lt;&lt;endl; return 0;&#125; 运行结果：12345678Class A: m_a=4Class B: m_a=4, m_b=40Class C: m_c=400\-----------------------pa=0x9b17f8pb=0x9b17f8pc=0x9b1800pd=0x9b17f8 ​ 本例中定义了多个对象指针，并尝试将派生类指针赋值给基类指针。与对象变量之间的赋值不同的是，对象指针之间的赋值并没有拷贝对象的成员，也没有修改对象本身的数据，仅仅是改变了指针的指向。 1) 通过基类指针访问派生类的成员​ 请读者先关注第 68 行代码，我们将派生类指针 pd 赋值给了基类指针 pa，从运行结果可以看出，调用 display() 函数时虽然使用了派生类的成员变量，但是 display() 函数本身却是基类的。也就是说，将派生类指针赋值给基类指针时，通过基类指针只能使用派生类的成员变量，但不能使用派生类的成员函数，这看起来有点不伦不类，究竟是为什么呢？第 71、74 行代码也是类似的情况。 ​ pa 本来是基类 A 的指针，现在指向了派生类 D 的对象，这使得隐式指针 this 发生了变化，也指向了 D 类的对象，所以最终在 display() 内部使用的是 D 类对象的成员变量，相信这一点不难理解。 ​ 编译器虽然通过指针的指向来访问成员变量，但是却不通过指针的指向来访问成员函数：编译器通过指针的类型来访问成员函数。对于 pa，它的类型是 A，不管它指向哪个对象，使用的都是 A 类的成员函数。 ​ 概括起来说就是：编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数。 2) 赋值后值不一致的情况​ 本例中我们将最终派生类的指针 pd 分别赋值给了基类指针 pa、pb、pc，按理说它们的值应该相等，都指向同一块内存，但是运行结果却有力地反驳了这种推论，只有 pa、pb、pd 三个指针的值相等，pc 的值比它们都大。也就是说，执行 1pc = pd; 语句后，pc 和 pd 的值并不相等。 ​ 这非常出乎我们的意料，按照我们通常的理解，赋值就是将一个变量的值交给另外一个变量，不会出现不相等的情况，究竟是什么导致了 pc 和 pd 不相等呢？ 将派生类引用赋值给基类引用​ 引用在本质上是通过指针的方式实现的，既然基类的指针可以指向派生类的对象，那么我们就有理由推断：基类的引用也可以指向派生类的对象，并且它的表现和指针是类似的。 修改上例中 main() 函数内部的代码，用引用取代指针： 12345678910111213int main()&#123; D d(4, 40, 400, 4000); A &amp;ra = d; B &amp;rb = d; C &amp;rc = d; ra.display(); rb.display(); rc.display(); return 0;&#125; 运行结果：123Class A: m_a=4Class B: m_a=4, m_b=40Class C: m_c=400 ​ ra、rb、rc 是基类的引用，它们都引用了派生类对象 d，并调用了 display() 函数，从运行结果可以发现，虽然使用了派生类对象的成员变量，但是却没有使用派生类的成员函数，这和指针的表现是一样的。 ​ 引用和指针的表现之所以如此类似，是因为引用和指针并没有本质上的区别，引用仅仅是对指针进行了简单封装。 ​ 最后需要注意的是，向上转型后通过基类的对象、指针、引用只能访问从基类继承过去的成员（包括成员变量和成员函数），不能访问派生类新增的成员。 将派生类指针赋值给基类指针时到底发生了什么​ 通过上节最后一个例子我们发现，将派生类的指针赋值给基类的指针后，它们的值有可能相等，也有可能不相等。例如执行 1pc = pd; ​ 语句后，pc 的值为 0x9b1800，pd 的值为 0x9b17f8，它们不相等。 ​ 我们通常认为，赋值就是将一个变量的值交给另外一个变量，这种想法虽然没错，但是有一点要注意，就是赋值以前编译器可能会对现有的值进行处理。例如将 double 类型的值赋给 int 类型的变量，编译器会直接抹掉小数部分，导致赋值运算符两边变量的值不相等。请看下面的例子： 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; double pi = 3.14159; int n = pi; cout&lt;&lt;pi&lt;&lt;", "&lt;&lt;n&lt;&lt;endl; return 0;&#125; 运行结果：13.14159, 3 ​ pi 的值是 3.14159，执行int n = pi;后 n 的值变为 3，虽然是赋值，但是 pi 和 n 的值并不相等。将派生类的指针赋值给基类的指针时也是类似的道理，编译器也可能会在赋值前进行处理。 ​ 要理解这个问题，首先要清楚 D 类对象的内存模型，如下图所示： ​ 首先要明确的一点是，对象的指针必须要指向对象的起始位置。 ​ 对于 A 类和 B 类来说，它们的子对象的起始地址和 D 类对象一样，所以将 pd 赋值给 pa、pb 时不需要做任何调整，直接传递现有的值即可；而 C 类子对象距离 D 类对象的开头有一定的偏移，将 pd 赋值给 pa 时要加上这个偏移，这样 pc 才能指向 C 类子对象的起始位置。也就是说，执行pc = pd;语句时编译器对 pd 的值进行了调整，才导致 pc、pd 的值不同。 ​ 下面的代码演示了将 pd 赋值给 pc 时编译器的调整过程： pc = (C*)( (int)pd + sizeof(B) ); ​ 如果我们把 B、C 类的继承顺序调整一下，让 C 在 B 前面，如下所示：1class D: public C, public B ​ 那么输出结果就会变为：1234pa=0x317fcpb=0x317fcpc=0x317f8pd=0x317f8 ​ 相信聪明的你能够自行分析出来。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++拷贝构造函数]]></title>
    <url>%2F2019%2F05%2F25%2Fc%2B%2B%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[拷贝和复制是一个意思，对应的英文单词都是copy。对于计算机来说，拷贝是指用一份原有的、已经存在的数据创建出一份新的数据，最终的结果是多了一份相同的数据。 拷贝构造函数​ 例如，将 Word 文档拷贝到U盘去复印店打印，将 D 盘的图片拷贝到桌面以方便浏览，将重要的文件上传到百度网盘以防止丢失等，都是「创建一份新数据」的意思。 ​ 在 C++ 中，拷贝并没有脱离它本来的含义，只是将这个含义进行了“特化”，是指用已经存在的对象创建出一个新的对象。从本质上讲，对象也是一份数据，因为它会占用内存。 ​ 严格来说，对象的创建包括两个阶段，首先要分配内存空间，然后再进行初始化： 分配内存很好理解，就是在堆区、栈区或者全局数据区留出足够多的字节。这个时候的内存还比较“原始”，没有被“教化”，它所包含的数据一般是零值或者随机值，没有实际的意义。 初始化就是首次对内存赋值，让它的数据有意义。注意是首次赋值，再次赋值不叫初始化。初始化的时候还可以为对象分配其他的资源（打开文件、连接网络、动态分配内存等），或者提前进行一些计算（根据价格和数量计算出总价、根据长度和宽度计算出矩形的面积等）等。说白了，初始化就是调用构造函数。 ​ 很明显，这里所说的拷贝是在初始化阶段进行的，也就是用其它对象的数据来初始化新对象的内存。 ​ 那么，如何用拷贝的方式来初始化一个对象呢？其实这样的例子比比皆是，string 类就是一个典型的例子。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void func(string str)&#123; cout&lt;&lt;str&lt;&lt;endl;&#125;int main()&#123; string s1 = "http://c.biancheng.net"; string s2(s1); string s3 = s1; string s4 = s1 + " " + s2; func(s1); cout&lt;&lt;s1&lt;&lt;endl&lt;&lt;s2&lt;&lt;endl&lt;&lt;s3&lt;&lt;endl&lt;&lt;s4&lt;&lt;endl; return 0;&#125; 运行结果：12345http://c.biancheng.nethttp://c.biancheng.nethttp://c.biancheng.nethttp://c.biancheng.nethttp://c.biancheng.net http://c.biancheng.net ​ s1、s2、s3、s4 以及 func() 的形参str，都是使用拷贝的方式来初始化的。 对于 s1，表面上看起来是将一个字符串直接赋值给了 s1，实际上在内部进行了类型转换，将 const char * 类型转换为 string 类型后才赋值的，s4 也是类似的道理。 ​ 对于s1、s2、s3、s4，都是将其它对象的数据拷贝给当前对象，以完成当前对象的初始化。 ​ 对于func() 的形参 str，其实在定义时就为它分配了内存，但是此时并没有初始化，只有等到调用func() 时，才会将其它对象的数据拷贝给 str以完成初始化。 ​ 当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是拷贝构造函数（Copy Constructor）。 ​ 下面的例子演示了拷贝构造函数的定义和使用： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Student&#123;public: Student(string name = "", int age = 0, float score = 0.0f); //普通构造函数 Student(const Student &amp;stu); //拷贝构造函数（声明）public: void display();private: string m_name; int m_age; float m_score;&#125;;Student::Student(string name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;//拷贝构造函数（定义）Student::Student(const Student &amp;stu)&#123; this-&gt;m_name = stu.m_name; this-&gt;m_age = stu.m_age; this-&gt;m_score = stu.m_score; cout&lt;&lt;"Copy constructor was called."&lt;&lt;endl;&#125;void Student::display()&#123; cout&lt;&lt;m_name&lt;&lt;"的年龄是"&lt;&lt;m_age&lt;&lt;"，成绩是"&lt;&lt;m_score&lt;&lt;endl;&#125;int main()&#123; Student stu1("小明", 16, 90.5); Student stu2 = stu1; //调用拷贝构造函数 Student stu3(stu1); //调用拷贝构造函数 stu1.display(); stu2.display(); stu3.display(); return 0;&#125; 运行结果： 12345Copy constructor was called.Copy constructor was called.小明的年龄是16，成绩是90.5小明的年龄是16，成绩是90.5小明的年龄是16，成绩是90.5 ​ 第 8 行是拷贝构造函数的声明，第 20 行是拷贝构造函数的定义。拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 const引用。 1) 为什么必须是当前类的引用呢？​ 如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。 ​ 只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是 C++ 语法的要求。 2) 为什么是 const 引用呢？​ 拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。 ​ 另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为const类型不能转换为非 const类型，这就意味着，不能使用 const对象来初始化当前对象了。 ​ 以上面的 Student 类为例，将const 去掉后，拷贝构造函数的原型变为：1Student::Student(Student &amp;stu); ​ 此时，下面的代码就会发生错误： 123const Student stu1("小明", 16, 90.5);Student stu2 = stu1;Student stu3(stu1); ​ stu1 是 const 类型，在初始化 stu2、stu3 时，编译器希望调用Student::Student(const Student &amp;stu)，但是这个函数却不存在，又不能将 const Student 类型转换为 Student 类型去调用Student::Student(Student &amp;stu)，所以最终调用失败了。 ​ 当然，你也可以再添加一个参数为 const 引用的拷贝构造函数，这样就不会出错了。换句话说，一个类可以同时存在两个拷贝构造函数，一个函数的参数为 const引用，另一个函数的参数为非 const 引用。 默认拷贝构造函数​ 在前面的教程中，我们还没有讲解拷贝构造函数，但是却已经在使用拷贝的方式创建对象了，并且也没有引发什么错误。这是因为，如果程序员没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数。这个默认的拷贝构造函数很简单，就是使用“老对象”的成员变量对“新对象”的成员变量进行一一赋值，和上面 Student 类的拷贝构造函数非常类似。 ​ 对于简单的类，默认拷贝构造函数一般是够用的，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认拷贝构造函数就不能拷贝这些资源，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据 拷贝构造函数的调用时机​ 当以拷贝的方式初始化对象时会调用拷贝构造函数。这里有两个关键点，分别是「以拷贝的方式」和「初始化对象」。 初始化对象​ 初始化对象是指，为对象分配内存后第一次向内存中填充数据，这个过程会调用构造函数。对象被创建后必须立即被初始化，换句话说，只要创建对象，就会调用构造函数。 初始化和赋值的区别​ 初始化和赋值都是将数据写入内存中，并且从表面上看起来，初始化在很多时候都是以赋值的方式来实现的，所以很容易混淆。请看下面的例子： 123456int a = 100; //以赋值的方式初始化a = 200; //赋值a = 300; //赋值int b; //默认初始化b = 29; //赋值b = 39; //赋值 ​ 在定义的同时进行赋值叫做初始化（Initialization），定义完成以后再赋值（不管在定义的时候有没有赋值）就叫做赋值（Assignment）。初始化只能有一次，赋值可以有多次。 ​ 对于基本类型的数据，我们很少会区分「初始化」和「赋值」这两个概念，即使将它们混淆，也不会出现什么错误。但是对于类，它们的区别就非常重要了，因为初始化时会调用构造函数（以拷贝的方式初始化时会调用拷贝构造函数），而赋值时会调用重载过的赋值运算符。请看下面的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Student&#123;public: Student(string name = "", int age = 0, float score = 0.0f); //普通构造函数 Student(const Student &amp;stu); //拷贝构造函数public: Student &amp; operator=(const Student &amp;stu); //重载=运算符 void display();private: string m_name; int m_age; float m_score;&#125;;Student::Student(string name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;//拷贝构造函数Student::Student(const Student &amp;stu)&#123; this-&gt;m_name = stu.m_name; this-&gt;m_age = stu.m_age; this-&gt;m_score = stu.m_score; cout&lt;&lt;"Copy constructor was called."&lt;&lt;endl;&#125;//重载=运算符Student &amp; Student::operator=(const Student &amp;stu)&#123; this-&gt;m_name = stu.m_name; this-&gt;m_age = stu.m_age; this-&gt;m_score = stu.m_score; cout&lt;&lt;"operator=() was called."&lt;&lt;endl; return *this;&#125;void Student::display()&#123; cout&lt;&lt;m_name&lt;&lt;"的年龄是"&lt;&lt;m_age&lt;&lt;"，成绩是"&lt;&lt;m_score&lt;&lt;endl;&#125;int main()&#123; //stu1、stu2、stu3都会调用普通构造函数Student(string name, int age, float score) Student stu1("小明", 16, 90.5); Student stu2("王城", 17, 89.0); Student stu3("陈晗", 18, 98.0); Student stu4 = stu1; //调用拷贝构造函数Student(const Student &amp;stu) stu4 = stu2; //调用operator=() stu4 = stu3; //调用operator=() Student stu5; //调用普通构造函数Student() stu5 = stu1; //调用operator=() stu5 = stu2; //调用operator=() return 0;&#125; 运行结果： 12345Copy constructor was called.operator=() was called.operator=() was called.operator=() was called.operator=() was called. 以拷贝的方式初始化对象​ 初始化对象时会调用构造函数，不同的初始化方式会调用不同的构造函数： 如果用传递进来的实参初始化对象，那么会调用普通的构造函数，我们不妨将此称为普通初始化； 如果用其它对象（现有对象）的数据来初始化对象，那么会调用拷贝构造函数，这就是以拷贝的方式初始化。 在实际编程中，具体有哪些情况是以拷贝的方式来初始化对象呢？ 1) 将其它对象作为实参​ 以上面的 Student 类为例，我们可以这样来创建一个新的对象： 12Student stu1("小明", 16, 90.5); //普通初始化Student stu2(stu1); //以拷贝的方式初始化 ​ 即使我们不在类中显式地定义拷贝构造函数，这种初始化方式也是有效的，因为编译器会生成默认的拷贝构造函数。 2) 在创建对象的同时赋值​ 接着使用 Student 类，请看下面的例子： 12Student stu1("小明", 16, 90.5); //普通初始化Student stu2 = stu1; //以拷贝的方式初始化 ​ 这是最常见的一种以拷贝的方式初始化对象的情况，非常容易理解，我们也已经多次使用。 3) 函数的形参为类类型​ 如果函数的形参为类类型（也就是一个对象），那么调用函数时要将另外一个对象作为实参传递进来赋值给形参，这也是以拷贝的方式初始化形参对象。请看下面的代码： 123456void func(Student s)&#123; //TODO:&#125;Student stu("小明", 16, 90.5); //普通初始化func(stu); //以拷贝的方式初始化 `func() `函数有一个 Student 类型的形参 s，将实参 `stu `传递给形参 s 就是以拷贝的方式初始化的过程。 ​ 函数是一段可以重复使用的代码，只有等到真正调用函数时才会为局部数据（形参和局部变量）在栈上分配内存。对于上面的func()，虽然它的形参 s 是一个对象，但在定义函数时 s 对象并没有被创建，只有等到调用函数时才会真正地创建 s 对象，并在栈上为它分配内存。而创建 s 对象，就是以拷贝的方式进行的，它等价于下面的代码：1Student s = stu; 4) 函数返回值为类类型​ 当函数的返回值为类类型时，return 语句会返回一个对象，不过为了防止局部对象被销毁，也为了防止通过返回值修改原来的局部对象，编译器并不会直接返回这个对象，而是根据这个对象先创建出一个临时对象（匿名对象），再将这个临时对象返回。而创建临时对象的过程，就是以拷贝的方式进行的，会调用拷贝构造函数。 下面的代码演示了返回一个对象的情形： 123456Student func()&#123; Student s("小明", 16, 90.5); return s;&#125;Student stu = func(); ​ 理论上讲，运行代码后会调用两次拷贝构造函数，一次是返回 s 对象时，另外一次是创建 stu 对象时。 深拷贝和浅拷贝​ 对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存。例如： 123456789101112131415161718class Base&#123;public: Base(): m_a(0), m_b(0)&#123; &#125; Base(int a, int b): m_a(a), m_b(b)&#123; &#125;private: int m_a; int m_b;&#125;;int main()&#123; int a = 10; int b = a; //拷贝 Base obj1(10, 20); Base obj2 = obj1; //拷贝 return 0;&#125; ​ b 和 obj2都是以拷贝的方式初始化的，具体来说，就是将 a 和 obj1所在内存中的数据按照二进制位（Bit）复制到 b 和 obj2 所在的内存，这种默认的拷贝行为就是浅拷贝，这和调用 memcpy()函数的效果非常类似。 ​ 对于简单的类，默认的拷贝构造函数一般就够用了，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，例如动态分配的内存、指向其他数据的指针等，默认的拷贝构造函数就不能拷贝这些资源了，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。 ​ 下面我们通过一个具体的例子来说明显式定义拷贝构造函数的必要性。我们知道，有些较老的编译器不支持变长数组，例如 VC6.0、VS2010 等，这有时候会给编程带来不便，下面我们通过自定义的 Array 类来实现变长数组。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;//变长数组类class Array&#123;public: Array(int len); Array(const Array &amp;arr); //拷贝构造函数 ~Array();public: int operator[](int i) const &#123; return m_p[i]; &#125; //获取元素（读取） int &amp;operator[](int i)&#123; return m_p[i]; &#125; //获取元素（写入） int length() const &#123; return m_len; &#125;private: int m_len; int *m_p;&#125;;Array::Array(int len): m_len(len)&#123; m_p = (int*)calloc( len, sizeof(int) );&#125;Array::Array(const Array &amp;arr)&#123; //拷贝构造函数 this-&gt;m_len = arr.m_len; this-&gt;m_p = (int*)calloc( this-&gt;m_len, sizeof(int) ); memcpy( this-&gt;m_p, arr.m_p, m_len * sizeof(int) );&#125;Array::~Array()&#123; free(m_p); &#125;//打印数组元素void printArray(const Array &amp;arr)&#123; int len = arr.length(); for(int i=0; i&lt;len; i++)&#123; if(i == len-1)&#123; cout&lt;&lt;arr[i]&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;arr[i]&lt;&lt;", "; &#125; &#125;&#125;int main()&#123; Array arr1(10); for(int i=0; i&lt;10; i++)&#123; arr1[i] = i; &#125; Array arr2 = arr1; arr2[5] = 100; arr2[3] = 29; printArray(arr1); printArray(arr2); return 0;&#125; 运行结果：120, 1, 2, 3, 4, 5, 6, 7, 8, 90, 1, 2, 29, 4, 100, 6, 7, 8, 9 ​ 本例中我们显式地定义了拷贝构造函数，它除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来。这样做的结果是，原有对象和新对象所持有的动态内存是相互独立的，更改一个对象的数据不会影响另外一个对象，本例中我们更改了 arr2的数据，就没有影响 arr1。 ​ 这种将对象所持有的其它资源一并拷贝的行为叫做深拷贝，我们必须显式地定义拷贝构造函数才能达到深拷贝的目的。 ​ 深拷贝的例子比比皆是，除了上面的变长数组类，标准模板库（STL）中的 string、vector、stack、set、map 等也都必须使用深拷贝。 ​ 读者如果希望亲眼目睹不使用深拷贝的后果，可以将上例中的拷贝构造函数删除，那么运行结果将变为：120, 1, 2, 29, 4, 100, 6, 7, 8, 90, 1, 2, 29, 4, 100, 6, 7, 8, 9 ​ 可以发现，更改arr2 的数据也影响到了 arr1。这是因为，在创建 arr2 对象时，默认拷贝构造函数将 arr1.m_p 直接赋值给了 arr2.m_p，导致 arr2.m_p和 arr1.m_p 指向了同一块内存，所以会相互影响。 ​ 另外需要注意的是，printArray()函数的形参为引用类型，这样做能够避免在传参时调用拷贝构造函数；又因为 printArray() 函数不会修改任何数组元素，所以我们添加了const 限制，以使得语义更加明确。 到底是浅拷贝还是深拷贝​ 如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深拷贝，因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。如果类的成员变量没有指针，一般浅拷贝足以。 ​ 另外一种需要深拷贝的情况就是在创建对象时进行一些预处理工作，比如统计创建过的对象的数目、记录对象创建的时间等，请看下面的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;ctime&gt;#include &lt;windows.h&gt; //在Linux和Mac下要换成 unistd.h 头文件using namespace std;class Base&#123;public: Base(int a = 0, int b = 0); Base(const Base &amp;obj); //拷贝构造函数public: int getCount() const &#123; return m_count; &#125; time_t getTime() const &#123; return m_time; &#125;private: int m_a; int m_b; time_t m_time; //对象创建时间 static int m_count; //创建过的对象的数目&#125;;int Base::m_count = 0;Base::Base(int a, int b): m_a(a), m_b(b)&#123; m_count++; m_time = time((time_t*)NULL);&#125;Base::Base(const Base &amp;obj)&#123; //拷贝构造函数 this-&gt;m_a = obj.m_a; this-&gt;m_b = obj.m_b; this-&gt;m_count++; this-&gt;m_time = time((time_t*)NULL);&#125;int main()&#123; Base obj1(10, 20); cout&lt;&lt;"obj1: count = "&lt;&lt;obj1.getCount()&lt;&lt;", time = "&lt;&lt;obj1.getTime()&lt;&lt;endl; Sleep(3000); //在Linux和Mac下要写作 sleep(3); Base obj2 = obj1; cout&lt;&lt;"obj2: count = "&lt;&lt;obj2.getCount()&lt;&lt;", time = "&lt;&lt;obj2.getTime()&lt;&lt;endl; return 0;&#125; 运行结果：123obj1: count = 1, time = 1488344372obj2: count = 2, time = 1488344375 ​ 运行程序，先输出第一行结果，等待 3 秒后再输出第二行结果。Base 类中的 m_time 和 m_count 分别记录了对象的创建时间和创建数目，它们在不同的对象中有不同的值，所以需要在初始化对象的时候提前处理一下，这样浅拷贝就不能胜任了，就必须使用深拷贝了。 重载赋值运算符​ 我们讲解了初始化和赋值的区别：在定义的同时进行赋值叫做初始化（Initialization），定义完成以后再赋值（不管在定义的时候有没有赋值）就叫做赋值（Assignment）。初始化只能有一次，赋值可以有多次。 ​ 当以拷贝的方式初始化一个对象时，会调用拷贝构造函数；当给一个对象赋值时，会调用重载过的赋值运算符。 ​ 即使我们没有显式的重载赋值运算符，编译器也会以默认地方式重载它。默认重载的赋值运算符功能很简单，就是将原有对象的所有成员变量一一赋值给新对象，这和默认拷贝构造函数的功能类似。 ​ 对于简单的类，默认的赋值运算符一般就够用了，我们也没有必要再显式地重载它。但是当类持有其它资源时，例如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认的赋值运算符就不能处理了，我们必须显式地重载它，这样才能将原有对象的所有数据都赋值给新对象。 ​ 仍然以上节的 Array 类为例，该类拥有一个指针成员，指向动态分配的内存。为了让 Array 类的对象之间能够正确地赋值，我们必须重载赋值运算符。请看下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;//变长数组类class Array&#123;public: Array(int len); Array(const Array &amp;arr); //拷贝构造函数 ~Array();public: int operator[](int i) const &#123; return m_p[i]; &#125; //获取元素（读取） int &amp;operator[](int i)&#123; return m_p[i]; &#125; //获取元素（写入） Array &amp; operator=(const Array &amp;arr); //重载赋值运算符 int length() const &#123; return m_len; &#125;private: int m_len; int *m_p;&#125;;Array::Array(int len): m_len(len)&#123; m_p = (int*)calloc( len, sizeof(int) );&#125;Array::Array(const Array &amp;arr)&#123; //拷贝构造函数 this-&gt;m_len = arr.m_len; this-&gt;m_p = (int*)calloc( this-&gt;m_len, sizeof(int) ); memcpy( this-&gt;m_p, arr.m_p, m_len * sizeof(int) );&#125;Array::~Array()&#123; free(m_p); &#125;Array &amp;Array::operator=(const Array &amp;arr)&#123; //重载赋值运算符 if( this != &amp;arr)&#123; //判断是否是给自己赋值 this-&gt;m_len = arr.m_len; free(this-&gt;m_p); //释放原来的内存 this-&gt;m_p = (int*)calloc( this-&gt;m_len, sizeof(int) ); memcpy( this-&gt;m_p, arr.m_p, m_len * sizeof(int) ); &#125; return *this;&#125;//打印数组元素void printArray(const Array &amp;arr)&#123; int len = arr.length(); for(int i=0; i&lt;len; i++)&#123; if(i == len-1)&#123; cout&lt;&lt;arr[i]&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;arr[i]&lt;&lt;", "; &#125; &#125;&#125;int main()&#123; Array arr1(10); for(int i=0; i&lt;10; i++)&#123; arr1[i] = i; &#125; printArray(arr1); Array arr2(5); for(int i=0; i&lt;5; i++)&#123; arr2[i] = i; &#125; printArray(arr2); arr2 = arr1; //调用operator=() printArray(arr2); arr2[3] = 234; //修改arr1的数据不会影响arr2 arr2[7] = 920; printArray(arr1); return 0;&#125; 运行结果：12340, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3, 40, 1, 2, 3, 4, 5, 6, 7, 8, 90, 1, 2, 3, 4, 5, 6, 7, 8, 9 ​ 将 arr1 赋值给 arr2后，修改 arr2 的数据不会影响 arr1。如果把 operator=() 注释掉，那么运行结果将变为：12340, 1, 2, 3, 4, 5, 6, 7, 8, 90, 1, 2, 3, 40, 1, 2, 3, 4, 5, 6, 7, 8, 90, 1, 2, 234, 4, 5, 6, 920, 8, 9 去掉operator=()后，由于 m_p 指向的堆内存会被 free() 两次，所以还会导致内存错误。 下面我们就来分析一下重载过的赋值运算符。 ​ 1) operator=() 的返回值类型为Array &amp;，这样不但能够避免在返回数据时调用拷贝构造函数，还能够达到连续赋值的目的。下面的语句就是连续赋值：1arr4 = arr3 = arr2 = arr1; ​ 2) if( this != &amp;arr)语句的作用是「判断是否是给同一个对象赋值」：如果是，那就什么也不做；如果不是，那就将原有对象的所有成员变量一一赋值给新对象，并为新对象重新分配内存。下面的语句就是给同一个对象赋值：12arr1 = arr1;arr2 = arr2; ​ 3) return *this表示返回当前对象（新对象）。 ​ 4) operator=() 的形参类型为const Array &amp;，这样不但能够避免在传参时调用拷贝构造函数，还能够同时接收const 类型和非 const 类型的实参。 ​ 5) 赋值运算符重载函数除了能有对象引用这样的参数之外，也能有其它参数。但是其它参数必须给出默认值，例如：1Array &amp; operator=(const Array &amp;arr, int a = 100);]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++运算符重载]]></title>
    <url>%2F2019%2F05%2F25%2Fc%2B%2B%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[所谓重载，就是赋予新的含义。函数重载（Function Overloading）可以让一个函数名有多种功能，在不同情况下进行不同的操作。运算符重载（Operator Overloading）也是一个道理，同一个运算符可以有不同的功能。 成员函数重载运算符​ 实际上，我们已经在不知不觉中使用了运算符重载。例如，+号可以对不同类型（int、float 等）的数据进行加法操作；&lt;&lt;既是位移运算符，又可以配合 cout 向控制台输出数据。C++ 本身已经对这些运算符进行了重载。 C++ 也允许程序员自己重载运算符，这给我们带来了很大的便利。 ​ 下面的代码定义了一个复数类，通过运算符重载，可以用+号实现复数的加法运算： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;class complex&#123;public: complex(); complex(double real, double imag);public: //声明运算符重载 complex operator+(const complex &amp;A) const; void display() const;private: double m_real; //实部 double m_imag; //虚部&#125;;complex::complex(): m_real(0.0), m_imag(0.0)&#123; &#125;complex::complex(double real, double imag): m_real(real), m_imag(imag)&#123; &#125;//实现运算符重载complex complex::operator+(const complex &amp;A) const&#123; complex B; B.m_real = this-&gt;m_real + A.m_real; B.m_imag = this-&gt;m_imag + A.m_imag; return B;&#125;void complex::display() const&#123; cout&lt;&lt;m_real&lt;&lt;" + "&lt;&lt;m_imag&lt;&lt;"i"&lt;&lt;endl;&#125;int main()&#123; complex c1(4.3, 5.8); complex c2(2.4, 3.7); complex c3; c3 = c1 + c2; c3.display(); return 0;&#125; 运行结果：16.7 + 9.5i ​ 本例中义了一个复数类 complex，m_real 表示实部，m_imag 表示虚部，第 10 行声明了运算符重载，第 21 行进行了实现（定义）。认真观察这两行代码，可以发现运算符重载的形式与函数非常类似。 ​ 运算符重载其实就是定义一个函数，在函数体内实现想要的功能，当用到该运算符时，编译器会自动调用这个函数。也就是说，运算符重载是通过函数实现的，它本质上是函数重载。 ​ 运算符重载的格式为：123返回值类型 operator 运算符名称 (形参表列)&#123; //TODO:&#125; ​ operator是关键字，专门用于定义重载运算符的函数。我们可以将operator 运算符名称这一部分看做函数名，对于上面的代码，函数名就是operator+。运算符重载函数除了函数名有特定的格式，其它地方和普通函数并没有区别。 ​ 上面的例子中，我们在 complex 类中重载了运算符+，该重载只对 complex 对象有效。当执行c3 = c1 + c2;语句时，编译器检测到+号左边（+号具有左结合性，所以先检测左边）是一个 complex 对象，就会调用成员函数operator+()，也就是转换为下面的形式：1c3 = c1.operator+(c2); c1 是要调用函数的对象，c2 是函数的实参。 ​ 上面的运算符重载还可以有更加简练的定义形式： 123complex complex::operator+(const complex &amp;A)const&#123; return complex(this-&gt;m_real + A.m_real, this-&gt;m_imag + A.m_imag);&#125; ​ return 语句中的 1complex(this-&gt;m_real + A.m_real, this-&gt;m_imag + A.m_imag) ​ 会创建一个临时对象，这个对象没有名称，是一个匿名对象。在创建临时对象过程中调用构造函数，return 语句将该临时对象作为函数返回值。 全局范围内重载运算符​ 运算符重载函数不仅可以作为类的成员函数，还可以作为全局函数。 ​ 更改上面的代码，在全局范围内重载+，实现复数的加法运算： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;class complex&#123;public: complex(); complex(double real, double imag);public: void display() const; //声明为友元函数 friend complex operator+(const complex &amp;A, const complex &amp;B);private: double m_real; double m_imag;&#125;;complex operator+(const complex &amp;A, const complex &amp;B);complex::complex(): m_real(0.0), m_imag(0.0)&#123; &#125;complex::complex(double real, double imag): m_real(real), m_imag(imag)&#123; &#125;void complex::display() const&#123; cout&lt;&lt;m_real&lt;&lt;" + "&lt;&lt;m_imag&lt;&lt;"i"&lt;&lt;endl;&#125;//在全局范围内重载+complex operator+(const complex &amp;A, const complex &amp;B)&#123; complex C; C.m_real = A.m_real + B.m_real; C.m_imag = A.m_imag + B.m_imag; return C;&#125;int main()&#123; complex c1(4.3, 5.8); complex c2(2.4, 3.7); complex c3; c3 = c1 + c2; c3.display(); return 0;&#125; ​ 运算符重载函数不是 complex 类的成员函数，但是却用到了 complex 类的 private 成员变量，所以必须在 complex 类中将该函数声明为友元函数。 ​ 当执行c3 = c1 + c2;语句时，编译器检测到+号两边都是 complex 对象，就会转换为类似下面的函数调用：1c3 = operator+(c1, c2); 运算符重载注意事项​ 运算符重载是通过函数重载实现的，概念上大家都很容易理解，这节我们来说一下运算符重载的注意事项。 1) 并不是所有的运算符都可以重载。能够重载的运算符包括： ​ \+ - * / % ^ &amp; | ~ ! = &lt; &gt; += -= *= /= %= ^= &amp;= |= &lt;&lt; &gt;&gt; &lt;&lt;= &gt;&gt;= == != &lt;= &gt;= &amp;&amp; || ++ -- , -&gt;* -&gt; () [] new new[] delete delete[] ​ 上述运算符中，[]是下标运算符，()是函数调用运算符。自增自减运算符的前置和后置形式都可以重载。长度运算符sizeof、条件运算符: ?、成员选择符.和域解析运算符::不能被重载。 2) 重载不能改变运算符的优先级和结合性。假设上一节的 complex 类中重载了`+`号和`*`·号，并且 `c1`、`c2`、`c3`、`c4` 都是 complex 类的对象，那么下面的语句： 1c4 = c1 + c2 * c3; ​ 等价于：1c4 = c1 + ( c2 * c3 ); ​ 乘法的优先级仍然高于加法，并且它们仍然是二元运算符。 3) 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变。例如`~`号右边只有一个操作数，`+`号总是出现在两个操作数之间，重载后也必须如此。 4) 运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的。 ​ 5) 运算符重载函数既可以作为类的成员函数，也可以作为全局函数。将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的。 ​ 例如，上节的 complex 类中重载了加法运算符：1complex operator+(const complex &amp; A) const; ​ 当执行：1c3 = c1 + c2; ​ 会被转换为：1c3 = c1.operator+(c2); ​ 通过 this 指针隐式的访问 c1 的成员变量。 ​ 将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要一个参数，而且其中必须有一个参数是对象，好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质。 例如，下面这样是不对的： 123int operator + (int a,int b)&#123; return (a-b);&#125; ​ +号原来是对两个数相加，现在企图通过重载使它的作用改为两个数相减， 如果允许这样重载的话，那么表达式4+3的结果是 7 还是 1 呢？显然，这是绝对禁止的。 ​ 如果有两个参数，这两个参数可以都是对象，也可以一个是对象，一个是C ++内置类型的数据，例如： 123complex operator+(int a, complex &amp;c)&#123; return complex(a+c.real, c.imag);&#125; ​ 它的作用是使一个整数和一个复数相加。另外，将运算符重载函数作为全局函数时，一般都需要在类中将该函数声明为友元函数。原因很简单，该函数大部分情况下都需要使用类的 private 成员。 ​ 上节的最后一个例子中，我们在全局范围内重载了+号，并在 complex 类中将运算符重载函数声明为友元函数，因为该函数使用到了 complex 类的 m_real 和 m_imag 两个成员变量，它们都是 private 属性的，默认不能在类的外部访问。 ​ 6) 箭头运算符-&gt;、下标运算符[ ]、函数调用运算符( )、赋值运算符=只能以成员函数的形式重载。 重载数学运算符​ 四则运算符（+、-、*、/、+=、-=、*=、/=）和关系运算符（&gt;、&lt;、&lt;=、&gt;=、==、!=）都是数学运算符，它们在实际开发中非常常见，被重载的几率也很高，并且有着相似的重载格式。本节以复数类 Complex 为例对它们进行重载，重在演示运算符重载的语法以及规范。 ​ 复数能够进行完整的四则运算，但不能进行完整的关系运算：我们只能判断两个复数是否相等，但不能比较它们的大小，所以不能对 &gt;、&lt;、&lt;=、&gt;= 进行重载。下面是具体的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;//复数类class Complex&#123;public: //构造函数 Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag)&#123; &#125;public: //运算符重载 //以全局函数的形式重载 friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2); friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2); friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2); friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2); friend bool operator==(const Complex &amp;c1, const Complex &amp;c2); friend bool operator!=(const Complex &amp;c1, const Complex &amp;c2); //以成员函数的形式重载 Complex &amp; operator+=(const Complex &amp;c); Complex &amp; operator-=(const Complex &amp;c); Complex &amp; operator*=(const Complex &amp;c); Complex &amp; operator/=(const Complex &amp;c);public: //成员函数 double real() const&#123; return m_real; &#125; double imag() const&#123; return m_imag; &#125;private: double m_real; //实部 double m_imag; //虚部&#125;;//重载+运算符Complex operator+(const Complex &amp;c1, const Complex &amp;c2)&#123; Complex c; c.m_real = c1.m_real + c2.m_real; c.m_imag = c1.m_imag + c2.m_imag; return c;&#125;//重载-运算符Complex operator-(const Complex &amp;c1, const Complex &amp;c2)&#123; Complex c; c.m_real = c1.m_real - c2.m_real; c.m_imag = c1.m_imag - c2.m_imag; return c;&#125;//重载*运算符 (a+bi) * (c+di) = (ac-bd) + (bc+ad)iComplex operator*(const Complex &amp;c1, const Complex &amp;c2)&#123; Complex c; c.m_real = c1.m_real * c2.m_real - c1.m_imag * c2.m_imag; c.m_imag = c1.m_imag * c2.m_real + c1.m_real * c2.m_imag; return c;&#125;//重载/运算符 (a+bi) / (c+di) = [(ac+bd) / (c²+d²)] + [(bc-ad) / (c²+d²)]iComplex operator/(const Complex &amp;c1, const Complex &amp;c2)&#123; Complex c; c.m_real = (c1.m_real*c2.m_real + c1.m_imag*c2.m_imag) / (pow(c2.m_real, 2) + pow(c2.m_imag, 2)); c.m_imag = (c1.m_imag*c2.m_real - c1.m_real*c2.m_imag) / (pow(c2.m_real, 2) + pow(c2.m_imag, 2)); return c;&#125;//重载==运算符bool operator==(const Complex &amp;c1, const Complex &amp;c2)&#123; if( c1.m_real == c2.m_real &amp;&amp; c1.m_imag == c2.m_imag )&#123; return true; &#125;else&#123; return false; &#125;&#125;//重载!=运算符bool operator!=(const Complex &amp;c1, const Complex &amp;c2)&#123; if( c1.m_real != c2.m_real || c1.m_imag != c2.m_imag )&#123; return true; &#125;else&#123; return false; &#125;&#125;//重载+=运算符Complex &amp; Complex::operator+=(const Complex &amp;c)&#123; this-&gt;m_real += c.m_real; this-&gt;m_imag += c.m_imag; return *this;&#125;//重载-=运算符Complex &amp; Complex::operator-=(const Complex &amp;c)&#123; this-&gt;m_real -= c.m_real; this-&gt;m_imag -= c.m_imag; return *this;&#125;//重载*=运算符Complex &amp; Complex::operator*=(const Complex &amp;c)&#123; this-&gt;m_real = this-&gt;m_real * c.m_real - this-&gt;m_imag * c.m_imag; this-&gt;m_imag = this-&gt;m_imag * c.m_real + this-&gt;m_real * c.m_imag; return *this;&#125;//重载/=运算符Complex &amp; Complex::operator/=(const Complex &amp;c)&#123; this-&gt;m_real = (this-&gt;m_real*c.m_real + this-&gt;m_imag*c.m_imag) / (pow(c.m_real, 2) + pow(c.m_imag, 2)); this-&gt;m_imag = (this-&gt;m_imag*c.m_real - this-&gt;m_real*c.m_imag) / (pow(c.m_real, 2) + pow(c.m_imag, 2)); return *this;&#125;int main()&#123; Complex c1(25, 35); Complex c2(10, 20); Complex c3(1, 2); Complex c4(4, 9); Complex c5(34, 6); Complex c6(80, 90); Complex c7 = c1 + c2; Complex c8 = c1 - c2; Complex c9 = c1 * c2; Complex c10 = c1 / c2; cout&lt;&lt;"c7 = "&lt;&lt;c7.real()&lt;&lt;" + "&lt;&lt;c7.imag()&lt;&lt;"i"&lt;&lt;endl; cout&lt;&lt;"c8 = "&lt;&lt;c8.real()&lt;&lt;" + "&lt;&lt;c8.imag()&lt;&lt;"i"&lt;&lt;endl; cout&lt;&lt;"c9 = "&lt;&lt;c9.real()&lt;&lt;" + "&lt;&lt;c9.imag()&lt;&lt;"i"&lt;&lt;endl; cout&lt;&lt;"c10 = "&lt;&lt;c10.real()&lt;&lt;" + "&lt;&lt;c10.imag()&lt;&lt;"i"&lt;&lt;endl; c3 += c1; c4 -= c2; c5 *= c2; c6 /= c2; cout&lt;&lt;"c3 = "&lt;&lt;c3.real()&lt;&lt;" + "&lt;&lt;c3.imag()&lt;&lt;"i"&lt;&lt;endl; cout&lt;&lt;"c4 = "&lt;&lt;c4.real()&lt;&lt;" + "&lt;&lt;c4.imag()&lt;&lt;"i"&lt;&lt;endl; cout&lt;&lt;"c5 = "&lt;&lt;c5.real()&lt;&lt;" + "&lt;&lt;c5.imag()&lt;&lt;"i"&lt;&lt;endl; cout&lt;&lt;"c6 = "&lt;&lt;c6.real()&lt;&lt;" + "&lt;&lt;c6.imag()&lt;&lt;"i"&lt;&lt;endl; if(c1 == c2)&#123; cout&lt;&lt;"c1 == c2"&lt;&lt;endl; &#125; if(c1 != c2)&#123; cout&lt;&lt;"c1 != c2"&lt;&lt;endl; &#125; return 0;&#125; 运行结果：123456789c7 = 35 + 55ic8 = 15 + 15ic9 = -450 + 850ic10 = 1.9 + -0.3ic3 = 26 + 37ic4 = -6 + -11ic5 = 220 + 4460ic6 = 5.2 + 1.592ic1 != c2 ​ 需要注意的是，我们以全局函数的形式重载了 +、-、、/、==、!=，以成员函数的形式重载了 +=、-=、=、/=，而且应该坚持这样做，不能一股脑都写作成员函数或者全局函数，具体原因我们将在下节讲解。 ​ 在上节的例子中，我们以全局函数的形式重载了 +、-、、/、==、!=，以成员函数的形式重载了 +=、-=、=、/=，而没有一股脑都写成全局函数或者成员函数，这样做是有原因的，这节我们就来分析一下。 简单地了解转换构造函数在分析以前，我们先来了解一个概念，叫做「转换构造函数」。 请大家先看下面的例子： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;//复数类class Complex&#123;public: Complex(): m_real(0.0), m_imag(0.0)&#123; &#125; Complex(double real, double imag): m_real(real), m_imag(imag)&#123; &#125; Complex(double real): m_real(real), m_imag(0.0)&#123; &#125; //转换构造函数public: friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2);public: double real() const&#123; return m_real; &#125; double imag() const&#123; return m_imag; &#125;private: double m_real; //实部 double m_imag; //虚部&#125;;//重载+运算符Complex operator+(const Complex &amp;c1, const Complex &amp;c2)&#123; Complex c; c.m_real = c1.m_real + c2.m_real; c.m_imag = c1.m_imag + c2.m_imag; return c;&#125;int main()&#123; Complex c1(25, 35); Complex c2 = c1 + 15.6; Complex c3 = 28.23 + c1; cout&lt;&lt;c2.real()&lt;&lt;" + "&lt;&lt;c2.imag()&lt;&lt;"i"&lt;&lt;endl; cout&lt;&lt;c3.real()&lt;&lt;" + "&lt;&lt;c3.imag()&lt;&lt;"i"&lt;&lt;endl; return 0;&#125; 运行结果： 1240.6 + 35i53.23 + 35i ​ 请读者留意第 30、31 行代码，它说明 Complex 类型可以和 double 类型相加，这很奇怪，因为我们并没有对针对这两个类型重载 +，这究竟是怎么做到的呢？ ​ 其实，编译器在检测到 Complex 和 double（小数默认为 double 类型）相加时，会先尝试将 double 转换为 Complex，或者反过来将 Complex 转换为 double（只有类型相同的数据才能进行 + 运算），如果都转换失败，或者都转换成功（产生了二义性），才报错。本例中，编译器会先通过构造函数Complex(double real);将 double 转换为 Complex，再调用重载过的 + 进行计算，整个过程类似于下面的形式： ​ 也就是说，小数被转换成了匿名的 Complex 对象。在这个转换过程中，构造函数Complex(double real);起到了至关重要的作用，如果没有它，转换就会失败，Complex 也不能和 double 相加。 ​ Complex(double real);在作为普通构造函数的同时，还能将 double 类型转换为 Complex 类型，集合了“构造函数”和“类型转换”的功能，所以被称为「转换构造函数」。换句话说，转换构造函数用来将其它类型（可以是 bool、int、double 等基本类型，也可以是数组、指针、结构体、类等构造类型）转换为当前类类型。 为什么要以全局函数的形式重载 +​ 上面的例子中，我们定义的operator+是一个全局函数（一个友元函数），而不是成员函数，这样做是为了保证 + 运算符的操作数能够被对称的处理；换句话说，小数（double 类型）在 + 左边和右边都是正确的。第 30 行代码中，15.6 在 + 的右边，第 31 行代码中，28.23 在 + 的左边，它们都能够被顺利地转换为 Complex 类型，所以不会出错。 ​ 如果将operator+定义为成员函数，根据“+ 运算符具有左结合性”这条原则，Complex c2 = c1 + 15.6;会被转换为下面的形式：1Complex c2 = c1.operator+(Complex(15.6)); ​ 这就是通过对象调用成员函数，是正确的。而对于Complex c3 = 28.23 + c1;，编译器会尝试转换为不同的形式：1Complex c3 = (28.23).operator+(c1); ​ 很显然这是错误的，因为 double 类型并没有以成员函数的形式重载 +。也就是说，以成员函数的形式重载 +，只能计算c1 + 15.6，不能计算28.23 + c1，这是不对称的 ​ 有读者可能会问，编译器明明可以把 28.23 先转换成 Complex 类型再相加呀，也就是下面的形式：1Complex c3 = Complex(28.23).operator+(c1); ​ 为什么就是不转换呢？没错，编译器不会转换，原因在于，C++ 只会对成员函数的参数进行类型转换，而不会对调用成员函数的对象进行类型转换。以下面的语句为例：1obj.func(params); ​ 编译器不会尝试对 obj 进行任何类型转换，它有 func() 成员函数就调用，没有就报错。而对于实参 params，编译器会“拼命地”将它转换为形参的类型。 为什么要以成员函数的形式重载 +=​ 我们首先要明白，运算符重载的初衷是给类添加新的功能，方便类的运算，它作为类的成员函数是理所应当的，是首选的。 ​ 不过，类的成员函数不能对称地处理数据，程序员必须在（参与运算的）所有类型的内部都重载当前的运算符。以上面的情况为例，我们必须在 Complex 和 double 内部都重载 + 运算符，这样做不但会增加运算符重载的数目，还要在许多地方修改代码，这显然不是我们所希望的，所以 C++ 进行了折中，允许以全局函数（友元函数）的形式重载运算符。 ​ C++ 创始人 Bjarne Stroustrup 也曾考虑过为内部类型（bool、int、double 等）定义额外运算符的问题，但后来还是放弃了这种想法，因为 Bjarne Stroustrup 不希望改变现有规则：任何类型（无论是内部类型还是用户自定义类型）都不能在其定义完成以后再增加额外的操作。这里还有另外的一个原因，C内部类型之间的转换已经够肮脏了，决不能再向里面添乱。而通过成员函数为已存在的类型提供混合运算的方式，从本质上看，比我们所采用的全局函数（友元函数）加转换构造函数的方式还要肮脏许多。 ​ 采用全局函数能使我们定义这样的运算符，它们的参数具有逻辑的对称性。与此相对应的，把运算符定义为成员函数能够保证在调用时对第一个（最左的）运算对象不出现类型转换，也就是上面提到的「C++ 不会对调用成员函数的对象进行类型转换」。 ​ 总起来说，有一部分运算符重载既可以是成员函数也可以是全局函数，虽然没有一个必然的、不可抗拒的理由选择成员函数，但我们应该优先考虑成员函数，这样更符合运算符重载的初衷；另外有一部分运算符重载必须是全局函数，这样能保证参数的对称性；除了 C++ 规定的几个特定的运算符外，暂时还没有发现必须以成员函数的形式重载的运算符。 C++ 规定，箭头运算符`-&gt;`、下标运算符`[ ]`、函数调用运算符`( )`、赋值运算符`=`只能以成员函数的形式重载。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言-引用和指针的异同]]></title>
    <url>%2F2019%2F05%2F25%2Fc%E8%AF%AD%E8%A8%80-%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"><![CDATA[引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样。 引用和指针的异同引用的含义​ 通过上节的讲解，相信各位读者对引用都有了一个概念上的认识，能够简单地使用引用编程了，但又感觉糊里糊涂，不明白它到底是什么，它和指针有点相似，但又不是一个东西。 ​ 首先来回顾一下上节的例子： 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 99; int &amp;b = a; cout&lt;&lt;a&lt;&lt;", "&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;&amp;a&lt;&lt;", "&lt;&lt;&amp;b&lt;&lt;endl; return 0;&#125; ​ 运行结果：1299, 990x28ff44, 0x28ff44 ​ 我们知道，变量是要占用内存的，虽然我们称 b 为变量，但是通过&amp;b获取到的却不是 b 的地址，而是 a 的地址，这会让我们觉得 b 这个变量不占用独立的内存，它和 a 指代的是同一份内存。 引用和指针的联系​ 请读者再继续看下面的例子： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int num = 99;class A&#123;public: A();private: int n; int &amp;r;&#125;;A::A(): n(0), r(num)&#123;&#125;int main ()&#123; A *a = new A(); cout&lt;&lt;sizeof(A)&lt;&lt;endl; //输出A类型的大小 cout&lt;&lt;hex&lt;&lt;showbase&lt;&lt;*((int*)a + 1)&lt;&lt;endl; //输出r的内容 cout&lt;&lt;&amp;num&lt;&lt;endl; //输出num变量的地址 return 0;&#125; ​ 运行结果：12380x4420000x442000 ​ 成员变量 r 是 private 属性的，不能直接通过对象来访问，但是借助强大的指针和类型转换，我们依然可以得到它的内容，只不过这种方法有点蹩脚。 ​ 第 20 行代码中，hex表示以十六进制输出，showbase表示添加十六进制前缀0x。 ​ 从运行结果可以看出： 成员变量 r 是占用内存的，如果不占用的话，sizeof(A)的结果应该为 4。 r 存储的内容是0x442000，也即变量 num 的地址。 ​ 这说明 r 的实现和指针非常类似。如果将 r 定义为int *类型的指针，并在构造函数中让它指向 num，那么 r 占用的内存也是 4 个字节，存储的内容也是 num 的地址。 ​ 其实引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样，在 32 位环境下是 4 个字节，在 64 位环境下是 8 个字节，之所以不能获取引用的地址，是因为编译器进行了内部转换。 ​ 以下面的语句为例： 1234int a = 99;int &amp;r = a;r = 18;cout&lt;&lt;&amp;r&lt;&lt;endl; ​ 编译时会被转换成如下的形式： 1234int a = 99;int *r = &amp;a;*r = 18;cout&lt;&lt;r&lt;&lt;endl; ​ 使用&amp;r取地址时，编译器会对代码进行隐式的转换，使得代码输出的是 r 的内容（a 的地址），而不是 r 的地址，这就是为什么获取不到引用变量的地址的原因。 ​ 也就是说，不是变量 r 不占用内存，而是编译器不让获取它的地址。 ​ 当引用作为函数参数时，也会有类似的转换。以下面的代码为例： 12345678910//定义函数void swap(int &amp;a, int &amp;b)&#123; int temp = a; a = b; b = temp;&#125;//调用函数int num1 = 10, num2 = 20;swap(num1, num2); ​ 编译时会被转换成如下的形式： 12345678910//定义函数void swap(int *a, int *b)&#123; int temp = *a; *a = *b; *b = temp;&#125;//调用函数int num1 = 10, num2 = 20;swap(&amp;num1, &amp;num2); ​ 引用虽然是基于指针实现的，但它比指针更加易用，从上面的两个例子也可以看出来，通过指针获取数据时需要加*，书写麻烦，而引用不需要，它和普通变量的使用方式一样。 ​ C++ 的发明人 Bjarne Stroustrup 也说过，他在 C++ 中引入引用的直接目的是为了让代码的书写更加漂亮，尤其是在运算符重载中，不借助引用有时候会使得运算符的使用很麻烦。 引用和指针的区别​ 1) 引用必须在定义时初始化，并且以后也要从一而终，不能再指向其他数据；而指针没有这个限制，指针在定义时不必赋值，以后也能指向任意数据。 ​ 2) 可以有 const 指针，但是没有 const 引用。也就是说，引用变量不能定义为下面的形式： 1int a = 20;int &amp; const r = a; ​ 因为 r 本来就不能改变指向，加上 const 是多此一举。 ​ 3) 指针可以有多级，但是引用只能有一级，例如，int **p是合法的，而int &amp;&amp;r是不合法的。如果希望定义一个引用变量来指代另外一个引用变量，那么也只需要加一个&amp;，如下所示： 123int a = 10;int &amp;r = a;int &amp;rr = r; ​ 4) 指针和引用的自增（++）自减（–）运算意义不一样。对指针使用 ++ 表示指向下一份数据，对引用使用 ++ 表示它所指代的数据本身加 1；自减（–）也是类似的道理。请看下面的例子： 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main ()&#123; int a = 10; int &amp;r = a; r++; cout&lt;&lt;r&lt;&lt;endl; int arr[2] = &#123; 27, 84 &#125;; int *p = arr; p++; cout&lt;&lt;*p&lt;&lt;endl; return 0;&#125; ​ 运行结果：121184]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言-整数在内存的存储]]></title>
    <url>%2F2019%2F05%2F25%2Fc%E8%AF%AD%E8%A8%80-%E6%95%B4%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[加法和减法是计算机中最基本的运算，计算机时时刻刻都离不开它们，所以它们由硬件直接支持。为了提高加减法的运算效率，硬件电路要设计得尽量简单。 对于有符号数，内存要区分符号位和数值位，对于人脑来说，很容易辨别，但是对于计算机来说，就要设计专门的电路，这无疑增加了硬件的复杂性，增加了计算的时间。要是能把符号位和数值位等同起来，让它们一起参与运算，不再加以区分，这样硬件电路就变得简单了。 整数在内存的存储 另外，加法和减法也可以合并为一种运算，就是加法运算，因为减去一个数相当于加上这个数的相反数，例如，5 - 3等价于 5 + (-3)，10 - (-9)等价于10 + 9。 相反数是指数值相同，符号不同的两个数，例如，10 和 -10 就是一对相反数，-98 和 98 也是一对相反数。 如果能够实现上面的两个目标，那么只要设计一种简单的、不用区分符号位和数值位的加法电路，就能同时实现加法和减法运算，并且非常高效。实际上，这两个目标都已经实现了，真正的计算机硬件电路就是如此简单。 然而，简化硬件电路是有代价的，这个代价就是有符号数在存储和读取时都要进行转化。那么，这个转换过程究竟是怎样的呢？接下来我们就详细地讲解一下。 首先，请读者先记住下面的几个概念。 原码 将一个整数转换成二进制形式，就是其原码。例如short a = 6;，a 的原码就是0000 0000 0000 0110；更改 a 的值a = -18;，此时 a 的原码就是1000 0000 0001 0010。 通俗的理解，原码就是一个整数本来的二进制形式。 反码 谈到反码，正数和负数要区别对待，因为它们的反码不一样。 对于正数，它的反码就是其原码（原码和反码相同）；负数的反码是将原码中除符号位以外的所有位（数值位）取反，也就是 0 变成 1，1 变成 0。例如short a = 6;，a 的原码和反码都是0000 0000 0000 0110；更改 a 的值a = -18;，此时 a 的反码是1111 1111 1110 1101。 补码 正数和负数的补码也不一样，也要区别对待。 对于正数，它的补码就是其原码（原码、反码、补码都相同）；负数的补码是其反码加 1。例如short a = 6;，a 的原码、反码、补码都是0000 0000 0000 0110；更改 a 的值a = -18;，此时 a 的补码是1111 1111 1110 1110。 可以认为，补码是在反码的基础上打了一个补丁，进行了一下修正，所以叫“补码”。 原码、反码、补码的概念只对负数有实际意义，对于正数，它们都一样。 最后我们总结一下 6 和 -18 从原码到补码的转换过程： 在计算机内存中，整数一律采用补码的形式来存储。这意味着，当读取整数时还要采用逆向的转换，也就是将补码转换为原码。 将补码转换为原码也很简单：先减去 1，再将数值位取反即可。 补码如何简化硬件电路 假设 6 和 18 都是 short 类型的，现在我们要计算 6 - 18 的结果，根据运算规则，它等价于6 + (-18)。 如果采用原码计算，那么运算过程为：12346 - 18 = 6 + (-18)= [0000 0000 0000 0110]原 + [1000 0000 0001 0010]原= [1000 0000 0001 1000]原= -24 直接用原码表示整数，让符号位也参与运算，对于类似上面的减法来说，结果显然是不正确的。 于是人们开始继续探索，不断试错，后来设计出了反码。下面就演示了反码运算的过程：123456 - 18 = 6 + (-18)= [0000 0000 0000 0110]反 + [1111 1111 1110 1101]反= [1111 1111 1111 0011]反= [1000 0000 0000 1100]原= -12 这样一来，计算结果就正确了。 然而，这样还不算万事大吉，我们不妨将减数和被减数交换一下位置，也就是计算18 - 6 的结果：12345618 - 6 = 18 + (-6)= [0000 0000 0001 0010]反 + [1111 1111 1111 1001]反= [1 0000 0000 0000 1011]反= [0000 0000 0000 1011]反= [0000 0000 0000 1011]原= 11 按照反码计算的结果是 11，而真实的结果应该是 12 才对，它们相差了 1。 蓝色的 **1** 是加法运算过程中的进位，它溢出了，内存容纳不了了，所以直接截掉。 6 - 18 的结果正确，18 - 6 的结果就不正确，相差 1。按照反码来计算，是不是小数减去大数正确，大数减去小数就不对了，始终相差 1 呢？我们不妨再看两个例子，分别是 5 - 13 和 13 - 5。 5 - 13 的运算过程为：1234565 - 13 = 5 + (-13)= [0000 0000 0000 0101]原 + [1000 0000 0000 1101]原= [0000 0000 0000 0101]反 + [1111 1111 1111 0010]反= [1111 1111 1111 0111]反= [1000 0000 0000 1000]原= -8 13 - 5的运算过程为： 123456713 - 5 = 13 + (-5)= [0000 0000 0000 1101]原 + [1000 0000 0000 0101]原= [0000 0000 0000 1101]反 + [1111 1111 1111 1010]反= [1 0000 0000 0000 0111]反 = [0000 0000 0000 0111]反= [0000 0000 0000 0111]原= 7 这足以证明，刚才的猜想是正确的：小数减去大数不会有问题，而大数减去小数的就不对了，结果始终相差 1。 相差的这个 1 要进行纠正，但是又不能影响小数减去大数，怎么办呢？于是人们又绞尽脑汁设计出了补码，给反码打了一个“补丁”，终于把相差的 1 给纠正过来了。 下面演示了按照补码计算的过程：12345678910111213141516171819202122232425262728296 - 18 = 6 + (-18)= [0000 0000 0000 0110]补 + [1111 1111 1110 1110]补= [1111 1111 1111 0100]补= [1111 1111 1111 0011]反= [1000 0000 0000 1100]原= -12 18 - 6 = 18 + (-6)= [0000 0000 0001 0010]补 + [1111 1111 1111 1010]补= [1 0000 0000 0000 1100]补= [0000 0000 0000 1100]补= [0000 0000 0000 1100]反= [0000 0000 0000 1100]原= 12 5 - 13 = 5 + (-13)= [0000 0000 0000 0101]补 + [1111 1111 1111 0011]补= [1111 1111 1111 1000]补= [1000 1111 1111 0111]反= [1000 0000 0000 1000]原= -8 13 - 5 = 13 + (-5)= [0000 0000 0000 1101]补 + [1111 1111 1111 1011]补= [1 0000 0000 0000 1000]补 = [0000 0000 0000 1000]补= [0000 0000 0000 1000]反= [0000 0000 0000 1000]原= 8 你看，采用补码的形式正好把相差的 1 纠正过来，也没有影响到小数减去大数，这个“补丁”真是巧妙。 小数减去大数，结果为负数，之前（负数从反码转换为补码要加 1）加上的 1，后来（负数从补码转换为反码要减 1）还要减去，正好抵消掉，所以不会受影响。 而大数减去小数，结果为正数，之前（负数从反码转换为补码要加 1）加上的 1，后来（正数的补码和反码相同，从补码转换为反码不用减 1）就没有再减去，不能抵消掉，这就相当于给计算结果多加了一个 1。 补码这种天才般的设计，一举达成了本文开头提到的两个目标，简化了硬件电路。 实例分析 上一节我们还留下了一个谜团，就是有符号数以无符号的形式输出，或者无符号数以有符号的形式输出时，会得到一个奇怪的值，请看下面的代码： 1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; short a = 0100; //八进制 int b = -0x1; //十六进制 long c = 720; //十进制 unsigned short m = 0xffff; //十六进制 unsigned int n = 0x80000000; //十六进制 unsigned long p = 100; //十进制 //以无符号的形式输出有符号数 printf("a=%#ho, b=%#x, c=%ld\n", a, b, c); //以有符号数的形式输出无符号类型（只能以十进制形式输出） printf("m=%hd, n=%d, p=%ld\n", m, n, p); return 0;&#125; 运行结果：123a=0100, b=0xffffffff, c=720m=-1, n=-2147483648, p=100 其中，b、m、n 的输出结果看起来非常奇怪。 b 是有符号数，它在内存中的存储形式（也就是补码）为：12345b = -0x1= [1000 0000 …… 0000 0001]原= [1111 1111 …… 1111 1110]反= [1111 1111 …… 1111 1111]补= [0xffffffff]补 %#x表示以无符号的形式输出，而无符号数的补码和原码相同，所以不用转换了，直接输出 0xffffffff 即可。 m 和n 是无符号数，它们在内存中的存储形式为：12345m = 0xffff= [1111 1111 1111 1111]补 n = 0x80000000= [1000 0000 …… 0000 0000]补 %hd和%d表示以有符号的形式输出，所以还要经过一个逆向的转换过程： 12345678[1111 1111 1111 1111]补= [1111 1111 1111 1110]反= [1000 0000 0000 0001]原= -1 [1000 0000 …… 0000 0000]补= -231= -2147483648 由此可见，-1 和-2147483648才是最终的输出值。 注意，`[1000 0000 …… 0000 0000]补`是一个特殊的补码，无法按照本节讲到的方法转换为原码，所以计算机直接规定这个补码对应的值就是 -231，至于为什么，下节我们会详细分析。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言存储空间布局]]></title>
    <url>%2F2019%2F05%2F08%2Fc%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[不管是在Linux下C程序，是由代码区、数据区、BSS区、堆区、栈区构成的，正文段在低地址。 存储空间组成 代码区（text）加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的，具有只读特性和共享性。 未初始化数据区（BSS）加载的是可执行文件 BSS 段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。 全局初始化数据区/静态数据区（data）加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。 栈区（stack）栈又称堆栈，是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等，也就是我们函数大括号”{}”中定义的变量(不包括static声明的变量)。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。由于栈的先进先出特性，所有栈特别方便用来保存/恢复调用现场。从这个意义上讲，把堆栈看成一个寄存、交换临时数据的内存区。 堆区（heap）堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于 BSS 区和栈区之间。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上(堆被扩张)；当利用free等函数释放内存时，被释放的内存从堆上被剔除(堆被缩减)。 详解数据段全局静态区全局静态区分为全局区、静态区、常量区 全局区​ 处于该区域的数据属于外部链接，可以被其他文件使用。 静态区​ 静态区分为静态全局变量和静态局部变量 静态全局变量 由static修饰的全局变量，属于内部链接，只能在本文件中使用 静态局部变量 由static修饰的局部变量，当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。 常量区​ 常量区分为字符串常量和常变量 字符串常量 常变量 全局常变量存放在静态存储区，不可以间接修改。 局部常变量存放于栈，实际可间接通过指针或者引用进行修改。 1234567891011121314151617181920212223242526272829303132333435363738394041#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;int a = 10; //全局变量，在全局区,默认外部链接static int b = 20; //全局静态变量，在静态区,是内部链接//全局变量和全局静态变量有什么区别？//全局变量是外部链接//静态全局变量是内部链接//内部链接和外部链接有什么区别？//1. 如果变量是内部链接的话，那么此变量只能在当前文件内访问//2. 如果是变量是外部链接的话，那么此变量可以被其他文件使用//全局静态变量和局部静态变量有什么区别？//1. 全局静态变量和局部静态变量都存储在静态区，都是在程序运行期间都是合法有效//2. 局部静态变量符号的可见范围仅限于当前函数内部，全局静态变量可见范围从定义到文件结尾const int v1 = 20; //全局常变量，一旦初始化，不可修改void test01()&#123; static char arr[] = "hello world!"; //局部静态变量，在静态区存储可读可写 arr[2] = 'c'; const int v2 = 20; //局部常变量，可以通过指针或者引用进行间接修改 char* p = "hello world!"; //字符串"hello world!"在常量区，p局部变量：stack(栈) //p[2] = 'c'; //只读，不可修改 printf("%d\n",arr); printf("%d\n",p);&#125;int main()&#123; test01(); system("pause"); return EXIT_SUCCESS;&#125; 栈区​ 栈(stack)是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函数，没有局部变量，也就没有我们如今能见到的所有计算机的语言。 ​ 在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中(入栈，push)，也可以将压入栈中的数据弹出(出栈，pop),但是栈容器必须遵循一条规则：先入后出(First In First Out,FIFO). ​ 在经典的操作系统中，栈总是向下增长的。压栈的操作使得栈顶的地址减小，弹出操作使得栈顶地址增大。 栈的增长方向如下图： 思考一下下列函数的调用过程： 12345678910int func(int a,int b)&#123; int t_a = a; int t_b = b; return t_a + t_b;&#125; int main()&#123; int ret = func(10, 20); int a = 20; return EXIT_SUCCESS;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之enum枚举]]></title>
    <url>%2F2019%2F05%2F08%2Fc%E8%AF%AD%E8%A8%80-enum%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[了解C语言enum枚举类型定义变量 一次定义多个常量​ 比如说我们的程序中处理问题时与星期几有关，可能要将星期一转换为数字1，星期二转换为数字2，一直到数字7，在不用enum关键字的情况下，可以使用define来定义，但是大家会觉得很麻烦，因为你要一个一个的定义，星期的还好说，只有7天，如果是月份呢，一年有12个月份，那就要写12个define，非常的不方面，如果利用enum的话就会非常的方便。 12345678910#include&lt;stdio.h&gt;enum week &#123;Mon=1,Tue,Wed,Thu,Fri,Sat,Sun&#125;;int main()&#123; printf("%d",Tue); return 0;&#125; ​ 这样定义以后，Mon的值为1，Tue的值为2，Wed的值为3，一次类推。 然后就可以像使用define之后的常量一样的使用定义的7个值了。 ​ 如果开头不写Mon=1的话，Mon的默认值为0，然后从0开始增长。例如： 1enum color &#123;red,blue,green,yellow&#125;; ​ 如果这样定义的话，red的值为0，blue的值为1，然后一次增长。 ​ 如果从中间开始赋值的话： 1enum color &#123;red,blue,green=5,yellow&#125;; ​ 那么red到blue是按照默认的从0开始增长的，green就是定义的值5，green之后的值都是从5开始增长的。 ​ 当然你也可以为每个枚举的变量都赋值，这样就和全都用define定义是一样的了，如果枚举中有某个值没有被赋值，那么它将是从前一个赋值的变 量开始，一次增加1. 限定变量的范围​ 比如我们的应用程序中要处理有关月份的东西，显然月份只能取1-12中的某个数字，为了保证程序的正确性和健壮性，我们应该使用enum。 1234567891011#include&lt;stdio.h&gt;enum Month &#123;Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125;;int main()&#123; enum Month a = Feb; printf("%d",a); return 0;&#125; 比如像这样，定义的枚举类型 a 的取值只能是那12个变量中的一个，如果赋予了其他的变量，编译器就会报错。 enum另几种用法 在定义enum的同时，声明变量： 1enum Month &#123;Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125; a,b; ​ 这样就声明了两个枚举类型a和b 定义完enum之后再声明变量： 12enum Month &#123;Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125;;enum Month a = Feb; 定义匿名的枚举变量 1enum &#123;Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125; a; ​ 这样的话，只能使用a这一个枚举类型的变量，不能再定义其他的枚举类型。 typedef enum则是用来定义一个数据类型，那么该类型的变量值只能在enum定义的范围内取 12typedef enum &#123;Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125; Day;Day a, b; 注意与宏定义区别： enum用来定义一系列宏定义常量区别用，相当于一系列的#define xx xx，当然它后面的标识符也可当作一个类型标识符； typedef enum则是用来定义一个数据类型，那么该类型的变量值只能在enum定义的范围内取。两者在这点上是没有差别的。 注意：同一个程序中不能定义同名的枚举类型，不同的枚举类型中也不能存在同名的命名常量]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客教程]]></title>
    <url>%2F2019%2F05%2F08%2Fhexo%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[​ 现在越来越多的人喜欢利用Github搭建静态网站，原因不外乎简单省钱。本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。 准备工作 下载node.js并安装（官网下载安装），默认会安装npm。 下载安装git（官网下载安装） 下载安装hexo。方法：打开cmd 运行*npm install -g hexo*（要翻墙） 本地搭建hexo静态博客 新建一个文件夹，如MyBlog 进入该文件夹内，右击运行git，输入：*hexo init*（生成hexo模板，可能要翻墙） 生成完模板，运行*npm install*（目前貌似不用运行这一步） 最后运行：hexo server （运行程序，访问本地localhost:4000可以看到博客已经搭建成功） 创建一个新仓库​ 新建一个名为你的github用户名.github.io的仓库，比如说，如果你的github用户名是code-hly(这个是我的用户名)，那么你就新建code-hly.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 https://code-hly.github.io 了，是不是很方便 ​ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库，所以访问的地址也是唯一的，方便github服务器管理。 设置仓库的参数​ 相信大多数人都知道，要想使用git命令来和github进行提交部署等操作，需要进行一些配置，大概就是下面一些命令，如不明白请自行搜索. 右键鼠标选择git Base here,输入如下命令： 123git config --global user.email xxx@qq.com git config --global user.name xxx ssh-keygen -t rsa -C xxx@qq.com(邮箱地址) // 生成ssh ​ 注：email和name分别为注册github时的邮箱和用户名，生成ssh时会提示让你选择存储地址，可直接按enter下一步存储为默认地址。 找到.ssh文件夹，找到id_rsa.pub文件打开复制SSH 登陆github，settings-&gt;Deploy keys-&gt;add deploy key（把复制的SSH添加进去即可） 将博客与Github关联 打开本地的MyBlog文件夹项目内的_config.yml配置文件，将其中的type设置为git 1234deploy: type: git repository: git@github.com:code-hly/code-hly.github.io.git branch: master repository为对应仓库的地址。注意仓库地址有两种形式。一种是https，一种是SSH。此处应该使用SSH形式的地址。 运行：npm install hexo-deployer-git –save 运行：hexo g（本地生成静态文件） 运行：hexo d（将本地静态文件推送至Github） 此时，打开浏览器，访问https://code-hly.github.io 可能问题 错误提示：FATAL bad indentation of a mapping entry at line 72, column 7: 可以hexo g 但是不可以hexo d12345错误提示：You should configure deployment settings in _config.yml first!Available deployer plugins: gitFor more help, you can check the online docs: http://hexo.io/ 天真的我，被他俩坑死了。 ​ 问题一：(上图)type: git这里的分号后面没有空格（纳尼，手动黑人问号脸）。所有的配置项目分号（你输入的http:这个分号不用）后面有参数的都要有一个空格 ​ 问题二：(上图)deploy和下面的那几项我从网上复制了一下，（不知为啥我的配置里没生成repo和branch）结果就因为后三个没有缩进，我又白白躺了几个小时 绑定域名 因为Hexo个人博客是托管在github之上，每次访问都要使用githubname.github.io这么一个长串的域名来访问，会显得非常繁琐。这个时候我们可以购买一个域名，设置DNS跳转，以达到通过域名即可访问我们的个人博客，我就是在阿里的万网购买的域名。 域名解析 点击对应域名的”解析” 点击添加解析，记录类型选A或CNAME A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是code-hly.github.io ​ 这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：penglei.com。实践证明如果此时你填写的是www.penglei.top 那么以后你只能用www.penglei.top 访问，而如果你填写的是penglei.top。那么用www.penglei.top 和 penglei.top 访问都是可以的。重新清理hexo,并发布即可用新的域名访问。 运行：hexo g 运行：hexo d 更新博客内容 至此博客已经搭建完毕，域名也已经正常解析，那么剩下的问题就是更新内容了。 更新文章 在MyBlog目录下执行：hexo new “我的第一篇文章”，会在source-&gt;_posts文件夹内生成一个.md文件。 编辑该文件（遵循Markdown规则） 修改起始字段 title 文章的标题 date 创建日期 （文件的创建日期 ） updated 修改日期 （ 文件的修改日期） comments 是否开启评论 true tags 标签 categories 分类 permalink url中的名字（文件名） 编写正文内容（MakeDown） hexo clean 删除本地静态文件（Public目录），可不执行。 hexo g 生成本地静态文件（Public目录） hexo deploy 将本地静态文件推送至github（hexo d） 添加菜单进入theme目录，编辑_config_yml文件，找到menu:字段，在该字段下添加一个字段。 1234menu: home: / about: /about ...... 然后找到lanhuages目录，编辑zh-Hans.yml文件： 1234menu: home: 首页 about: 关于作者 ...... 更新页面显示的中文字符，最后进入theme目录下的Source目录，新增一个about目录，里面写一个index.html文件。 文章内插入图片在文章中写入: 1![](/upload_image/1.jpg) 然后进入themes-主题名-source-upload_image目录下(自己创建)，将图片放到这个目录下，就可以了。 说明：当执行hexo g命令时，会自动把图片复制到 public文件的upload_image目录下。 个性化设置基本信息 在根目录下的_config.yml文件中，可以修改标题，作者等信息。打开编辑该文件，注意：每一个值的冒号后面都有一个半角空格！ 未生效的写法：title:nMask的博客 能生效的写法：title:[空格]nMask的博客 主题访问主题列表，获取主题代码。 进入themes目录，进入以下操作： 下载主题 (以next主题为例) 1git clone https://github.com/iissnan/hexo-theme-next.git（主题的地址） 打开__config.yml文件，将themes修改为next（下载到的主题文件夹的名字） hexo g hexo d 关于hexo-next主题下的一些个性化配置，参考：Next主题配置 主题美化文章中添加居中模块文章Markdown中填写如下： 1&lt;blockquote class="blockquote-center"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 在文章底部增加版权信息 在目录next/layout/_macro/下添加my-copyright.swig： 1234567891011121314151617181920212223242526272829303132&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"&gt;&lt;/script&gt; &lt;script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); clipboard.on('success', $(function()&#123; $(".fa-clipboard").click(function()&#123; swal(&#123; title: "", text: '复制成功', html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import "my-post-copyright" 如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 1234567---title: date: tags: categories: copyright: true--- 自定义hexo new生成md文件的选项在/scaffolds/post.md文件中添加： 12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: copyright: truepermalink: 01top: 0password:--- 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。 123456789101112&lt;!--&lt;div class="powered-by"&gt; &#123;&#123; __('footer.powered', '&lt;a class="theme-link" rel="external nofollow" href="https://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125;&lt;/div&gt;&lt;div class="theme-info"&gt; &#123;&#123; __('footer.theme') &#125;&#125; - &lt;a class="theme-link" rel="external nofollow" href="https://github.com/iissnan/hexo-theme-next"&gt; NexT.&#123;&#123; theme.scheme &#125;&#125; &lt;/a&gt;&lt;/div&gt;--&gt; 文章加密访问打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在meta标签后面插入这样一段代码： 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后文章中添加： 1password: nmask 如果password后面为空，则表示不用密码。 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如: 12345---......copyright: truetop: 100--- 默认不设置则为0，数值相同时按时间排序。 添加顶部加载条打开/themes/next/layout/_partials/head.swig文件，在maximum-scale=1”/&gt;后添加如下代码: 12&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 添加热度next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig在”leancloud-visitors-count”&gt;标签后面添加℃。然后打开，/themes/next/languages/zh-Hans.yml，将visitors内容改为热度即可。 主页文章添加阴影效果打开\themes\next\source\css_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 鼠标点击小红心的设置将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 背景的设置将 particle.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout_layout.swing 文件， 在文件的后面，标签之前 添加以下代码： 12&lt;!-- 背景动画 --&gt;&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css\_custom\custom.styl ，添加如下 css 样式： 12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 博文压缩在站点的根目录下执行以下命令： 12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在博客根目录下新建 gulpfile.js ，并填入以下内容： 123456789101112131415161718192021222324252627282930313233var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js']); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 搜索功能安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 增加阅读排行统计页面首先我们可以使用leancloud来统计页面阅读数量，以及储存这些信息，然后通过leancloud提供的api编写js脚本来获取阅读数量信息，并展示在页面上。首先新建一个page页面，hexo new page “”,然后编辑此.md文件，写下： 1234567891011121314151617181920212223242526&lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"&gt;&lt;/script&gt;&lt;script&gt;AV.initialize("", "");&lt;/script&gt; //需要写上leancloud的key&lt;script type="text/javascript"&gt; var time=0 var title="" var url="" var query = new AV.Query('Counter');//表名 query.notEqualTo('id',0); //id不为0的结果 query.descending('time'); //结果按阅读次数降序排序 query.limit(20); //最终只返回10条结果 query.find().then(function (todo) &#123; for (var i=0;i&lt;10;i++)&#123; var result=todo[i].attributes; time=result.time; //阅读次数 title=result.title; //文章标题 url=result.url; //文章url var content="&lt;p&gt;"+"&lt;font color='#0477ab'&gt;"+"【阅读次数:"+time+"】"+"&lt;a href='"+"http://thief.one"+url+"'&gt;"+title+"&lt;/font&gt;"+"&lt;/a&gt;"+"&lt;/p&gt;"; // document.write("&lt;a href='"+"http://thief.one/"+url+"'&gt;"+title+"&lt;/a&gt;"+" Readtimes:"+time+"&lt;br&gt;"); document.getElementById("heheda").innerHTML+=content &#125; &#125;, function (error) &#123; console.log("error"); &#125;);&lt;/script&gt; 最终的效果查看：http://thief.one/count 多说替换成来必力评论更新于@2017年5月18日多说已经宣布下线了，因此我找了个来必力评论系统来替换，以下是替换的教程，教程内容来自：https://blog.smoker.cc/web/add-comments-livere-for-hexo-theme-next.html 来必力评价优点：界面美观缺点：不支持数据导入，加载慢 首先在 _config.yml 文件中添加如下配置： 1livere_uid: your uid 其中 livere_uid 即注册来必力获取到的 uid。在 layout/_scripts/third-party/comments/ 目录中添加 livere.swig，文件内容如下： 1234567891011121314&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125; &#123;% if theme.livere_uid %&#125; &lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script'); &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; ​ 优先使用其他评论插件，如果其他评论插件没有开启，且LiveRe评论插件配置开启了，则使用LiveRe。其中脚本代码为上一步管理页面中获取到的。在layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include './comments/livere.swig' %&#125; 引入 LiveRe 评论插件。最后，在 layout/_partials/comments.swig 文件中条件最后追加LiveRe插件是否引用的判断逻辑： 123&#123;% elseif theme.livere_uid %&#125; &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere_uid &#125;&#125;"&gt;&lt;/div&gt;&#123;% endif %&#125; 最后打开博客瞧瞧吧！ 多说替换成网易云跟贴最好的方法就是更新next主题，因为最新版本的主题已经支持这几种评论。如果不想更新主题，则往下看： 网易云跟贴评价：性能稳定，功能中规中矩，支持数据导入 首先在 _config.yml 文件中添加如下配置： 1gentie_productKey: #your-gentie-product-key 其中 gentie_productKey 即注册网易云跟贴获取到的key。在 layout/_scripts/third-party/comments/ 目录中添加 gentie.swig，文件内容如下： 12345678910111213141516&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id %&#125; &#123;% if theme.gentie_productKey %&#125; &#123;% set gentie_productKey = theme.gentie_productKey %&#125; &lt;script&gt; var cloudTieConfig = &#123; url: document.location.href, sourceId: "", productKey: "&#123;&#123;gentie_productKey&#125;&#125;", target: "cloud-tie-wrapper" &#125;; &lt;/script&gt; &lt;script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"&gt;&lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 在layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include './comments/gentie.swig' %&#125; 最后，在 layout/_partials/comments.swig 文件中条件最后追加网易云跟帖插件引用的判断逻辑： 123&#123;% elseif theme.gentie_productKey %&#125; &lt;div id="cloud-tie-wrapper" class="cloud-tie-wrapper"&gt; &lt;/div&gt; 报错解决（一）Deployer not found: git当编辑__config.yml文件，将type: git设置完成后，运行hexo g 报错：git not found解决方案：可以在MyBlog目录下运行: npm install hexo-deployer-git –save。 （二）permission denied当执行: hexo deploy 报错时，把__config.yml中的github连接形式从ssh改成http。 （三）当在themes目录下载主题时，报错。将该目录只读属性取消。 （四）genrnate 报错检查_config.yml配置中，键值对冒号后面是否已经预留了一个半角空格。 （五）ERROR Plugin load failed: hexo-generator-feed12npm install hexo-generator-feednpm install hexo-generator-feed --save （六）fatal: The remote end hung up unexpectedly123$ git config https.postBuffer 524288000$ git config http.postBuffer 524288000$ git config ssh.postBuffer 524288000 （七）hero d推送的内容有问题 首先检查下.deploy_git文件夹下的.git文件是否存在，此.git文件指定了hexo d时推送public文件夹，而不是所有的内容。如果此.git文件不存在，则会出现推送内容错误。 用npm install hexo-deployer-git –save生成的.deploy_git不包含.git文件，因此正确的做法是.deploy_git文件夹也需要备份，然后再用npm install hexo-deployer-git –save更新一下其内容即可。 如果已经出现这个错误，则删除.deploy_git，重新hexo d。 （八）hexo s报错在新版本的mac上，安装运行hexo会报此错误，但不影响使用。 1&#123; Error: Cannot find module 解决方案： 1npm install hexo --no-optional Local Search错误 最近发现Local Search搜索出来的连接有错误，到不是说连接不对，而是当我在/aaa/目录下搜索一个页面时，跳转到了/aaa/正确的连接/，这样明显是正确的，应该是跟目录+跳转的目录。 网上搜索了下，没有类似的案例，那么自己动手修改吧，打开node_modules/hexo-generator-searchdb/templates下的xml.ejs文件： 1&lt;url&gt;&lt;%- ("../../../../../../../../"+post.path) %&gt;&lt;/url&gt; 说明：将这个文件的两处url都改成这样就可以了。 异地同步博客内容 现在电脑已经很普及了，因为一般来说我们都是公司一台电脑，家里一台电脑，那么如何将两台电脑上博客的内容同步内，即两台电脑上都可以编辑更新博客？要解决这个问题，首先我们要清楚我们博客文件的组成： node_modules public scaffolds source themes _config_yml db.json package.json .deploy_git 以上为利用hexo生成的博客全部内容，那么当我们执行hexo d时，正真被推送到github上的又有哪些内容呢？ 我们可以看下github上的code-hly.github.io项目，发现里面只有Public目录下的内容。也就是说，我们博客上呈现的内容，其实就是public下的文件内容。那么这个Pulic目录是怎么生成的呢？ 一开始hexo init的时候是没有public目录的，而当我们运行hexo g命令时，public`目录被生成了，换句话说hexo g命令就是用来生成博客文件的（会根据_config.yml，source目录文件以及themes目录下文件生成）。同样当我们运行hexo clean命令时，public目录被删除了。 好了，既然我们知道了决定博客显示内容的只有一个Public目录，而public目录又是可以动态生成的，那么其实我们只要在不同电脑上同步可以生成Public`目录的文件即可。 以下文件以及目录是必须要同步的： source themes _config.yml db.json package.json .deploy_git 同步的方式有很多种，可以每次更新后都备份到一个地址。我采用github去备份，也就是新建一个项目用来存放以上文件，每次更新后推送到github上，用作备份同步。 同步完必须的文件后，怎么再其他电脑上也可以更新博客呢？ 前提假设我们现在配置了一台新电脑，里面没有安装任何有关博客的东西，那么我们开始吧： 下载node.js并安装（官网下载安装），默认会安装npm。 下载安装git（官网下载安装） 下载安装hexo。方法：打开cmd 运行npm install -g hexo（要翻墙） 新建一个文件夹，如MyBlog 进入该文件夹内，右击运行git，输入：hexo init（生成hexo模板，可能要翻墙) 我们重复了一开始搭建博客的步骤，重新生成了一个新的模板，这个模板中包含了hexo生成的一些文件。 git clone 我们备份的项目，生成一个文件夹，如：MyBlogData 将MyBlog里面的node_modules、scaffolds文件夹复制到MyBlogData里面。 做完这些，从表面上看，两台电脑上MyBlogData目录下的文件应该都是一样的了。那么我们运行hexo ghexo d试试，如果会报错，则往下看。 这是因为.deploy_git没有同步，在MyBlogData目录内运行:npm install hexo-deployer-git –save后再次推送即可 总结流程：当我们每次更新MyBlog内容后，先利用hexo将public推送到github，然后再将其余必须同步的文件利用git推送到github。 SEO优化seo优化对于网站是否能被搜索引擎快速收录有很大帮助，因此适当做一些seo还是有必要的，以下内容参考：https://lancelot_lewis.coding.me/2016/08/16/blog/Hexo-NexT-SEO/ 添加sitemap文件安装以下2个插件，然后重启hexo后，网站根目录（source）下会生成sitemap.xml与baidusitemap.xml文件，搜索引擎在爬取时会参照文件中的url去收录。 1234npm install hexo-generator-sitemap --save-devhexo d -gnpm install hexo-generator-baidu-sitemap --save-devhexo d -g 添加robots.txt新建robots.txt文件，添加以下文件内容，把robots.txt放在hexo站点的source文件下。 1234567891011User-agent: * Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://thief.one/sitemap.xmlSitemap: http://thief.one/baidusitemap.xml 首页title的优化更改index.swig文件，文件路径是your-hexo-site\themes\next\layout，将下面代码 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改成 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock 观察首页title就是标题+描述了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo双站点部署github和coding]]></title>
    <url>%2F2019%2F05%2F08%2Fhexo%E5%8F%8C%E7%AB%99%E7%82%B9%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[​ 这是搭建博客系列的第二篇，至于为什么要托管到 coding 上，原因大家也应该能猜到，就是github访问速度偏慢，体验不是很好。 注册 coding.net 账号并创建项目项目名最好跟用户名一样 设置 coding SSH KEY这个就用当时设置github的一样就行了 _config.yml配置12345deploy: type: git repo: github: git@github.com:code-hly/code-hly.github.io.git,master coding: git@git.coding.net:huliaoyuan/huliaoyuan.git,master 替换你的项目名，注意空格，我这儿用的是ssh，而不是https 部署项目到 coding上 进入 myblog 根目录下，先敲如下命令。为了使用hexo d来部署到git上 1$ npm install hexo-deployer-git --save 使用部署命令就能把博客同步到 coding 上面 1hexo deploy -g pages服务方式部署​ 部署博客方式有两种，第一种就是pages服务的方式，也推荐这种方式，因为可以绑定域名，而第二种演示的方式必须升级会员才能绑定自定义域名。pages方式也很简单就是在source/需要创建一个空白文件，至于原因，是因为coding.net需要这个文件来作为以静态文件部署的标志。就是说看到这个Staticfile就知道按照静态文件来发布。 12cd source/touch Staticfile #名字必须是Staticfile 个人域名绑定 注意github绑定需要在 myblog/source目录下建一 CNAME 文件，并写上你购买的域名，域名我是在阿里万网买的 我当时按照别人的做法写的默认和海外，这样发现只能访问 coding 上的博客而不能访问 github 上的博客了 coding 绑定私有域名 发布博客新文章后直接部署到 github 和 coding1$ hexo g -d]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo腾讯云COS部署+Markdown图床]]></title>
    <url>%2F2019%2F05%2F08%2Fhexo%E8%85%BE%E8%AE%AF%E4%BA%91cos%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[静态博客网站的需求就是一片足够大的空间，而腾讯云COS提供免费50G的存储空间，无疑是一个不错的选择。 同时也可以用腾讯云cos制作Markdown的图床，这样网站访问速度会比较快 hexo部署腾讯云cos域名​ 域名注册与备案 注意：腾讯云cos绑定cdn域名加速时需要备案域名，而域名的备案需要购买腾讯云的服务器。这点比较坑！ 根据个人情况选择，也可以选择上篇博文，采用hexo双站点部署 创建存储桶(Bucket) 创建存储桶 COS地址 填写名称后，选择权限为公有读私有写。 配置存储桶 选择基础配置 编辑静态网站 打开设置 绑定域名 域名管理，添加域名，选择静态网站源站 域名解析，添加记录 第一个框为二级域名，第二个框为记录值。 上传文件测试 在test存储桶上传CNAME文件和index.html进行测试。 CANME文件的内容为（域名换成自己的域名）： 1test.fiftykg.com index.html的内容为： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;测试主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;测试主页内容&lt;/body&gt;&lt;/html&gt; 在浏览器中查看结果： 刷新CDN缓存 上图的效果是不能立刻看到的，大部分时候需要等待。 有可能你会看到以下的效果： 首先请确认你的网站类型为静态网站源站。如果设置正确，那么可能需要手动刷新以下cdn的缓存： hexo部署安装cos部署插件： npm install hexo-deployer-cos --save 在根目录的_config.yml配置： region等参数可以在下图位置查看： 秘钥可以在访问管理中云API秘密钥中找到。 Markdown图床创建存储桶(Bucket) 创建存储桶 COS地址 填写名称后，选择权限为公有读写。 PicGo 客户端配置下载&amp;安装​ PicGo （目前 2.0.4）是一个开源的图床工具，非常优秀。可以到 git 上下载，但下载速度太慢，所以我放了一个百度云的链接，速度快很多。 git的地址：https://github.com/Molunerfinn/PicGo Win版下载链接：https://pan.baidu.com/s/1sr7DKuP7p0WQ1WNBK3Zkow 提取码：d4cx 配置 存储空间名：所存储图片的桶名称 存储路径：选择的地区，例如：ap-guangzhou]]></content>
      <categories>
        <category>Hexo</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ceph部署难题]]></title>
    <url>%2F2019%2F05%2F08%2Fceph-%E9%83%A8%E7%BD%B2%E9%9A%BE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本章总结了搭建ceph集群过程中遇到的各种问题，以及相应的原理过程 Q1. 环境预准备**​ 绝大多数MON创建的失败都是由于防火墙没有关导致的，亦或是SeLinux没关闭导致的。一定一定一定要关闭每个每个每个节点的防火墙(执行一次就好，没安装报错就忽视)： CentOS 123456sed -i 's/SELINUX=.*/SELINUX=disabled/' /etc/selinux/configsetenforce 0systemctl stop firewalld systemctl disable firewalld# iptables -Fservice iptables stop Q2. 清理环境​ MON部署不上的第二大问题就是在旧的节点部署MON，或者在这个节点部署MON失败了，然后重新new再mon create-initial，请查看要部署MON的节点上的/var/lib/ceph/mon/目录下是否为空，如果不为空，说明已经在这个目录部署过MON，再次部署会检测子目录下的done文件，由于有了这个文件，就不会再建立新的MON数据库，并且不会覆盖之，导致了部署时的各种异常，这里就不赘述了，直接给出万能清理大法： 对于任何需要新部署MON的节点，请到这个节点下执行如下指令，确保环境已经清理干净： 123456789ps aux|grep ceph |awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep ceph#确保此时所有ceph进程都已经关闭！！！如果没有关闭，多执行几次。rm -rf /var/lib/ceph/mon/*rm -rf /var/lib/ceph/bootstrap-mds/*rm -rf /var/lib/ceph/bootstrap-osd/*rm -rf /var/lib/ceph/bootstrap-rgw/*rm -rf /etc/ceph/*rm -rf /var/run/ceph/* 请直接复制粘贴，遇到过好些个自己打错打漏删了目录的。 Q3. 部署前最后的确认这里介绍的都是个案，不过还是需要提一下： 确保每个节点的hostname都设置正确，并且添加至/etc/hosts文件中，然后同步到所有节点下。克隆出来的虚拟机或者批量建的虚拟机有可能发生此情形。 确保以下目录在各个节点都存在： /var/lib/ceph/ /var/lib/ceph/mon/ /var/lib/ceph/osd/ /etc/ceph/ /var/run/ceph/ 上面的目录，如果Ceph版本大于等于jewel,请确认权限均为ceph:ceph，如果是root:root，请自行chown。 Q4. 安装Ceph​ 官网指导方法是使用ceph-deploy install nodeX,但是因为是国外的源，速度慢得令人发指，所以我们换到阿里的源，并且使用yum install的方式安装，没差啦其实，这样反而还快点，毕竟多个节点一起装。 很多安装失败的都是因为没有添加epel源请在每个存储节点都执行以下指令，来安装Ceph: 123456789101112131415161718yum clean allrm -rf /etc/yum.repos.d/*.repowget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repowget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.reposed -i '/aliyuncs/d' /etc/yum.repos.d/CentOS-Base.reposed -i '/aliyuncs/d' /etc/yum.repos.d/epel.reposed -i 's/$releasever/7.2.1511/g' /etc/yum.repos.d/CentOS-Base.repoecho "[ceph]name=cephbaseurl=http://mirrors.aliyun.com/ceph/rpm-hammer/el7/x86_64/gpgcheck=0[ceph-noarch]name=cephnoarchbaseurl=http://mirrors.aliyun.com/ceph/rpm-hammer/el7/noarch/gpgcheck=0" &gt; /etc/yum.repos.d/ceph.repoyum install ceph ceph-radosgw -y 这里是安装的hammer版本的Ceph，如果需要安装jewel版本的，请执行： 12sed -i 's/hammer/jewel/' /etc/yum.repos.d/ceph.repoyum install ceph ceph-radosgw -y 如果安装了jewel版本的Ceph，想要换回hammer版本的Ceph，可以执行下面的指令： 卸载Ceph客户端 1rpm -qa |grep `ceph -v |awk '&#123;print $3&#125;'` |xargs rpm -e --nodeps 更改ceph.repo里面的Ceph版本 12sed -i 's/jewel/hammer/' /etc/yum.repos.d/ceph.repoyum install ceph ceph-radosgw -y Q5. ceph-deploy这里我要开启话唠模式： ① Ceph-deploy 是什么？ ​ Ceph-deploy是Ceph官方给出的用于部署Ceph的一个工具，这个工具几乎全部是Python写的脚本，其代码位于/usr/lib/python2.7/site-packages/ceph_deploy目录下(1.5.36版本)。最主要的功能就是用几个简单的指令部署好一个集群，而不是手动部署操碎了心，敲错一个地方就可能失败。所以对于新人来说，或者说以我的经验，接触Ceph少于一个月的，又或者说，集群规模不上PB的，都没有必要手动部署，Ceph-deploy完全足够了。 ② Ceph-deploy怎么装? ​ 这个包在ceph的源里面： 1yum install ceph-deploy -y ③Ceph-deploy装在哪？ ​ 既然Ceph-deploy只是个部署Ceph的脚本工具而已，那么这个工具随便装在哪个节点都可以，并不需要单独为了装这个工具再搞个节点，我一般习惯放在第一个节点，以后好找部署目录。 ④Ceph-deploy怎么用？ ​ 详细的指令暂时不介绍，下面会有，在安装好后，需要在这个节点新建一个目录，用作部署目录，这里是强烈建议建一个单独的目录的，比如我习惯在集群的第一个节点下建一个/root/cluster目录，为了以后好找。Ceph-deploy的所有的指令都需要在这个目录下执行。包括new,mon,osd等等一切ceph-deploy的指令都需要在这个部署目录下执行！最后一遍，所有的ceph-deploy的指令都要在部署目录下执行！否则就会报下面的错： 1[ceph_deploy][ERROR ] ConfigError: Cannot load config: [Errno 2] No such file or directory: 'ceph.conf'; has ceph-deploy new been run in this directory? ⑤ Ceph-deploy怎么部署集群? ​ 我们暂且把部署目录所在的节点叫做部署节点。Ceph-deploy通过SSH到各个节点，然后再在各个节点执行本机的Ceph指令来创建MON或者OSD等。所以在部署之前，你需要从部署节点ssh-copy-id到各个集群节点，使其可以免秘钥登陆。 ⑥Ceph-deploy部署的日志在哪里? ​ 就在部署目录下面的ceph-deploy-ceph.log文件，部署过程中产生的所有的日志都会保存在里面，比如你大半年前敲的创建OSD的指令。在哪个目录下执行ceph-deploy指令，就会在这个目录下生成log，如果你跑到别的目录下执行，就会在执行目录里生成log再记下第四点的错。当然，这个LOG最有用的地方还是里面记录的部署指令，你可以通过cat ceph-deploy-ceph.log |grep &quot;Running command&quot;查看到创建一个集群所需的所有指令，这对你手动建立集群或者创建秘钥等等等等有着很大的帮助！！！ ⑦ Ceph-deploy版本 ​ 写这段时的最新的版本号为1.5.36，下载链接为ceph-deploy-1.5.36-0.noarch.rpm， 之前的1.5.35里面有点bug在这个版本被修复了，如果使用1.5.25部署遇到了问题，可以更新至这个版本，会绕过一些坑。更新到1.5.36之后，腰也不酸了,退了不疼了，Ceph也能部署上了。 Q6. ceph-deploy new 做了什么​ 进入部署目录，执行ceph-deploy new node1 node2 node3，会生成两个文件（第三个是ceph-deploy-ceph.log，忽视之）: 12[root@blog cluster]# lsceph.conf ceph-deploy-ceph.log ceph.mon.keyring ​ new后面跟的是你即将部署MON的节点的hostname，推荐三个就够了，需要是奇数个MON节点。不要因为只有两个节点就搞两个MON，两个节点请用一个MON，因为两个MON挂掉一个，集群也就挂了，和一个MON挂掉一个效果是一样的。生成的ceph.conf默认情况下长成这样： 12345678[root@blog cluster]# cat ceph.conf [global]fsid = 13b5d863-75aa-479d-84ba-9e5edd881ec9mon_initial_members = blogmon_host = 1.2.3.4auth_cluster_required = cephxauth_service_required = cephxauth_client_required = cephx ​ 会调用uuidgen生成一个fsid，用作集群的唯一ID，再将new后面的主机加入到mon_initial_members和mon_host里面，剩下的三行大家都是一样的，默认开启CephX认证。下面有一节会专门介绍这个，需要注意的是，部署的时候，千万不要动这三行 下面会有一节介绍之。还有一个文件ceph.mon.keyring： 1234[root@blog cluster]# cat ceph.mon.keyring [mon.]key = AQB1yWRYAAAAABAAhMoAcadfCdy9VtAaY79+Sw==caps mon = allow * ​ 除了key的内容不一样，剩下的都会是一样的。因为是开启了CephX认证了，所以MON直接的通讯是需要一个秘钥的，key的内容就是秘钥。是不是对Ceph里面的明文认证感到吃惊，有总比没有强。如果，你再次执行new，会生成新的ceph.conf和新的ceph.mon.keyring，并将之前的这两个文件给覆盖掉，新旧文件唯一不同的就是fsid和key的内容，但是对Ceph来说，这就是两个集群了。这里说一下我个人非常非常非常反感的一个问题，有的朋友喜欢在/etc/ceph/目录下面执行ceph-deploy的命令，这么做和在部署目录下面做一般是没有差别的，因为这两个目录下面都有ceph.conf和ceph.client.admin.keyring，但是我还是强烈推荐创建独立的部署目录，因为/etc/ceph目录是Ceph节点的运行目录，为了体现各自的功能性，也为了安全性，请不要在**/etc/ceph**目录下部署集群！！！ Q7. 为ceph-deploy添加参数​ Ceph-deploy的log还是很有看头的，查看ceph-deploy new blog(blog是我的一台主机)的log： 12345678910111213141516171819[root@blog cluster]# ceph-deploy new blog[ceph_deploy.conf][DEBUG ] found configuration file at: /root/.cephdeploy.conf[ceph_deploy.cli][INFO ] Invoked (1.5.36): /usr/bin/ceph-deploy new blog[ceph_deploy.cli][INFO ] ceph-deploy options:[ceph_deploy.cli][INFO ] username : None[ceph_deploy.cli][INFO ] func : &lt;function new at 0x288e2a8&gt;[ceph_deploy.cli][INFO ] verbose : False[ceph_deploy.cli][INFO ] overwrite_conf : False[ceph_deploy.cli][INFO ] quiet : False[ceph_deploy.cli][INFO ] cd_conf : &lt;ceph_deploy.conf.cephdeploy.Conf instance at 0x28eccf8&gt;[ceph_deploy.cli][INFO ] cluster : ceph[ceph_deploy.cli][INFO ] ssh_copykey : True[ceph_deploy.cli][INFO ] mon : ['blog'][ceph_deploy.cli][INFO ] public_network : None[ceph_deploy.cli][INFO ] ceph_conf : None[ceph_deploy.cli][INFO ] cluster_network : None[ceph_deploy.cli][INFO ] default_release : False[ceph_deploy.cli][INFO ] fsid : None[ceph_deploy.new][DEBUG ] Creating new cluster named ceph ​ 可以看到有很多的参数被列出来了，比如：mon : [&#39;blog&#39;]，也有很多参数是False或者None， 这些参数能否被设置呢? 因为这里我们可以看到有fsid : None 这个参数，难道集群的fsid可以被指定吗？抱着这些疑惑，我就去看完了ceph-deploy的所有代码，答案是：可以设置。所有上面的参数都可以使用参数的形式进行设置，只需要在前面加上两个--，比如对于fsid可以执行： 1ceph-deploy new blog --fsid xx-xx-xx-xxxx ​ 如果想要查看每个执行可指定的参数，可以-h： 1234567891011121314[root@blog cluster]# ceph-deploy new -husage: ceph-deploy new [-h] [--no-ssh-copykey] [--fsid FSID] [--cluster-network CLUSTER_NETWORK] [--public-network PUBLIC_NETWORK] MON [MON ...]...optional arguments: -h, --help show this help message and exit --no-ssh-copykey do not attempt to copy SSH keys --fsid FSID provide an alternate FSID for ceph.conf generation --cluster-network CLUSTER_NETWORK specify the (internal) cluster network --public-network PUBLIC_NETWORK specify the public network for a cluster ​ 这里就可以看到可以指定--cluster-network，--public-network，等等，如果optional arguments里面没有介绍这个参数，可以直接使用--xxarg的方式指定，比如--overwrite-conf，--verbose等等，能不能设置这些参数，自己动手试一下就知道了。需要注意的是，参数的位置根据指令而异，比如--overwrite-conf参数是跟在ceph-deploy后面的，而--public-network是跟在new后面的： 123ceph-deploy --overwrite-conf --verbose new blog --fsid a-a-a-a[root@blog cluster]# cat ceph.conf |grep fsidfsid = a-a-a-a Q8. Public VS Cluster​ 如果非要在刚刚生成的ceph.conf里面添加什么的话，那么可能就要加public_network或者cluster_network了。那么这两个配置项有什么用呢？这里简单得介绍下Ceph的Public(外网或者叫公网或者前端网)和Cluster(内网或者叫集群网或者叫后端网)这两个网络，在Ceph中，存在以下三种主要的网络通讯关系： client-&gt; mon =&gt;public : 也就是客户端获取集群状态，或者叫客户端与MON通讯走的网络，是走的外网。 client-&gt; osd =&gt; public : 也就是客户端向OSD直接写入数据走的也是外网。 osd osd =&gt; cluster ：也就是OSD之间的数据克隆，恢复走的是内网，客户端写第一份数据时通过外网写，对于三副本剩下的两个副本OSD之间通过内网完成数据复制。当OSD挂掉之后产生的recover,走的也是内网。 通常，我们会将外网配置为千兆网，而内网配置成万兆网，这是有一定原因的： 客户端可能由成百上千的计算节点组成，外网配成万兆成本太高。 存储节点一般只有几个到几十个节点，配置了万兆内网可以大大加快故障恢复速度，而且剩余的两副本写速度会大大加快，万兆网的性价比极高。举个例子，集群坏掉一个OSD千兆需要一小时，那么万兆网只需要五六分钟，一定程度上增加了集群的安全性。 借用官网的这张图来说明集群的网络走势：再假设你的节点有两个网段172.23.0.1和3.3.4.1，还记得我们上一节ceph-deploy new的时候是可以指定public_network和cluster_network的吗！如果不指定这两个参数，那么ceph-deploy怎么知道用哪个IP作为这个节点的mon_host的IP呢，其实他是随便选的，如果它选了172网段但是你想使用3.3网段作为这个节点的mon_host的IP，那么只需要指定--public-network 172.23.0.0/24 就可以了，其中的/24就相当于一个掩码，表示前面的IP的前24位，也就是172.23.0.XXX，只要你的主机上有一个处于这个范围内的IP，那么就会选择这个IP作为公网IP。类似的，/16表示范围：172.23.XXX.XXX。 如果想指定内网IP，那么只要指定--cluster-network 3.3.4.1/24就可以了。 ​ 一般情况下，会在new生成的ceph.conf文件里加入public_network配置项以指定公网IP。当然你的MON主机上需要有至少一个IP在公网范围内。除了在生成的ceph.conf文件中加入公网IP的方式，我们还可以使用参数的方式来指定公网IP： 12345678910111213141516171819202122[root@ceph-1 cluster]# ceph-deploy new ceph-1 --public-network 172.23.0.0/24[ceph_deploy.cli][INFO ] Invoked (1.5.36): /usr/bin/ceph-deploy new ceph-1 --public-network 172.23.0.0/24[ceph_deploy.cli][INFO ] ceph-deploy options:...[ceph_deploy.cli][INFO ] public_network : 172.23.0.0/24...[ceph-1][DEBUG ] IP addresses found: [u'172.23.0.101', u'10.0.2.15'][ceph_deploy.new][DEBUG ] Resolving host ceph-1[ceph_deploy.new][DEBUG ] Monitor ceph-1 at 172.23.0.101[ceph_deploy.new][DEBUG ] Monitor initial members are ['ceph-1'][ceph_deploy.new][DEBUG ] Monitor addrs are [u'172.23.0.101'][ceph_deploy.new][DEBUG ] Writing monitor keyring to ceph.mon.keyring...[ceph_deploy.new][DEBUG ] Writing initial config to ceph.conf...[root@ceph-1 cluster]# cat ceph.conf [global]fsid = d2a2bccc-b215-4f3e-922b-cf6019068e76public_network = 172.23.0.0/24mon_initial_members = ceph-1mon_host = 172.23.0.101auth_cluster_required = cephxauth_service_required = cephxauth_client_required = cephx ​ 查看部署log可以发现参数配置已经生效，而这个节点有两个IP，public_nwtwork这个参数限定了公网IP的搜索范围，生成的ceph.conf文件内也包含了public_network这个参数。 Q9. 参数是下划线还是空格分隔​ 这里只是简单的提一下这个小困惑，对于以下的两个参数书写方式，哪种会有问题呢： 1234public_network = 172.23.0.1/24public network = 172.23.0.1/24osd_journal_size = 128osd journal size = 128 ​ 这两种参数的书写方式其实都是正确的，说到底是因为底层调用的是Python的argparse模块。这两种方式都是等效的，所以不需要担心。 Q10. ceph-deploy mon create-initial如何一次性通过​ 这一步坑哭了多少迫切加入Ceph世界的新人，看到的最多的就是5s，10s，10s, 15s，20s。。。然后报了错。再执行，再报错。所以这里给出以下的预检清单，如果被报错失败所烦恼，请认真执行各个子项，尤其是失败后要执行清理环境： 请确保所有节点都安装了Ceph。 请确保所有节点的防火墙等都关闭了。参考环境预准备一节 请前往各个MON节点清理干净，不论你是否相信这个节点是干净的。参考清理环境一节。 请确保各个MON节点下存在以下目录，并且对于Jewel版本及之后的请确保目录权限为ceph:ceph。参考部署前最后的确认一节。 请在ceph-deploy new生成的ceph.conf内添加public_network配置项，参考Public VS Cluster一节。 这些总结来之不易，我帮过上百个人解决过部署问题和集群故障。我相信在认真确认过之后是肯定可以通过的(反正前三点如果有问题一般是不会建好MON的，为什么不认真确认下呢)，我遇到过绝大多数都是因为防火墙没关，或者手动删除了一些目录，或者没有修改权限导致的问题。 ​ 相对来说，新环境只要关了防火墙就可以一次性通过，旧环境或者失败的环境只要清理环境就可以通过了。 Q11. mon create-initial 做了什么 简单介绍下流程： ceph-deploy读取配置文件中的 1mon_initial_members 的各个主机，然后依次SSH前往各个主机： 将部署目录下的ceph.conf推送到新节点的/etc/ceph/目录下。 创建/var/lib/ceph/mon/$cluster-$hostname/目录。 检查MON目录下是否有done文件，如果有则直接跳到第6步。 将ceph.mon.keyring拷贝到新节点，并利用该秘钥在MON目录下建立MON数据库。 在MON目录下建立done文件，防止重新建立MON。 启动MON进程。 查看/var/run/ceph/$cluster-mon.$hostname.asokSOCKET文件，这个是由MON进程启动后生成的，输出MON状态。 在所有的MON都建立好后，再次前往各个主机，查看所有主机是否运行并且到达法定人群(quorum)。如果有没到到的，直接结束报错。如果都到达了，执行下一步。 调用 1auth get-or-create 方法创建(如果不存在)或者拉取(已经存在)MON节点上的以下几个keyring到 部署目录 中： ceph.bootstrap-mds.keyring ceph.bootstrap-osd.keyring ceph.bootstrap-rgw.keyring ceph.client.admin.keyring 指令结束。 Q12. mon create-initial 为什么会失败​ 我不喜欢讲怎么做，我愿意花很大的篇幅介绍为什么会造成各种各样的问题，如果知道了原因，你自然知道该怎么做，所以才会理解Ceph，而不是机械的去敲指令。 综合上面的所有小节，我来总结下这一步失败的基本上所有可能的原因： 所谓MON的quorum，相当于多个MON形成的一个群体，它们之间需要通过网络发送数据包来通讯达成某种协议，如果打开了防火墙，会阻断数据交流。所以不能构成群体，一直等待(5s-&gt;10s-&gt;10s-&gt;15s-&gt;20s)其他MON的数据包，既然被阻断了这样的等待是没有意义的，等了30s还没有正常，就可以直接ctrl+z去检查了。 我在配置文件里面添加了pubilc_network，但是有个主机的所有IP都不在公网IP段内，那么这个MON是建不好的，因为没有IP用作MON使用，public_network相当于一个过滤器。 搭好了一台虚拟机后，直接克隆了两台，没有修改主机名，导致socket文件路径名识别错误，报了异常，不过这很少发生。 如果在旧的MON节点上再次部署新的MON，再又没有清理环境，之前的MON数据库会保留着done文件，MON数据库里面还是记录着之前fsid，keyring等等，和新集群是两套完全不同的，所以这个节点的MON自然到达不了MON群体。 即使你单单删除了/var/lib/ceph/mon下的东西，而没有清理那些keyring，也有可能会因为收集了旧集群的秘钥而发生稀奇古怪的问题。 对于Jewel，你一不小心删除了/var/lib/ceph/mon目录，或者其他的OSD目录或者/var/run/ceph目录，然后又重建了目录，依然部署不上，是因为Jewel的所有Ceph指定都是运行在ceph:ceph用户下的，自然不能在root权限目录下建立任何文件，修改权限即可。 Ceph生成MON数据库是依照主机的hostname来命名至目录/var/lib/ceph/mon/${cluster}-${hostname}的，而检测SOCKET文件则是用ceph.conf里面的mon_initial_members里面的名字来检测的 ，如果mon_initial_members里面的名字和真是的主机名不一致，就会报错。 ​ 一旦你运行了ceph-deploy mon create-initial指令，并且失败了，有极大的可能性已经在某些节点建立好了MON的数据库，再次执行可能会因为旧的环境导致再次失败，所以如果失败了，执行一下第二节中的清理环境即可。清理完毕后，再执行ceph-deploy mon create-initial。 Q13. ceph -s 的全称以及报错原因**​ 开开心心过了mon create-initial，这个时候执行ceph -s，如果你恰好在monitor节点执行，那就会显示正常的信息，但是如果你在别的节点执行ceph -s，很有可能会报下面的错，但是有的节点又不会，所以这里花一点篇幅介绍ceph -s到底是怎么工作的。 1234[root@root cluster]# ceph -s2017-01-17 13:47:34.190226 7f446ccde700 -1 auth: unable to find a keyring on /etc/ceph/ceph.client.admin.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin: (2) No such file or directory2017-01-17 13:47:34.190393 7f446ccde700 -1 monclient(hunting): ERROR: missing keyring, cannot use cephx for authentication2017-01-17 13:47:34.190443 7f446ccde700 0 librados: client.admin initialization error (2) No such file or directory ​ 首先，如果你要执行ceph开头的任何指令，你当然要安装好Ceph客户端！（yum install ceph）而ceph -s的全称是： 123456ceph \--name client.admin \--keyring /etc/ceph/ceph.client.admin.keyring \--conf /etc/ceph/ceph.conf--cluster ceph \-s ​ 上面两个参数很好理解，Ceph内部自身使用CephX进行认证，和普通的认证没什么区别，同样需要用户名和密码进行认证，那么这里默认的用户名就叫做client.admin，而默认的秘钥保存位置就位于以下几个位置任一： /etc/ceph/ceph.client.admin.keyring /etc/ceph/ceph.keyring /etc/ceph/keyring /etc/ceph/keyring.bin 一般我们选择第一个，因为秘钥的命名规则采用/etc/ceph/$cluster.$name.keyring也就是集群名加上用户名再加上keyring的后缀组成。所以在我们执行ceph -s的时候，默认使用的是client.admin用户，同时会去那四个默认位置搜索该用户的秘钥，如果和集群保存的认证信息一致，那么就会显示出集群的状态。如果在那四个位置下面无法找到秘钥文件，就会报上面的unable to find a keyring这样的错误，解决方法后面再说。如果这个位置下面的秘钥文件保存了错误的秘钥值，就会报下面的错误： 122017-01-17 15:59:07.625018 7f8757577700 0 librados: client.admin authentication error (1) Operation not permittedError connecting to cluster: PermissionError ​ 翻译过来很简单，就是认证不通过，就好比你使用了错误的密码，去登陆系统不通过一样。这可能是由于这个节点保存了旧的集群的秘钥信息导致的。 ​ 那么正确的秘钥信息保存在哪里呢？还记得部署目录吗，在mon create-initial正确通过后，就会自动收集所有的秘钥，并保存在部署目录下面，眼疾手快的把部署目录的ceph.client.admin.keyring拷贝到/etc/ceph下面就会发现ceph -s正常显示了，不过，这不是授权的正确的姿势。 如果我们想要给一个节点admin权限，也就是执行所有Ceph指令的权限，我们可以前往部署目录，然后调用下面的指令： 1ceph-deploy admin xxNode ​ 这样就会把部署目录下的ceph.client.admin.keyring和ceph.conf拷贝到xxNode的/etc/ceph目录下，并覆盖掉原先的秘钥文件，虽然实际上也就是scp了这两个文件，但是管理Ceph遵循一定的规则是一个很好的习惯。所以，想要得到ceph -s的正确输出，你需要确认在/etc/ceph目录下有ceph.conf和ceph.client.admin.keyring这两个文件，并且和集群认证信息相同即可。如果认证失败，可以前往部署目录授权该节点。 Q14. ceph -s 卡住了简单介绍下ceph -s的流程: 每当你敲下一个Ceph指令时，相当于建立了一个Ceph的客户端进程去连接集群。 连接集群需要知道MON的IP地址，这个地址从/etc/ceph/ceph.conf里面的mon_host读取。 有了IP客户端就拿着自己用户名和秘钥向MON进行认证，认证通过执行指令返回输出。 如果你只有一个MON，然后这个MON挂掉了，那么执行指令会返回： 123[root@blog ceph]# ceph -s2017-01-19 17:49:45.437748 7f02f44e1700 0 -- :/1314350745 &gt;&gt; 139.224.0.251:6789/0 pipe(0x7f02f0063e80 sd=3 :0 s=1 pgs=0 cs=0 l=1 c=0x7f02f005c4f0).fault2017-01-19 17:49:48.442946 7f02f43e0700 0 -- :/1314350745 &gt;&gt; 139.224.0.251:6789/0 pipe(0x7f02e4000c80 sd=3 :0 s=1 pgs=0 cs=0 l=1 c=0x7f02e4001f90).fault Tips: MON的端口号为6789，所以一般看到IP:6789时，就可以判断这个IP的MON可能挂了，或者MON的防火墙开开了。上面的报错还好处理， 前往MON节点，检查ceph-mon进程是否正常运行，正确启动MON进程就可以了。 ​ 如果你有两个MON，挂了一个，指令会返回和上面一样的信息，所以，两个MON只能坏一个，一般MON个数都是奇数个。如果你有三个MON，挂了一个，那么会返回下面信息，集群还是会有输出的： 123456789[root@st001 ~]# ceph -s2017-01-19 17:59:40.753370 7f72ac31c700 0 -- :/4173548806 &gt;&gt; 10.8.0.101:6789/0 pipe(0x7f72a805e9d0 sd=3 :0 s=1 pgs=0 cs=0 l=1 c=0x7f72a805fce0).fault2017-01-19 17:59:49.754198 7f72ac21b700 0 -- 10.8.0.101:0/4173548806 &gt;&gt; 10.8.0.101:6789/0 pipe(0x7f729c000b90 sd=4 :0 s=1 pgs=0 cs=0 l=1 c=0x7f729c0041e0).fault cluster 810eaecb-2b15-4a97-84ad-7340e6cbe969 health HEALTH_WARN 1 mons down, quorum 1,2 st002,st003 monmap e1: 3 mons at &#123;st001=10.8.0.101:6789/0,st002=10.8.0.102:6789/0,st003=10.8.0.103:6789/0&#125; election epoch 18, quorum 1,2 st002,st003... ​ 客户端会去连挂掉的MON，如果过一秒钟左右连不上，就会连接剩下的MON，剩下的还有两个在运行，就连到了运行中的MON，一切输出照旧，就是多了那个连不上的MON报错输出。 ​ 而ceph -s卡住有一种可能是：对于有三个MON的集群，挂掉了两个MON之后 ，手动去/etc/ceph/ceph.conf里面把挂掉的MON的IP给删除了， 只留下一个，这时候ceph -s的指令就会一直卡在那里，查看MON的log可以发现，那个活着的MON一直处于probing状态，这样的MON是不会给客户端返回信息的，所以会卡在那里。有一点需要知道的是，MON的删除比较复杂，不能仅仅通过修改配置文件里面的IP值修改MON，所以，这里正确的做法就是，将删除的IP加回去，然后ceph -s就会报出6789之类的错误，然后再去对应的IP的MON去启动MON服务。 ​ 那么一个集群能坏多少MON呢 ，简单的计算法法就是： ​ (mon个数 -1 )/ 2 取整数位 ​ 也就是说三个能坏一个，两个和一个不能坏，四个坏一个，五个坏两个等等等。当你坏的MON个数大于可以坏的个数，那么所有的指令是不能返回的。 Q15. Monitor clock skew detected​ 如果你部署了多个monitor，比如三个MON，而这三个MON的时间不是严格相同的，那么就会报这个错，而Ceph需要MON节点之间的时间差在0.05秒之内，所以一般会选择配置一个内部的NTP server。剩余节点指向该Server节点。 ​ 千万一定不要小看了时间对其这个问题，如果各个节点时间不对其的话，有可能会导致某些OSD无法启动，而校准后，OSD立马就启动成功了，亦或导致OSD异常挂掉等等一系列的奇怪现象，十分不利于故障排查。 ​ 然而，简单的增加mon_clock_drift_allowed的时间偏移大小，是治标不治本的方法，并且OSD节点的时间偏移并不会报告在ceph -s里面，所以根本的节点方法还是配置NTP，具体方法请参考我之前写的配置NTP一段，这里就不重复了。 Q16. CephX是什么，以及CephX的开启与关闭在默认生成的ceph.conf里面有三行包含CephX的配置： 123auth_cluster_required = cephxauth_service_required = cephxauth_client_required = cephx Ceph提供认证功能，想要连接集群，是需要提供用户名和密码的，这三个配置的值只有两种： cephx: 开启CephX，即需要提供用户名和密码才能连接集群。 none: 关闭CephX，即不需要提供，任何人都可以连接集群。 注意：如果关闭了CephX，那么任何一个客户端只要拥有了MON的IP和集群的fsid，就可以连接到集群中，然后执行所有的Ceph的指令，这是相当危险的，所以对于一个非局域网的集群，是需要开启的。 之所以写这一节，是因为见过好几个在部署集群时就关闭了CephX而遇到了奇怪的现象的情形，他们一般的操作步骤是： ceph-deploy new node1 node2 node3 将生成的ceph.conf中的三个cephx改成了none ceph-deploy mon create-initial 这一步报错如下: 123456789[ceph_deploy.mon][INFO ] mon.blog monitor has reached quorum![ceph_deploy.mon][INFO ] all initial monitors are running and have formed quorum[ceph_deploy.mon][INFO ] Running gatherkeys..........[blog][DEBUG ] fetch remote file[ceph_deploy.gatherkeys][WARNIN] No mon key found in host: blog[ceph_deploy.gatherkeys][ERROR ] Failed to connect to host:blog[ceph_deploy.gatherkeys][INFO ] Destroy temp directory /tmp/tmpyGDe4r[ceph_deploy][ERROR ] RuntimeError: Failed to connect any mon ​ 先介绍下这里报错的原因，在Ceph中，除了需要使用Ceph的普通用户之外，Ceph的基本组件：MON，OSD，MDS再到RGW等都可以看做一个用户，而在使用ceph-deploy部署的时候，会默认为这些用户生成秘钥文件，在ceph-deploy new的时候，除了生成了ceph.conf，还生成了ceph.mon.keyring，顾名思义这个就是为MON用户生成的秘钥文件。查看该文件的内容可以看到如下内容： 123[mon.]key = AQCUXIRYAAAAABAAOi6Cxnvm+zFzd5gi+hrt+A==caps mon = allow * 一个秘钥文件一般由三部分组成： [mon.] ： 也就是用户名，在方括号里面的就是用户名，这里为mon.，注意是有个点号的。 key = AQCUXIRYAAAAABAAOi6Cxnvm+zFzd5gi+hrt+A== : 顾名思义，这就是mon.用户的密码。 caps ： 后面的就是权限，这里可以简单理解成，该用户可以对所有的MON进行所有操作。 也就是说，Ceph中的Monitor也会像一个用户一样，拥有自己的用户名和秘钥以及操作MON的权限。简单理解了CephX之后，我们再来看上面修改了none之后报的错。 ​ 在ceph-deploy mon create-initial执行的时候，它会去读取ceph.conf里面的auth_cluster_required配置，当被修改为none之后， 就不会在创建MON的时候，为其生成对应的keyring，但是有一点要注意的是，尽管没有为MON生成秘钥文件，但是，MON是正确生成的，这时候执行ceph -s是可以得到集群状态的，说明MON已经正确建立。但是在所有的MON建立成功之后，mon create-initial指令内部会执行gatherkeys指令，这个指令会首先去MON的目录下面查找/var/lib/ceph/mon/ceph-$HOSTNAME/keyring文件，由于关闭了CephX，在创建MON的时候不会为其生成该文件，所以gatherkeys指令报错：No mon key found in host: blog。这里只要清理下MON环境然后开启CephX重新部署MON就可以通过了。所以在我们部署集群的时候，强烈建议开启CephX，这样除了可以正确通过mon create-initial，还可以在后续的添加OSD时，为每个OSD生成对应的秘钥。在集群部署完毕后，可以关闭CephX认证，具体方法如下： 修改部署目录内ceph.conf的cephx-&gt;none,将配置推送到所有节点。 重启所有的MON和OSD。如果只重启MON，过一段时间(几个小时)，所有的OSD就会挂掉。。。 在ceph-deploy mon create-initial正确通过之后，我们可以在部署目录下面看到多出了几个文件，都是以keyring结尾： ceph.client.admin.keyring： 这个是超级用户client.admin的秘钥文件，查看其对应的权限，可以发现全部都是allow *，所以有了这个秘钥之后，相当于有了Linux系统的root用户，可以为所欲为了。 ceph.bootstrap-osd.keyring: 类似的还有两个mds和rgw，bootstrap的意思是引导，查看其权限mon = &quot;allow profile bootstrap-osd&quot;，简单解释就是，这个用户可以用于创建OSD(or MDS or RGW)用户。也就是说，后续的OSD的用户的生成是由该用户引导生成的。 最后再说一点，对于秘钥文件，其实我们只需要提供key= xxxxxxxx和用户名[xxx]就好了，不需要提供权限部分，因为权限已经在Ceph集群中保存了，秘钥文件说了不算的。具体权限可以通过ceph auth list来查看。 Q17. –overwrite-conf参数这是个经常会遇到的问题，修改配置文件内的某些参数后，再执行ceph-deploy指令，会报如下的错误： 123[blog][DEBUG ] write cluster configuration to /etc/ceph/&#123;cluster&#125;.conf[ceph_deploy.mon][ERROR ] RuntimeError: config file /etc/ceph/ceph.conf exists with different content; use --overwrite-conf to overwrite[ceph_deploy][ERROR ] GenericError: Failed to create 1 monitors ​ 报错信息提示得很明确，部署目录内的ceph.conf和集群的配置文件/etc/ceph/ceph.conf内容不一致，使用--overwrite-conf参数来覆盖集群的配置文件，也就是用部署目录的ceph.conf覆盖之。使用ceph-deploy --overwrite-conf xxxCMD来达到这一效果，当然，你也可以直接cp覆盖之。但是这不是一个好习惯。 正确的修改集群配置文件的姿势应该是： 修改部署目录下的ceph.conf。 ceph-deploy --overwrite-conf config push NodeA NodeB ... NodeZ将部署目录下的配置文件推送到各个节点。 强烈建议使用上面的方法 有的朋友可能喜欢直接去某个节点下的/etc/ceph/ceph.conf去改配置文件，这样有很多坏处： 过了一周你可能忘了你改过这个节点的配置文件。 这个节点的配置和集群其他节点的配置不一样，会带来一些安全隐患。 如果再来一个不知情的同事，他使用了正确的姿势推送配置文件，你改过的参数很容易被覆盖掉。 所以，从一开始，大家都使用同样的方式去修改集群的配置，是一个很好的习惯，对集群对同事有利无害。 ​ 如果你觉得可以接受这种推送配置的方式，但是又不喜欢每次都敲--overwrite-conf这么长的参数，你可以修改~/.cephdeploy.conf这个文件，增加一行overwrite_conf = true： 12345# ceph-deploy configuration file[ceph-deploy-global]# Overrides for some of ceph-deploy's global flags, like verbosity or cluster# nameoverwrite_conf = true ​ 打开文件你就会发现，这个是ceph-deploy的配置文件，里面的配置项是对ceph-deploy生效的，在加了那一行之后，我们再去执行ceph-deploy的任何指令，都会默认带上了--overwrite-conf参数，这样就可以不打这个参数还能覆盖节点的配置文件。好处是少打了一些参数，坏处是你可能会不知不觉就覆盖了配置文件，各中利弊自行取舍。 ​ ~/.cephdeploy.conf这个文件的用处是很大的，可以为不同的ceph-deploy xxxCMD添加参数，刚刚添加在[ceph-deploy-global]下的参数对全局都会生效，如果你希望只对xxxCMD比如new，osd，mon指定对应的参数，可以添加[ceph-deploy-xxxCMD]域，同时在对应的域下添加对应的参数。 ​ 比如给ceph-deploy osd 添加参数--zap-disk，可以在~/.cephdeploy.conf中添加： 12[ceph-deploy-osd]zap_disk = true Q18. PG卡在creating状态​ 这时候，Monitor已经建好了，可以执行ceph -s的指令了，然而我们看到集群的健康状态却是：health HEALTH_ERR。之所以是ERROR状态，是因为目前还没有建立OSD，PG处于creating状态，在建好了OSD之后，自然会解决这一问题。然而我要说的重点是creating这个状态的几个产生原因。 ​ creating字面意思很好理解，正在创建，那么怎么理解PG正在创建呢？ 用最简单的方式解释PG就是： PG等于目录。如果我们使用磁盘做OSD的话，那么这个OSD上的PG就相当于，在这个磁盘上建立的目录。那么现在的问题就可以简化成，我们尚未添加任何磁盘，那么需要落盘的目录无处可建，所以就会长时间处于creating状态。在添加了一些OSD后，PG就可以建立了。 ​ 还有一种可能的原因是，刚入门的同学在配置文件中加了osd_crush_update_on_start = false 参数，这个参数的具体意义会有专门的小节介绍，这个参数的默认值是true，在使用这个参数后不论创建多少OSD，PG都依旧卡在creating状态。原因是所添加的OSD均不在默认的root=default根节点下。CRUSH在default下无法找到OSD，所以效果就和没有创建OSD一样，再解释就过于深入了，这里只简单介绍下解决方法： 将部署目录里的ceph.conf的osd_crush_update_on_start = false去掉，或者将false改为true。 将配置文件推送到各个节点。 重启所有的OSD。 这样OSD在启动时，就会自动加到对应的主机名下的host下方，并将主机名加到default下方。这样CRUSH就可以找到OSD了。当然，对于新入门的同学，一点建议就是，不知道意义的参数都不用加上，Ceph有自己一套默认参数，而这些参数不用修改就可以正常运行集群。如果添加了某些参数，最好知道其作用再使用。 Q19. osd_crush_update_on_start 参数的使用和注意点​ 这是一个很有趣的参数，使用得当会省去很多事情，使用不当可能会造成灾难(亲身体验)。这个参数在ceph --show-config中并不能查询到，所以这并不是Ceph进程的一个配置项。实际上，这个配置相当于一个启动配置项。也就是说在OSD启动的时候会加载这个参数。由于Jewel将OSD的启动方式做了修改，所以针对Hammer及其之前和Jewel两种启动方式，分别在下面的两个文件使用到了这个参数，实际上，加载的方式还是一样的，只是启动文件有所变化： Hammer 及其之前 : 0.94.9 -&gt; /etc/init.d/ceph -&gt; line 370 -&gt; get_conf update_crush &quot;&quot; &quot;osd crush update on start&quot; Jewel : 10.2.3 -&gt;/usr/lib/ceph/ceph-osd-prestart.sh -&gt; line 23 -&gt; update=&quot;$(ceph-conf --cluster=${cluster:-ceph} --name=osd.$id --lookup osd_crush_update_on_start || :)&quot; 在OSD启动的时候，都会去配置文件中读取osd_crush_update_on_start。然后启动脚本根据是否存在以及配置值来决定是否将该OSD按照一定的方式(CRUSH位置，OSD的ID，OSD的weight)将这个OSD添加到CRUSH中。 ​ 简单点说，如果这个值为false，那么OSD在启动的时候不会去修改你的CRUSH树，也就是说OSD不会自动填加到对应的主机名下再自己添加到root=default下。 ​ 如果这个值为true，或者不添加该配置项(也就是说，默认为true)，OSD在启动时(任何一次启动)都会将自己添加到CRUSH树下。默认的位置为：/usr/bin/ceph-crush-location -&gt; line 86 -&gt; host=$(hostname -s) root=default。]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ceph存储引擎之bluestore]]></title>
    <url>%2F2019%2F05%2F07%2FCeph-bluestore%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[​ ceph后端支持多种存储引擎，以插件式的方式来进行管理使用，目前支持filestore，kvstore，memstore以及最新的bluestore，本文介绍的是bluestore的存储方法。 ​ 目前ceph10版本默认使用的filestore，但是因为filestore在写数据前需要先写journal，会有一倍的写放大，并且filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑，因此诞生的bluestore初衷就是为了减少写放大，并针对ssd做优化，而且直接管理裸盘，从理论上进一步减少文件系统如ext4/xfs等部分的开销，目前bluestore还处于开发优化阶段，在jewel版本还是试用版本，并且最新的master相比jewel已经做了大的重构，预期会在后续的大版本中稳定下来成为默认的存储引擎。本文基于master分支对bluestore存储引擎进行分析。 bluestore整体架构 ​ bluestore直接管理裸设备，抛弃了ext4/xfs等本地文件系统，BlockDevice实现在用户态下使用linux aio直接对裸设备进行I/O操作。既然是直接管理裸设备就必然需要进行裸设备的空间管理，对应的就是Allocator，目前支持StupidAllocator和BitmapAllocator两种分配器。 ​ 相关的元数据以kv的形式保存到kv数据库里，默认使用的是rocksdb，由于rocksdb本身是基于文件系统的，不是直接操作裸设备，但是rocksdb也比较灵活，将系统相关的处理抽象成Env，用户可用实现相应的接口，rocksdb默认的Env是PosixEnv，直接对接本地文件系统，为此，bluestore实现了一个BlueRocksEnv，继承自EnvWrapper，来为rocksdb提供底层系统的封装，为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口，在系统启动mount这个文件系统的时候将所有的元数据都加载到内存中，BluesFS的数据和日志文件都通过BlockDevice保存到裸设备上，BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备。 核心模块​ RocksDB： 存储预写式日志、数据对象元数据、Ceph的omap数据信息、以及分配器的元数据（分配器负责决定真正的数据应在什么地方存储）​ BlueRocksEnv： 与RocksDB交互的接口​ BlueFS： 小的文件系统，解决元数据、文件空间及磁盘空间的分配和管理，并实现了rocksdb::Env 接口(存储RocksDB日志和sst文件)。因为rocksdb常规来说是运行在文件系统的顶层，下面是BlueFS。 它是数据存储后端层，RocksDB的数据和BlueStore中的真正数据被存储在同一个块物理设备​ HDD/SSD： 物理块设备，存储实际的数据 ​ rocksdb本身是基于文件系统的，不是直接操作裸设备。它将系统相关的处理抽象成Env，用户可用实现相应的接口（rocksdb默认的Env是PosixEnv，直接对接本地文件系统）。BlueRocksEnv是bluestore实现的一个类，继承自rocksdb::EnvWrapper，来为rocksdb提供底层系统的封装。 ​ 为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口。所有的元数据的修改都记录在BlueFS的日志中，也就是对于BlueFS，元数据的持久化保存在日志中。在系统启动mount这个文件系统时，只需replay日志，就可将所有的元数据都加载到内存中。BluesFS的数据和日志文件都通过块设备保存到裸设备上（BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备）。 ​ bluestore不使用本地文件系统，直接接管裸设备，并且只使用一个原始分区，HDD/SSD所在的物理块设备实现在用户态下使用linux aio直接对裸设备进行I/O操作。由于操作系统支持的aio操作只支持directIO，所以对BlockDevice的写操作直接写入磁盘，并且需要按照page对齐。其内部有一个aio_thread 线程，用来检查aio是否完成。其完成后，通过回调函数aio_callback 通知调用方。 wal &amp; dbBlueFs将整个BlueStore的存储空间分为三个层次 ： 慢速(Slow)空间 主要用于存储对象数据，可由普通大容量机械盘提供，由BlueStore自行管理 高速(DB)空间 存储BlueStore内部产生的元数据，可由普通SSD提供，需求小于（慢速空间）。 超高速(WAL)空间 主要存储RocksDB内部产生的.log文件，可由ＳＳＤ或者ＮＶＲＡＭ等时延相较普通ＳＳＤ更小的设备充当。容量需求和（高速空间）相当，同样由ＢｌｕｅＦｓ直接管理。 wal &amp; db 的大小问题​ 在 ceph bluestore 的情况下，wal 是 RocksDB 的 write-ahead log, 相当于之前的 journal 数据，db 是 RocksDB 的 metadata 信息。在磁盘选择原则是 block.wal &gt; block.db &gt; block。当然所有的数据也可以放到同一块盘上。 ​ 默认情况下， wal 和 db 的大小分别是 512 MB 和 1GB, 现在没有一个好的理论值，好像和 ceph 本身承载的数据类型有关系。 ​ 值得注意的是，如果所有的数据都在单块盘上，那是没有必要指定 wal &amp; db 的大小的。如果 wal &amp; db 是在不同的盘上，由于 wal/db 一般都会分的比较小，是有满的可能性的。如果满了，这些数据会迁移到下一个快的盘上(wal - db - main)。所以最少不会因为数据满了，而造成无法写入。 bluestore元数据 ​ 在之前的存储引擎filestore里，对象的表现形式是对应到文件系统里的文件，默认4MB大小的文件，但是在bluestore里，已经没有传统的文件系统，而是自己管理裸盘，因此需要有元数据来管理对象，对应的就是Onode，Onode是常驻内存的数据结构，持久化的时候会以kv的形式存到rocksdb里。 ​ 在onode里又分为lextent，表示逻辑的数据块，用一个map来记录，一个onode里会存在多个lextent，lextent通过blob的id对应到blob（bluestore_blob_t ），blob里通过pextent对应到实际物理盘上的区域（pextent里就是offset和length来定位物理盘的位置区域）。一个onode里的多个lextent可能在同一个blob里，而一个blob也可能对应到多个pextent。 ​ 另外还有Bnode这个元数据，它是用来表示多个object可能共享extent，目前在做了快照后写I/O触发的cow进行clone的时候会用到。 I/O读写映射逻辑写I/O处理​ 到达bluestore的I/O的offset和length都是对象内（onode）的，offset是相对于这个对象起始位置的偏移，在_do_write里首先就会根据最小分配单位min_alloc_size进行判断，从而将I/O分为对齐和非对齐的。如下图所示： ​ 当一个写请求按照min_alloc_size进行拆分后，就会分为对齐写，对应到do_write_big，非对齐写（即落到某一个min_alloc_size区间的写I/O（对应到do_write_small）。 do_write_big​ 对齐到min_alloc_size的写请求处理起来比较简单，有可能是多个min_alloc_size的大小，在处理时会根据实际大小新生成lextent和blob，这个lextent跨越的区域是min_alloc_size的整数倍，如果这段区间是之前写过的，会将之前的lextent记录下来便于后续的空间回收。 do_write_small​ 在处理落到某个min_alloc_size区间的写请求时，会首先根据offset去查找有没有可以复用的blob，因为最小分配单元是min_alloc_size，默认64KB，如果一个4KB的写I/O就只会用到blob的一部分，blob里剩余的还能放其他的。 1）没有找到可以复用的blob，新生成blob ​ 在处理还还需要根据offset和len是否对齐到block_size（默认是4KB）进行补零对齐的操作，之所以需要补齐是与后续的写盘操作有关，真正写盘时有两种方式，一种是Direct I/O的方式，这种要求偏移和缓冲区都对齐的，另外一种非Direct I/O，即Buffered I/O，这种可以不对齐，但是是写到cache里，然后再sync刷到磁盘上，比如只写了100字节，在内核里是需要先从设备上读出来补齐成一个完整的扇区，然后再刷的，这样反而降低了效率。因此在bluestore里直接处理好对齐，对于后面的写盘来说比较有利，这里对齐到block_size，是个可配置的参数。 ​ 进行对齐补零时就是按照如上图那样把前后对齐到block_size，然后再把对齐后的offset和len作为lextent，进而放到blob里。 2）找到可以复用的blob​ 对于可以复用的blob，也是先按照block_size进行对齐补零的动作，然后再判断是否可以直接使用blob里空闲的空间进行区分做不同的处理。 a）直接写在blob未使用的空间上​ 这种情况下直接新生成lextent放到blob里。 b）覆盖写的情况​ 比如下面的这种情况，写I/O会覆盖部分已经写过的数据。 ​ 对于这种情况的处理如下图：也是需要先处理对齐补零的情况，如果覆盖的区域刚好是已经对齐到block_size，那么就不需要从磁盘读数据，但是如果覆盖的区域没有对齐到block_size，那么就需要把不对齐的那部分读出来，拼成一个对齐的buffer，然后新生成lextent，并且会对原来那个lextent进行调整，会记录需要回收的那部分区域。对于覆盖写的情况，都不是直接写盘，而是通过wal写到rocksdb。 整体写I/O的逻辑​ 之前组内同事画过一个流程图，这里借用一下算是一个简单的总结。 读I/O的处理 ​ 读I/O请求的处理时也是通过寻找相关联的lextent，可能会存在空洞的情况，即读到未写过的数据，这部分就直接补零。 clone及extent共享前面说到Bnode就是用来记录共享的lextent，目前是在做完快照后对原卷进行写I/O会触发cow，从而产生clone操作。clone时就是将原对象的blob从onode-&gt;blob_map移到onode-&gt;bnode-&gt;blob_map，并且将blob id置为负的，并设置共享标记，然后将新的快照对象的onode-&gt;bnode指向原对象的onode-&gt;bnode，并且用原onode里的lextents里的值赋给新的onode的lextents，从而达到共享extent的目的，图示仅供参考。 ​ 在clone完之后，继续对原对象进行写I/O操作时，当碰到共享的blob时就需要跳过，新生成blob，并且取消对原来那部分lextent的引用，在后续的空间释放时的判断依据就是否还有引用。 小结​ 从BlueStore 的设计和实现上看，可以将其理解为用户态下的一个文件系统，同时使用RocksDB来实现BlueStore所有元数据的管理，简化实现。 ​ 对于整块数据的写入，数据直接以aio的方式写入磁盘，再更新RocksDB中数据对象的元数据，避免了filestore的先写日志，后apply到实际磁盘的两次写盘。同时避免了日志元数据的冗余存储占用，因为传统文件系统有他们自己内部的日志和元数据管理机制。 ​ 对于随机IO，直接WAL的形式，写入RocksDB 高性能的KV存储中。 ​ 本文总体上介绍了bluestore的架构、相关元数据及内部I/O映射的逻辑，这还只是bluestore的冰山一角，后续会陆续对bluestore的处理流程、空间分配器、缓存管理、压缩等实现进行分析。]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ceph存储引擎之bluestore]]></title>
    <url>%2F2019%2F05%2F07%2FCeph-bluestore%2F</url>
    <content type="text"><![CDATA[​ ceph后端支持多种存储引擎，以插件式的方式来进行管理使用，目前支持filestore，kvstore，memstore以及最新的bluestore，本文介绍的是bluestore的存储方法。 ​ 目前ceph10版本默认使用的filestore，但是因为filestore在写数据前需要先写journal，会有一倍的写放大，并且filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑，因此诞生的bluestore初衷就是为了减少写放大，并针对ssd做优化，而且直接管理裸盘，从理论上进一步减少文件系统如ext4/xfs等部分的开销，目前bluestore还处于开发优化阶段，在jewel版本还是试用版本，并且最新的master相比jewel已经做了大的重构，预期会在后续的大版本中稳定下来成为默认的存储引擎。本文基于master分支对bluestore存储引擎进行分析。 bluestore整体架构 ​ bluestore直接管理裸设备，抛弃了ext4/xfs等本地文件系统，BlockDevice实现在用户态下使用linux aio直接对裸设备进行I/O操作。既然是直接管理裸设备就必然需要进行裸设备的空间管理，对应的就是Allocator，目前支持StupidAllocator和BitmapAllocator两种分配器。 ​ 相关的元数据以kv的形式保存到kv数据库里，默认使用的是rocksdb，由于rocksdb本身是基于文件系统的，不是直接操作裸设备，但是rocksdb也比较灵活，将系统相关的处理抽象成Env，用户可用实现相应的接口，rocksdb默认的Env是PosixEnv，直接对接本地文件系统，为此，bluestore实现了一个BlueRocksEnv，继承自EnvWrapper，来为rocksdb提供底层系统的封装，为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口，在系统启动mount这个文件系统的时候将所有的元数据都加载到内存中，BluesFS的数据和日志文件都通过BlockDevice保存到裸设备上，BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备。 核心模块​ RocksDB： 存储预写式日志、数据对象元数据、Ceph的omap数据信息、以及分配器的元数据（分配器负责决定真正的数据应在什么地方存储）​ BlueRocksEnv： 与RocksDB交互的接口​ BlueFS： 小的文件系统，解决元数据、文件空间及磁盘空间的分配和管理，并实现了rocksdb::Env 接口(存储RocksDB日志和sst文件)。因为rocksdb常规来说是运行在文件系统的顶层，下面是BlueFS。 它是数据存储后端层，RocksDB的数据和BlueStore中的真正数据被存储在同一个块物理设备​ HDD/SSD： 物理块设备，存储实际的数据 ​ rocksdb本身是基于文件系统的，不是直接操作裸设备。它将系统相关的处理抽象成Env，用户可用实现相应的接口（rocksdb默认的Env是PosixEnv，直接对接本地文件系统）。BlueRocksEnv是bluestore实现的一个类，继承自rocksdb::EnvWrapper，来为rocksdb提供底层系统的封装。 ​ 为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口。所有的元数据的修改都记录在BlueFS的日志中，也就是对于BlueFS，元数据的持久化保存在日志中。在系统启动mount这个文件系统时，只需replay日志，就可将所有的元数据都加载到内存中。BluesFS的数据和日志文件都通过块设备保存到裸设备上（BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备）。 ​ bluestore不使用本地文件系统，直接接管裸设备，并且只使用一个原始分区，HDD/SSD所在的物理块设备实现在用户态下使用linux aio直接对裸设备进行I/O操作。由于操作系统支持的aio操作只支持directIO，所以对BlockDevice的写操作直接写入磁盘，并且需要按照page对齐。其内部有一个aio_thread 线程，用来检查aio是否完成。其完成后，通过回调函数aio_callback 通知调用方。 wal &amp; dbBlueFs将整个BlueStore的存储空间分为三个层次 ： 慢速(Slow)空间 主要用于存储对象数据，可由普通大容量机械盘提供，由BlueStore自行管理 高速(DB)空间 存储BlueStore内部产生的元数据，可由普通SSD提供，需求小于（慢速空间）。 超高速(WAL)空间 主要存储RocksDB内部产生的.log文件，可由ＳＳＤ或者ＮＶＲＡＭ等时延相较普通ＳＳＤ更小的设备充当。容量需求和（高速空间）相当，同样由ＢｌｕｅＦｓ直接管理。 wal &amp; db 的大小问题​ 在 ceph bluestore 的情况下，wal 是 RocksDB 的 write-ahead log, 相当于之前的 journal 数据，db 是 RocksDB 的 metadata 信息。在磁盘选择原则是 block.wal &gt; block.db &gt; block。当然所有的数据也可以放到同一块盘上。 ​ 默认情况下， wal 和 db 的大小分别是 512 MB 和 1GB, 现在没有一个好的理论值，好像和 ceph 本身承载的数据类型有关系。 ​ 值得注意的是，如果所有的数据都在单块盘上，那是没有必要指定 wal &amp; db 的大小的。如果 wal &amp; db 是在不同的盘上，由于 wal/db 一般都会分的比较小，是有满的可能性的。如果满了，这些数据会迁移到下一个快的盘上(wal - db - main)。所以最少不会因为数据满了，而造成无法写入。 bluestore元数据 ​ 在之前的存储引擎filestore里，对象的表现形式是对应到文件系统里的文件，默认4MB大小的文件，但是在bluestore里，已经没有传统的文件系统，而是自己管理裸盘，因此需要有元数据来管理对象，对应的就是Onode，Onode是常驻内存的数据结构，持久化的时候会以kv的形式存到rocksdb里。 ​ 在onode里又分为lextent，表示逻辑的数据块，用一个map来记录，一个onode里会存在多个lextent，lextent通过blob的id对应到blob（bluestore_blob_t ），blob里通过pextent对应到实际物理盘上的区域（pextent里就是offset和length来定位物理盘的位置区域）。一个onode里的多个lextent可能在同一个blob里，而一个blob也可能对应到多个pextent。 ​ 另外还有Bnode这个元数据，它是用来表示多个object可能共享extent，目前在做了快照后写I/O触发的cow进行clone的时候会用到。 I/O读写映射逻辑写I/O处理​ 到达bluestore的I/O的offset和length都是对象内（onode）的，offset是相对于这个对象起始位置的偏移，在_do_write里首先就会根据最小分配单位min_alloc_size进行判断，从而将I/O分为对齐和非对齐的。如下图所示： ​ 当一个写请求按照min_alloc_size进行拆分后，就会分为对齐写，对应到do_write_big，非对齐写（即落到某一个min_alloc_size区间的写I/O（对应到do_write_small）。 do_write_big​ 对齐到min_alloc_size的写请求处理起来比较简单，有可能是多个min_alloc_size的大小，在处理时会根据实际大小新生成lextent和blob，这个lextent跨越的区域是min_alloc_size的整数倍，如果这段区间是之前写过的，会将之前的lextent记录下来便于后续的空间回收。 do_write_small​ 在处理落到某个min_alloc_size区间的写请求时，会首先根据offset去查找有没有可以复用的blob，因为最小分配单元是min_alloc_size，默认64KB，如果一个4KB的写I/O就只会用到blob的一部分，blob里剩余的还能放其他的。 1）没有找到可以复用的blob，新生成blob ​ 在处理还还需要根据offset和len是否对齐到block_size（默认是4KB）进行补零对齐的操作，之所以需要补齐是与后续的写盘操作有关，真正写盘时有两种方式，一种是Direct I/O的方式，这种要求偏移和缓冲区都对齐的，另外一种非Direct I/O，即Buffered I/O，这种可以不对齐，但是是写到cache里，然后再sync刷到磁盘上，比如只写了100字节，在内核里是需要先从设备上读出来补齐成一个完整的扇区，然后再刷的，这样反而降低了效率。因此在bluestore里直接处理好对齐，对于后面的写盘来说比较有利，这里对齐到block_size，是个可配置的参数。 ​ 进行对齐补零时就是按照如上图那样把前后对齐到block_size，然后再把对齐后的offset和len作为lextent，进而放到blob里。 2）找到可以复用的blob​ 对于可以复用的blob，也是先按照block_size进行对齐补零的动作，然后再判断是否可以直接使用blob里空闲的空间进行区分做不同的处理。 a）直接写在blob未使用的空间上​ 这种情况下直接新生成lextent放到blob里。 b）覆盖写的情况​ 比如下面的这种情况，写I/O会覆盖部分已经写过的数据。 ​ 对于这种情况的处理如下图：也是需要先处理对齐补零的情况，如果覆盖的区域刚好是已经对齐到block_size，那么就不需要从磁盘读数据，但是如果覆盖的区域没有对齐到block_size，那么就需要把不对齐的那部分读出来，拼成一个对齐的buffer，然后新生成lextent，并且会对原来那个lextent进行调整，会记录需要回收的那部分区域。对于覆盖写的情况，都不是直接写盘，而是通过wal写到rocksdb。 整体写I/O的逻辑​ 之前组内同事画过一个流程图，这里借用一下算是一个简单的总结。 读I/O的处理 ​ 读I/O请求的处理时也是通过寻找相关联的lextent，可能会存在空洞的情况，即读到未写过的数据，这部分就直接补零。 clone及extent共享前面说到Bnode就是用来记录共享的lextent，目前是在做完快照后对原卷进行写I/O会触发cow，从而产生clone操作。clone时就是将原对象的blob从onode-&gt;blob_map移到onode-&gt;bnode-&gt;blob_map，并且将blob id置为负的，并设置共享标记，然后将新的快照对象的onode-&gt;bnode指向原对象的onode-&gt;bnode，并且用原onode里的lextents里的值赋给新的onode的lextents，从而达到共享extent的目的，图示仅供参考。 ​ 在clone完之后，继续对原对象进行写I/O操作时，当碰到共享的blob时就需要跳过，新生成blob，并且取消对原来那部分lextent的引用，在后续的空间释放时的判断依据就是否还有引用。 小结​ 从BlueStore 的设计和实现上看，可以将其理解为用户态下的一个文件系统，同时使用RocksDB来实现BlueStore所有元数据的管理，简化实现。 ​ 对于整块数据的写入，数据直接以aio的方式写入磁盘，再更新RocksDB中数据对象的元数据，避免了filestore的先写日志，后apply到实际磁盘的两次写盘。同时避免了日志元数据的冗余存储占用，因为传统文件系统有他们自己内部的日志和元数据管理机制。 ​ 对于随机IO，直接WAL的形式，写入RocksDB 高性能的KV存储中。 ​ 本文总体上介绍了bluestore的架构、相关元数据及内部I/O映射的逻辑，这还只是bluestore的冰山一角，后续会陆续对bluestore的处理流程、空间分配器、缓存管理、压缩等实现进行分析。]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ceph存储引擎之FileStore]]></title>
    <url>%2F2019%2F05%2F07%2FCeph-FileStore%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[​ Ceph作为一个高可用和强一致性的软件定义存储实现，去使用它非常重要的就是了解其内部的IO路径和存储实现。这篇文章主要介绍在IO路径中最底层的ObjectStore的实现之一FileStore。 ObjectStore​ ObjectStore是Ceph OSD中最重要的概念之一，它封装了所有对底层存储的IO操作。从上图中可以看到所有IO请求在Clieng端发出，在Message层统一解析后会被OSD层分发到各个PG，每个PG都拥有一个队列，一个线程池会对每个队列进行处理。 ​ 当一个在PG队列里的IO被提出后，该IO请求会被根据类型和相关附带参数进行处理。如果是读请求会通过ObjectStore提供的API获得相应的内容，如果是写请求也会利用ObjectStore提供的事务API将所有写操作组合成一个原子事务提交给ObjectStore。ObjectStore通过接口对上层提供不同的隔离级别，目前PG层只采用了Serializable级别,保证读写的顺序性。 ​ ObjectStore主要接口分为三部分，第一部分是Object的读写操作，类似于POSIX的部分接口，第二部分是Object的属性(xattr)读写操作，这类操作的特征是kv对并且与某一个Object关联。第三部分是关联Object的kv操作(在Ceph中称为omap)，这个其实与第二部分非常类似，但是在实现上可能会有所变化。 ​ 目前ObjectStore的主要实现是FileStore，也就是利用文件系统的POSIX接口实现ObjectStore API。每个Object在FileStore层会被看成是一个文件，Object的属性(xattr)会利用文件的xattr属性存取，因为有些文件系统(如Ext4)对xattr的长度有限制，因此超出长度的Metadata会被存储在DBObjectMap里。而Object的omap则直接利用DBObjectMap实现。因此，可以看出xattr和omap操作是互通的，在用户角度来说，前者可以看作是受限的长度，后者更宽泛(API没有对这些做出硬性要求)。 FileJournal 为了缩小写事务的处理时间，提高写事务的处理能力并且实现事务的原子性，FileStore引入了FileJournal，所有写事务在被FileJournal处理以后都会立即返回(上图中的第二步)。FileJournal类似于数据库的writeahead日志，使用O_DIRECT和O_DSYNC每次同步写入到journal文件，完成后该事务会被塞到FileStore的op queue。事务通常有若干个写操作组成，当在中间过程进程crash时，journal会OSD recover提供了完备的输入。FileStore会存在多个thread从op queue里获取op，然后真正apply到文件系统上对应的Object(Buffer IO)。当FileStore将事务落到disk上之后，后续的该Object的读请求才会继续(上图中的第五步)。当FileStore完成一个op后，对应的Journal可以丢弃这部分日志。 ​ 实际上并不是所有的文件系统都按照这个顺序，一般来说如Ceph推荐的Ext4和XFS文件系统会先写入Journal，然后再写入Filesystem，而COW(Copy on Write)文件系统如Btrfs和ZFS会同时写入Journal和FileSystem。 DBObjectMap ​ DBObjectMap是FileStore的一部分，利用KeyValue数据库实现了ObjectStore的第三部分API，DBObjectMap主要复杂在其实现了clone操作的no-copy。因为ObjectStore提供了clone API，提供对一个Object的完全clone(包括Object的属性和omap)。DBObjectMap对每一个Object有一个Header，每个Object联系的omap(kv pairs)对会与该Header联系，当clone时，会产生两个新的Header，原来的Header作为这两个新Header的parent，这时候无论是原来的Object还是cloned Object在查询或者写操作时都会查询parent的情况，并且实现copy-on-write。那么Header如何与omap(kv pairs)联系呢，首先每个Header有一个唯一的seq，然后所有属于该Header的omap的key里面都会包含该seq，因此，利用KeyValueDB的提供的有序prefix检索来实现对omap的遍历。 ​ 上面提到FileStore会将每个Object作为一个文件，那么Object的一些属性会与Object Name一起作为文件名，Object 所属的PG会作为文件目录，当一个PG内所包含的文件超过一定程度时(在目录内文件太多会造成文件系统的lookup性能损耗)，PG会被分裂成两个PG。]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ceph-deploy部署ceph12集群]]></title>
    <url>%2F2019%2F05%2F07%2Fceph-12%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[1. 环境1.1 硬件4台 Linux虚拟机： server0, server1, server2, server3 每台有两块磁盘 ： /dev/vdb, /dev/vdc 每台有两块网卡 ：eth0, ens9 1.2 软件linux版本： CentOS 7.2.1511 内核版本 ： 3.10.0-327.el7.x86_64 ceph版本： 12.2.12 ceph-deploy版本： 2.0.0 2. 准备工作(所有server)2.1 配置静态IP每台server有两个interface, 分别配置在如下两个网段： 192.168.122.0/24 192.168.100.0/24 具体如下表： Server Interface IPADDR server0 eth0 192.168.122.160 server0 ens9 192.168.100.160 server1 eth0 192.168.122.161 server1 ens9 192.168.100.161 server2 eth0 192.168.122.162 server2 ens9 192.168.100.162 server3 eth0 192.168.122.163 server3 ens9 192.168.100.163 2.2 生成ssh key1# ssh-keygen 2.3 配置主机名解析把如下内容追加到/etc/hosts: 1234192.168.100.160 server0192.168.100.161 server1192.168.100.162 server2192.168.100.163 server3 2.4 配置ntp1234# yum install -y ntp ntpdate ntp-doc# vim /etc/ntp.conf （一般不需要修改）# systemctl start ntpd.service# systemctl enable ntpd.service 2.5 关闭防火墙12# systemctl stop firewalld# systemctl disable firewalld 2.6 安装yum源epel为了方便yum安装一些常用的软件包： 1# yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm 3. 安装ceph软件包3.1 添加yum源(所有server)在所有server上添加ceph.repo，内容如下： 123456789101112131415161718192021222324# cat /etc/yum.repos.d/ceph.repo [Ceph]name=Ceph packages for $basearchbaseurl=http://mirrors.163.com/ceph/rpm-luminous/el7/$basearchenabled=1priority=1gpgcheck=1gpgkey=https://download.ceph.com/keys/release.asc[Ceph-noarch]name=Ceph noarch packagesbaseurl=http://mirrors.163.com/ceph/rpm-luminous/el7/noarchenabled=1priority=1gpgcheck=1gpgkey=https://download.ceph.com/keys/release.asc[ceph-source]name=Ceph source packagesbaseurl=http://mirrors.163.com/ceph/rpm-luminous/el7/SRPMSenabled=0priority=1gpgcheck=1gpgkey=https://download.ceph.com/keys/release.asc [Ceph]： ceph软件包的yum源，所有server都需要添加。[Ceph-noarch]：ceph-deploy的yum源。admin server (见3.2节) 需要安装ceph-deploy，所以它需要这个yum源。admin server控制其他server的时候，也需要被控server添加这个yum源。最终，所有server都需要添加。[ceph-source]： admin server控制其他server的时候，也需要被控server添加这个yum源。所以，所有server都需要添加。 3.2 选择admin server选择server0作为admin server。官网上建议admin server使用一个单独的user来进行ceph-deploy操作，这里避免麻烦，还用root账户。 admin server需要免密登录所有server（包括自己），所以在admin server上配置免密登录（其他server不必配置）： 1234# ssh-copy-id root@server0# ssh-copy-id root@server1# ssh-copy-id root@server2# ssh-copy-id root@server3 测试一下： 12345# for i in &#123;0..3&#125; ; do ssh server$i hostname ; done server0server1server2server3 3.3 安装ceph-deploy(在admin server上)在3.1节已经添加了ceph-deploy的yum源，这里直接通过yum安装： 1# yum -y install ceph-deploy 然后测试一下，发现报错： 1234567# ceph-deploy --versionTraceback (most recent call last): File &quot;/usr/bin/ceph-deploy&quot;, line 18, in &lt;module&gt; from ceph_deploy.cli import main File &quot;/usr/lib/python2.7/site-packages/ceph_deploy/cli.py&quot;, line 1, in &lt;module&gt; import pkg_resourcesImportError: No module named pkg_resources 原因是缺python-setuptools，安装它即可： 1234# yum install python-setuptools# ceph-deploy --version2.0.0 3.4 安装ceph包(在admin server上执行)这一步的目标是：admin server通过远程控制在所有server上安装ceph包。它需要在所有server上添加yum源：[Ceph], [Ceph-noarch]和[ceph-source]，见3.1节。 另外注意：在所有server上安装deltarpm (yum install -y deltarpm)， 否则会报如下错误： 12345[server0][DEBUG ] Delta RPMs disabled because /usr/bin/applydeltarpm not installed.[server0][WARNIN] No data was received after 300 seconds, disconnecting...[server0][INFO ] Running command: ceph --version[server0][ERROR ] Traceback (most recent call last):[server0][ERROR ] File &quot;/usr/lib/python2.7/site-packages/ceph_deploy 下面就是安装了： 1# ceph-deploy install --release=luminous server0 server1 server2 server3 成功之后，每台server都安装了ceph包，在任意sever上检查： 123456789101112131415161718# ceph -vceph version 12.2.5 (cad919881333ac92274171586c827e01f554a70a) luminous (stable)# ceph -vceph version 12.2.5 (cad919881333ac92274171586c827e01f554a70a) luminous (stable)[root@server1 ~]# rpm -qa | grep cephceph-common-12.2.5-0.el7.x86_64ceph-mds-12.2.5-0.el7.x86_64ceph-12.2.5-0.el7.x86_64ceph-release-1-1.el7.noarchlibcephfs2-12.2.5-0.el7.x86_64python-cephfs-12.2.5-0.el7.x86_64ceph-base-12.2.5-0.el7.x86_64ceph-mon-12.2.5-0.el7.x86_64ceph-osd-12.2.5-0.el7.x86_64ceph-mgr-12.2.5-0.el7.x86_64ceph-radosgw-12.2.5-0.el7.x86_64ceph-selinux-12.2.5-0.el7.x86_64 4. 部署ceph集群（在admin server上执行）为了演示，我们 创建一个集群：1 mon + 1 mgr。这个是initial monitor。 添加 osd 添加 2 mon + 2 mgr 创建一个mds 实际上，我们完全可以在第1步中直接创建 3 mon + 3 mgr的集群 (3个都是initial monitor)，然后添加osd就行了。这里分作1和3两步，是为了演示添加mon和mgr。 另外，ceph-deploy在部署集群的过程中，会产生一些文件(log，keyring，ceph.conf等)，所以，我们在一个新目录下执行： 12# mkdir test-ceph-deploy# cd test-ceph-deploy/ 若部署出现错误，需要重头开始： 1234ceph-deploy purge server0 server1 server2 server3ceph-deploy purgedata server0 server1 server2 server3ceph-deploy forgetkeysrm ceph.* 4.1 创建集群：1 mon + 1 mgrA. 以server2为initial monitor创建集群 1# ceph-deploy new server2 这里指定server2作为initial monitor。这一步完成之后，在当前目录下会产生如下文件： 123ceph.conf ceph.mon.keyring ceph-deploy-ceph.log ceph.conf是ceph的配置文件。它将会被分发到所有server的/etc/ceph/目录下。在后续的ceph运维中，若需要做某些配置，可以在所有server上修改/etc/ceph/ceph.conf。 12345678# cat ceph.conf [global]fsid = 744f59b7-c403-48e6-a1c6-2c74901a4d0bmon_initial_members = server2mon_host = 192.168.100.162auth_cluster_required = cephxauth_service_required = cephxauth_client_required = cephx ceph.mon.keyring是monitor的keyring，它定义了monitor的key，以及monitor有什么权限： 1234# cat ceph.mon.keyring [mon.]key = AQDf7O9aAAAAABAAX4qmBiNsPhvK43wnpNCtLA==caps mon = allow * B. 配置ceph网络 ceph集群使用两个网络：public network和cluster network。前者用于服务client；后者用于集群内部通信，例如osd之间迁移数据。另外，两个网络上都有heartbeat。 注意：若只有一个网络，也可以部署ceph。这个网络同时担任public network和cluster network。这种情况下，跳过本小节。 我们有两个网络（见第2.1节），所以在ceph.conf中，增加如下两行： 1234# vim ceph.conf......public network = 192.168.100.0/24cluster network = 192.168.122.0/24 注意以下两点： 在2.3节，我们配置主机名解析的时候，把主机名解析为public network的地址。这是因为，ceph-deploy是作为client (见下文D小节：client.admin, client.bootstrap-mds,client.bootstrap-mgr,client.bootstrap-osd,client.bootstrap-rgw)来操作集群的，ceph集群通过public network服务于client。 monitor是运行于public network上的。这也很容易理解，ceph的client都需要访问monitor，若monitor运行于cluster network上，client无法访问。 C. 部署initial monitor 1# ceph-deploy mon create server2 这时候，server2上，monitor已经运行起来了。可以到server2上检查。 12[root@server2 ~]# ps -ef | grep cephceph 18240 1 1 14:24 ? 00:00:00 /usr/bin/ceph-mon -f --cluster ceph --id server2 --setuser ceph --setgroup ceph 如前文B小节所述，monitor运行于public network之上： 12[root@server2 ~]# netstat -anpl | grep 6789 | grep LISTENtcp 0 0 192.168.100.162:6789 0.0.0.0:* LISTEN 18240/ceph-mon D. 创建ceph keyring 经过前一步，server2上的monitor已经运行起来了。但这时候ceph -s失败，因为ceph -s是admin的命令，我们还没有admin的权限信息呢。 1234# ceph -c ceph.conf -s 2018-05-07 14:25:46.127163 7f76e1834700 -1 auth: unable to find a keyring on /etc/ceph/ceph.client.admin.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin,: (2) No such file or directory2018-05-07 14:25:46.127199 7f76e1834700 -1 monclient: ERROR: missing keyring, cannot use cephx for authentication2018-05-07 14:25:46.127201 7f76e1834700 0 librados: client.admin initialization error (2) No such file or directory 下面使用gatherkeys来创建各个角色（包括admin）的权限信息。gatherkeys 依次对角色 admin, bootstrap-mds, bootstrap-mgr, bootstrap-osd, bootstrap-rgw作如下操作（问题：为什么没有bootstrap-rbd？）： 使用 ceph auth get 来获取角色的key和权限； 若不存在，则使用auth get-or-create {角色} {权限}来创建角色的key和权限； 把角色的key保存到 {角色}.keyring文件； 123456789101112131415161718192021# ceph-deploy gatherkeys server2[ceph_deploy.conf][DEBUG ] found configuration file at: /root/.cephdeploy.conf[ceph_deploy.cli][INFO ] Invoked (2.0.0): /usr/bin/ceph-deploy gatherkeys server2......[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.admin[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.admin osd allow * mds allow * mon allow * mgr allow *[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.bootstrap-mds[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.bootstrap-mds mon allow profile bootstrap-mds[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.bootstrap-mgr[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.bootstrap-mgr mon allow profile bootstrap-mgr[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.bootstrap-osd[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.bootstrap-osd mon allow profile bootstrap-osd[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.bootstrap-rgw[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.bootstrap-rgw mon allow profile bootstrap-rgw[ceph_deploy.gatherkeys][INFO ] Storing ceph.client.admin.keyring[ceph_deploy.gatherkeys][INFO ] Storing ceph.bootstrap-mds.keyring[ceph_deploy.gatherkeys][INFO ] Storing ceph.bootstrap-mgr.keyring[ceph_deploy.gatherkeys][INFO ] keyring &apos;ceph.mon.keyring&apos; already exists[ceph_deploy.gatherkeys][INFO ] Storing ceph.bootstrap-osd.keyring[ceph_deploy.gatherkeys][INFO ] Storing ceph.bootstrap-rgw.keyring[ceph_deploy.gatherkeys][INFO ] Destroy temp directory /tmp/tmpCHsfbU 创建之后，各个角色的key和权限就存在于集群中了。某个角色（例如admin）要对集群的某个组件（例如osd）进行读写操作时，要提供自己的key；集群根据它的key找到它的权限，然后鉴定它是否能够对这个组件进行读写操作。 上面gatherkeys在生成各个角色的key+权限的同时，把角色的key保存成keyring文件，供各个角色读写集群组件时使用： 123456789101112131415# lltotal 120-rw-------. 1 root root 71 May 7 14:28 ceph.bootstrap-mds.keyring-rw-------. 1 root root 71 May 7 14:28 ceph.bootstrap-mgr.keyring-rw-------. 1 root root 71 May 7 14:28 ceph.bootstrap-osd.keyring-rw-------. 1 root root 71 May 7 14:28 ceph.bootstrap-rgw.keyring-rw-------. 1 root root 63 May 7 14:28 ceph.client.admin.keyring# cat ceph.client.admin.keyring [client.admin] key = AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==# cat ceph.bootstrap-osd.keyring [client.bootstrap-osd] key = AQD+8e9aFC9+LxAApTnB/DImy5ZjoRbQhYoiVA== 现在就可以执行ceph的admin命令了（admin的key保存在ceph.client.admin.keyring文件里，通过–keyring提供）： 12345678910111213141516171819202122232425# ceph --keyring ceph.client.admin.keyring -c ceph.conf -s cluster: id: 744f59b7-c403-48e6-a1c6-2c74901a4d0b health: HEALTH_OK services: mon: 1 daemons, quorum server2 mgr: no daemons active osd: 0 osds: 0 up, 0 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0 bytes usage: 0 kB used, 0 kB / 0 kB avail pgs: # ceph --keyring ceph.client.admin.keyring -c ceph.conf auth get client.adminexported keyring for client.admin[client.admin] key = AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA== caps mds = &quot;allow *&quot; caps mgr = &quot;allow *&quot; caps mon = &quot;allow *&quot; caps osd = &quot;allow *&quot; E. 分发keyring 如前所示，我们执行admin的命令，要提供admin的key（–keyring ceph.client.admin.keyring）以及配置文件(-c ceph.conf)。在后续的运维中，我们经常需要在某个server上执行admin命令。每次都提供这些参数比较麻烦。实际上，ceph会默认地从/etc/ceph/中找keyring和ceph.conf。因此，我们可以把ceph.client.admin.keyring和ceph.conf放到每个server的/etc/ceph/。ceph-deploy可以帮我做这些： 1# ceph-deploy admin server0 server1 server2 server3 检查每个server，发现/etc/ceph/下都多了ceph.client.admin.keyring和ceph.conf这两个文件。现在就不用提供那些参数了： 12# ceph -s# ceph auth get client.admin F. 创建mgr 从ceph 12（luminous）开始，需要为每个monitor创建一个mgr（其功能待研究，之前的版本都没有这个组件）。 1234567891011121314151617# ceph-deploy mgr create server2# ceph -s cluster: id: 744f59b7-c403-48e6-a1c6-2c74901a4d0b health: HEALTH_OK services: mon: 1 daemons, quorum server2 mgr: server2(active) ----------------------新加的mgr osd: 0 osds: 0 up, 0 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0 bytes usage: 0 kB used, 0 kB / 0 kB avail pgs: 4.2 添加OSDceph-deploy osd create通过调用ceph-volume来创建OSD。使用bluestore时(默认)，需要指定3个device： device 如何指定 说明 block –data 主要存储，必选。可以是磁盘，分区或者lv block.db –block-db 可选。若不指定，则对应内容存储于block。可以是分区或者lv block.wal –block-wal 可选。若不指定，则对应内容存储于block。可以是分区或者lv 注意： 不可以使用磁盘作为block.db或者block.wal，否则会报错：blkid could not detect a PARTUUID for device； 若使用磁盘或者分区作block，则ceph-volume会在其上创建lv来使用。若使用分区作block.db或block.wal，则直接使用分区而不创建lv。 在使用磁盘之前，我们先把磁盘清空。若已经创建了volume group，需要先删掉（vgremove），然后通过ceph-deploy的disk zap进行清空。ceph-deploy disk zap会发生如下错误： 12345678910111213# ceph-deploy disk zap server0 /dev/vdb[ceph_deploy.conf][DEBUG ] found configuration file at: /root/.cephdeploy.conf[ceph_deploy.cli][INFO ] Invoked (2.0.0): /usr/bin/ceph-deploy disk zap [ceph_deploy.osd][DEBUG ] zapping /dev/vdb on server0......[server0][DEBUG ] find the location of an executable[ceph_deploy][ERROR ] Traceback (most recent call last):[ceph_deploy][ERROR ] File &quot;/usr/lib/python2.7/site-packages/ceph_deploy/util/decorators.py&quot;, line 69, in newfunc[ceph_deploy][ERROR ] return f(*a, **kw)[ceph_deploy][ERROR ] File &quot;/usr/lib/python2.7/site-packages/ceph_deploy/cli.py&quot;, line 164, in _main[ceph_deploy][ERROR ] return args.func(args)[ceph_deploy][ERROR ] File &quot;/usr/lib/python2.7/site-packages/ceph_deploy/osd.py&quot;, line 438, in disk[ceph_deploy][ERROR ] disk_zap(args) 修改ceph-deploy的 osd.py的disk_zap函数，即可成功： 1234# vim /usr/lib/python2.7/site-packages/ceph_deploy/osd.pyceph_volume_executable = system.executable_path(distro.conn, &apos;ceph-volume&apos;)#if args.debug:if False: A. 添加osd.0（磁盘作block，无block.db，无block.wal） 123456789101112131415161718192021222324252627282930# ceph-deploy osd create server0 --data /dev/vdb# ceph -s cluster: id: 744f59b7-c403-48e6-a1c6-2c74901a4d0b health: HEALTH_OK services: mon: 1 daemons, quorum server2 mgr: server2(active) osd: 1 osds: 1 up, 1 in# mount | grep cephtmpfs on /var/lib/ceph/osd/ceph-0 type tmpfs (rw,relatime,seclabel)# ll /var/lib/ceph/osd/ceph-0 total 48-rw-r--r--. 1 ceph ceph 189 May 7 15:19 activate.monmaplrwxrwxrwx. 1 ceph ceph 93 May 7 15:19 block -&gt; /dev/ceph-012c2043-33ef-4219-af69-34c7ed389d41/osd-block-5beb22d5-891c-4d6e-affe-87eb4bc083b2-rw-r--r--. 1 ceph ceph 2 May 7 15:19 bluefs-rw-r--r--. 1 ceph ceph 37 May 7 15:19 ceph_fsid-rw-r--r--. 1 ceph ceph 37 May 7 15:19 fsid-rw-------. 1 ceph ceph 55 May 7 15:19 keyring-rw-r--r--. 1 ceph ceph 8 May 7 15:19 kv_backend-rw-r--r--. 1 ceph ceph 21 May 7 15:19 magic-rw-r--r--. 1 ceph ceph 4 May 7 15:19 mkfs_done-rw-r--r--. 1 ceph ceph 41 May 7 15:19 osd_key-rw-r--r--. 1 ceph ceph 6 May 7 15:19 ready-rw-r--r--. 1 ceph ceph 10 May 7 15:19 type-rw-r--r--. 1 ceph ceph 2 May 7 15:19 whoami 可见： 使用磁盘vdb创建lv供block使用； osd是mount到tmpfs的（bluefs, ceph_fsid, fsid, keyring等等都存于集群中）； B. 添加osd.1（分区作block，分区作block.db，无block.wal） 把server0的vdc分成两个分区（分区过程省略，注意，要是有gpt分区格式）：vdc1作block.db，vdc2作block。 12345678910111213141516171819# ceph-deploy osd create server0 --data /dev/vdc2 --block-db /dev/vdc1# ll /var/lib/ceph/osd/ceph-1 total 52-rw-r--r--. 1 ceph ceph 189 May 7 15:25 activate.monmaplrwxrwxrwx. 1 ceph ceph 93 May 7 15:25 block -&gt; /dev/ceph-ae408599-db16-4028-914d-4006594c5cd8/osd-block-1edeced4-e5e9-45ac-a5d3-ddd238d720d4lrwxrwxrwx. 1 root root 9 May 7 15:25 block.db -&gt; /dev/vdc1-rw-r--r--. 1 ceph ceph 2 May 7 15:25 bluefs-rw-r--r--. 1 ceph ceph 37 May 7 15:25 ceph_fsid-rw-r--r--. 1 ceph ceph 37 May 7 15:25 fsid-rw-------. 1 ceph ceph 55 May 7 15:25 keyring-rw-r--r--. 1 ceph ceph 8 May 7 15:25 kv_backend-rw-r--r--. 1 ceph ceph 21 May 7 15:25 magic-rw-r--r--. 1 ceph ceph 4 May 7 15:25 mkfs_done-rw-r--r--. 1 ceph ceph 41 May 7 15:25 osd_key-rw-r--r--. 1 ceph ceph 10 May 7 15:25 path_block.db-rw-r--r--. 1 ceph ceph 6 May 7 15:25 ready-rw-r--r--. 1 ceph ceph 10 May 7 15:25 type-rw-r--r--. 1 ceph ceph 2 May 7 15:25 whoami 可见，使用分区vdc2创建lv供block使用； block.db直接使用vdc1; C. 添加osd.2（分区作block，分区作block.db，分区作block.wal） 把serve1的vdb分成3个分区：vdb3作block，vdb2作block.db，vdb1作block-wal： 1# ceph-deploy osd create server1 --data /dev/vdb3 --block-db /dev/vdb2 --block-wal /dev/vdb1 到server1上： 12345678910111213141516171819# ll /var/lib/ceph/osd/ceph-2 total 56-rw-r--r--. 1 ceph ceph 189 May 7 15:34 activate.monmaplrwxrwxrwx. 1 ceph ceph 93 May 7 15:34 block -&gt; /dev/ceph-c2f66dc2-076b-46cd-a1cd-e3ef9511a38a/osd-block-7bf0f953-2feb-4064-8d19-873495cae7f5lrwxrwxrwx. 1 root root 9 May 7 15:34 block.db -&gt; /dev/vdb2lrwxrwxrwx. 1 root root 9 May 7 15:34 block.wal -&gt; /dev/vdb1-rw-r--r--. 1 ceph ceph 2 May 7 15:34 bluefs-rw-r--r--. 1 ceph ceph 37 May 7 15:34 ceph_fsid-rw-r--r--. 1 ceph ceph 37 May 7 15:34 fsid-rw-------. 1 ceph ceph 55 May 7 15:34 keyring-rw-r--r--. 1 ceph ceph 8 May 7 15:34 kv_backend-rw-r--r--. 1 ceph ceph 21 May 7 15:34 magic-rw-r--r--. 1 ceph ceph 4 May 7 15:34 mkfs_done-rw-r--r--. 1 ceph ceph 41 May 7 15:34 osd_key-rw-r--r--. 1 ceph ceph 10 May 7 15:34 path_block.db-rw-r--r--. 1 ceph ceph 10 May 7 15:34 path_block.wal-rw-r--r--. 1 ceph ceph 6 May 7 15:34 ready-rw-r--r--. 1 ceph ceph 10 May 7 15:34 type-rw-r--r--. 1 ceph ceph 2 May 7 15:34 whoami D. 添加osd.3（lv作block，lv作block.db，lv作block.wal） 首先，在server1上，使用vdc创建出3个lv 123456789101112131415161718# pvcreate /dev/vdc Physical volume &quot;/dev/vdc&quot; successfully created# vgcreate myvg /dev/vdc Volume group &quot;myvg&quot; successfully created# lvcreate -n block-lv -L 30G myvg Logical volume &quot;block-lv&quot; created.# lvcreate -n db-lv -L 10G myvg Logical volume &quot;db-lv&quot; created.# lvcreate -n wal-lv -L 10G myvg Logical volume &quot;wal-lv&quot; created.# ls /dev/myvg/block-lv db-lv wal-lv 然后，在admin server上创建osd.3: 1# ceph-deploy osd create server1 --data myvg/block-lv --block-db myvg/db-lv --block-wal myvg/wal-lv 到server1上： 12345678910111213141516171819# ll /var/lib/ceph/osd/ceph-3 total 56-rw-r--r--. 1 ceph ceph 189 May 7 15:47 activate.monmaplrwxrwxrwx. 1 ceph ceph 18 May 7 15:47 block -&gt; /dev/myvg/block-lvlrwxrwxrwx. 1 root root 15 May 7 15:47 block.db -&gt; /dev/myvg/db-lvlrwxrwxrwx. 1 root root 16 May 7 15:47 block.wal -&gt; /dev/myvg/wal-lv-rw-r--r--. 1 ceph ceph 2 May 7 15:47 bluefs-rw-r--r--. 1 ceph ceph 37 May 7 15:47 ceph_fsid-rw-r--r--. 1 ceph ceph 37 May 7 15:47 fsid-rw-------. 1 ceph ceph 55 May 7 15:47 keyring-rw-r--r--. 1 ceph ceph 8 May 7 15:47 kv_backend-rw-r--r--. 1 ceph ceph 21 May 7 15:47 magic-rw-r--r--. 1 ceph ceph 4 May 7 15:47 mkfs_done-rw-r--r--. 1 ceph ceph 41 May 7 15:47 osd_key-rw-r--r--. 1 ceph ceph 16 May 7 15:47 path_block.db-rw-r--r--. 1 ceph ceph 17 May 7 15:47 path_block.wal-rw-r--r--. 1 ceph ceph 6 May 7 15:47 ready-rw-r--r--. 1 ceph ceph 10 May 7 15:47 type-rw-r--r--. 1 ceph ceph 2 May 7 15:47 whoami 注意： lv应写作 myvg/xx-lv，而不是/dev/myvg/xx-lv。否则会报错。 E. 添加其他osd 为了方便，block, block.db和block.wal都使用分区。 12345678910111213141516171819202122# ceph-deploy osd create server3 --data /dev/vdb3 --block-db /dev/vdb2 --block-wal /dev/vdb1# ceph-deploy osd create server3 --data /dev/vdc3 --block-db /dev/vdc2 --block-wal /dev/vdc1# ceph-deploy osd create server2 --data /dev/vdb3 --block-db /dev/vdb2 --block-wal /dev/vdb1# ceph-deploy osd create server2 --data /dev/vdc3 --block-db /dev/vdc2 --block-wal /dev/vdc1# ceph -s cluster: id: 744f59b7-c403-48e6-a1c6-2c74901a4d0b health: HEALTH_OK services: mon: 1 daemons, quorum server2 mgr: server2(active) osd: 8 osds: 8 up, 8 in &lt;-------- 8 个 osd data: pools: 0 pools, 0 pgs objects: 0 objects, 0 bytes usage: 8226 MB used, 339 GB / 347 GB avail pgs: 4.3 添加 2 mon + 2 mgr1234# ceph-deploy mon add server0# ceph-deploy mgr create server0# ceph-deploy mon add server1# ceph-deploy mgr create server1 注意：貌似新版的ceph-deploy一次只能增加一个mon. 现在集群就有3个mon和3个mgr了： 123456789101112131415# ceph -s cluster: id: 744f59b7-c403-48e6-a1c6-2c74901a4d0b health: HEALTH_OK services: mon: 3 daemons, quorum server0,server1,server2 mgr: server2(active), standbys: server0, server1 osd: 8 osds: 8 up, 8 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0 bytes usage: 8230 MB used, 339 GB / 347 GB avail pgs: 4.4 创建一个mds为了支持cephfs，我们在server2上创建一个mds： 1# ceph-deploy mds create server2 成功之后，到server2上可以看见mds进程： 12[root@server2 ~]# ps -ef | grep ceph-mdsceph 19995 1 0 16:35 ? 00:00:00 /usr/bin/ceph-mds -f --cluster ceph --id server2 --setuser ceph --setgroup ceph 但这个时候，mds并没有active，如下，我们通过ceph -s看不到mds服务。直到创建ceph filesystem的时候，mds才进入active状态（见6.1节）。 1234567891011121314151617# ceph -s cluster: id: 744f59b7-c403-48e6-a1c6-2c74901a4d0b health: HEALTH_WARN too few PGs per OSD (12 &lt; min 30) services: -----------------&gt; 看不到mds mon: 3 daemons, quorum server0,server1,server2 mgr: server2(active), standbys: server0, server1 osd: 8 osds: 8 up, 8 in rgw: 2 daemons active data: pools: 4 pools, 32 pgs objects: 187 objects, 1113 bytes usage: 8239 MB used, 339 GB / 347 GB avail pgs: 32 active+clean 至此，ceph集群就完全部署起来了。下面，我们为ceph集群增加一些client。 5. 增加rgw （在admin server上操作）我们可以使用ceph集群之外的server来部署rgw。部署之前，需要保证默认端口（7480）没有被防火墙禁止。并且需要安装ceph-radosgw包机器依赖： 1ceph-deploy install --rgw &lt;client-node&gt; [&lt;client-node&gt; ...] 为了方便起见，我们复用集群内的server1和server3来部署rgw。由于ceph-radosgw已经安装（见3.4节），并且防火墙已经被停掉（见2.5节），所以，直接部署即可： 1# ceph-deploy rgw create server1 server3 成功之后，在server1和server3上rgw进程就运行起来了： 12345678[root@server1 ~]# ps -ef | grep ceph......ceph 15884 1 2 16:23 ? 00:00:00 /usr/bin/radosgw -f --cluster ceph --name client.rgw.server1 --setuser ceph --setgroup ceph[root@server3 ~]# ps -ef | grep ceph......ceph 14107 1 2 16:23 ? 00:00:00 /usr/bin/radosgw -f --cluster ceph --name client.rgw.server3 --setuser ceph --setgroup ceph 并且我们可以通过http来访问： 123456789# curl server1:7480&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ListAllMyBucketsResult xmlns=&quot;http://s3.amazonaws.com/doc/2006-03-01/&quot;&gt;&lt;Owner&gt; &lt;ID&gt;anonymous&lt;/ID&gt; &lt;DisplayName&gt;&lt;/DisplayName&gt;&lt;/Owner&gt;&lt;Buckets&gt;&lt;/Buckets&gt;&lt;/ListAllMyBucketsResult&gt; 6. 增加cephfsceph filesystem需要mds（我们在4.4节已经部署）。并且，有两种方式来挂载：ceph fuse和ceph kernel driver。在这一节，我们: 创建一个ceph filesystem 通过ceph fuse挂载 通过ceph kernel driver挂载 6.1 创建ceph filesystem（在集群内任意server上）A. 创建所需的pool 1234# ceph osd pool create cephfs_data 80pool &apos;cephfs_data&apos; created# ceph osd pool create cephfs_metadata 40pool &apos;cephfs_metadata&apos; created B. 创建filesystem 12# ceph fs new mycephfs cephfs_metadata cephfs_datanew fs with metadata pool 6 and data pool 5 如第4.4节所示，在没有创建filesystem之前，mds没有active。现在mds就进入active状态了： 1234567891011121314151617# ceph -s cluster: id: 744f59b7-c403-48e6-a1c6-2c74901a4d0b health: HEALTH_OK services: mon: 3 daemons, quorum server0,server1,server2 mgr: server2(active), standbys: server0, server1 mds: mycephfs-1/1/1 up &#123;0=server2=up:active&#125; ---------&gt;mds已经active osd: 8 osds: 8 up, 8 in rgw: 2 daemons active data: pools: 6 pools, 152 pgs objects: 208 objects, 3359 bytes usage: 8248 MB used, 339 GB / 347 GB avail pgs: 152 active+clean 6.2 通过ceph fuse挂载（在server2上）和rgw一样，原则上我们在ceph集群之外的某台server上挂载ceph filesystem。但为了方便起见，我们还是在server2上挂载。 首先，要在server2上安装ceph-fuse（若使用ceph集群外的server，也只需这一个包）： 1# yum install -y ceph-fuse.x86_64 然后，创建一个挂载点，就可以挂载了。注意，ceph-fuse挂载使用的是admin的权限，所以，通过-k选项传入admin的key。 123456# mkdir /mnt/cephfs# ceph-fuse -k /etc/ceph/ceph.client.admin.keyring -m server0:6789 /mnt/cephfs2018-05-07 17:27:07.205147 7f501e11f040 -1 init, newargv = 0x7f502968cb80 newargc=9ceph-fuse[20080]: starting ceph clientceph-fuse[20080]: starting fuse 这时候，一个全新的ceph filesystem就可以使用了。注意：这时cephfs_data是空的，但cephfs_metadata不空： 123456789# ceph dfGLOBAL: SIZE AVAIL RAW USED %RAW USED 347G 339G 8248M 2.32 POOLS: NAME ID USED %USED MAX AVAIL OBJECTS ...... cephfs_data 5 0 0 106G 0 cephfs_metadata 6 2624 0 106G 21 往里拷贝一些东西，就会发现cephfs_data也不空了： 1234567891011121314# cp /boot/vmlinuz-3.10.0-327.el7.x86_64 /mnt/cephfs/# ls /mnt/cephfs/vmlinuz-3.10.0-327.el7.x86_64# ceph dfGLOBAL: SIZE AVAIL RAW USED %RAW USED 347G 339G 8263M 2.32 POOLS: NAME ID USED %USED MAX AVAIL OBJECTS ...... cephfs_data 5 5035k 0 106G 2 cephfs_metadata 6 7541 0 106G 21 6.3 通过ceph kernel driver挂载首先，我们尝试在server3上测试ceph kernel driver挂载。 和ceph-fuse一样，通过ceph kernel driver挂载也需要admin的权限。不同的是，不需要admin的keyring文件，而是直接需要admin的key： 12[root@server3 ~]# mkdir /mnt/kcephfs[root@server3 ~]# mount -t ceph server0:6789:/ /mnt/kcephfs/ -o name=admin,secret=AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA== 这个命令卡了一段时间后，报出如下错误： 1mount error 5 = Input/output error 在/var/log/messages中，有如下错误信息： 123[root@server3 ~]# tail /var/log/messagesMay 7 17:41:29 server3 kernel: libceph: mon0 192.168.100.160:6789 feature set mismatch, my 103b84a842aca &lt; server&apos;s 40103b84a842aca, missing 400000000000000May 7 17:41:29 server3 kernel: libceph: mon0 192.168.100.160:6789 missing required protocol features 就是说：ceph集群需要的feature set，我们的ceph kernel driver没能够全部提供，缺失的是400000000000000。 从CephNotes里，我们可以看到，缺失有些feature，可以通过两种办法解决： 升级内核 （从客户端入手解决） 对集群做某些设置 （从server端入手解决） 例如： missing 2040000 (CEPH_FEATURE_CRUSH_TUNABLES 和CEPH_FEATURE_CRUSH_TUNABLES2 )： 把客户server（cephfs挂载机）的内核升到3.9（或以上） ； 把tunables设置为legacy : ceph osd crush tunables legacy； missing 40000000 (CEPH_FEATURE_OSDHASHPSPOOL)： 把客户server（rbd客户机？）的内核升到3.9（或以上） ； ceph osd pool set rbd hashpspool false missing 800000000 (CEPH_FEATURE_OSD_CACHEPOOL)： 把客户server的内核升到3.14（或以上） ； 删除cache pool并reload monitors； 悲剧的是，我们缺失的400000000000000 (CEPH_FEATURE_NEW_OSDOPREPLY_ENCODING)，无法通过设置集群来解决，也就是说必须升级内核（到4.5以上）。 参考：http://cephnotes.ksperis.com/blog/2014/01/21/feature-set-mismatch-error-on-ceph-kernel-client 刚好，我有个开发server（devbuild：192.168.100.150），已经编译安装过内核 4.14.39。去试试。如4.1.B节所述，monitor运行于public network上（192.168.100.0/24），devbuild能够访问这个网络。这就足够了。注意：这个server不需安装任何ceph包。 123456789101112131415# ping 192.168.100.160PING 192.168.100.160 (192.168.100.160) 56(84) bytes of data.64 bytes from 192.168.100.160: icmp_seq=1 ttl=64 time=4.12 ms64 bytes from 192.168.100.160: icmp_seq=2 ttl=64 time=0.557 ms......[root@devbuild ~]# uname -aLinux devbuild 4.14.39.hyg.20180503 ......[root@devbuild ~]# mkdir /mnt/kcephfs[root@devbuild ~]# mount -t ceph 192.168.100.162:6789:/ /mnt/kcephfs/ -o name=admin,secret=AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==[root@devbuild ~]# ls /mnt/kcephfs/vmlinuz-3.10.0-327.el7.x86_64 已经mount成功，并且能看到第6.2节拷贝过去的文件。再测试拷贝一个文件，可见读写正常： 123456[root@devbuild ~]# cp linux-4.14.39.tar.xz /mnt/kcephfs/[root@devbuild ~]# ll /mnt/kcephfs/total 103560-rw-r--r-- 1 root root 100888428 May 7 18:27 linux-4.14.39.tar.xz-rwxr-xr-x 1 root root 5156528 May 7 17:30 vmlinuz-3.10.0-327.el7.x86_64 另外，根据官方文档，命令： 1# mount -t ceph 192.168.100.162:6789:/ /mnt/kcephfs/ -o name=admin,secret=AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA== 也可以换做： 1234# cat admin.secret AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==# mount -t ceph 192.168.100.162:6789:/ /mnt/kcephfs/ -o name=admin,secretfile=admin.secret 但是，我这样尝试，一直报错： 1234567891011121314151617[root@devbuild ~]# cat admin.secretAQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==[root@devbuild ~]# mount -t ceph 192.168.100.162:6789:/ /mnt/kcephfs/ -o name=admin,secretfile=admin.secretmount: wrong fs type, bad option, bad superblock on 192.168.100.162:6789:/, missing codepage or helper program, or other error In some cases useful info is found in syslog - try dmesg | tail or so.[root@devbuild ~]# dmesg | tail [ 66.850589] random: 7 urandom warning(s) missed due to ratelimiting[ 140.953833] Key type dns_resolver registered[ 141.096210] Key type ceph registered[ 141.097950] libceph: loaded (mon/osd proto 15/24)[ 141.160712] ceph: loaded (mds proto 32)[ 141.163762] libceph: bad option at &apos;secretfile=admin.secret&apos; 原因是，我的这个server没有安装任何ceph包，所以没有/usr/sbin/mount.ceph这个文件。解决办法： \1. 从别的server拷贝这个文件; \2. 安装ceph-common； 1# yum install -y ceph-common-12.2.5-0.el7.x86_64 前文说过，devbuild server不需安装任何ceph包，但若使用secretfile的方式，还是安装这个ceph-common为好。 7. 增加rbd7.1 准备rbd pool在集群内的任意server上创建一个pool，并init： 1234# ceph osd pool create rbd_pool 100 100pool &apos;rbd_pool&apos; created# rbd pool init rbd_pool 7.2 创建块设备首先我们尝试在集群内的一个server（server0）上创建块设备。 1234567891011121314# rbd create foo --size 4096 --image-feature layering -m 192.168.100.160 -K admin.secret -p rbd_pool# rbd map foo --name client.admin -m 192.168.100.160 -K admin.secret -p rbd_poolrbd: sysfs write failedrbd: error opening default pool &apos;rbd&apos;Ensure that the default pool has been created or specify an alternate pool name.In some cases useful info is found in syslog - try &quot;dmesg | tail&quot;.rbd: map failed: (5) Input/output error# dmesg | tail ......[527394.031762] libceph: mon0 192.168.100.160:6789 feature set mismatch, my 102b84a842a42 &lt; server&apos;s 40102b84a842a42, missing 400000000000000[527394.034677] libceph: mon0 192.168.100.160:6789 missing required protocol features 和6.3节遇到的问题一样，内核版本低，缺feature 400000000000000。还是到devbuild这个server上创建吧，要求： devbuild server能够访问monitor (public network)； 安装ceph-common； admin.secret； 如6.3节所述，都已满足。可以创建块设备了： 123# rbd create foo --size 4096 --image-feature layering -m 192.168.100.160 -K admin.secret -p rbd_pool# rbd map foo --name client.admin -m 192.168.100.160 -K admin.secret -p rbd_pool 选项-K admin.secret也可以换成-k ceph.client.admin.keyring。成功之后： 12345678# ll /dev/rbd0brw-rw----. 1 root disk 251, 0 May 10 16:31 /dev/rbd0# ls /dev/rbd/rbd_pool# ls /dev/rbd/rbd_poolfoo 这时候，我们可以使用/dev/rbd0了： 12# mkfs.ext4 /dev/rbd0 # mount /dev/rbd0 /mnt/rbd/ 8. 小结本文实践了使用ceph-deploy安装部署ceph集群的过程，给集群添加了三种类型的客户端，并且解决了一些部署中常见的问题。]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级变量类型]]></title>
    <url>%2F2019%2F04%2F22%2Fpython-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[目标 列表 元组 字典 字符串 公共方法 变量高级 知识点回顾 Python 中数据类型可以分为 数字型 和 非数字型 数字型 整型 (int) 浮点型（float） 布尔型（bool） 真 True 非 0 数 —— 非零即真 假 False 0 复数型 (complex) 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题 非数字型 字符串 列表 元组 字典 在 Python 中，所有 非数字型变量 都支持以下特点： 都是一个 序列 sequence，也可以理解为 容器 取值 [] 遍历 for in 计算长度、最大/最小值、比较、删除 链接 + 和 重复 * 切片 1. 列表1.1 列表的定义 List（列表） 是 Python 中使用 最频繁 的数据类型，在其他语言中通常叫做 数组 专门用于存储 一串 信息 列表用 [] 定义，数据 之间使用 , 分隔 列表的 索引 从 0 开始 索引 就是数据在 列表 中的位置编号，索引 又可以被称为 下标 注意：从列表中取值时，如果 超出索引范围，程序会报错 1name_list = ["zhangsan", "lisi", "wangwu"] 1.2 列表常用操作 在 ipython3 中定义一个 列表，例如：name_list = [] 输入 name_list. 按下 TAB 键，ipython 会提示 列表 能够使用的 方法 如下： 1234In [1]: name_list.name_list.append name_list.count name_list.insert name_list.reversename_list.clear name_list.extend name_list.pop name_list.sortname_list.copy name_list.index name_list.remove del 关键字（科普） 使用 del 关键字(delete) 同样可以删除列表中元素 del 关键字本质上是用来 将一个变量从内存中删除的 如果使用 del 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了 1del name_list[1] 在日常开发中，要从列表删除数据，建议 使用列表提供的方法 关键字、函数和方法（科普） 关键字 是 Python 内置的、具有特殊意义的标识符 123In [1]: import keywordIn [2]: print(keyword.kwlist)In [3]: print(len(keyword.kwlist)) 关键字后面不需要使用括号 函数 封装了独立功能，可以直接调用 1函数名(参数) 函数需要死记硬背 方法 和函数类似，同样是封装了独立的功能 方法 需要通过 对象 来调用，表示针对这个 对象 要做的操作 1对象.方法名(参数) 在变量后面输入 .，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多 1.3 循环遍历 遍历 就是 从头到尾 依次 从 列表 中获取数据 在 循环体内部 针对 每一个元素，执行相同的操作 在 Python 中为了提高列表的遍历效率，专门提供的 迭代 iteration 遍历 使用 for 就能够实现迭代遍历 12345# for 循环内部使用的变量 in 列表for name in name_list: 循环内部针对列表元素进行操作 print(name) 1.4 应用场景 尽管 Python 的 列表 中可以 存储不同类型的数据 但是在开发中，更多的应用场景是 列表 存储相同类型的数据 通过 迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作 2. 元组2.1 元组的定义 Tuple（元组）与列表类似，不同之处在于元组的 元素不能修改 元组 表示多个元素组成的序列 元组 在 Python 开发中，有特定的应用场景 用于存储 一串 信息，数据 之间使用 , 分隔 元组用 () 定义 元组的 索引 从 0 开始 索引 就是数据在 元组 中的位置编号 1info_tuple = ("zhangsan", 18, 1.75) 创建空元组1info_tuple = () 元组中 只包含一个元素 时，需要 在元素后面添加逗号1info_tuple = (50, ) 2.2 元组常用操作 在 ipython3 中定义一个 元组，例如：info = () 输入 info. 按下 TAB 键，ipython 会提示 元组 能够使用的函数如下： 1info.count info.index 有关 元组 的 常用操作 可以参照上图练习 2.3 循环遍历 取值 就是从 元组 中获取存储在指定位置的数据 遍历 就是 从头到尾 依次 从 元组 中获取数据 12345# for 循环内部使用的变量 in 元组for item in info: 循环内部针对元组元素进行操作 print(item) 在 Python 中，可以使用 for 循环遍历所有非数字型类型的变量：列表、元组、字典 以及 字符串 提示：在实际开发中，除非 能够确认元组中的数据类型，否则针对元组的循环遍历需求并不是很多 2.4 应用场景 尽管可以使用 for in 遍历 元组 但是在开发中，更多的应用场景是： 函数的 参数 和 返回值，一个函数可以接收 任意多个参数，或者 一次返回多个数据 有关 函数的参数 和 返回值，在后续 函数高级 给大家介绍 格式字符串，格式化字符串后面的 () 本质上就是一个元组 让列表不可以被修改，以保护数据安全 123info = ("zhangsan", 18)print("%s 的年龄是 %d" % info) 元组和列表之间的转换 使用 list 函数可以把元组转换成列表 1list(元组) 使用 tuple 函数可以把列表转换成元组 1tuple(列表) 3. 字典3.1 字典的定义 dictionary（字典） 是 除列表以外 Python 之中 最灵活 的数据类型 字典同样可以用来 存储多个数据 通常用于存储 描述一个 物体 的相关信息 和列表的区别 列表 是 有序 的对象集合 字典 是 无序 的对象集合 字典用 {} 定义 字典使用 键值对 存储数据，键值对之间使用 , 分隔 键 key 是索引 值 value 是数据 键 和 值 之间使用 : 分隔 键必须是唯一的 值 可以取任何数据类型，但 键 只能使用 字符串、数字或 元组 1234xiaoming = &#123;"name": "小明", "age": 18, "gender": True, "height": 1.75&#125; 3.2 字典常用操作 在 ipython3 中定义一个 字典，例如：xiaoming = {} 输入 xiaoming. 按下 TAB 键，ipython 会提示 字典 能够使用的函数如下： 12345In [1]: xiaoming.xiaoming.clear xiaoming.items xiaoming.setdefaultxiaoming.copy xiaoming.keys xiaoming.updatexiaoming.fromkeys xiaoming.pop xiaoming.valuesxiaoming.get xiaoming.popitem 有关 字典 的 常用操作 可以参照上图练习 3.3 循环遍历 遍历 就是 依次 从 字典 中获取所有键值对 1234# for 循环内部使用的 `key 的变量` in 字典for k in xiaoming: print("%s: %s" % (k, xiaoming[k])) 提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多 3.4 应用场景 尽管可以使用 for in 遍历 字典 但是在开发中，更多的应用场景是： 使用 多个键值对，存储 描述一个 物体 的相关信息 —— 描述更复杂的数据信息 将 多个字典 放在 一个列表 中，再进行遍历，在循环体内部针对每一个字典进行 相同的处理 1234567card_list = [&#123;"name": "张三", "qq": "12345", "phone": "110"&#125;, &#123;"name": "李四", "qq": "54321", "phone": "10086"&#125; ] 4. 字符串4.1 字符串的定义 字符串 就是 一串字符，是编程语言中表示文本的数据类型 在 Python 中可以使用 一对双引号 &quot; 或者 一对单引号 &#39; 定义一个字符串 虽然可以使用 \&quot; 或者 \&#39; 做字符串的转义，但是在实际开发中： 如果字符串内部需要使用 &quot;，可以使用 &#39; 定义字符串 如果字符串内部需要使用 &#39;，可以使用 &quot; 定义字符串 可以使用 索引 获取一个字符串中 指定位置的字符，索引计数从 0 开始 也可以使用 for 循环遍历 字符串中每一个字符 大多数编程语言都是用 &quot; 来定义字符串 1234string = "Hello Python"for c in string: print(c) 4.2 字符串的常用操作 在 ipython3 中定义一个 字符串，例如：hello_str = &quot;&quot; 输入 hello_str. 按下 TAB 键，ipython 会提示 字符串 能够使用的 方法 如下： 12345678910111213141516In [1]: hello_str.hello_str.capitalize hello_str.isidentifier hello_str.rindexhello_str.casefold hello_str.islower hello_str.rjusthello_str.center hello_str.isnumeric hello_str.rpartitionhello_str.count hello_str.isprintable hello_str.rsplithello_str.encode hello_str.isspace hello_str.rstriphello_str.endswith hello_str.istitle hello_str.splithello_str.expandtabs hello_str.isupper hello_str.splitlineshello_str.find hello_str.join hello_str.startswithhello_str.format hello_str.ljust hello_str.striphello_str.format_map hello_str.lower hello_str.swapcasehello_str.index hello_str.lstrip hello_str.titlehello_str.isalnum hello_str.maketrans hello_str.translatehello_str.isalpha hello_str.partition hello_str.upperhello_str.isdecimal hello_str.replace hello_str.zfillhello_str.isdigit hello_str.rfind 提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！ 1) 判断类型 - 9 方法 说明 string.isspace() 如果 string 中只包含空格，则返回 True string.isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True string.isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True string.isdecimal() 如果 string 只包含数字则返回 True，全角数字 string.isdigit() 如果 string 只包含数字则返回 True，全角数字、⑴、\u00b2 string.isnumeric() 如果 string 只包含数字则返回 True，全角数字，汉字数字 string.istitle() 如果 string 是标题化的(每个单词的首字母大写)则返回 True string.islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True string.isupper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True 2) 查找和替换 - 7 方法 说明 string.startswith(str) 检查字符串是否是以 str 开头，是则返回 True string.endswith(str) 检查字符串是否是以 str 结束，是则返回 True string.find(str, start=0, end=len(string)) 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1 string.rfind(str, start=0, end=len(string)) 类似于 find()，不过是从右边开始查找 string.index(str, start=0, end=len(string)) 跟 find() 方法类似，不过如果 str 不在 string 会报错 string.rindex(str, start=0, end=len(string)) 类似于 index()，不过是从右边开始 string.replace(old_str, new_str, num=string.count(old)) 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 3) 大小写转换 - 5 方法 说明 string.capitalize() 把字符串的第一个字符大写 string.title() 把字符串的每个单词首字母大写 string.lower() 转换 string 中所有大写字符为小写 string.upper() 转换 string 中的小写字母为大写 string.swapcase() 翻转 string 中的大小写 4) 文本对齐 - 3 方法 说明 string.ljust(width) 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 string.rjust(width) 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 string.center(width) 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串 5) 去除空白字符 - 3 方法 说明 string.lstrip() 截掉 string 左边（开始）的空白字符 string.rstrip() 截掉 string 右边（末尾）的空白字符 string.strip() 截掉 string 左右两边的空白字符 6) 拆分和连接 - 5 方法 说明 string.partition(str) 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) string.rpartition(str) 类似于 partition() 方法，不过是从右边开始查找 string.split(str=””, num) 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\r’, ‘\t’, ‘\n’ 和空格 string.splitlines() 按照行(‘\r’, ‘\n’, ‘\r\n’)分隔，返回一个包含各行作为元素的列表 string.join(seq) 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 4.3 字符串的切片 切片 方法适用于 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 1字符串[开始索引:结束索引:步长] 注意： 指定的区间属于 左闭右开 型 [开始索引, 结束索引) =&gt; 开始索引 &gt;= 范围 &lt; 结束索引 从 起始 位开始，到 结束位的前一位 结束（不包含结束位本身) 从头开始，开始索引 数字可以省略，冒号不能省略 到末尾结束，结束索引 数字可以省略，冒号不能省略 步长默认为 1，如果连续切片，数字和冒号都可以省略 索引的顺序和倒序 在 Python 中不仅支持 顺序索引，同时还支持 倒序索引 所谓倒序索引就是 从右向左 计算索引 最右边的索引值是 -1，依次递减 演练需求 截取从 2 ~ 5 位置 的字符串 截取从 2 ~ 末尾 的字符串 截取从 开始 ~ 5 位置 的字符串 截取完整的字符串 从开始位置，每隔一个字符截取字符串 从索引 1 开始，每隔一个取一个 截取从 2 ~ 末尾 - 1 的字符串 截取字符串末尾两个字符 字符串的逆序 答案 123456789101112131415161718192021222324252627282930313233343536373839404142num_str = &quot;0123456789&quot;# 1. 截取从 2 ~ 5 位置 的字符串print(num_str[2:6])---&gt;2345# 2. 截取从 2 ~ `末尾` 的字符串print(num_str[2:])---&gt;23456789# 3. 截取从 `开始` ~ 5 位置 的字符串print(num_str[:6])---&gt;012345# 4. 截取完整的字符串print(num_str[:])---&gt;0123456789# 5. 从开始位置，每隔一个字符截取字符串print(num_str[::2])---&gt;02468# 6. 从索引 1 开始，每隔一个取一个print(num_str[1::2])---&gt;13579# 倒序切片# -1 表示倒数第一个字符print(num_str[-1])---&gt;9# 7. 截取从 2 ~ `末尾 - 1` 的字符串print(num_str[2:-1])---&gt;2345678# 8. 截取字符串末尾两个字符print(num_str[-2:])---&gt;89# 9. 字符串的逆序print(num_str[::-1])---&gt;9876543210 5. 公共方法5.1 Python 内置函数Python 包含了以下内置函数： 函数 描述 备注 len(item) 计算容器中元素个数 del(item) 删除变量 del 有两种方式 max(item) 返回容器中元素最大值 如果是字典，只针对 key 比较 min(item) 返回容器中元素最小值 如果是字典，只针对 key 比较 cmp(item1, item2) 比较两个值，-1 小于/0 相等/1 大于 Python 3.x 取消了 cmp 函数 注意 字符串 比较符合以下规则： “0” &lt; “A” &lt; “a” 5.2 切片 描述 Python 表达式 结果 支持的数据类型 切片 “0123456789”[::-2] “97531” 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 5.3 运算符 运算符 Python 表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * [“Hi!”] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 重复 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 &gt; &gt;= == &lt; &lt;= (1, 2, 3) &lt; (2, 2, 3) True 元素比较 字符串、列表、元组 注意 in 在对 字典 操作时，判断的是 字典的键 in 和 not in 被称为 成员运算符 成员运算符成员运算符用于 测试 序列中是否包含指定的 成员 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False 3 in (1, 2, 3) 返回 True not in 如果在指定的序列中没有找到值返回 True，否则返回 False 3 not in (1, 2, 3) 返回 False 注意：在对 字典 操作时，判断的是 字典的键 5.4 完整的 for 循环语法 在 Python 中完整的 for 循环 的语法如下： 12345for 变量 in 集合: 循环体代码else: 没有通过 break 退出循环，循环结束后，会执行的代码 应用场景 在 迭代遍历 嵌套的数据类型时，例如 一个列表包含了多个字典 需求：要判断 某一个字典中 是否存在 指定的 值 如果 存在，提示并且退出循环 如果 不存在，在 循环整体结束 后，希望 得到一个统一的提示 123456789101112131415161718192021222324252627282930students = [ &#123;"name": "阿土", "age": 20, "gender": True, "height": 1.7, "weight": 75.0&#125;, &#123;"name": "小美", "age": 19, "gender": False, "height": 1.6, "weight": 45.0&#125;,]find_name = "阿土"for stu_dict in students: print(stu_dict) # 判断当前遍历的字典中姓名是否为find_name if stu_dict["name"] == find_name: print("找到了") # 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较 breakelse: print("没有找到")print("循环结束")]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量进阶]]></title>
    <url>%2F2019%2F04%2F22%2Fpython-%E5%8F%98%E9%87%8F%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[目标 变量的引用 可变和不可变类型 局部变量和全局变量 01. 变量的引用 变量 和 数据 都是保存在 内存 中的 在 Python 中 函数 的 参数传递 以及 返回值 都是靠 引用 传递的 1.1 引用的概念在 Python 中 变量 和 数据 是分开存储的 数据 保存在内存中的一个位置 变量 中保存着数据在内存中的地址 变量 中 记录数据的地址，就叫做 引用 使用 id() 函数可以查看变量中保存数据所在的 内存地址 注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 修改了数据的引用 变量 不再 对之前的数据引用 变量 改为 对新赋值的数据引用 1.2 变量引用 的示例在 Python 中，变量的名字类似于 便签纸 贴在 数据 上 定义一个整数变量 a，并且赋值为 1 代码 图示 a = 1 将变量 a 赋值为 2 代码 图示 a = 2 定义一个整数变量 b，并且将变量 a 的值赋值给 b 代码 图示 b = a 变量 b 是第 2 个贴在数字 2 上的标签 1.3 函数的参数和返回值的传递在 Python 中，函数的 实参/返回值 都是是靠 引用 来传递来的 12345678910111213141516171819def test(num): print("-" * 50) print("%d 在函数内的内存地址是 %x" % (num, id(num))) result = 100 print("返回值 %d 在内存中的地址是 %x" % (result, id(result))) print("-" * 50) return resulta = 10print("调用函数前 内存地址是 %x" % id(a))r = test(a)print("调用函数后 实参内存地址是 %x" % id(a))print("调用函数后 返回值内存地址是 %x" % id(r)) 02. 可变和不可变类型 不可变类型，内存中的数据不允许被修改： 数字类型 int, bool, float, complex, long(2.x) 字符串 str 元组 tuple 可变类型，内存中的数据可以被修改： 列表 list 字典 dict 1234a = 1a = "hello"a = [1, 2, 3]a = [3, 2, 1] 1234567891011121314151617181920demo_list = [1, 2, 3]print("定义列表后的内存地址 %d" % id(demo_list))demo_list.append(999)demo_list.pop(0)demo_list.remove(2)demo_list[0] = 10print("修改数据后的内存地址 %d" % id(demo_list))demo_dict = &#123;"name": "小明"&#125;print("定义字典后的内存地址 %d" % id(demo_dict))demo_dict["age"] = 18demo_dict.pop("name")demo_dict["name"] = "老王"print("修改数据后的内存地址 %d" % id(demo_dict)) 注意：字典的 key 只能使用不可变类型的数据 注意 可变类型的数据变化，是通过 方法 来实现的 如果给一个可变类型的变量，赋值了一个新的数据，引用会修改 变量 不再 对之前的数据引用 变量 改为 对新赋值的数据引用 哈希 (hash) Python 中内置有一个名字叫做 hash(o) 的函数 接收一个 不可变类型 的数据作为 参数 返回 结果是一个 整数 哈希 是一种 算法，其作用就是提取数据的 特征码（指纹） 相同的内容 得到 相同的结果 不同的内容 得到 不同的结果 在 Python 中，设置字典的 键值对 时，会首先对 key 进行 hash 已决定如何在内存中保存字典的数据，以方便 后续 对字典的操作：增、删、改、查 键值对的 key 必须是不可变类型数据 键值对的 value 可以是任意类型的数据 03. 局部变量和全局变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！ 3.1 局部变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 函数执行结束后，函数内部的局部变量，会被系统回收 不同的函数，可以定义相同的名字的局部变量，但是 彼此之间 不会产生影响 局部变量的作用 在函数内部使用，临时 保存 函数内部需要使用的数据 123456789101112131415161718192021def demo1(): num = 10 print(num) num = 20 print("修改后 %d" % num)def demo2(): num = 100 print(num)demo1()demo2()print("over") 局部变量的生命周期 所谓 生命周期 就是变量从 被创建 到 被系统回收 的过程 局部变量 在 函数执行时 才会被创建 函数执行结束后 局部变量 被系统回收 局部变量在生命周期 内，可以用来存储 函数内部临时使用到的数据 3.2 全局变量 全局变量 是在 函数外部定义 的变量，所有函数内部都可以使用这个变量 1234567891011121314151617# 定义一个全局变量num = 10def demo1(): print(num)def demo2(): print(num)demo1()demo2()print("over") 注意：函数执行时，需要处理变量时 会： 首先 查找 函数内部 是否存在 指定名称 的局部变量，如果有，直接使用 如果没有，查找 函数外部 是否存在 指定名称 的全局变量，如果有，直接使用 如果还没有，程序报错！ 1) 函数不能直接修改 全局变量的引用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！ 在函数内部，可以 通过全局变量的引用获取对应的数据 但是，不允许直接修改全局变量的引用 —— 使用赋值语句修改全局变量的值 123456789101112131415161718192021num = 10def demo1(): print("demo1" + "-" * 50) # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num)def demo2(): print("demo2" + "-" * 50) print(num)demo1()demo2()print("over") 注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值 2) 在函数内部修改全局变量的值 如果在函数中需要修改全局变量，需要使用 global 进行声明 1234567891011121314151617181920212223num = 10def demo1(): print("demo1" + "-" * 50) # global 关键字，告诉 Python 解释器 num 是一个全局变量 global num # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num)def demo2(): print("demo2" + "-" * 50) print(num)demo1()demo2()print("over") 3) 全局变量定义的位置 为了保证所有的函数都能够正确使用到全局变量，应该 将全局变量定义在其他函数的上方 1234567891011a = 10def demo(): print("%d" % a) print("%d" % b) print("%d" % c)b = 20demo()c = 30 注意 由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！ 代码结构示意图如下 4) 全局变量命名的建议 为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如： 全局变量名前应该增加 g_ 或者 gl_ 的前缀 提示：具体的要求格式，各公司要求可能会有些差异]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数进阶]]></title>
    <url>%2F2019%2F04%2F22%2Fpython-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[目标 函数参数和返回值的作用 函数的返回值 进阶 函数的参数 进阶 递归函数 01. 函数参数和返回值的作用 函数根据 有没有参数 以及 有没有返回值，可以 相互组合，一共有 4 种 组合形式 无参数，无返回值 无参数，有返回值 有参数，无返回值 有参数，有返回值 定义函数时，是否接收参数，或者是否返回结果，是根据 实际的功能需求 来决定的！ 如果函数 内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部 如果希望一个函数 执行完成后，向外界汇报执行结果，就可以增加函数的返回值 1.1 无参数，无返回值此类函数，不接收参数，也没有返回值，应用场景如下： 只是单纯地做一件事情，例如 显示菜单 在函数内部 针对全局变量进行操作，例如：新建名片，最终结果 记录在全局变量 中 注意： 如果全局变量的数据类型是一个 可变类型，在函数内部可以使用 方法 修改全局变量的内容 —— 变量的引用不会改变 在函数内部，使用赋值语句 才会 修改变量的引用 1.2 无参数，有返回值此类函数，不接收参数，但是有返回值，应用场景如下： 采集数据，例如 温度计，返回结果就是当前的温度，而不需要传递任何的参数 1.3 有参数，无返回值此类函数，接收参数，没有返回值，应用场景如下： 函数内部的代码保持不变，针对 不同的参数 处理 不同的数据 例如 名片管理系统 针对 找到的名片 做 修改、删除 操作 1.4 有参数，有返回值此类函数，接收参数，同时有返回值，应用场景如下： 函数内部的代码保持不变，针对 不同的参数 处理 不同的数据，并且 返回期望的处理结果 例如 名片管理系统 使用 字典默认值 和 提示信息 提示用户输入内容 如果输入，返回输入内容 如果没有输入，返回字典默认值 02. 函数的返回值 进阶 在程序开发中，有时候，会希望 一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理 返回值 是函数 完成工作后，最后 给调用者的 一个结果 在函数中使用 return 关键字可以返回结果 调用函数一方，可以 使用变量 来 接收 函数的返回结果 问题：一个函数执行后能否返回多个结果？ 示例 —— 温度和湿度测量 假设要开发一个函数能够同时返回当前的温度和湿度 先完成返回温度的功能如下： 1234567891011def measure(): """返回当前的温度""" print("开始测量...") temp = 39 print("测量结束...") return tempresult = measure()print(result) 在利用 元组 在返回温度的同时，也能够返回 湿度 改造如下： 123456789def measure(): """返回当前的温度""" print("开始测量...") temp = 39 wetness = 10 print("测量结束...") return (temp, wetness) 提示：如果一个函数返回的是元组，括号可以省略 技巧 在 Python 中，可以 将一个元组 使用 赋值语句 同时赋值给 多个变量 注意：变量的数量需要和元组中的元素数量保持一致 1result = temp, wetness = measure() 03. 函数的参数 进阶3.1. 不可变和可变的参数 问题 1：在函数内部，针对参数使用 赋值语句，会不会影响调用函数时传递的 实参变量？ —— 不会！ 无论传递的参数是 可变 还是 不可变 只要 针对参数 使用 赋值语句，会在 函数内部 修改 局部变量的引用，不会影响到 外部变量的引用 12345678910111213141516171819def demo(num, num_list): print("函数内部") # 赋值语句 num = 200 num_list = [1, 2, 3] print(num) print(num_list) print("函数代码完成")gl_num = 99gl_list = [4, 5, 6]demo(gl_num, gl_list)print(gl_num)print(gl_list) 问题 2：如果传递的参数是 可变类型，在函数内部，使用 方法 修改了数据的内容，同样会影响到外部的数据 12345678910def mutable(num_list): # num_list = [1, 2, 3] num_list.extend([1, 2, 3]) print(num_list)gl_list = [6, 7, 8]mutable(gl_list)print(gl_list) 在 python 中，列表变量调用 += 本质上是在执行列表变量的 extend 方法，不会修改变量的引用 1234567891011121314151617181920def demo(num, num_list): print("函数内部代码") # num = num + num num += num # num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用 # 函数执行结束后，外部数据同样会发生变化 num_list += num_list print(num) print(num_list) print("函数代码完成")gl_num = 9gl_list = [1, 2, 3]demo(gl_num, gl_list)print(gl_num)print(gl_list) 3.2 缺省参数 定义函数时，可以给 某个参数 指定一个默认值，具有默认值的参数就叫做 缺省参数 调用函数时，如果没有传入 缺省参数 的值，则在函数内部使用定义函数时指定的 参数默认值 函数的缺省参数，将常见的值设置为参数的缺省值，从而 简化函数的调用 例如：对列表排序的方法 123456789gl_num_list = [6, 3, 9]# 默认就是升序排序，因为这种应用需求更多gl_num_list.sort()print(gl_num_list)# 只有当需要降序排序时，才需要传递 `reverse` 参数gl_num_list.sort(reverse=True)print(gl_num_list) 指定函数的缺省参数 在参数后使用赋值语句，可以指定参数的缺省值 1234567def print_info(name, gender=True): gender_text = "男生" if not gender: gender_text = "女生" print("%s 是 %s" % (name, gender_text)) 提示 缺省参数，需要使用 最常见的值 作为默认值！ 如果一个参数的值 不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递！ 缺省参数的注意事项1) 缺省参数的定义位置 必须保证 带有默认值的缺省参数 在参数列表末尾 所以，以下定义是错误的！ 1def print_info(name, gender=True, title): 2) 调用带有多个缺省参数的函数 在 调用函数时，如果有 多个缺省参数，需要指定参数名，这样解释器才能够知道参数的对应关系！ 1234567891011121314151617181920def print_info(name, title="", gender=True): """ :param title: 职位 :param name: 班上同学的姓名 :param gender: True 男生 False 女生 """ gender_text = "男生" if not gender: gender_text = "女生" print("%s%s 是 %s" % (title, name, gender_text))# 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！print_info("小明")print_info("老王", title="班长")print_info("小美", gender=False) 3.3 多值参数定义支持多值参数的函数 有时可能需要 一个函数 能够处理的参数 个数 是不确定的，这个时候，就可以使用 多值参数 python 中有 两种 多值参数： 参数名前增加 一个 * 可以接收 元组 参数名前增加 两个 * 可以接收 字典 一般在给多值参数命名时，习惯使用以下两个名字 *args —— 存放 元组 参数，前面有一个 * **kwargs —— 存放 字典 参数，前面有两个 * args 是 arguments 的缩写，有变量的含义 kw 是 keyword 的缩写，kwargs 可以记忆 键值对参数 12345678def demo(num, *args, **kwargs): print(num) print(args) print(kwargs)demo(1, 2, 3, 4, 5, name="小明", age=18, gender=True) 提示：多值参数 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，有利于我们能够读懂大牛的代码 多值参数案例 —— 计算任意多个数字的和需求 定义一个函数 sum_numbers，可以接收的 任意多个整数 功能要求：将传递的 所有数字累加 并且返回累加结果 12345678910def sum_numbers(*args): num = 0 # 遍历 args 元组顺序求和 for n in args: num += n return numprint(sum_numbers(1, 2, 3)) 元组和字典的拆包（知道） 在调用带有多值参数的函数时，如果希望： 将一个 元组变量，直接传递给 args 将一个 字典变量，直接传递给 kwargs 就可以使用 拆包，简化参数的传递，拆包 的方式是： 在 元组变量前，增加 一个 * 在 字典变量前，增加 两个 * 123456789101112def demo(*args, **kwargs): print(args) print(kwargs)# 需要将一个元组变量/字典变量传递给函数对应的参数gl_nums = (1, 2, 3)gl_xiaoming = &#123;"name": "小明", "age": 18&#125;# demo(gl_nums, gl_xiaoming)--&gt;会把 num_tuple 和 xiaoming 作为元组传递个 argsdemo(*gl_nums, **gl_xiaoming) 04. 函数的递归 函数调用自身的 编程技巧 称为递归 4.1 递归函数的特点特点 一个函数 内部 调用自己 函数内部可以调用其他函数，当然在函数内部也可以调用自己 代码特点 函数内部的 代码 是相同的，只是针对 参数 不同，处理的结果不同 当 参数满足一个条件 时，函数不再执行 这个非常重要，通常被称为递归的出口，否则 会出现死循环！ 示例代码 1234567891011def sum_numbers(num): print(num) # 递归的出口很重要，否则会出现死循环 if num == 1: return sum_numbers(num - 1) sum_numbers(3) 4.2 递归案例 —— 计算数字累加需求 定义一个函数 sum_numbers 能够接收一个 num 的整数参数 计算 1 + 2 + … num 的结果 123456789101112def sum_numbers(num): if num == 1: return 1 # 假设 sum_numbers 能够完成 num - 1 的累加 temp = sum_numbers(num - 1) # 函数内部的核心算法就是 两个数字的相加 return num + tempprint(sum_numbers(2)) 提示：递归是一个 编程技巧，初次接触递归会感觉有些吃力！在处理 不确定的循环条件时，格外的有用，例如：遍历整个文件目录的结构]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>function</tag>
      </tags>
  </entry>
</search>
