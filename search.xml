<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux-内核模块编译安装]]></title>
    <url>%2F2019%2F06%2F08%2Flinux-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[模块的编译​ 我们在前面内核编译中驱动移植那块，讲到驱动编译分为静态编译和动态编译；静态编译即为将驱动直接编译进内核，动态编译即为将驱动编译成模块。 ​ 而动态编译又分为以下两种 内部编译​ 在内核源码目录内编译 外部编译​ 在内核源码的目录外编译 具体编译过程分析​ 注：本次编译是外部编译，使用的内核源码是Ubuntu的源代码，而非开发板所用linux 3.14内核源码，运行平台为X86。 ​ 对于一个普通的linux设备驱动模块，以下是一个经典的makefile代码，使用下面这个makefile可以完成大部分驱动的编译，使用时只需要修改一下要编译生成的驱动名称即可。只需修改obj-m的值。 12345678910ifneq ($(KERNELRELEASE),)obj-m:=hello.oelseKDIR := /lib/modules/$(shell uname -r)/buildPWD:=$(shell pwd)all: make -C $(KDIR) M=$(PWD) modulesclean: rm -f *.ko *.o *.symvers *.cmd *.cmd.oendif Makefile中的变量先说明以下Makefile中一些变量意义： ​ （1）KERNELRELEASE：在linux内核源代码中的顶层makefile中有定义。 ​ （2）shell pwd：取得当前工作路径。 ​ （3）shell uname -r：取得当前内核的版本号。 ​ （4）KDIR：当前内核的源代码目录。 关于linux源码的目录有两个，分别为&quot;/lib/modules/$(shell uname -r)/build&quot;和&quot;/usr/src/linux-header-$(shell uname -r)/&quot; ​ 但如果编译过内核就会知道，usr目录下那个源代码一般是我们自己下载后解压的，而lib目录下的则是在编译时自动copy过去的，两者的文件结构完全一样，因此有时也将内核源码目录设置成/usr/src/linux-header-$(shell uname -r)/。关于内核源码目录可以根据自己的存放位置进行修改。 （5）make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules 这就是编译模块了： 首先改变目录到-C选项指定的位置（即内核源代码目录），其中保存有内核的顶层makefile； M=选项让该makefile在构造modules目标之前返回到模块源代码目录；然后，modueles目标指向obj-m变量中设定的模块；在上面的例子中，我们将该变量设置成了hello.o。 Make的的执行步骤 第一次进来的时候，宏“KERNELRELEASE”未定义，因此进入else； 记录内核路径，记录当前路径； ​ 由于make后面没有目标，所以make会在Makefile中的第一个不是以.开头的目标作为默认的目标执行。默认执行all这个规则 make -C $(KDIR) M=$(PWD) modules -C进入到内核的目录执行Makefile ，在执行的时候KERNELRELEASE就会被赋值，M=$(PWD)表示返回当前目录，再次执行makefile，modules编译成模块的意思。 所以这里实际运行的是make -C /lib/modules/2.6.13-study/build M=/home/fs/code/1/module/hello/ modules。 再次执行该makefile，KERNELRELEASE就有值了，就会执行obj-m:=hello.o。 obj-m：表示把hello.o和其他的目标文件链接成hello.ko模块文件，编译的时候还要先把hello.c编译成hello.o文件 可以看出make在这里一共调用了3次 (1）make(2）linux内核源码树的顶层makedile调用，产生.o文件(3）linux内核源码树makefile调用，把.o文件链接成ko文件 编译多文件若有多个源文件，则采用如下方法： obj-m := hello.o hello-objs := file1.o file2.o file3.o 内部编译简单说明​ 如果把hello模块移动到内核源代码中。例如放到/usr/src/linux/driver/中， KERNELRELEASE就有定义了。在/usr/src/linux/Makefile中有KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)$(LOCALVERSION)。 ​ 这时候，hello模块也不再是单独用make编译，而是在内核中用make modules进行编译，此时驱动模块便和内核编译在一起。]]></content>
      <categories>
        <category>Linux-kernel</category>
      </categories>
      <tags>
        <tag>Linux-kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-centos下编译内核rpm包]]></title>
    <url>%2F2019%2F06%2F07%2Flinux-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91rpm%2F</url>
    <content type="text"><![CDATA[构建编译所需环境rpm编译目录创建12[user@host]$ mkdir -p ~/rpmbuild/&#123;BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS&#125;[user@host]$ echo &apos;%_topdir %(echo $HOME)/rpmbuild&apos; &gt; ~/.rpmmacros 编译所需的一些依赖包安装123[root@host]# yum install rpm-build redhat-rpm-config asciidoc hmaccalc perl-ExtUtils-Embed pesign xmlto -y[root@host]# yum install audit-libs-devel binutils-devel elfutils-devel elfutils-libelf-devel java-devel -y[root@host]# yum install ncurses-devel newt-devel numactl-devel pciutils-devel python-devel zlib-devel -y[root@host]# yum install make gcc bc openssl-devel -y 下载下载内核1# https://mirrors.edge.kernel.org/pub/linux/kernel/ 解压包1# tar -zxvf linux-4.14.113.tar.gz 进入源码目录1# cd linux-4.14.113 编译拷贝设置拷贝正在运行的内核的配置文件(.config文件)到编译根目录 1# cp /boot/config-$(uname -r) .config 手动设置输入命令 make menuconfig。该命令将打开一个配置工具（图 1），它可以让你遍历每个可用模块，然后启用或者禁用你需要或者不需要的模块。 注： 为了编译迅速，且rpm包大小适中。我们选择kernel hacking选项，进入以后继续选择compile-time checks and compile options， 然后选择compile the kernel with debug info，关闭这个选项，这样编译的rpm包就不带调试信息 开始编译1# make rpm 编译完成可以在~/.rpmmacros文件中找到rpm包的编译目录 123# cat ~/.rpmmacros | grep topdir%_topdir /home/rpmbuild //编译rpm包的目录# cd /home/rpmbuild/RPMS/x86_64/ //编译好的rpm包就在这个目录]]></content>
      <categories>
        <category>Linux-kernel</category>
      </categories>
      <tags>
        <tag>Linux-kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-ubuntu下编译内核deb包]]></title>
    <url>%2F2019%2F06%2F03%2Flinux-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91deb%2F</url>
    <content type="text"><![CDATA[传统编译方式​ 通常，如果我们需要在线编译安装Linux内核，大概要经历以下几个步骤： 配置内核​ 最常用的配置内核的方法是“make menuconfig”。 编译内核和模块​ 依次执行“make”、“make modules”、“make modules_install”、“make install”，如果前面的配置没有问题的话，耐心等待一段时间就可以得到编译好的内核和模块了。 生成initramfs并配置Grub​ 经过第二个步骤的“make install”，kbuild系统会把生成的内核镜像拷贝到INSTALL_PATH路径下（默认这个路径是/boot），但这时并不能使用，我们必须配置手动Grub才可以。另外，很多发行版会使用initramfs来做引导之用（还有部分发行版采用initrd），我们还需要为我们的新内核手动生成initramfs镜像。 编译内核deb安装包​ 在线编译安装有时不是很方便，可以在性能很好的编译机上编译linux代码为deb安装包，以便在新机器上安装。 ​ 如果您是Ubuntu/Debian的用户，可以使用make-kpkg简化这个流程，而且还能带来其他额外的好处。 安装make-kpkg​ 在Ubuntu下，安装kernel-package这个包之后，就可以使用make-kpkg了。 1[root@ubuntu ~]# sudo apt-get install kernel-package 配置内核​ 使用make-kpkg编译内核，第一个步骤“配置内核”还是必不可少的。建议在发行版默认的config的基础上再进行配置，这样配置出的内核和发行版本身才会有更好的相容性。比如Ubuntu 10.10，可以在运行“make menuconfig”之前执行命令“cp /boot/config-2.6.35-24-generic .config”。 编译内核deb包​ 配置完内核之后，接下来要执行真正的编译过程。通常我们可以这样下命令： 1[root@ubuntu ~]# make-kpkg --initrd --revision 001 --append-to-version -20110107 kernel_image kernek_headers --initrd选项会让make-kpkg自动帮我们生成initramfs； --revision会给生成的deb文件加上一个版本信息。这个参数只是影响到文件名，如果不指定，默认会是“10.00.Custom”； --append-to-version也是一种版本信息，它不仅出现在deb安装包的文件名里，也会影响到kernel的名称，比如本例中，内核更新完成之后，用“uname -r”察看会得到“2.6.36-20110107”； kernel_image表示生成内核和默认模块的安装包。 kernel_headers表示生成一个内核头文件的安装包。 安装内核deb包​ 编译完成后，在源码目录的上层目录会生成kernel相关deb安装包 1[root@ubuntu ~]# dpkg -i kernel*.deb]]></content>
      <categories>
        <category>Linux-kernel</category>
      </categories>
      <tags>
        <tag>Linux-kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ceph部署难题]]></title>
    <url>%2F2019%2F05%2F08%2Fceph-%E9%83%A8%E7%BD%B2%E9%9A%BE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本章总结了搭建ceph集群过程中遇到的各种问题，以及相应的原理过程 Q1. 环境预准备**​ 绝大多数MON创建的失败都是由于防火墙没有关导致的，亦或是SeLinux没关闭导致的。一定一定一定要关闭每个每个每个节点的防火墙(执行一次就好，没安装报错就忽视)： CentOS 123456sed -i 's/SELINUX=.*/SELINUX=disabled/' /etc/selinux/configsetenforce 0systemctl stop firewalld systemctl disable firewalld# iptables -Fservice iptables stop Q2. 清理环境​ MON部署不上的第二大问题就是在旧的节点部署MON，或者在这个节点部署MON失败了，然后重新new再mon create-initial，请查看要部署MON的节点上的/var/lib/ceph/mon/目录下是否为空，如果不为空，说明已经在这个目录部署过MON，再次部署会检测子目录下的done文件，由于有了这个文件，就不会再建立新的MON数据库，并且不会覆盖之，导致了部署时的各种异常，这里就不赘述了，直接给出万能清理大法： 对于任何需要新部署MON的节点，请到这个节点下执行如下指令，确保环境已经清理干净： 123456789ps aux|grep ceph |awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep ceph#确保此时所有ceph进程都已经关闭！！！如果没有关闭，多执行几次。rm -rf /var/lib/ceph/mon/*rm -rf /var/lib/ceph/bootstrap-mds/*rm -rf /var/lib/ceph/bootstrap-osd/*rm -rf /var/lib/ceph/bootstrap-rgw/*rm -rf /etc/ceph/*rm -rf /var/run/ceph/* 请直接复制粘贴，遇到过好些个自己打错打漏删了目录的。 Q3. 部署前最后的确认这里介绍的都是个案，不过还是需要提一下： 确保每个节点的hostname都设置正确，并且添加至/etc/hosts文件中，然后同步到所有节点下。克隆出来的虚拟机或者批量建的虚拟机有可能发生此情形。 确保以下目录在各个节点都存在： /var/lib/ceph/ /var/lib/ceph/mon/ /var/lib/ceph/osd/ /etc/ceph/ /var/run/ceph/ 上面的目录，如果Ceph版本大于等于jewel,请确认权限均为ceph:ceph，如果是root:root，请自行chown。 Q4. 安装Ceph​ 官网指导方法是使用ceph-deploy install nodeX,但是因为是国外的源，速度慢得令人发指，所以我们换到阿里的源，并且使用yum install的方式安装，没差啦其实，这样反而还快点，毕竟多个节点一起装。 很多安装失败的都是因为没有添加epel源请在每个存储节点都执行以下指令，来安装Ceph: 123456789101112131415161718yum clean allrm -rf /etc/yum.repos.d/*.repowget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repowget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.reposed -i '/aliyuncs/d' /etc/yum.repos.d/CentOS-Base.reposed -i '/aliyuncs/d' /etc/yum.repos.d/epel.reposed -i 's/$releasever/7.2.1511/g' /etc/yum.repos.d/CentOS-Base.repoecho "[ceph]name=cephbaseurl=http://mirrors.aliyun.com/ceph/rpm-hammer/el7/x86_64/gpgcheck=0[ceph-noarch]name=cephnoarchbaseurl=http://mirrors.aliyun.com/ceph/rpm-hammer/el7/noarch/gpgcheck=0" &gt; /etc/yum.repos.d/ceph.repoyum install ceph ceph-radosgw -y 这里是安装的hammer版本的Ceph，如果需要安装jewel版本的，请执行： 12sed -i 's/hammer/jewel/' /etc/yum.repos.d/ceph.repoyum install ceph ceph-radosgw -y 如果安装了jewel版本的Ceph，想要换回hammer版本的Ceph，可以执行下面的指令： 卸载Ceph客户端 1rpm -qa |grep `ceph -v |awk '&#123;print $3&#125;'` |xargs rpm -e --nodeps 更改ceph.repo里面的Ceph版本 12sed -i 's/jewel/hammer/' /etc/yum.repos.d/ceph.repoyum install ceph ceph-radosgw -y Q5. ceph-deploy这里我要开启话唠模式： ① Ceph-deploy 是什么？ ​ Ceph-deploy是Ceph官方给出的用于部署Ceph的一个工具，这个工具几乎全部是Python写的脚本，其代码位于/usr/lib/python2.7/site-packages/ceph_deploy目录下(1.5.36版本)。最主要的功能就是用几个简单的指令部署好一个集群，而不是手动部署操碎了心，敲错一个地方就可能失败。所以对于新人来说，或者说以我的经验，接触Ceph少于一个月的，又或者说，集群规模不上PB的，都没有必要手动部署，Ceph-deploy完全足够了。 ② Ceph-deploy怎么装? ​ 这个包在ceph的源里面： 1yum install ceph-deploy -y ③Ceph-deploy装在哪？ ​ 既然Ceph-deploy只是个部署Ceph的脚本工具而已，那么这个工具随便装在哪个节点都可以，并不需要单独为了装这个工具再搞个节点，我一般习惯放在第一个节点，以后好找部署目录。 ④Ceph-deploy怎么用？ ​ 详细的指令暂时不介绍，下面会有，在安装好后，需要在这个节点新建一个目录，用作部署目录，这里是强烈建议建一个单独的目录的，比如我习惯在集群的第一个节点下建一个/root/cluster目录，为了以后好找。Ceph-deploy的所有的指令都需要在这个目录下执行。包括new,mon,osd等等一切ceph-deploy的指令都需要在这个部署目录下执行！最后一遍，所有的ceph-deploy的指令都要在部署目录下执行！否则就会报下面的错： 1[ceph_deploy][ERROR ] ConfigError: Cannot load config: [Errno 2] No such file or directory: 'ceph.conf'; has ceph-deploy new been run in this directory? ⑤ Ceph-deploy怎么部署集群? ​ 我们暂且把部署目录所在的节点叫做部署节点。Ceph-deploy通过SSH到各个节点，然后再在各个节点执行本机的Ceph指令来创建MON或者OSD等。所以在部署之前，你需要从部署节点ssh-copy-id到各个集群节点，使其可以免秘钥登陆。 ⑥Ceph-deploy部署的日志在哪里? ​ 就在部署目录下面的ceph-deploy-ceph.log文件，部署过程中产生的所有的日志都会保存在里面，比如你大半年前敲的创建OSD的指令。在哪个目录下执行ceph-deploy指令，就会在这个目录下生成log，如果你跑到别的目录下执行，就会在执行目录里生成log再记下第四点的错。当然，这个LOG最有用的地方还是里面记录的部署指令，你可以通过cat ceph-deploy-ceph.log |grep &quot;Running command&quot;查看到创建一个集群所需的所有指令，这对你手动建立集群或者创建秘钥等等等等有着很大的帮助！！！ ⑦ Ceph-deploy版本 ​ 写这段时的最新的版本号为1.5.36，下载链接为ceph-deploy-1.5.36-0.noarch.rpm， 之前的1.5.35里面有点bug在这个版本被修复了，如果使用1.5.25部署遇到了问题，可以更新至这个版本，会绕过一些坑。更新到1.5.36之后，腰也不酸了,退了不疼了，Ceph也能部署上了。 Q6. ceph-deploy new 做了什么​ 进入部署目录，执行ceph-deploy new node1 node2 node3，会生成两个文件（第三个是ceph-deploy-ceph.log，忽视之）: 12[root@blog cluster]# lsceph.conf ceph-deploy-ceph.log ceph.mon.keyring ​ new后面跟的是你即将部署MON的节点的hostname，推荐三个就够了，需要是奇数个MON节点。不要因为只有两个节点就搞两个MON，两个节点请用一个MON，因为两个MON挂掉一个，集群也就挂了，和一个MON挂掉一个效果是一样的。生成的ceph.conf默认情况下长成这样： 12345678[root@blog cluster]# cat ceph.conf [global]fsid = 13b5d863-75aa-479d-84ba-9e5edd881ec9mon_initial_members = blogmon_host = 1.2.3.4auth_cluster_required = cephxauth_service_required = cephxauth_client_required = cephx ​ 会调用uuidgen生成一个fsid，用作集群的唯一ID，再将new后面的主机加入到mon_initial_members和mon_host里面，剩下的三行大家都是一样的，默认开启CephX认证。下面有一节会专门介绍这个，需要注意的是，部署的时候，千万不要动这三行 下面会有一节介绍之。还有一个文件ceph.mon.keyring： 1234[root@blog cluster]# cat ceph.mon.keyring [mon.]key = AQB1yWRYAAAAABAAhMoAcadfCdy9VtAaY79+Sw==caps mon = allow * ​ 除了key的内容不一样，剩下的都会是一样的。因为是开启了CephX认证了，所以MON直接的通讯是需要一个秘钥的，key的内容就是秘钥。是不是对Ceph里面的明文认证感到吃惊，有总比没有强。如果，你再次执行new，会生成新的ceph.conf和新的ceph.mon.keyring，并将之前的这两个文件给覆盖掉，新旧文件唯一不同的就是fsid和key的内容，但是对Ceph来说，这就是两个集群了。这里说一下我个人非常非常非常反感的一个问题，有的朋友喜欢在/etc/ceph/目录下面执行ceph-deploy的命令，这么做和在部署目录下面做一般是没有差别的，因为这两个目录下面都有ceph.conf和ceph.client.admin.keyring，但是我还是强烈推荐创建独立的部署目录，因为/etc/ceph目录是Ceph节点的运行目录，为了体现各自的功能性，也为了安全性，请不要在**/etc/ceph**目录下部署集群！！！ Q7. 为ceph-deploy添加参数​ Ceph-deploy的log还是很有看头的，查看ceph-deploy new blog(blog是我的一台主机)的log： 12345678910111213141516171819[root@blog cluster]# ceph-deploy new blog[ceph_deploy.conf][DEBUG ] found configuration file at: /root/.cephdeploy.conf[ceph_deploy.cli][INFO ] Invoked (1.5.36): /usr/bin/ceph-deploy new blog[ceph_deploy.cli][INFO ] ceph-deploy options:[ceph_deploy.cli][INFO ] username : None[ceph_deploy.cli][INFO ] func : &lt;function new at 0x288e2a8&gt;[ceph_deploy.cli][INFO ] verbose : False[ceph_deploy.cli][INFO ] overwrite_conf : False[ceph_deploy.cli][INFO ] quiet : False[ceph_deploy.cli][INFO ] cd_conf : &lt;ceph_deploy.conf.cephdeploy.Conf instance at 0x28eccf8&gt;[ceph_deploy.cli][INFO ] cluster : ceph[ceph_deploy.cli][INFO ] ssh_copykey : True[ceph_deploy.cli][INFO ] mon : ['blog'][ceph_deploy.cli][INFO ] public_network : None[ceph_deploy.cli][INFO ] ceph_conf : None[ceph_deploy.cli][INFO ] cluster_network : None[ceph_deploy.cli][INFO ] default_release : False[ceph_deploy.cli][INFO ] fsid : None[ceph_deploy.new][DEBUG ] Creating new cluster named ceph ​ 可以看到有很多的参数被列出来了，比如：mon : [&#39;blog&#39;]，也有很多参数是False或者None， 这些参数能否被设置呢? 因为这里我们可以看到有fsid : None 这个参数，难道集群的fsid可以被指定吗？抱着这些疑惑，我就去看完了ceph-deploy的所有代码，答案是：可以设置。所有上面的参数都可以使用参数的形式进行设置，只需要在前面加上两个--，比如对于fsid可以执行： 1ceph-deploy new blog --fsid xx-xx-xx-xxxx ​ 如果想要查看每个执行可指定的参数，可以-h： 1234567891011121314[root@blog cluster]# ceph-deploy new -husage: ceph-deploy new [-h] [--no-ssh-copykey] [--fsid FSID] [--cluster-network CLUSTER_NETWORK] [--public-network PUBLIC_NETWORK] MON [MON ...]...optional arguments: -h, --help show this help message and exit --no-ssh-copykey do not attempt to copy SSH keys --fsid FSID provide an alternate FSID for ceph.conf generation --cluster-network CLUSTER_NETWORK specify the (internal) cluster network --public-network PUBLIC_NETWORK specify the public network for a cluster ​ 这里就可以看到可以指定--cluster-network，--public-network，等等，如果optional arguments里面没有介绍这个参数，可以直接使用--xxarg的方式指定，比如--overwrite-conf，--verbose等等，能不能设置这些参数，自己动手试一下就知道了。需要注意的是，参数的位置根据指令而异，比如--overwrite-conf参数是跟在ceph-deploy后面的，而--public-network是跟在new后面的： 123ceph-deploy --overwrite-conf --verbose new blog --fsid a-a-a-a[root@blog cluster]# cat ceph.conf |grep fsidfsid = a-a-a-a Q8. Public VS Cluster​ 如果非要在刚刚生成的ceph.conf里面添加什么的话，那么可能就要加public_network或者cluster_network了。那么这两个配置项有什么用呢？这里简单得介绍下Ceph的Public(外网或者叫公网或者前端网)和Cluster(内网或者叫集群网或者叫后端网)这两个网络，在Ceph中，存在以下三种主要的网络通讯关系： client-&gt; mon =&gt;public : 也就是客户端获取集群状态，或者叫客户端与MON通讯走的网络，是走的外网。 client-&gt; osd =&gt; public : 也就是客户端向OSD直接写入数据走的也是外网。 osd osd =&gt; cluster ：也就是OSD之间的数据克隆，恢复走的是内网，客户端写第一份数据时通过外网写，对于三副本剩下的两个副本OSD之间通过内网完成数据复制。当OSD挂掉之后产生的recover,走的也是内网。 通常，我们会将外网配置为千兆网，而内网配置成万兆网，这是有一定原因的： 客户端可能由成百上千的计算节点组成，外网配成万兆成本太高。 存储节点一般只有几个到几十个节点，配置了万兆内网可以大大加快故障恢复速度，而且剩余的两副本写速度会大大加快，万兆网的性价比极高。举个例子，集群坏掉一个OSD千兆需要一小时，那么万兆网只需要五六分钟，一定程度上增加了集群的安全性。 借用官网的这张图来说明集群的网络走势：再假设你的节点有两个网段172.23.0.1和3.3.4.1，还记得我们上一节ceph-deploy new的时候是可以指定public_network和cluster_network的吗！如果不指定这两个参数，那么ceph-deploy怎么知道用哪个IP作为这个节点的mon_host的IP呢，其实他是随便选的，如果它选了172网段但是你想使用3.3网段作为这个节点的mon_host的IP，那么只需要指定--public-network 172.23.0.0/24 就可以了，其中的/24就相当于一个掩码，表示前面的IP的前24位，也就是172.23.0.XXX，只要你的主机上有一个处于这个范围内的IP，那么就会选择这个IP作为公网IP。类似的，/16表示范围：172.23.XXX.XXX。 如果想指定内网IP，那么只要指定--cluster-network 3.3.4.1/24就可以了。 ​ 一般情况下，会在new生成的ceph.conf文件里加入public_network配置项以指定公网IP。当然你的MON主机上需要有至少一个IP在公网范围内。除了在生成的ceph.conf文件中加入公网IP的方式，我们还可以使用参数的方式来指定公网IP： 12345678910111213141516171819202122[root@ceph-1 cluster]# ceph-deploy new ceph-1 --public-network 172.23.0.0/24[ceph_deploy.cli][INFO ] Invoked (1.5.36): /usr/bin/ceph-deploy new ceph-1 --public-network 172.23.0.0/24[ceph_deploy.cli][INFO ] ceph-deploy options:...[ceph_deploy.cli][INFO ] public_network : 172.23.0.0/24...[ceph-1][DEBUG ] IP addresses found: [u'172.23.0.101', u'10.0.2.15'][ceph_deploy.new][DEBUG ] Resolving host ceph-1[ceph_deploy.new][DEBUG ] Monitor ceph-1 at 172.23.0.101[ceph_deploy.new][DEBUG ] Monitor initial members are ['ceph-1'][ceph_deploy.new][DEBUG ] Monitor addrs are [u'172.23.0.101'][ceph_deploy.new][DEBUG ] Writing monitor keyring to ceph.mon.keyring...[ceph_deploy.new][DEBUG ] Writing initial config to ceph.conf...[root@ceph-1 cluster]# cat ceph.conf [global]fsid = d2a2bccc-b215-4f3e-922b-cf6019068e76public_network = 172.23.0.0/24mon_initial_members = ceph-1mon_host = 172.23.0.101auth_cluster_required = cephxauth_service_required = cephxauth_client_required = cephx ​ 查看部署log可以发现参数配置已经生效，而这个节点有两个IP，public_nwtwork这个参数限定了公网IP的搜索范围，生成的ceph.conf文件内也包含了public_network这个参数。 Q9. 参数是下划线还是空格分隔​ 这里只是简单的提一下这个小困惑，对于以下的两个参数书写方式，哪种会有问题呢： 1234public_network = 172.23.0.1/24public network = 172.23.0.1/24osd_journal_size = 128osd journal size = 128 ​ 这两种参数的书写方式其实都是正确的，说到底是因为底层调用的是Python的argparse模块。这两种方式都是等效的，所以不需要担心。 Q10. ceph-deploy mon create-initial如何一次性通过​ 这一步坑哭了多少迫切加入Ceph世界的新人，看到的最多的就是5s，10s，10s, 15s，20s。。。然后报了错。再执行，再报错。所以这里给出以下的预检清单，如果被报错失败所烦恼，请认真执行各个子项，尤其是失败后要执行清理环境： 请确保所有节点都安装了Ceph。 请确保所有节点的防火墙等都关闭了。参考环境预准备一节 请前往各个MON节点清理干净，不论你是否相信这个节点是干净的。参考清理环境一节。 请确保各个MON节点下存在以下目录，并且对于Jewel版本及之后的请确保目录权限为ceph:ceph。参考部署前最后的确认一节。 请在ceph-deploy new生成的ceph.conf内添加public_network配置项，参考Public VS Cluster一节。 这些总结来之不易，我帮过上百个人解决过部署问题和集群故障。我相信在认真确认过之后是肯定可以通过的(反正前三点如果有问题一般是不会建好MON的，为什么不认真确认下呢)，我遇到过绝大多数都是因为防火墙没关，或者手动删除了一些目录，或者没有修改权限导致的问题。 ​ 相对来说，新环境只要关了防火墙就可以一次性通过，旧环境或者失败的环境只要清理环境就可以通过了。 Q11. mon create-initial 做了什么 简单介绍下流程： ceph-deploy读取配置文件中的 1mon_initial_members 的各个主机，然后依次SSH前往各个主机： 将部署目录下的ceph.conf推送到新节点的/etc/ceph/目录下。 创建/var/lib/ceph/mon/$cluster-$hostname/目录。 检查MON目录下是否有done文件，如果有则直接跳到第6步。 将ceph.mon.keyring拷贝到新节点，并利用该秘钥在MON目录下建立MON数据库。 在MON目录下建立done文件，防止重新建立MON。 启动MON进程。 查看/var/run/ceph/$cluster-mon.$hostname.asokSOCKET文件，这个是由MON进程启动后生成的，输出MON状态。 在所有的MON都建立好后，再次前往各个主机，查看所有主机是否运行并且到达法定人群(quorum)。如果有没到到的，直接结束报错。如果都到达了，执行下一步。 调用 1auth get-or-create 方法创建(如果不存在)或者拉取(已经存在)MON节点上的以下几个keyring到 部署目录 中： ceph.bootstrap-mds.keyring ceph.bootstrap-osd.keyring ceph.bootstrap-rgw.keyring ceph.client.admin.keyring 指令结束。 Q12. mon create-initial 为什么会失败​ 我不喜欢讲怎么做，我愿意花很大的篇幅介绍为什么会造成各种各样的问题，如果知道了原因，你自然知道该怎么做，所以才会理解Ceph，而不是机械的去敲指令。 综合上面的所有小节，我来总结下这一步失败的基本上所有可能的原因： 所谓MON的quorum，相当于多个MON形成的一个群体，它们之间需要通过网络发送数据包来通讯达成某种协议，如果打开了防火墙，会阻断数据交流。所以不能构成群体，一直等待(5s-&gt;10s-&gt;10s-&gt;15s-&gt;20s)其他MON的数据包，既然被阻断了这样的等待是没有意义的，等了30s还没有正常，就可以直接ctrl+z去检查了。 我在配置文件里面添加了pubilc_network，但是有个主机的所有IP都不在公网IP段内，那么这个MON是建不好的，因为没有IP用作MON使用，public_network相当于一个过滤器。 搭好了一台虚拟机后，直接克隆了两台，没有修改主机名，导致socket文件路径名识别错误，报了异常，不过这很少发生。 如果在旧的MON节点上再次部署新的MON，再又没有清理环境，之前的MON数据库会保留着done文件，MON数据库里面还是记录着之前fsid，keyring等等，和新集群是两套完全不同的，所以这个节点的MON自然到达不了MON群体。 即使你单单删除了/var/lib/ceph/mon下的东西，而没有清理那些keyring，也有可能会因为收集了旧集群的秘钥而发生稀奇古怪的问题。 对于Jewel，你一不小心删除了/var/lib/ceph/mon目录，或者其他的OSD目录或者/var/run/ceph目录，然后又重建了目录，依然部署不上，是因为Jewel的所有Ceph指定都是运行在ceph:ceph用户下的，自然不能在root权限目录下建立任何文件，修改权限即可。 Ceph生成MON数据库是依照主机的hostname来命名至目录/var/lib/ceph/mon/${cluster}-${hostname}的，而检测SOCKET文件则是用ceph.conf里面的mon_initial_members里面的名字来检测的 ，如果mon_initial_members里面的名字和真是的主机名不一致，就会报错。 ​ 一旦你运行了ceph-deploy mon create-initial指令，并且失败了，有极大的可能性已经在某些节点建立好了MON的数据库，再次执行可能会因为旧的环境导致再次失败，所以如果失败了，执行一下第二节中的清理环境即可。清理完毕后，再执行ceph-deploy mon create-initial。 Q13. ceph -s 的全称以及报错原因**​ 开开心心过了mon create-initial，这个时候执行ceph -s，如果你恰好在monitor节点执行，那就会显示正常的信息，但是如果你在别的节点执行ceph -s，很有可能会报下面的错，但是有的节点又不会，所以这里花一点篇幅介绍ceph -s到底是怎么工作的。 1234[root@root cluster]# ceph -s2017-01-17 13:47:34.190226 7f446ccde700 -1 auth: unable to find a keyring on /etc/ceph/ceph.client.admin.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin: (2) No such file or directory2017-01-17 13:47:34.190393 7f446ccde700 -1 monclient(hunting): ERROR: missing keyring, cannot use cephx for authentication2017-01-17 13:47:34.190443 7f446ccde700 0 librados: client.admin initialization error (2) No such file or directory ​ 首先，如果你要执行ceph开头的任何指令，你当然要安装好Ceph客户端！（yum install ceph）而ceph -s的全称是： 123456ceph \--name client.admin \--keyring /etc/ceph/ceph.client.admin.keyring \--conf /etc/ceph/ceph.conf--cluster ceph \-s ​ 上面两个参数很好理解，Ceph内部自身使用CephX进行认证，和普通的认证没什么区别，同样需要用户名和密码进行认证，那么这里默认的用户名就叫做client.admin，而默认的秘钥保存位置就位于以下几个位置任一： /etc/ceph/ceph.client.admin.keyring /etc/ceph/ceph.keyring /etc/ceph/keyring /etc/ceph/keyring.bin 一般我们选择第一个，因为秘钥的命名规则采用/etc/ceph/$cluster.$name.keyring也就是集群名加上用户名再加上keyring的后缀组成。所以在我们执行ceph -s的时候，默认使用的是client.admin用户，同时会去那四个默认位置搜索该用户的秘钥，如果和集群保存的认证信息一致，那么就会显示出集群的状态。如果在那四个位置下面无法找到秘钥文件，就会报上面的unable to find a keyring这样的错误，解决方法后面再说。如果这个位置下面的秘钥文件保存了错误的秘钥值，就会报下面的错误： 122017-01-17 15:59:07.625018 7f8757577700 0 librados: client.admin authentication error (1) Operation not permittedError connecting to cluster: PermissionError ​ 翻译过来很简单，就是认证不通过，就好比你使用了错误的密码，去登陆系统不通过一样。这可能是由于这个节点保存了旧的集群的秘钥信息导致的。 ​ 那么正确的秘钥信息保存在哪里呢？还记得部署目录吗，在mon create-initial正确通过后，就会自动收集所有的秘钥，并保存在部署目录下面，眼疾手快的把部署目录的ceph.client.admin.keyring拷贝到/etc/ceph下面就会发现ceph -s正常显示了，不过，这不是授权的正确的姿势。 如果我们想要给一个节点admin权限，也就是执行所有Ceph指令的权限，我们可以前往部署目录，然后调用下面的指令： 1ceph-deploy admin xxNode ​ 这样就会把部署目录下的ceph.client.admin.keyring和ceph.conf拷贝到xxNode的/etc/ceph目录下，并覆盖掉原先的秘钥文件，虽然实际上也就是scp了这两个文件，但是管理Ceph遵循一定的规则是一个很好的习惯。所以，想要得到ceph -s的正确输出，你需要确认在/etc/ceph目录下有ceph.conf和ceph.client.admin.keyring这两个文件，并且和集群认证信息相同即可。如果认证失败，可以前往部署目录授权该节点。 Q14. ceph -s 卡住了简单介绍下ceph -s的流程: 每当你敲下一个Ceph指令时，相当于建立了一个Ceph的客户端进程去连接集群。 连接集群需要知道MON的IP地址，这个地址从/etc/ceph/ceph.conf里面的mon_host读取。 有了IP客户端就拿着自己用户名和秘钥向MON进行认证，认证通过执行指令返回输出。 如果你只有一个MON，然后这个MON挂掉了，那么执行指令会返回： 123[root@blog ceph]# ceph -s2017-01-19 17:49:45.437748 7f02f44e1700 0 -- :/1314350745 &gt;&gt; 139.224.0.251:6789/0 pipe(0x7f02f0063e80 sd=3 :0 s=1 pgs=0 cs=0 l=1 c=0x7f02f005c4f0).fault2017-01-19 17:49:48.442946 7f02f43e0700 0 -- :/1314350745 &gt;&gt; 139.224.0.251:6789/0 pipe(0x7f02e4000c80 sd=3 :0 s=1 pgs=0 cs=0 l=1 c=0x7f02e4001f90).fault Tips: MON的端口号为6789，所以一般看到IP:6789时，就可以判断这个IP的MON可能挂了，或者MON的防火墙开开了。上面的报错还好处理， 前往MON节点，检查ceph-mon进程是否正常运行，正确启动MON进程就可以了。 ​ 如果你有两个MON，挂了一个，指令会返回和上面一样的信息，所以，两个MON只能坏一个，一般MON个数都是奇数个。如果你有三个MON，挂了一个，那么会返回下面信息，集群还是会有输出的： 123456789[root@st001 ~]# ceph -s2017-01-19 17:59:40.753370 7f72ac31c700 0 -- :/4173548806 &gt;&gt; 10.8.0.101:6789/0 pipe(0x7f72a805e9d0 sd=3 :0 s=1 pgs=0 cs=0 l=1 c=0x7f72a805fce0).fault2017-01-19 17:59:49.754198 7f72ac21b700 0 -- 10.8.0.101:0/4173548806 &gt;&gt; 10.8.0.101:6789/0 pipe(0x7f729c000b90 sd=4 :0 s=1 pgs=0 cs=0 l=1 c=0x7f729c0041e0).fault cluster 810eaecb-2b15-4a97-84ad-7340e6cbe969 health HEALTH_WARN 1 mons down, quorum 1,2 st002,st003 monmap e1: 3 mons at &#123;st001=10.8.0.101:6789/0,st002=10.8.0.102:6789/0,st003=10.8.0.103:6789/0&#125; election epoch 18, quorum 1,2 st002,st003... ​ 客户端会去连挂掉的MON，如果过一秒钟左右连不上，就会连接剩下的MON，剩下的还有两个在运行，就连到了运行中的MON，一切输出照旧，就是多了那个连不上的MON报错输出。 ​ 而ceph -s卡住有一种可能是：对于有三个MON的集群，挂掉了两个MON之后 ，手动去/etc/ceph/ceph.conf里面把挂掉的MON的IP给删除了， 只留下一个，这时候ceph -s的指令就会一直卡在那里，查看MON的log可以发现，那个活着的MON一直处于probing状态，这样的MON是不会给客户端返回信息的，所以会卡在那里。有一点需要知道的是，MON的删除比较复杂，不能仅仅通过修改配置文件里面的IP值修改MON，所以，这里正确的做法就是，将删除的IP加回去，然后ceph -s就会报出6789之类的错误，然后再去对应的IP的MON去启动MON服务。 ​ 那么一个集群能坏多少MON呢 ，简单的计算法法就是： ​ (mon个数 -1 )/ 2 取整数位 ​ 也就是说三个能坏一个，两个和一个不能坏，四个坏一个，五个坏两个等等等。当你坏的MON个数大于可以坏的个数，那么所有的指令是不能返回的。 Q15. Monitor clock skew detected​ 如果你部署了多个monitor，比如三个MON，而这三个MON的时间不是严格相同的，那么就会报这个错，而Ceph需要MON节点之间的时间差在0.05秒之内，所以一般会选择配置一个内部的NTP server。剩余节点指向该Server节点。 ​ 千万一定不要小看了时间对其这个问题，如果各个节点时间不对其的话，有可能会导致某些OSD无法启动，而校准后，OSD立马就启动成功了，亦或导致OSD异常挂掉等等一系列的奇怪现象，十分不利于故障排查。 ​ 然而，简单的增加mon_clock_drift_allowed的时间偏移大小，是治标不治本的方法，并且OSD节点的时间偏移并不会报告在ceph -s里面，所以根本的节点方法还是配置NTP，具体方法请参考我之前写的配置NTP一段，这里就不重复了。 Q16. CephX是什么，以及CephX的开启与关闭在默认生成的ceph.conf里面有三行包含CephX的配置： 123auth_cluster_required = cephxauth_service_required = cephxauth_client_required = cephx Ceph提供认证功能，想要连接集群，是需要提供用户名和密码的，这三个配置的值只有两种： cephx: 开启CephX，即需要提供用户名和密码才能连接集群。 none: 关闭CephX，即不需要提供，任何人都可以连接集群。 注意：如果关闭了CephX，那么任何一个客户端只要拥有了MON的IP和集群的fsid，就可以连接到集群中，然后执行所有的Ceph的指令，这是相当危险的，所以对于一个非局域网的集群，是需要开启的。 之所以写这一节，是因为见过好几个在部署集群时就关闭了CephX而遇到了奇怪的现象的情形，他们一般的操作步骤是： ceph-deploy new node1 node2 node3 将生成的ceph.conf中的三个cephx改成了none ceph-deploy mon create-initial 这一步报错如下: 123456789[ceph_deploy.mon][INFO ] mon.blog monitor has reached quorum![ceph_deploy.mon][INFO ] all initial monitors are running and have formed quorum[ceph_deploy.mon][INFO ] Running gatherkeys..........[blog][DEBUG ] fetch remote file[ceph_deploy.gatherkeys][WARNIN] No mon key found in host: blog[ceph_deploy.gatherkeys][ERROR ] Failed to connect to host:blog[ceph_deploy.gatherkeys][INFO ] Destroy temp directory /tmp/tmpyGDe4r[ceph_deploy][ERROR ] RuntimeError: Failed to connect any mon ​ 先介绍下这里报错的原因，在Ceph中，除了需要使用Ceph的普通用户之外，Ceph的基本组件：MON，OSD，MDS再到RGW等都可以看做一个用户，而在使用ceph-deploy部署的时候，会默认为这些用户生成秘钥文件，在ceph-deploy new的时候，除了生成了ceph.conf，还生成了ceph.mon.keyring，顾名思义这个就是为MON用户生成的秘钥文件。查看该文件的内容可以看到如下内容： 123[mon.]key = AQCUXIRYAAAAABAAOi6Cxnvm+zFzd5gi+hrt+A==caps mon = allow * 一个秘钥文件一般由三部分组成： [mon.] ： 也就是用户名，在方括号里面的就是用户名，这里为mon.，注意是有个点号的。 key = AQCUXIRYAAAAABAAOi6Cxnvm+zFzd5gi+hrt+A== : 顾名思义，这就是mon.用户的密码。 caps ： 后面的就是权限，这里可以简单理解成，该用户可以对所有的MON进行所有操作。 也就是说，Ceph中的Monitor也会像一个用户一样，拥有自己的用户名和秘钥以及操作MON的权限。简单理解了CephX之后，我们再来看上面修改了none之后报的错。 ​ 在ceph-deploy mon create-initial执行的时候，它会去读取ceph.conf里面的auth_cluster_required配置，当被修改为none之后， 就不会在创建MON的时候，为其生成对应的keyring，但是有一点要注意的是，尽管没有为MON生成秘钥文件，但是，MON是正确生成的，这时候执行ceph -s是可以得到集群状态的，说明MON已经正确建立。但是在所有的MON建立成功之后，mon create-initial指令内部会执行gatherkeys指令，这个指令会首先去MON的目录下面查找/var/lib/ceph/mon/ceph-$HOSTNAME/keyring文件，由于关闭了CephX，在创建MON的时候不会为其生成该文件，所以gatherkeys指令报错：No mon key found in host: blog。这里只要清理下MON环境然后开启CephX重新部署MON就可以通过了。所以在我们部署集群的时候，强烈建议开启CephX，这样除了可以正确通过mon create-initial，还可以在后续的添加OSD时，为每个OSD生成对应的秘钥。在集群部署完毕后，可以关闭CephX认证，具体方法如下： 修改部署目录内ceph.conf的cephx-&gt;none,将配置推送到所有节点。 重启所有的MON和OSD。如果只重启MON，过一段时间(几个小时)，所有的OSD就会挂掉。。。 在ceph-deploy mon create-initial正确通过之后，我们可以在部署目录下面看到多出了几个文件，都是以keyring结尾： ceph.client.admin.keyring： 这个是超级用户client.admin的秘钥文件，查看其对应的权限，可以发现全部都是allow *，所以有了这个秘钥之后，相当于有了Linux系统的root用户，可以为所欲为了。 ceph.bootstrap-osd.keyring: 类似的还有两个mds和rgw，bootstrap的意思是引导，查看其权限mon = &quot;allow profile bootstrap-osd&quot;，简单解释就是，这个用户可以用于创建OSD(or MDS or RGW)用户。也就是说，后续的OSD的用户的生成是由该用户引导生成的。 最后再说一点，对于秘钥文件，其实我们只需要提供key= xxxxxxxx和用户名[xxx]就好了，不需要提供权限部分，因为权限已经在Ceph集群中保存了，秘钥文件说了不算的。具体权限可以通过ceph auth list来查看。 Q17. –overwrite-conf参数这是个经常会遇到的问题，修改配置文件内的某些参数后，再执行ceph-deploy指令，会报如下的错误： 123[blog][DEBUG ] write cluster configuration to /etc/ceph/&#123;cluster&#125;.conf[ceph_deploy.mon][ERROR ] RuntimeError: config file /etc/ceph/ceph.conf exists with different content; use --overwrite-conf to overwrite[ceph_deploy][ERROR ] GenericError: Failed to create 1 monitors ​ 报错信息提示得很明确，部署目录内的ceph.conf和集群的配置文件/etc/ceph/ceph.conf内容不一致，使用--overwrite-conf参数来覆盖集群的配置文件，也就是用部署目录的ceph.conf覆盖之。使用ceph-deploy --overwrite-conf xxxCMD来达到这一效果，当然，你也可以直接cp覆盖之。但是这不是一个好习惯。 正确的修改集群配置文件的姿势应该是： 修改部署目录下的ceph.conf。 ceph-deploy --overwrite-conf config push NodeA NodeB ... NodeZ将部署目录下的配置文件推送到各个节点。 强烈建议使用上面的方法 有的朋友可能喜欢直接去某个节点下的/etc/ceph/ceph.conf去改配置文件，这样有很多坏处： 过了一周你可能忘了你改过这个节点的配置文件。 这个节点的配置和集群其他节点的配置不一样，会带来一些安全隐患。 如果再来一个不知情的同事，他使用了正确的姿势推送配置文件，你改过的参数很容易被覆盖掉。 所以，从一开始，大家都使用同样的方式去修改集群的配置，是一个很好的习惯，对集群对同事有利无害。 ​ 如果你觉得可以接受这种推送配置的方式，但是又不喜欢每次都敲--overwrite-conf这么长的参数，你可以修改~/.cephdeploy.conf这个文件，增加一行overwrite_conf = true： 12345# ceph-deploy configuration file[ceph-deploy-global]# Overrides for some of ceph-deploy's global flags, like verbosity or cluster# nameoverwrite_conf = true ​ 打开文件你就会发现，这个是ceph-deploy的配置文件，里面的配置项是对ceph-deploy生效的，在加了那一行之后，我们再去执行ceph-deploy的任何指令，都会默认带上了--overwrite-conf参数，这样就可以不打这个参数还能覆盖节点的配置文件。好处是少打了一些参数，坏处是你可能会不知不觉就覆盖了配置文件，各中利弊自行取舍。 ​ ~/.cephdeploy.conf这个文件的用处是很大的，可以为不同的ceph-deploy xxxCMD添加参数，刚刚添加在[ceph-deploy-global]下的参数对全局都会生效，如果你希望只对xxxCMD比如new，osd，mon指定对应的参数，可以添加[ceph-deploy-xxxCMD]域，同时在对应的域下添加对应的参数。 ​ 比如给ceph-deploy osd 添加参数--zap-disk，可以在~/.cephdeploy.conf中添加： 12[ceph-deploy-osd]zap_disk = true Q18. PG卡在creating状态​ 这时候，Monitor已经建好了，可以执行ceph -s的指令了，然而我们看到集群的健康状态却是：health HEALTH_ERR。之所以是ERROR状态，是因为目前还没有建立OSD，PG处于creating状态，在建好了OSD之后，自然会解决这一问题。然而我要说的重点是creating这个状态的几个产生原因。 ​ creating字面意思很好理解，正在创建，那么怎么理解PG正在创建呢？ 用最简单的方式解释PG就是： PG等于目录。如果我们使用磁盘做OSD的话，那么这个OSD上的PG就相当于，在这个磁盘上建立的目录。那么现在的问题就可以简化成，我们尚未添加任何磁盘，那么需要落盘的目录无处可建，所以就会长时间处于creating状态。在添加了一些OSD后，PG就可以建立了。 ​ 还有一种可能的原因是，刚入门的同学在配置文件中加了osd_crush_update_on_start = false 参数，这个参数的具体意义会有专门的小节介绍，这个参数的默认值是true，在使用这个参数后不论创建多少OSD，PG都依旧卡在creating状态。原因是所添加的OSD均不在默认的root=default根节点下。CRUSH在default下无法找到OSD，所以效果就和没有创建OSD一样，再解释就过于深入了，这里只简单介绍下解决方法： 将部署目录里的ceph.conf的osd_crush_update_on_start = false去掉，或者将false改为true。 将配置文件推送到各个节点。 重启所有的OSD。 这样OSD在启动时，就会自动加到对应的主机名下的host下方，并将主机名加到default下方。这样CRUSH就可以找到OSD了。当然，对于新入门的同学，一点建议就是，不知道意义的参数都不用加上，Ceph有自己一套默认参数，而这些参数不用修改就可以正常运行集群。如果添加了某些参数，最好知道其作用再使用。 Q19. osd_crush_update_on_start 参数的使用和注意点​ 这是一个很有趣的参数，使用得当会省去很多事情，使用不当可能会造成灾难(亲身体验)。这个参数在ceph --show-config中并不能查询到，所以这并不是Ceph进程的一个配置项。实际上，这个配置相当于一个启动配置项。也就是说在OSD启动的时候会加载这个参数。由于Jewel将OSD的启动方式做了修改，所以针对Hammer及其之前和Jewel两种启动方式，分别在下面的两个文件使用到了这个参数，实际上，加载的方式还是一样的，只是启动文件有所变化： Hammer 及其之前 : 0.94.9 -&gt; /etc/init.d/ceph -&gt; line 370 -&gt; get_conf update_crush &quot;&quot; &quot;osd crush update on start&quot; Jewel : 10.2.3 -&gt;/usr/lib/ceph/ceph-osd-prestart.sh -&gt; line 23 -&gt; update=&quot;$(ceph-conf --cluster=${cluster:-ceph} --name=osd.$id --lookup osd_crush_update_on_start || :)&quot; 在OSD启动的时候，都会去配置文件中读取osd_crush_update_on_start。然后启动脚本根据是否存在以及配置值来决定是否将该OSD按照一定的方式(CRUSH位置，OSD的ID，OSD的weight)将这个OSD添加到CRUSH中。 ​ 简单点说，如果这个值为false，那么OSD在启动的时候不会去修改你的CRUSH树，也就是说OSD不会自动填加到对应的主机名下再自己添加到root=default下。 ​ 如果这个值为true，或者不添加该配置项(也就是说，默认为true)，OSD在启动时(任何一次启动)都会将自己添加到CRUSH树下。默认的位置为：/usr/bin/ceph-crush-location -&gt; line 86 -&gt; host=$(hostname -s) root=default。]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo双站点部署github和coding]]></title>
    <url>%2F2019%2F05%2F08%2Fhexo%E5%8F%8C%E7%AB%99%E7%82%B9%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[​ 这是搭建博客系列的第二篇，至于为什么要托管到coding上，原因大家也应该能猜到，就是github访问速度偏慢，体验不是很好。 注册coding.net账号并创建项目项目名最好跟用户名一样 设置coding SSH KEY这个就用当时设置github的一样就行了 _config.yml配置12345deploy: type: git repo: github: git@github.com:code-hly/code-hly.github.io.git,master coding: git@git.coding.net:huliaoyuan/huliaoyuan.git,master 替换你的项目名，注意空格，我这儿用的是ssh，而不是https 部署项目到coding上 进入myblog根目录下，先敲如下命令。为了使用hexo d来部署到git上 1$ npm install hexo-deployer-git --save 使用部署命令就能把博客同步到coding上面 1hexo deploy -g pages服务方式部署​ 部署博客方式有两种，第一种就是pages服务的方式，也推荐这种方式，因为可以绑定域名，而第二种演示的方式必须升级会员才能绑定自定义域名。pages方式也很简单就是在source/需要创建一个空白文件，至于原因，是因为coding.net需要这个文件来作为以静态文件部署的标志。就是说看到这个Staticfile就知道按照静态文件来发布。 12cd source/touch Staticfile #名字必须是Staticfile 个人域名绑定 注意github绑定需要在 myblog/source目录下建一 CNAME 文件，并写上你购买的域名，域名我是在阿里万网买的 我当时按照别人的做法写的默认和海外，这样发现只能访问coding上的博客而不能访问 github 上的博客了 coding绑定私有域名 发布博客新文章后直接部署到github和coding1$ hexo g -d]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客教程]]></title>
    <url>%2F2019%2F05%2F08%2Fhexo%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[​ 现在越来越多的人喜欢利用Github搭建静态网站，原因不外乎简单省钱。本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。 准备工作 下载node.js并安装（官网下载安装），默认会安装npm。 下载安装git（官网下载安装） 下载安装hexo。方法：打开cmd 运行*npm install -g hexo*（要翻墙） 本地搭建hexo静态博客 新建一个文件夹，如MyBlog 进入该文件夹内，右击运行git，输入：*hexo init*（生成hexo模板，可能要翻墙） 生成完模板，运行*npm install*（目前貌似不用运行这一步） 最后运行：hexo server （运行程序，访问本地localhost:4000可以看到博客已经搭建成功） 创建一个新仓库​ 新建一个名为你的github用户名.github.io的仓库，比如说，如果你的github用户名是code-hly(这个是我的用户名)，那么你就新建code-hly.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 https://code-hly.github.io 了，是不是很方便 ​ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库，所以访问的地址也是唯一的，方便github服务器管理。 设置仓库的参数​ 相信大多数人都知道，要想使用git命令来和github进行提交部署等操作，需要进行一些配置，大概就是下面一些命令，如不明白请自行搜索. 右键鼠标选择git Base here,输入如下命令： 123git config --global user.email xxx@qq.com git config --global user.name xxx ssh-keygen -t rsa -C xxx@qq.com(邮箱地址) // 生成ssh ​ 注：email和name分别为注册github时的邮箱和用户名，生成ssh时会提示让你选择存储地址，可直接按enter下一步存储为默认地址。 找到.ssh文件夹，找到id_rsa.pub文件打开复制SSH 登陆github，settings-&gt;Deploy keys-&gt;add deploy key（把复制的SSH添加进去即可） 将博客与Github关联 打开本地的MyBlog文件夹项目内的_config.yml配置文件，将其中的type设置为git 1234deploy: type: git repository: git@github.com:code-hly/code-hly.github.io.git branch: master repository为对应仓库的地址。注意仓库地址有两种形式。一种是https，一种是SSH。此处应该使用SSH形式的地址。 运行：npm install hexo-deployer-git –save 运行：hexo g（本地生成静态文件） 运行：hexo d（将本地静态文件推送至Github） 此时，打开浏览器，访问https://code-hly.github.io 可能问题 错误提示：FATAL bad indentation of a mapping entry at line 72, column 7: 可以hexo g 但是不可以hexo d12345错误提示：You should configure deployment settings in _config.yml first!Available deployer plugins: gitFor more help, you can check the online docs: http://hexo.io/ 天真的我，被他俩坑死了。 ​ 问题一：(上图)type: git这里的分号后面没有空格（纳尼，手动黑人问号脸）。所有的配置项目分号（你输入的http:这个分号不用）后面有参数的都要有一个空格 ​ 问题二：(上图)deploy和下面的那几项我从网上复制了一下，（不知为啥我的配置里没生成repo和branch）结果就因为后三个没有缩进，我又白白躺了几个小时 绑定域名 因为Hexo个人博客是托管在github之上，每次访问都要使用githubname.github.io这么一个长串的域名来访问，会显得非常繁琐。这个时候我们可以购买一个域名，设置DNS跳转，以达到通过域名即可访问我们的个人博客，我就是在阿里的万网购买的域名。 域名解析 点击对应域名的”解析” 点击添加解析，记录类型选A或CNAME A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是code-hly.github.io ​ 这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：penglei.com。实践证明如果此时你填写的是www.penglei.top 那么以后你只能用www.penglei.top 访问，而如果你填写的是penglei.top。那么用www.penglei.top 和 penglei.top 访问都是可以的。重新清理hexo,并发布即可用新的域名访问。 运行：hexo g 运行：hexo d 更新博客内容 至此博客已经搭建完毕，域名也已经正常解析，那么剩下的问题就是更新内容了。 更新文章 在MyBlog目录下执行：hexo new “我的第一篇文章”，会在source-&gt;_posts文件夹内生成一个.md文件。 编辑该文件（遵循Markdown规则） 修改起始字段 title 文章的标题 date 创建日期 （文件的创建日期 ） updated 修改日期 （ 文件的修改日期） comments 是否开启评论 true tags 标签 categories 分类 permalink url中的名字（文件名） 编写正文内容（MakeDown） hexo clean 删除本地静态文件（Public目录），可不执行。 hexo g 生成本地静态文件（Public目录） hexo deploy 将本地静态文件推送至github（hexo d） 添加菜单进入theme目录，编辑_config_yml文件，找到menu:字段，在该字段下添加一个字段。 1234menu: home: / about: /about ...... 然后找到lanhuages目录，编辑zh-Hans.yml文件： 1234menu: home: 首页 about: 关于作者 ...... 更新页面显示的中文字符，最后进入theme目录下的Source目录，新增一个about目录，里面写一个index.html文件。 文章内插入图片在文章中写入: 1![](/upload_image/1.jpg) 然后进入themes-主题名-source-upload_image目录下(自己创建)，将图片放到这个目录下，就可以了。 说明：当执行hexo g命令时，会自动把图片复制到 public文件的upload_image目录下。 个性化设置基本信息 在根目录下的_config.yml文件中，可以修改标题，作者等信息。打开编辑该文件，注意：每一个值的冒号后面都有一个半角空格！ 未生效的写法：title:nMask的博客 能生效的写法：title:[空格]nMask的博客 主题访问主题列表，获取主题代码。 进入themes目录，进入以下操作： 下载主题 (以next主题为例) 1git clone https://github.com/iissnan/hexo-theme-next.git（主题的地址） 打开__config.yml文件，将themes修改为next（下载到的主题文件夹的名字） hexo g hexo d 关于hexo-next主题下的一些个性化配置，参考：Next主题配置 主题美化文章中添加居中模块文章Markdown中填写如下： 1&lt;blockquote class="blockquote-center"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 在文章底部增加版权信息 在目录next/layout/_macro/下添加my-copyright.swig： 1234567891011121314151617181920212223242526272829303132&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"&gt;&lt;/script&gt; &lt;script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); clipboard.on('success', $(function()&#123; $(".fa-clipboard").click(function()&#123; swal(&#123; title: "", text: '复制成功', html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import "my-post-copyright" 如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 1234567---title: date: tags: categories: copyright: true--- 自定义hexo new生成md文件的选项在/scaffolds/post.md文件中添加： 12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: copyright: truepermalink: 01top: 0password:--- 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。 123456789101112&lt;!--&lt;div class="powered-by"&gt; &#123;&#123; __('footer.powered', '&lt;a class="theme-link" rel="external nofollow" href="https://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125;&lt;/div&gt;&lt;div class="theme-info"&gt; &#123;&#123; __('footer.theme') &#125;&#125; - &lt;a class="theme-link" rel="external nofollow" href="https://github.com/iissnan/hexo-theme-next"&gt; NexT.&#123;&#123; theme.scheme &#125;&#125; &lt;/a&gt;&lt;/div&gt;--&gt; 文章加密访问打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在meta标签后面插入这样一段代码： 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后文章中添加： 1password: nmask 如果password后面为空，则表示不用密码。 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如: 12345---......copyright: truetop: 100--- 默认不设置则为0，数值相同时按时间排序。 添加顶部加载条打开/themes/next/layout/_partials/head.swig文件，在maximum-scale=1”/&gt;后添加如下代码: 12&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 添加热度next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig在”leancloud-visitors-count”&gt;标签后面添加℃。然后打开，/themes/next/languages/zh-Hans.yml，将visitors内容改为热度即可。 主页文章添加阴影效果打开\themes\next\source\css_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 鼠标点击小红心的设置将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 背景的设置将 particle.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout_layout.swing 文件， 在文件的后面，标签之前 添加以下代码： 12&lt;!-- 背景动画 --&gt;&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css\_custom\custom.styl ，添加如下 css 样式： 12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 博文压缩在站点的根目录下执行以下命令： 12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在博客根目录下新建 gulpfile.js ，并填入以下内容： 123456789101112131415161718192021222324252627282930313233var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js']); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 搜索功能安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 增加阅读排行统计页面首先我们可以使用leancloud来统计页面阅读数量，以及储存这些信息，然后通过leancloud提供的api编写js脚本来获取阅读数量信息，并展示在页面上。首先新建一个page页面，hexo new page “”,然后编辑此.md文件，写下： 1234567891011121314151617181920212223242526&lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"&gt;&lt;/script&gt;&lt;script&gt;AV.initialize("", "");&lt;/script&gt; //需要写上leancloud的key&lt;script type="text/javascript"&gt; var time=0 var title="" var url="" var query = new AV.Query('Counter');//表名 query.notEqualTo('id',0); //id不为0的结果 query.descending('time'); //结果按阅读次数降序排序 query.limit(20); //最终只返回10条结果 query.find().then(function (todo) &#123; for (var i=0;i&lt;10;i++)&#123; var result=todo[i].attributes; time=result.time; //阅读次数 title=result.title; //文章标题 url=result.url; //文章url var content="&lt;p&gt;"+"&lt;font color='#0477ab'&gt;"+"【阅读次数:"+time+"】"+"&lt;a href='"+"http://thief.one"+url+"'&gt;"+title+"&lt;/font&gt;"+"&lt;/a&gt;"+"&lt;/p&gt;"; // document.write("&lt;a href='"+"http://thief.one/"+url+"'&gt;"+title+"&lt;/a&gt;"+" Readtimes:"+time+"&lt;br&gt;"); document.getElementById("heheda").innerHTML+=content &#125; &#125;, function (error) &#123; console.log("error"); &#125;);&lt;/script&gt; 最终的效果查看：http://thief.one/count 多说替换成来必力评论更新于@2017年5月18日多说已经宣布下线了，因此我找了个来必力评论系统来替换，以下是替换的教程，教程内容来自：https://blog.smoker.cc/web/add-comments-livere-for-hexo-theme-next.html 来必力评价优点：界面美观缺点：不支持数据导入，加载慢 首先在 _config.yml 文件中添加如下配置： 1livere_uid: your uid 其中 livere_uid 即注册来必力获取到的 uid。在 layout/_scripts/third-party/comments/ 目录中添加 livere.swig，文件内容如下： 1234567891011121314&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125; &#123;% if theme.livere_uid %&#125; &lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script'); &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; ​ 优先使用其他评论插件，如果其他评论插件没有开启，且LiveRe评论插件配置开启了，则使用LiveRe。其中脚本代码为上一步管理页面中获取到的。在layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include './comments/livere.swig' %&#125; 引入 LiveRe 评论插件。最后，在 layout/_partials/comments.swig 文件中条件最后追加LiveRe插件是否引用的判断逻辑： 123&#123;% elseif theme.livere_uid %&#125; &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere_uid &#125;&#125;"&gt;&lt;/div&gt;&#123;% endif %&#125; 最后打开博客瞧瞧吧！ 多说替换成网易云跟贴最好的方法就是更新next主题，因为最新版本的主题已经支持这几种评论。如果不想更新主题，则往下看： 网易云跟贴评价：性能稳定，功能中规中矩，支持数据导入 首先在 _config.yml 文件中添加如下配置： 1gentie_productKey: #your-gentie-product-key 其中 gentie_productKey 即注册网易云跟贴获取到的key。在 layout/_scripts/third-party/comments/ 目录中添加 gentie.swig，文件内容如下： 12345678910111213141516&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id %&#125; &#123;% if theme.gentie_productKey %&#125; &#123;% set gentie_productKey = theme.gentie_productKey %&#125; &lt;script&gt; var cloudTieConfig = &#123; url: document.location.href, sourceId: "", productKey: "&#123;&#123;gentie_productKey&#125;&#125;", target: "cloud-tie-wrapper" &#125;; &lt;/script&gt; &lt;script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"&gt;&lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 在layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include './comments/gentie.swig' %&#125; 最后，在 layout/_partials/comments.swig 文件中条件最后追加网易云跟帖插件引用的判断逻辑： 123&#123;% elseif theme.gentie_productKey %&#125; &lt;div id="cloud-tie-wrapper" class="cloud-tie-wrapper"&gt; &lt;/div&gt; 报错解决（一）Deployer not found: git当编辑__config.yml文件，将type: git设置完成后，运行hexo g 报错：git not found解决方案：可以在MyBlog目录下运行: npm install hexo-deployer-git –save。 （二）permission denied当执行: hexo deploy 报错时，把__config.yml中的github连接形式从ssh改成http。 （三）当在themes目录下载主题时，报错。将该目录只读属性取消。 （四）genrnate 报错检查_config.yml配置中，键值对冒号后面是否已经预留了一个半角空格。 （五）ERROR Plugin load failed: hexo-generator-feed12npm install hexo-generator-feednpm install hexo-generator-feed --save （六）fatal: The remote end hung up unexpectedly123$ git config https.postBuffer 524288000$ git config http.postBuffer 524288000$ git config ssh.postBuffer 524288000 （七）hero d推送的内容有问题 首先检查下.deploy_git文件夹下的.git文件是否存在，此.git文件指定了hexo d时推送public文件夹，而不是所有的内容。如果此.git文件不存在，则会出现推送内容错误。 用npm install hexo-deployer-git –save生成的.deploy_git不包含.git文件，因此正确的做法是.deploy_git文件夹也需要备份，然后再用npm install hexo-deployer-git –save更新一下其内容即可。 如果已经出现这个错误，则删除.deploy_git，重新hexo d。 （八）hexo s报错在新版本的mac上，安装运行hexo会报此错误，但不影响使用。 1&#123; Error: Cannot find module 解决方案： 1npm install hexo --no-optional Local Search错误 最近发现Local Search搜索出来的连接有错误，到不是说连接不对，而是当我在/aaa/目录下搜索一个页面时，跳转到了/aaa/正确的连接/，这样明显是正确的，应该是跟目录+跳转的目录。 网上搜索了下，没有类似的案例，那么自己动手修改吧，打开node_modules/hexo-generator-searchdb/templates下的xml.ejs文件： 1&lt;url&gt;&lt;%- ("../../../../../../../../"+post.path) %&gt;&lt;/url&gt; 说明：将这个文件的两处url都改成这样就可以了。 异地同步博客内容 现在电脑已经很普及了，因为一般来说我们都是公司一台电脑，家里一台电脑，那么如何将两台电脑上博客的内容同步内，即两台电脑上都可以编辑更新博客？要解决这个问题，首先我们要清楚我们博客文件的组成： node_modules public scaffolds source themes _config_yml db.json package.json .deploy_git 以上为利用hexo生成的博客全部内容，那么当我们执行hexo d时，正真被推送到github上的又有哪些内容呢？ 我们可以看下github上的code-hly.github.io项目，发现里面只有Public目录下的内容。也就是说，我们博客上呈现的内容，其实就是public下的文件内容。那么这个Pulic目录是怎么生成的呢？ 一开始hexo init的时候是没有public目录的，而当我们运行hexo g命令时，public`目录被生成了，换句话说hexo g命令就是用来生成博客文件的（会根据_config.yml，source目录文件以及themes目录下文件生成）。同样当我们运行hexo clean命令时，public目录被删除了。 好了，既然我们知道了决定博客显示内容的只有一个Public目录，而public目录又是可以动态生成的，那么其实我们只要在不同电脑上同步可以生成Public`目录的文件即可。 以下文件以及目录是必须要同步的： source themes _config.yml db.json package.json .deploy_git 同步的方式有很多种，可以每次更新后都备份到一个地址。我采用github去备份，也就是新建一个项目用来存放以上文件，每次更新后推送到github上，用作备份同步。 同步完必须的文件后，怎么再其他电脑上也可以更新博客呢？ 前提假设我们现在配置了一台新电脑，里面没有安装任何有关博客的东西，那么我们开始吧： 下载node.js并安装（官网下载安装），默认会安装npm。 下载安装git（官网下载安装） 下载安装hexo。方法：打开cmd 运行npm install -g hexo（要翻墙） 新建一个文件夹，如MyBlog 进入该文件夹内，右击运行git，输入：hexo init（生成hexo模板，可能要翻墙) 我们重复了一开始搭建博客的步骤，重新生成了一个新的模板，这个模板中包含了hexo生成的一些文件。 git clone 我们备份的项目，生成一个文件夹，如：MyBlogData 将MyBlog里面的node_modules、scaffolds文件夹复制到MyBlogData里面。 做完这些，从表面上看，两台电脑上MyBlogData目录下的文件应该都是一样的了。那么我们运行hexo ghexo d试试，如果会报错，则往下看。 这是因为.deploy_git没有同步，在MyBlogData目录内运行:npm install hexo-deployer-git –save后再次推送即可 总结流程：当我们每次更新MyBlog内容后，先利用hexo将public推送到github，然后再将其余必须同步的文件利用git推送到github。 SEO优化seo优化对于网站是否能被搜索引擎快速收录有很大帮助，因此适当做一些seo还是有必要的，以下内容参考：https://lancelot_lewis.coding.me/2016/08/16/blog/Hexo-NexT-SEO/ 添加sitemap文件安装以下2个插件，然后重启hexo后，网站根目录（source）下会生成sitemap.xml与baidusitemap.xml文件，搜索引擎在爬取时会参照文件中的url去收录。 1234npm install hexo-generator-sitemap --save-devhexo d -gnpm install hexo-generator-baidu-sitemap --save-devhexo d -g 添加robots.txt新建robots.txt文件，添加以下文件内容，把robots.txt放在hexo站点的source文件下。 1234567891011User-agent: * Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://thief.one/sitemap.xmlSitemap: http://thief.one/baidusitemap.xml 首页title的优化更改index.swig文件，文件路径是your-hexo-site\themes\next\layout，将下面代码 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改成 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock 观察首页title就是标题+描述了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo腾讯云COS部署+Markdown图床]]></title>
    <url>%2F2019%2F05%2F08%2Fhexo%E8%85%BE%E8%AE%AF%E4%BA%91cos%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[静态博客网站的需求就是一片足够大的空间，而腾讯云COS提供免费50G的存储空间，无疑是一个不错的选择。 同时也可以用腾讯云cos制作Markdown的图床，这样网站访问速度会比较快 hexo部署腾讯云cos域名​ 域名注册与备案 注意：腾讯云cos绑定cdn域名加速时需要备案域名，而域名的备案需要购买腾讯云的服务器。这点比较坑！ 根据个人情况选择，也可以选择上篇博文，采用hexo双站点部署 创建存储桶(Bucket) 创建存储桶 COS地址 填写名称后，选择权限为公有读私有写。 配置存储桶 选择基础配置 编辑静态网站 打开设置 绑定域名 域名管理，添加域名，选择静态网站源站 域名解析，添加记录 第一个框为二级域名，第二个框为记录值。 上传文件测试 在test存储桶上传CNAME文件和index.html进行测试。 CANME文件的内容为（域名换成自己的域名）： 1test.fiftykg.com index.html的内容为： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;测试主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;测试主页内容&lt;/body&gt;&lt;/html&gt; 在浏览器中查看结果： 刷新CDN缓存 上图的效果是不能立刻看到的，大部分时候需要等待。 有可能你会看到以下的效果： 首先请确认你的网站类型为静态网站源站。如果设置正确，那么可能需要手动刷新以下cdn的缓存： hexo部署安装cos部署插件： npm install hexo-deployer-cos --save 在根目录的_config.yml配置： region等参数可以在下图位置查看： 秘钥可以在访问管理中云API秘密钥中找到。 Markdown图床创建存储桶(Bucket) 创建存储桶 COS地址 填写名称后，选择权限为公有读写。 PicGo 客户端配置下载&amp;安装​ PicGo （目前 2.0.4）是一个开源的图床工具，非常优秀。可以到 git 上下载，但下载速度太慢，所以我放了一个百度云的链接，速度快很多。 git的地址：https://github.com/Molunerfinn/PicGo Win版下载链接：https://pan.baidu.com/s/1sr7DKuP7p0WQ1WNBK3Zkow 提取码：d4cx 配置 存储空间名：所存储图片的桶名称 存储路径：选择的地区，例如：ap-guangzhou]]></content>
      <categories>
        <category>Hexo</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ceph存储引擎之FileStore]]></title>
    <url>%2F2019%2F05%2F07%2Fceph-FileStore%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[​ Ceph作为一个高可用和强一致性的软件定义存储实现，去使用它非常重要的就是了解其内部的IO路径和存储实现。这篇文章主要介绍在IO路径中最底层的ObjectStore的实现之一FileStore。 ObjectStore​ ObjectStore是Ceph OSD中最重要的概念之一，它封装了所有对底层存储的IO操作。从上图中可以看到所有IO请求在Clieng端发出，在Message层统一解析后会被OSD层分发到各个PG，每个PG都拥有一个队列，一个线程池会对每个队列进行处理。 ​ 当一个在PG队列里的IO被提出后，该IO请求会被根据类型和相关附带参数进行处理。如果是读请求会通过ObjectStore提供的API获得相应的内容，如果是写请求也会利用ObjectStore提供的事务API将所有写操作组合成一个原子事务提交给ObjectStore。ObjectStore通过接口对上层提供不同的隔离级别，目前PG层只采用了Serializable级别,保证读写的顺序性。 ​ ObjectStore主要接口分为三部分，第一部分是Object的读写操作，类似于POSIX的部分接口，第二部分是Object的属性(xattr)读写操作，这类操作的特征是kv对并且与某一个Object关联。第三部分是关联Object的kv操作(在Ceph中称为omap)，这个其实与第二部分非常类似，但是在实现上可能会有所变化。 ​ 目前ObjectStore的主要实现是FileStore，也就是利用文件系统的POSIX接口实现ObjectStore API。每个Object在FileStore层会被看成是一个文件，Object的属性(xattr)会利用文件的xattr属性存取，因为有些文件系统(如Ext4)对xattr的长度有限制，因此超出长度的Metadata会被存储在DBObjectMap里。而Object的omap则直接利用DBObjectMap实现。因此，可以看出xattr和omap操作是互通的，在用户角度来说，前者可以看作是受限的长度，后者更宽泛(API没有对这些做出硬性要求)。 FileJournal 为了缩小写事务的处理时间，提高写事务的处理能力并且实现事务的原子性，FileStore引入了FileJournal，所有写事务在被FileJournal处理以后都会立即返回(上图中的第二步)。FileJournal类似于数据库的writeahead日志，使用O_DIRECT和O_DSYNC每次同步写入到journal文件，完成后该事务会被塞到FileStore的op queue。事务通常有若干个写操作组成，当在中间过程进程crash时，journal会OSD recover提供了完备的输入。FileStore会存在多个thread从op queue里获取op，然后真正apply到文件系统上对应的Object(Buffer IO)。当FileStore将事务落到disk上之后，后续的该Object的读请求才会继续(上图中的第五步)。当FileStore完成一个op后，对应的Journal可以丢弃这部分日志。 ​ 实际上并不是所有的文件系统都按照这个顺序，一般来说如Ceph推荐的Ext4和XFS文件系统会先写入Journal，然后再写入Filesystem，而COW(Copy on Write)文件系统如Btrfs和ZFS会同时写入Journal和FileSystem。 DBObjectMap ​ DBObjectMap是FileStore的一部分，利用KeyValue数据库实现了ObjectStore的第三部分API，DBObjectMap主要复杂在其实现了clone操作的no-copy。因为ObjectStore提供了clone API，提供对一个Object的完全clone(包括Object的属性和omap)。DBObjectMap对每一个Object有一个Header，每个Object联系的omap(kv pairs)对会与该Header联系，当clone时，会产生两个新的Header，原来的Header作为这两个新Header的parent，这时候无论是原来的Object还是cloned Object在查询或者写操作时都会查询parent的情况，并且实现copy-on-write。那么Header如何与omap(kv pairs)联系呢，首先每个Header有一个唯一的seq，然后所有属于该Header的omap的key里面都会包含该seq，因此，利用KeyValueDB的提供的有序prefix检索来实现对omap的遍历。 ​ 上面提到FileStore会将每个Object作为一个文件，那么Object的一些属性会与Object Name一起作为文件名，Object 所属的PG会作为文件目录，当一个PG内所包含的文件超过一定程度时(在目录内文件太多会造成文件系统的lookup性能损耗)，PG会被分裂成两个PG。]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ceph存储引擎之bluestore]]></title>
    <url>%2F2019%2F05%2F07%2Fceph-bluestore%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[​ ceph后端支持多种存储引擎，以插件式的方式来进行管理使用，目前支持filestore，kvstore，memstore以及最新的bluestore，本文介绍的是bluestore的存储方法。 ​ 目前ceph10版本默认使用的filestore，但是因为filestore在写数据前需要先写journal，会有一倍的写放大，并且filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑，因此诞生的bluestore初衷就是为了减少写放大，并针对ssd做优化，而且直接管理裸盘，从理论上进一步减少文件系统如ext4/xfs等部分的开销，目前bluestore还处于开发优化阶段，在jewel版本还是试用版本，并且最新的master相比jewel已经做了大的重构，预期会在后续的大版本中稳定下来成为默认的存储引擎。本文基于master分支对bluestore存储引擎进行分析。 bluestore整体架构 ​ bluestore直接管理裸设备，抛弃了ext4/xfs等本地文件系统，BlockDevice实现在用户态下使用linux aio直接对裸设备进行I/O操作。既然是直接管理裸设备就必然需要进行裸设备的空间管理，对应的就是Allocator，目前支持StupidAllocator和BitmapAllocator两种分配器。 ​ 相关的元数据以kv的形式保存到kv数据库里，默认使用的是rocksdb，由于rocksdb本身是基于文件系统的，不是直接操作裸设备，但是rocksdb也比较灵活，将系统相关的处理抽象成Env，用户可用实现相应的接口，rocksdb默认的Env是PosixEnv，直接对接本地文件系统，为此，bluestore实现了一个BlueRocksEnv，继承自EnvWrapper，来为rocksdb提供底层系统的封装，为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口，在系统启动mount这个文件系统的时候将所有的元数据都加载到内存中，BluesFS的数据和日志文件都通过BlockDevice保存到裸设备上，BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备。 核心模块​ RocksDB： 存储预写式日志、数据对象元数据、Ceph的omap数据信息、以及分配器的元数据（分配器负责决定真正的数据应在什么地方存储）​ BlueRocksEnv： 与RocksDB交互的接口​ BlueFS： 小的文件系统，解决元数据、文件空间及磁盘空间的分配和管理，并实现了rocksdb::Env 接口(存储RocksDB日志和sst文件)。因为rocksdb常规来说是运行在文件系统的顶层，下面是BlueFS。 它是数据存储后端层，RocksDB的数据和BlueStore中的真正数据被存储在同一个块物理设备​ HDD/SSD： 物理块设备，存储实际的数据 ​ rocksdb本身是基于文件系统的，不是直接操作裸设备。它将系统相关的处理抽象成Env，用户可用实现相应的接口（rocksdb默认的Env是PosixEnv，直接对接本地文件系统）。BlueRocksEnv是bluestore实现的一个类，继承自rocksdb::EnvWrapper，来为rocksdb提供底层系统的封装。 ​ 为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口。所有的元数据的修改都记录在BlueFS的日志中，也就是对于BlueFS，元数据的持久化保存在日志中。在系统启动mount这个文件系统时，只需replay日志，就可将所有的元数据都加载到内存中。BluesFS的数据和日志文件都通过块设备保存到裸设备上（BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备）。 ​ bluestore不使用本地文件系统，直接接管裸设备，并且只使用一个原始分区，HDD/SSD所在的物理块设备实现在用户态下使用linux aio直接对裸设备进行I/O操作。由于操作系统支持的aio操作只支持directIO，所以对BlockDevice的写操作直接写入磁盘，并且需要按照page对齐。其内部有一个aio_thread 线程，用来检查aio是否完成。其完成后，通过回调函数aio_callback 通知调用方。 wal &amp; dbBlueFs将整个BlueStore的存储空间分为三个层次 ： 慢速(Slow)空间 主要用于存储对象数据，可由普通大容量机械盘提供，由BlueStore自行管理 高速(DB)空间 存储BlueStore内部产生的元数据，可由普通SSD提供，需求小于（慢速空间）。 超高速(WAL)空间 主要存储RocksDB内部产生的.log文件，可由ＳＳＤ或者ＮＶＲＡＭ等时延相较普通ＳＳＤ更小的设备充当。容量需求和（高速空间）相当，同样由ＢｌｕｅＦｓ直接管理。 wal &amp; db 的大小问题​ 在 ceph bluestore 的情况下，wal 是 RocksDB 的 write-ahead log, 相当于之前的 journal 数据，db 是 RocksDB 的 metadata 信息。在磁盘选择原则是 block.wal &gt; block.db &gt; block。当然所有的数据也可以放到同一块盘上。 ​ 默认情况下， wal 和 db 的大小分别是 512 MB 和 1GB, 现在没有一个好的理论值，好像和 ceph 本身承载的数据类型有关系。 ​ 值得注意的是，如果所有的数据都在单块盘上，那是没有必要指定 wal &amp; db 的大小的。如果 wal &amp; db 是在不同的盘上，由于 wal/db 一般都会分的比较小，是有满的可能性的。如果满了，这些数据会迁移到下一个快的盘上(wal - db - main)。所以最少不会因为数据满了，而造成无法写入。 bluestore元数据 ​ 在之前的存储引擎filestore里，对象的表现形式是对应到文件系统里的文件，默认4MB大小的文件，但是在bluestore里，已经没有传统的文件系统，而是自己管理裸盘，因此需要有元数据来管理对象，对应的就是Onode，Onode是常驻内存的数据结构，持久化的时候会以kv的形式存到rocksdb里。 ​ 在onode里又分为lextent，表示逻辑的数据块，用一个map来记录，一个onode里会存在多个lextent，lextent通过blob的id对应到blob（bluestore_blob_t ），blob里通过pextent对应到实际物理盘上的区域（pextent里就是offset和length来定位物理盘的位置区域）。一个onode里的多个lextent可能在同一个blob里，而一个blob也可能对应到多个pextent。 ​ 另外还有Bnode这个元数据，它是用来表示多个object可能共享extent，目前在做了快照后写I/O触发的cow进行clone的时候会用到。 I/O读写映射逻辑写I/O处理​ 到达bluestore的I/O的offset和length都是对象内（onode）的，offset是相对于这个对象起始位置的偏移，在_do_write里首先就会根据最小分配单位min_alloc_size进行判断，从而将I/O分为对齐和非对齐的。如下图所示： ​ 当一个写请求按照min_alloc_size进行拆分后，就会分为对齐写，对应到do_write_big，非对齐写（即落到某一个min_alloc_size区间的写I/O（对应到do_write_small）。 do_write_big​ 对齐到min_alloc_size的写请求处理起来比较简单，有可能是多个min_alloc_size的大小，在处理时会根据实际大小新生成lextent和blob，这个lextent跨越的区域是min_alloc_size的整数倍，如果这段区间是之前写过的，会将之前的lextent记录下来便于后续的空间回收。 do_write_small​ 在处理落到某个min_alloc_size区间的写请求时，会首先根据offset去查找有没有可以复用的blob，因为最小分配单元是min_alloc_size，默认64KB，如果一个4KB的写I/O就只会用到blob的一部分，blob里剩余的还能放其他的。 1）没有找到可以复用的blob，新生成blob ​ 在处理还还需要根据offset和len是否对齐到block_size（默认是4KB）进行补零对齐的操作，之所以需要补齐是与后续的写盘操作有关，真正写盘时有两种方式，一种是Direct I/O的方式，这种要求偏移和缓冲区都对齐的，另外一种非Direct I/O，即Buffered I/O，这种可以不对齐，但是是写到cache里，然后再sync刷到磁盘上，比如只写了100字节，在内核里是需要先从设备上读出来补齐成一个完整的扇区，然后再刷的，这样反而降低了效率。因此在bluestore里直接处理好对齐，对于后面的写盘来说比较有利，这里对齐到block_size，是个可配置的参数。 ​ 进行对齐补零时就是按照如上图那样把前后对齐到block_size，然后再把对齐后的offset和len作为lextent，进而放到blob里。 2）找到可以复用的blob​ 对于可以复用的blob，也是先按照block_size进行对齐补零的动作，然后再判断是否可以直接使用blob里空闲的空间进行区分做不同的处理。 a）直接写在blob未使用的空间上​ 这种情况下直接新生成lextent放到blob里。 b）覆盖写的情况​ 比如下面的这种情况，写I/O会覆盖部分已经写过的数据。 ​ 对于这种情况的处理如下图：也是需要先处理对齐补零的情况，如果覆盖的区域刚好是已经对齐到block_size，那么就不需要从磁盘读数据，但是如果覆盖的区域没有对齐到block_size，那么就需要把不对齐的那部分读出来，拼成一个对齐的buffer，然后新生成lextent，并且会对原来那个lextent进行调整，会记录需要回收的那部分区域。对于覆盖写的情况，都不是直接写盘，而是通过wal写到rocksdb。 整体写I/O的逻辑​ 之前组内同事画过一个流程图，这里借用一下算是一个简单的总结。 读I/O的处理 ​ 读I/O请求的处理时也是通过寻找相关联的lextent，可能会存在空洞的情况，即读到未写过的数据，这部分就直接补零。 clone及extent共享前面说到Bnode就是用来记录共享的lextent，目前是在做完快照后对原卷进行写I/O会触发cow，从而产生clone操作。clone时就是将原对象的blob从onode-&gt;blob_map移到onode-&gt;bnode-&gt;blob_map，并且将blob id置为负的，并设置共享标记，然后将新的快照对象的onode-&gt;bnode指向原对象的onode-&gt;bnode，并且用原onode里的lextents里的值赋给新的onode的lextents，从而达到共享extent的目的，图示仅供参考。 ​ 在clone完之后，继续对原对象进行写I/O操作时，当碰到共享的blob时就需要跳过，新生成blob，并且取消对原来那部分lextent的引用，在后续的空间释放时的判断依据就是否还有引用。 小结​ 从BlueStore 的设计和实现上看，可以将其理解为用户态下的一个文件系统，同时使用RocksDB来实现BlueStore所有元数据的管理，简化实现。 ​ 对于整块数据的写入，数据直接以aio的方式写入磁盘，再更新RocksDB中数据对象的元数据，避免了filestore的先写日志，后apply到实际磁盘的两次写盘。同时避免了日志元数据的冗余存储占用，因为传统文件系统有他们自己内部的日志和元数据管理机制。 ​ 对于随机IO，直接WAL的形式，写入RocksDB 高性能的KV存储中。 ​ 本文总体上介绍了bluestore的架构、相关元数据及内部I/O映射的逻辑，这还只是bluestore的冰山一角，后续会陆续对bluestore的处理流程、空间分配器、缓存管理、压缩等实现进行分析。]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ceph-deploy部署ceph12集群]]></title>
    <url>%2F2019%2F05%2F07%2Fceph-12%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[1. 环境1.1 硬件4台 Linux虚拟机： server0, server1, server2, server3 每台有两块磁盘 ： /dev/vdb, /dev/vdc 每台有两块网卡 ：eth0, ens9 1.2 软件linux版本： CentOS 7.2.1511 内核版本 ： 3.10.0-327.el7.x86_64 ceph版本： 12.2.12 ceph-deploy版本： 2.0.0 2. 准备工作(所有server)2.1 配置静态IP每台server有两个interface, 分别配置在如下两个网段： 192.168.122.0/24 192.168.100.0/24 具体如下表： Server Interface IPADDR server0 eth0 192.168.122.160 server0 ens9 192.168.100.160 server1 eth0 192.168.122.161 server1 ens9 192.168.100.161 server2 eth0 192.168.122.162 server2 ens9 192.168.100.162 server3 eth0 192.168.122.163 server3 ens9 192.168.100.163 2.2 生成ssh key1# ssh-keygen 2.3 配置主机名解析把如下内容追加到/etc/hosts: 1234192.168.100.160 server0192.168.100.161 server1192.168.100.162 server2192.168.100.163 server3 2.4 配置ntp1234# yum install -y ntp ntpdate ntp-doc# vim /etc/ntp.conf （一般不需要修改）# systemctl start ntpd.service# systemctl enable ntpd.service 2.5 关闭防火墙12# systemctl stop firewalld# systemctl disable firewalld 2.6 安装yum源epel为了方便yum安装一些常用的软件包： 1# yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm 3. 安装ceph软件包3.1 添加yum源(所有server)在所有server上添加ceph.repo，内容如下： 123456789101112131415161718192021222324# cat /etc/yum.repos.d/ceph.repo [Ceph]name=Ceph packages for $basearchbaseurl=http://mirrors.163.com/ceph/rpm-luminous/el7/$basearchenabled=1priority=1gpgcheck=1gpgkey=https://download.ceph.com/keys/release.asc[Ceph-noarch]name=Ceph noarch packagesbaseurl=http://mirrors.163.com/ceph/rpm-luminous/el7/noarchenabled=1priority=1gpgcheck=1gpgkey=https://download.ceph.com/keys/release.asc[ceph-source]name=Ceph source packagesbaseurl=http://mirrors.163.com/ceph/rpm-luminous/el7/SRPMSenabled=0priority=1gpgcheck=1gpgkey=https://download.ceph.com/keys/release.asc [Ceph]： ceph软件包的yum源，所有server都需要添加。[Ceph-noarch]：ceph-deploy的yum源。admin server (见3.2节) 需要安装ceph-deploy，所以它需要这个yum源。admin server控制其他server的时候，也需要被控server添加这个yum源。最终，所有server都需要添加。[ceph-source]： admin server控制其他server的时候，也需要被控server添加这个yum源。所以，所有server都需要添加。 3.2 选择admin server选择server0作为admin server。官网上建议admin server使用一个单独的user来进行ceph-deploy操作，这里避免麻烦，还用root账户。 admin server需要免密登录所有server（包括自己），所以在admin server上配置免密登录（其他server不必配置）： 1234# ssh-copy-id root@server0# ssh-copy-id root@server1# ssh-copy-id root@server2# ssh-copy-id root@server3 测试一下： 12345# for i in &#123;0..3&#125; ; do ssh server$i hostname ; done server0server1server2server3 3.3 安装ceph-deploy(在admin server上)在3.1节已经添加了ceph-deploy的yum源，这里直接通过yum安装： 1# yum -y install ceph-deploy 然后测试一下，发现报错： 1234567# ceph-deploy --versionTraceback (most recent call last): File &quot;/usr/bin/ceph-deploy&quot;, line 18, in &lt;module&gt; from ceph_deploy.cli import main File &quot;/usr/lib/python2.7/site-packages/ceph_deploy/cli.py&quot;, line 1, in &lt;module&gt; import pkg_resourcesImportError: No module named pkg_resources 原因是缺python-setuptools，安装它即可： 1234# yum install python-setuptools# ceph-deploy --version2.0.0 3.4 安装ceph包(在admin server上执行)这一步的目标是：admin server通过远程控制在所有server上安装ceph包。它需要在所有server上添加yum源：[Ceph], [Ceph-noarch]和[ceph-source]，见3.1节。 另外注意：在所有server上安装deltarpm (yum install -y deltarpm)， 否则会报如下错误： 12345[server0][DEBUG ] Delta RPMs disabled because /usr/bin/applydeltarpm not installed.[server0][WARNIN] No data was received after 300 seconds, disconnecting...[server0][INFO ] Running command: ceph --version[server0][ERROR ] Traceback (most recent call last):[server0][ERROR ] File &quot;/usr/lib/python2.7/site-packages/ceph_deploy 下面就是安装了： 1# ceph-deploy install --release=luminous server0 server1 server2 server3 成功之后，每台server都安装了ceph包，在任意sever上检查： 123456789101112131415161718# ceph -vceph version 12.2.5 (cad919881333ac92274171586c827e01f554a70a) luminous (stable)# ceph -vceph version 12.2.5 (cad919881333ac92274171586c827e01f554a70a) luminous (stable)[root@server1 ~]# rpm -qa | grep cephceph-common-12.2.5-0.el7.x86_64ceph-mds-12.2.5-0.el7.x86_64ceph-12.2.5-0.el7.x86_64ceph-release-1-1.el7.noarchlibcephfs2-12.2.5-0.el7.x86_64python-cephfs-12.2.5-0.el7.x86_64ceph-base-12.2.5-0.el7.x86_64ceph-mon-12.2.5-0.el7.x86_64ceph-osd-12.2.5-0.el7.x86_64ceph-mgr-12.2.5-0.el7.x86_64ceph-radosgw-12.2.5-0.el7.x86_64ceph-selinux-12.2.5-0.el7.x86_64 4. 部署ceph集群（在admin server上执行）为了演示，我们 创建一个集群：1 mon + 1 mgr。这个是initial monitor。 添加 osd 添加 2 mon + 2 mgr 创建一个mds 实际上，我们完全可以在第1步中直接创建 3 mon + 3 mgr的集群 (3个都是initial monitor)，然后添加osd就行了。这里分作1和3两步，是为了演示添加mon和mgr。 另外，ceph-deploy在部署集群的过程中，会产生一些文件(log，keyring，ceph.conf等)，所以，我们在一个新目录下执行： 12# mkdir test-ceph-deploy# cd test-ceph-deploy/ 若部署出现错误，需要重头开始： 1234ceph-deploy purge server0 server1 server2 server3ceph-deploy purgedata server0 server1 server2 server3ceph-deploy forgetkeysrm ceph.* 4.1 创建集群：1 mon + 1 mgrA. 以server2为initial monitor创建集群 1# ceph-deploy new server2 这里指定server2作为initial monitor。这一步完成之后，在当前目录下会产生如下文件： 123ceph.conf ceph.mon.keyring ceph-deploy-ceph.log ceph.conf是ceph的配置文件。它将会被分发到所有server的/etc/ceph/目录下。在后续的ceph运维中，若需要做某些配置，可以在所有server上修改/etc/ceph/ceph.conf。 12345678# cat ceph.conf [global]fsid = 744f59b7-c403-48e6-a1c6-2c74901a4d0bmon_initial_members = server2mon_host = 192.168.100.162auth_cluster_required = cephxauth_service_required = cephxauth_client_required = cephx ceph.mon.keyring是monitor的keyring，它定义了monitor的key，以及monitor有什么权限： 1234# cat ceph.mon.keyring [mon.]key = AQDf7O9aAAAAABAAX4qmBiNsPhvK43wnpNCtLA==caps mon = allow * B. 配置ceph网络 ceph集群使用两个网络：public network和cluster network。前者用于服务client；后者用于集群内部通信，例如osd之间迁移数据。另外，两个网络上都有heartbeat。 注意：若只有一个网络，也可以部署ceph。这个网络同时担任public network和cluster network。这种情况下，跳过本小节。 我们有两个网络（见第2.1节），所以在ceph.conf中，增加如下两行： 1234# vim ceph.conf......public network = 192.168.100.0/24cluster network = 192.168.122.0/24 注意以下两点： 在2.3节，我们配置主机名解析的时候，把主机名解析为public network的地址。这是因为，ceph-deploy是作为client (见下文D小节：client.admin, client.bootstrap-mds,client.bootstrap-mgr,client.bootstrap-osd,client.bootstrap-rgw)来操作集群的，ceph集群通过public network服务于client。 monitor是运行于public network上的。这也很容易理解，ceph的client都需要访问monitor，若monitor运行于cluster network上，client无法访问。 C. 部署initial monitor 1# ceph-deploy mon create server2 这时候，server2上，monitor已经运行起来了。可以到server2上检查。 12[root@server2 ~]# ps -ef | grep cephceph 18240 1 1 14:24 ? 00:00:00 /usr/bin/ceph-mon -f --cluster ceph --id server2 --setuser ceph --setgroup ceph 如前文B小节所述，monitor运行于public network之上： 12[root@server2 ~]# netstat -anpl | grep 6789 | grep LISTENtcp 0 0 192.168.100.162:6789 0.0.0.0:* LISTEN 18240/ceph-mon D. 创建ceph keyring 经过前一步，server2上的monitor已经运行起来了。但这时候ceph -s失败，因为ceph -s是admin的命令，我们还没有admin的权限信息呢。 1234# ceph -c ceph.conf -s 2018-05-07 14:25:46.127163 7f76e1834700 -1 auth: unable to find a keyring on /etc/ceph/ceph.client.admin.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin,: (2) No such file or directory2018-05-07 14:25:46.127199 7f76e1834700 -1 monclient: ERROR: missing keyring, cannot use cephx for authentication2018-05-07 14:25:46.127201 7f76e1834700 0 librados: client.admin initialization error (2) No such file or directory 下面使用gatherkeys来创建各个角色（包括admin）的权限信息。gatherkeys 依次对角色 admin, bootstrap-mds, bootstrap-mgr, bootstrap-osd, bootstrap-rgw作如下操作（问题：为什么没有bootstrap-rbd？）： 使用 ceph auth get 来获取角色的key和权限； 若不存在，则使用auth get-or-create {角色} {权限}来创建角色的key和权限； 把角色的key保存到 {角色}.keyring文件； 123456789101112131415161718192021# ceph-deploy gatherkeys server2[ceph_deploy.conf][DEBUG ] found configuration file at: /root/.cephdeploy.conf[ceph_deploy.cli][INFO ] Invoked (2.0.0): /usr/bin/ceph-deploy gatherkeys server2......[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.admin[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.admin osd allow * mds allow * mon allow * mgr allow *[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.bootstrap-mds[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.bootstrap-mds mon allow profile bootstrap-mds[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.bootstrap-mgr[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.bootstrap-mgr mon allow profile bootstrap-mgr[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.bootstrap-osd[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.bootstrap-osd mon allow profile bootstrap-osd[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.bootstrap-rgw[server2][INFO ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.bootstrap-rgw mon allow profile bootstrap-rgw[ceph_deploy.gatherkeys][INFO ] Storing ceph.client.admin.keyring[ceph_deploy.gatherkeys][INFO ] Storing ceph.bootstrap-mds.keyring[ceph_deploy.gatherkeys][INFO ] Storing ceph.bootstrap-mgr.keyring[ceph_deploy.gatherkeys][INFO ] keyring &apos;ceph.mon.keyring&apos; already exists[ceph_deploy.gatherkeys][INFO ] Storing ceph.bootstrap-osd.keyring[ceph_deploy.gatherkeys][INFO ] Storing ceph.bootstrap-rgw.keyring[ceph_deploy.gatherkeys][INFO ] Destroy temp directory /tmp/tmpCHsfbU 创建之后，各个角色的key和权限就存在于集群中了。某个角色（例如admin）要对集群的某个组件（例如osd）进行读写操作时，要提供自己的key；集群根据它的key找到它的权限，然后鉴定它是否能够对这个组件进行读写操作。 上面gatherkeys在生成各个角色的key+权限的同时，把角色的key保存成keyring文件，供各个角色读写集群组件时使用： 123456789101112131415# lltotal 120-rw-------. 1 root root 71 May 7 14:28 ceph.bootstrap-mds.keyring-rw-------. 1 root root 71 May 7 14:28 ceph.bootstrap-mgr.keyring-rw-------. 1 root root 71 May 7 14:28 ceph.bootstrap-osd.keyring-rw-------. 1 root root 71 May 7 14:28 ceph.bootstrap-rgw.keyring-rw-------. 1 root root 63 May 7 14:28 ceph.client.admin.keyring# cat ceph.client.admin.keyring [client.admin] key = AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==# cat ceph.bootstrap-osd.keyring [client.bootstrap-osd] key = AQD+8e9aFC9+LxAApTnB/DImy5ZjoRbQhYoiVA== 现在就可以执行ceph的admin命令了（admin的key保存在ceph.client.admin.keyring文件里，通过–keyring提供）： 12345678910111213141516171819202122232425# ceph --keyring ceph.client.admin.keyring -c ceph.conf -s cluster: id: 744f59b7-c403-48e6-a1c6-2c74901a4d0b health: HEALTH_OK services: mon: 1 daemons, quorum server2 mgr: no daemons active osd: 0 osds: 0 up, 0 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0 bytes usage: 0 kB used, 0 kB / 0 kB avail pgs: # ceph --keyring ceph.client.admin.keyring -c ceph.conf auth get client.adminexported keyring for client.admin[client.admin] key = AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA== caps mds = &quot;allow *&quot; caps mgr = &quot;allow *&quot; caps mon = &quot;allow *&quot; caps osd = &quot;allow *&quot; E. 分发keyring 如前所示，我们执行admin的命令，要提供admin的key（–keyring ceph.client.admin.keyring）以及配置文件(-c ceph.conf)。在后续的运维中，我们经常需要在某个server上执行admin命令。每次都提供这些参数比较麻烦。实际上，ceph会默认地从/etc/ceph/中找keyring和ceph.conf。因此，我们可以把ceph.client.admin.keyring和ceph.conf放到每个server的/etc/ceph/。ceph-deploy可以帮我做这些： 1# ceph-deploy admin server0 server1 server2 server3 检查每个server，发现/etc/ceph/下都多了ceph.client.admin.keyring和ceph.conf这两个文件。现在就不用提供那些参数了： 12# ceph -s# ceph auth get client.admin F. 创建mgr 从ceph 12（luminous）开始，需要为每个monitor创建一个mgr（其功能待研究，之前的版本都没有这个组件）。 1234567891011121314151617# ceph-deploy mgr create server2# ceph -s cluster: id: 744f59b7-c403-48e6-a1c6-2c74901a4d0b health: HEALTH_OK services: mon: 1 daemons, quorum server2 mgr: server2(active) ----------------------新加的mgr osd: 0 osds: 0 up, 0 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0 bytes usage: 0 kB used, 0 kB / 0 kB avail pgs: 4.2 添加OSDceph-deploy osd create通过调用ceph-volume来创建OSD。使用bluestore时(默认)，需要指定3个device： device 如何指定 说明 block –data 主要存储，必选。可以是磁盘，分区或者lv block.db –block-db 可选。若不指定，则对应内容存储于block。可以是分区或者lv block.wal –block-wal 可选。若不指定，则对应内容存储于block。可以是分区或者lv 注意： 不可以使用磁盘作为block.db或者block.wal，否则会报错：blkid could not detect a PARTUUID for device； 若使用磁盘或者分区作block，则ceph-volume会在其上创建lv来使用。若使用分区作block.db或block.wal，则直接使用分区而不创建lv。 在使用磁盘之前，我们先把磁盘清空。若已经创建了volume group，需要先删掉（vgremove），然后通过ceph-deploy的disk zap进行清空。ceph-deploy disk zap会发生如下错误： 12345678910111213# ceph-deploy disk zap server0 /dev/vdb[ceph_deploy.conf][DEBUG ] found configuration file at: /root/.cephdeploy.conf[ceph_deploy.cli][INFO ] Invoked (2.0.0): /usr/bin/ceph-deploy disk zap [ceph_deploy.osd][DEBUG ] zapping /dev/vdb on server0......[server0][DEBUG ] find the location of an executable[ceph_deploy][ERROR ] Traceback (most recent call last):[ceph_deploy][ERROR ] File &quot;/usr/lib/python2.7/site-packages/ceph_deploy/util/decorators.py&quot;, line 69, in newfunc[ceph_deploy][ERROR ] return f(*a, **kw)[ceph_deploy][ERROR ] File &quot;/usr/lib/python2.7/site-packages/ceph_deploy/cli.py&quot;, line 164, in _main[ceph_deploy][ERROR ] return args.func(args)[ceph_deploy][ERROR ] File &quot;/usr/lib/python2.7/site-packages/ceph_deploy/osd.py&quot;, line 438, in disk[ceph_deploy][ERROR ] disk_zap(args) 修改ceph-deploy的 osd.py的disk_zap函数，即可成功： 1234# vim /usr/lib/python2.7/site-packages/ceph_deploy/osd.pyceph_volume_executable = system.executable_path(distro.conn, &apos;ceph-volume&apos;)#if args.debug:if False: A. 添加osd.0（磁盘作block，无block.db，无block.wal） 123456789101112131415161718192021222324252627282930# ceph-deploy osd create server0 --data /dev/vdb# ceph -s cluster: id: 744f59b7-c403-48e6-a1c6-2c74901a4d0b health: HEALTH_OK services: mon: 1 daemons, quorum server2 mgr: server2(active) osd: 1 osds: 1 up, 1 in# mount | grep cephtmpfs on /var/lib/ceph/osd/ceph-0 type tmpfs (rw,relatime,seclabel)# ll /var/lib/ceph/osd/ceph-0 total 48-rw-r--r--. 1 ceph ceph 189 May 7 15:19 activate.monmaplrwxrwxrwx. 1 ceph ceph 93 May 7 15:19 block -&gt; /dev/ceph-012c2043-33ef-4219-af69-34c7ed389d41/osd-block-5beb22d5-891c-4d6e-affe-87eb4bc083b2-rw-r--r--. 1 ceph ceph 2 May 7 15:19 bluefs-rw-r--r--. 1 ceph ceph 37 May 7 15:19 ceph_fsid-rw-r--r--. 1 ceph ceph 37 May 7 15:19 fsid-rw-------. 1 ceph ceph 55 May 7 15:19 keyring-rw-r--r--. 1 ceph ceph 8 May 7 15:19 kv_backend-rw-r--r--. 1 ceph ceph 21 May 7 15:19 magic-rw-r--r--. 1 ceph ceph 4 May 7 15:19 mkfs_done-rw-r--r--. 1 ceph ceph 41 May 7 15:19 osd_key-rw-r--r--. 1 ceph ceph 6 May 7 15:19 ready-rw-r--r--. 1 ceph ceph 10 May 7 15:19 type-rw-r--r--. 1 ceph ceph 2 May 7 15:19 whoami 可见： 使用磁盘vdb创建lv供block使用； osd是mount到tmpfs的（bluefs, ceph_fsid, fsid, keyring等等都存于集群中）； B. 添加osd.1（分区作block，分区作block.db，无block.wal） 把server0的vdc分成两个分区（分区过程省略，注意，要是有gpt分区格式）：vdc1作block.db，vdc2作block。 12345678910111213141516171819# ceph-deploy osd create server0 --data /dev/vdc2 --block-db /dev/vdc1# ll /var/lib/ceph/osd/ceph-1 total 52-rw-r--r--. 1 ceph ceph 189 May 7 15:25 activate.monmaplrwxrwxrwx. 1 ceph ceph 93 May 7 15:25 block -&gt; /dev/ceph-ae408599-db16-4028-914d-4006594c5cd8/osd-block-1edeced4-e5e9-45ac-a5d3-ddd238d720d4lrwxrwxrwx. 1 root root 9 May 7 15:25 block.db -&gt; /dev/vdc1-rw-r--r--. 1 ceph ceph 2 May 7 15:25 bluefs-rw-r--r--. 1 ceph ceph 37 May 7 15:25 ceph_fsid-rw-r--r--. 1 ceph ceph 37 May 7 15:25 fsid-rw-------. 1 ceph ceph 55 May 7 15:25 keyring-rw-r--r--. 1 ceph ceph 8 May 7 15:25 kv_backend-rw-r--r--. 1 ceph ceph 21 May 7 15:25 magic-rw-r--r--. 1 ceph ceph 4 May 7 15:25 mkfs_done-rw-r--r--. 1 ceph ceph 41 May 7 15:25 osd_key-rw-r--r--. 1 ceph ceph 10 May 7 15:25 path_block.db-rw-r--r--. 1 ceph ceph 6 May 7 15:25 ready-rw-r--r--. 1 ceph ceph 10 May 7 15:25 type-rw-r--r--. 1 ceph ceph 2 May 7 15:25 whoami 可见，使用分区vdc2创建lv供block使用； block.db直接使用vdc1; C. 添加osd.2（分区作block，分区作block.db，分区作block.wal） 把serve1的vdb分成3个分区：vdb3作block，vdb2作block.db，vdb1作block-wal： 1# ceph-deploy osd create server1 --data /dev/vdb3 --block-db /dev/vdb2 --block-wal /dev/vdb1 到server1上： 12345678910111213141516171819# ll /var/lib/ceph/osd/ceph-2 total 56-rw-r--r--. 1 ceph ceph 189 May 7 15:34 activate.monmaplrwxrwxrwx. 1 ceph ceph 93 May 7 15:34 block -&gt; /dev/ceph-c2f66dc2-076b-46cd-a1cd-e3ef9511a38a/osd-block-7bf0f953-2feb-4064-8d19-873495cae7f5lrwxrwxrwx. 1 root root 9 May 7 15:34 block.db -&gt; /dev/vdb2lrwxrwxrwx. 1 root root 9 May 7 15:34 block.wal -&gt; /dev/vdb1-rw-r--r--. 1 ceph ceph 2 May 7 15:34 bluefs-rw-r--r--. 1 ceph ceph 37 May 7 15:34 ceph_fsid-rw-r--r--. 1 ceph ceph 37 May 7 15:34 fsid-rw-------. 1 ceph ceph 55 May 7 15:34 keyring-rw-r--r--. 1 ceph ceph 8 May 7 15:34 kv_backend-rw-r--r--. 1 ceph ceph 21 May 7 15:34 magic-rw-r--r--. 1 ceph ceph 4 May 7 15:34 mkfs_done-rw-r--r--. 1 ceph ceph 41 May 7 15:34 osd_key-rw-r--r--. 1 ceph ceph 10 May 7 15:34 path_block.db-rw-r--r--. 1 ceph ceph 10 May 7 15:34 path_block.wal-rw-r--r--. 1 ceph ceph 6 May 7 15:34 ready-rw-r--r--. 1 ceph ceph 10 May 7 15:34 type-rw-r--r--. 1 ceph ceph 2 May 7 15:34 whoami D. 添加osd.3（lv作block，lv作block.db，lv作block.wal） 首先，在server1上，使用vdc创建出3个lv 123456789101112131415161718# pvcreate /dev/vdc Physical volume &quot;/dev/vdc&quot; successfully created# vgcreate myvg /dev/vdc Volume group &quot;myvg&quot; successfully created# lvcreate -n block-lv -L 30G myvg Logical volume &quot;block-lv&quot; created.# lvcreate -n db-lv -L 10G myvg Logical volume &quot;db-lv&quot; created.# lvcreate -n wal-lv -L 10G myvg Logical volume &quot;wal-lv&quot; created.# ls /dev/myvg/block-lv db-lv wal-lv 然后，在admin server上创建osd.3: 1# ceph-deploy osd create server1 --data myvg/block-lv --block-db myvg/db-lv --block-wal myvg/wal-lv 到server1上： 12345678910111213141516171819# ll /var/lib/ceph/osd/ceph-3 total 56-rw-r--r--. 1 ceph ceph 189 May 7 15:47 activate.monmaplrwxrwxrwx. 1 ceph ceph 18 May 7 15:47 block -&gt; /dev/myvg/block-lvlrwxrwxrwx. 1 root root 15 May 7 15:47 block.db -&gt; /dev/myvg/db-lvlrwxrwxrwx. 1 root root 16 May 7 15:47 block.wal -&gt; /dev/myvg/wal-lv-rw-r--r--. 1 ceph ceph 2 May 7 15:47 bluefs-rw-r--r--. 1 ceph ceph 37 May 7 15:47 ceph_fsid-rw-r--r--. 1 ceph ceph 37 May 7 15:47 fsid-rw-------. 1 ceph ceph 55 May 7 15:47 keyring-rw-r--r--. 1 ceph ceph 8 May 7 15:47 kv_backend-rw-r--r--. 1 ceph ceph 21 May 7 15:47 magic-rw-r--r--. 1 ceph ceph 4 May 7 15:47 mkfs_done-rw-r--r--. 1 ceph ceph 41 May 7 15:47 osd_key-rw-r--r--. 1 ceph ceph 16 May 7 15:47 path_block.db-rw-r--r--. 1 ceph ceph 17 May 7 15:47 path_block.wal-rw-r--r--. 1 ceph ceph 6 May 7 15:47 ready-rw-r--r--. 1 ceph ceph 10 May 7 15:47 type-rw-r--r--. 1 ceph ceph 2 May 7 15:47 whoami 注意： lv应写作 myvg/xx-lv，而不是/dev/myvg/xx-lv。否则会报错。 E. 添加其他osd 为了方便，block, block.db和block.wal都使用分区。 12345678910111213141516171819202122# ceph-deploy osd create server3 --data /dev/vdb3 --block-db /dev/vdb2 --block-wal /dev/vdb1# ceph-deploy osd create server3 --data /dev/vdc3 --block-db /dev/vdc2 --block-wal /dev/vdc1# ceph-deploy osd create server2 --data /dev/vdb3 --block-db /dev/vdb2 --block-wal /dev/vdb1# ceph-deploy osd create server2 --data /dev/vdc3 --block-db /dev/vdc2 --block-wal /dev/vdc1# ceph -s cluster: id: 744f59b7-c403-48e6-a1c6-2c74901a4d0b health: HEALTH_OK services: mon: 1 daemons, quorum server2 mgr: server2(active) osd: 8 osds: 8 up, 8 in &lt;-------- 8 个 osd data: pools: 0 pools, 0 pgs objects: 0 objects, 0 bytes usage: 8226 MB used, 339 GB / 347 GB avail pgs: 4.3 添加 2 mon + 2 mgr1234# ceph-deploy mon add server0# ceph-deploy mgr create server0# ceph-deploy mon add server1# ceph-deploy mgr create server1 注意：貌似新版的ceph-deploy一次只能增加一个mon. 现在集群就有3个mon和3个mgr了： 123456789101112131415# ceph -s cluster: id: 744f59b7-c403-48e6-a1c6-2c74901a4d0b health: HEALTH_OK services: mon: 3 daemons, quorum server0,server1,server2 mgr: server2(active), standbys: server0, server1 osd: 8 osds: 8 up, 8 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0 bytes usage: 8230 MB used, 339 GB / 347 GB avail pgs: 4.4 创建一个mds为了支持cephfs，我们在server2上创建一个mds： 1# ceph-deploy mds create server2 成功之后，到server2上可以看见mds进程： 12[root@server2 ~]# ps -ef | grep ceph-mdsceph 19995 1 0 16:35 ? 00:00:00 /usr/bin/ceph-mds -f --cluster ceph --id server2 --setuser ceph --setgroup ceph 但这个时候，mds并没有active，如下，我们通过ceph -s看不到mds服务。直到创建ceph filesystem的时候，mds才进入active状态（见6.1节）。 1234567891011121314151617# ceph -s cluster: id: 744f59b7-c403-48e6-a1c6-2c74901a4d0b health: HEALTH_WARN too few PGs per OSD (12 &lt; min 30) services: -----------------&gt; 看不到mds mon: 3 daemons, quorum server0,server1,server2 mgr: server2(active), standbys: server0, server1 osd: 8 osds: 8 up, 8 in rgw: 2 daemons active data: pools: 4 pools, 32 pgs objects: 187 objects, 1113 bytes usage: 8239 MB used, 339 GB / 347 GB avail pgs: 32 active+clean 至此，ceph集群就完全部署起来了。下面，我们为ceph集群增加一些client。 5. 增加rgw （在admin server上操作）我们可以使用ceph集群之外的server来部署rgw。部署之前，需要保证默认端口（7480）没有被防火墙禁止。并且需要安装ceph-radosgw包机器依赖： 1ceph-deploy install --rgw &lt;client-node&gt; [&lt;client-node&gt; ...] 为了方便起见，我们复用集群内的server1和server3来部署rgw。由于ceph-radosgw已经安装（见3.4节），并且防火墙已经被停掉（见2.5节），所以，直接部署即可： 1# ceph-deploy rgw create server1 server3 成功之后，在server1和server3上rgw进程就运行起来了： 12345678[root@server1 ~]# ps -ef | grep ceph......ceph 15884 1 2 16:23 ? 00:00:00 /usr/bin/radosgw -f --cluster ceph --name client.rgw.server1 --setuser ceph --setgroup ceph[root@server3 ~]# ps -ef | grep ceph......ceph 14107 1 2 16:23 ? 00:00:00 /usr/bin/radosgw -f --cluster ceph --name client.rgw.server3 --setuser ceph --setgroup ceph 并且我们可以通过http来访问： 123456789# curl server1:7480&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ListAllMyBucketsResult xmlns=&quot;http://s3.amazonaws.com/doc/2006-03-01/&quot;&gt;&lt;Owner&gt; &lt;ID&gt;anonymous&lt;/ID&gt; &lt;DisplayName&gt;&lt;/DisplayName&gt;&lt;/Owner&gt;&lt;Buckets&gt;&lt;/Buckets&gt;&lt;/ListAllMyBucketsResult&gt; 6. 增加cephfsceph filesystem需要mds（我们在4.4节已经部署）。并且，有两种方式来挂载：ceph fuse和ceph kernel driver。在这一节，我们: 创建一个ceph filesystem 通过ceph fuse挂载 通过ceph kernel driver挂载 6.1 创建ceph filesystem（在集群内任意server上）A. 创建所需的pool 1234# ceph osd pool create cephfs_data 80pool &apos;cephfs_data&apos; created# ceph osd pool create cephfs_metadata 40pool &apos;cephfs_metadata&apos; created B. 创建filesystem 12# ceph fs new mycephfs cephfs_metadata cephfs_datanew fs with metadata pool 6 and data pool 5 如第4.4节所示，在没有创建filesystem之前，mds没有active。现在mds就进入active状态了： 1234567891011121314151617# ceph -s cluster: id: 744f59b7-c403-48e6-a1c6-2c74901a4d0b health: HEALTH_OK services: mon: 3 daemons, quorum server0,server1,server2 mgr: server2(active), standbys: server0, server1 mds: mycephfs-1/1/1 up &#123;0=server2=up:active&#125; ---------&gt;mds已经active osd: 8 osds: 8 up, 8 in rgw: 2 daemons active data: pools: 6 pools, 152 pgs objects: 208 objects, 3359 bytes usage: 8248 MB used, 339 GB / 347 GB avail pgs: 152 active+clean 6.2 通过ceph fuse挂载（在server2上）和rgw一样，原则上我们在ceph集群之外的某台server上挂载ceph filesystem。但为了方便起见，我们还是在server2上挂载。 首先，要在server2上安装ceph-fuse（若使用ceph集群外的server，也只需这一个包）： 1# yum install -y ceph-fuse.x86_64 然后，创建一个挂载点，就可以挂载了。注意，ceph-fuse挂载使用的是admin的权限，所以，通过-k选项传入admin的key。 123456# mkdir /mnt/cephfs# ceph-fuse -k /etc/ceph/ceph.client.admin.keyring -m server0:6789 /mnt/cephfs2018-05-07 17:27:07.205147 7f501e11f040 -1 init, newargv = 0x7f502968cb80 newargc=9ceph-fuse[20080]: starting ceph clientceph-fuse[20080]: starting fuse 这时候，一个全新的ceph filesystem就可以使用了。注意：这时cephfs_data是空的，但cephfs_metadata不空： 123456789# ceph dfGLOBAL: SIZE AVAIL RAW USED %RAW USED 347G 339G 8248M 2.32 POOLS: NAME ID USED %USED MAX AVAIL OBJECTS ...... cephfs_data 5 0 0 106G 0 cephfs_metadata 6 2624 0 106G 21 往里拷贝一些东西，就会发现cephfs_data也不空了： 1234567891011121314# cp /boot/vmlinuz-3.10.0-327.el7.x86_64 /mnt/cephfs/# ls /mnt/cephfs/vmlinuz-3.10.0-327.el7.x86_64# ceph dfGLOBAL: SIZE AVAIL RAW USED %RAW USED 347G 339G 8263M 2.32 POOLS: NAME ID USED %USED MAX AVAIL OBJECTS ...... cephfs_data 5 5035k 0 106G 2 cephfs_metadata 6 7541 0 106G 21 6.3 通过ceph kernel driver挂载首先，我们尝试在server3上测试ceph kernel driver挂载。 和ceph-fuse一样，通过ceph kernel driver挂载也需要admin的权限。不同的是，不需要admin的keyring文件，而是直接需要admin的key： 12[root@server3 ~]# mkdir /mnt/kcephfs[root@server3 ~]# mount -t ceph server0:6789:/ /mnt/kcephfs/ -o name=admin,secret=AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA== 这个命令卡了一段时间后，报出如下错误： 1mount error 5 = Input/output error 在/var/log/messages中，有如下错误信息： 123[root@server3 ~]# tail /var/log/messagesMay 7 17:41:29 server3 kernel: libceph: mon0 192.168.100.160:6789 feature set mismatch, my 103b84a842aca &lt; server&apos;s 40103b84a842aca, missing 400000000000000May 7 17:41:29 server3 kernel: libceph: mon0 192.168.100.160:6789 missing required protocol features 就是说：ceph集群需要的feature set，我们的ceph kernel driver没能够全部提供，缺失的是400000000000000。 从CephNotes里，我们可以看到，缺失有些feature，可以通过两种办法解决： 升级内核 （从客户端入手解决） 对集群做某些设置 （从server端入手解决） 例如： missing 2040000 (CEPH_FEATURE_CRUSH_TUNABLES 和CEPH_FEATURE_CRUSH_TUNABLES2 )： 把客户server（cephfs挂载机）的内核升到3.9（或以上） ； 把tunables设置为legacy : ceph osd crush tunables legacy； missing 40000000 (CEPH_FEATURE_OSDHASHPSPOOL)： 把客户server（rbd客户机？）的内核升到3.9（或以上） ； ceph osd pool set rbd hashpspool false missing 800000000 (CEPH_FEATURE_OSD_CACHEPOOL)： 把客户server的内核升到3.14（或以上） ； 删除cache pool并reload monitors； 悲剧的是，我们缺失的400000000000000 (CEPH_FEATURE_NEW_OSDOPREPLY_ENCODING)，无法通过设置集群来解决，也就是说必须升级内核（到4.5以上）。 参考：http://cephnotes.ksperis.com/blog/2014/01/21/feature-set-mismatch-error-on-ceph-kernel-client 刚好，我有个开发server（devbuild：192.168.100.150），已经编译安装过内核 4.14.39。去试试。如4.1.B节所述，monitor运行于public network上（192.168.100.0/24），devbuild能够访问这个网络。这就足够了。注意：这个server不需安装任何ceph包。 123456789101112131415# ping 192.168.100.160PING 192.168.100.160 (192.168.100.160) 56(84) bytes of data.64 bytes from 192.168.100.160: icmp_seq=1 ttl=64 time=4.12 ms64 bytes from 192.168.100.160: icmp_seq=2 ttl=64 time=0.557 ms......[root@devbuild ~]# uname -aLinux devbuild 4.14.39.hyg.20180503 ......[root@devbuild ~]# mkdir /mnt/kcephfs[root@devbuild ~]# mount -t ceph 192.168.100.162:6789:/ /mnt/kcephfs/ -o name=admin,secret=AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==[root@devbuild ~]# ls /mnt/kcephfs/vmlinuz-3.10.0-327.el7.x86_64 已经mount成功，并且能看到第6.2节拷贝过去的文件。再测试拷贝一个文件，可见读写正常： 123456[root@devbuild ~]# cp linux-4.14.39.tar.xz /mnt/kcephfs/[root@devbuild ~]# ll /mnt/kcephfs/total 103560-rw-r--r-- 1 root root 100888428 May 7 18:27 linux-4.14.39.tar.xz-rwxr-xr-x 1 root root 5156528 May 7 17:30 vmlinuz-3.10.0-327.el7.x86_64 另外，根据官方文档，命令： 1# mount -t ceph 192.168.100.162:6789:/ /mnt/kcephfs/ -o name=admin,secret=AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA== 也可以换做： 1234# cat admin.secret AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==# mount -t ceph 192.168.100.162:6789:/ /mnt/kcephfs/ -o name=admin,secretfile=admin.secret 但是，我这样尝试，一直报错： 1234567891011121314151617[root@devbuild ~]# cat admin.secretAQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==[root@devbuild ~]# mount -t ceph 192.168.100.162:6789:/ /mnt/kcephfs/ -o name=admin,secretfile=admin.secretmount: wrong fs type, bad option, bad superblock on 192.168.100.162:6789:/, missing codepage or helper program, or other error In some cases useful info is found in syslog - try dmesg | tail or so.[root@devbuild ~]# dmesg | tail [ 66.850589] random: 7 urandom warning(s) missed due to ratelimiting[ 140.953833] Key type dns_resolver registered[ 141.096210] Key type ceph registered[ 141.097950] libceph: loaded (mon/osd proto 15/24)[ 141.160712] ceph: loaded (mds proto 32)[ 141.163762] libceph: bad option at &apos;secretfile=admin.secret&apos; 原因是，我的这个server没有安装任何ceph包，所以没有/usr/sbin/mount.ceph这个文件。解决办法： \1. 从别的server拷贝这个文件; \2. 安装ceph-common； 1# yum install -y ceph-common-12.2.5-0.el7.x86_64 前文说过，devbuild server不需安装任何ceph包，但若使用secretfile的方式，还是安装这个ceph-common为好。 7. 增加rbd7.1 准备rbd pool在集群内的任意server上创建一个pool，并init： 1234# ceph osd pool create rbd_pool 100 100pool &apos;rbd_pool&apos; created# rbd pool init rbd_pool 7.2 创建块设备首先我们尝试在集群内的一个server（server0）上创建块设备。 1234567891011121314# rbd create foo --size 4096 --image-feature layering -m 192.168.100.160 -K admin.secret -p rbd_pool# rbd map foo --name client.admin -m 192.168.100.160 -K admin.secret -p rbd_poolrbd: sysfs write failedrbd: error opening default pool &apos;rbd&apos;Ensure that the default pool has been created or specify an alternate pool name.In some cases useful info is found in syslog - try &quot;dmesg | tail&quot;.rbd: map failed: (5) Input/output error# dmesg | tail ......[527394.031762] libceph: mon0 192.168.100.160:6789 feature set mismatch, my 102b84a842a42 &lt; server&apos;s 40102b84a842a42, missing 400000000000000[527394.034677] libceph: mon0 192.168.100.160:6789 missing required protocol features 和6.3节遇到的问题一样，内核版本低，缺feature 400000000000000。还是到devbuild这个server上创建吧，要求： devbuild server能够访问monitor (public network)； 安装ceph-common； admin.secret； 如6.3节所述，都已满足。可以创建块设备了： 123# rbd create foo --size 4096 --image-feature layering -m 192.168.100.160 -K admin.secret -p rbd_pool# rbd map foo --name client.admin -m 192.168.100.160 -K admin.secret -p rbd_pool 选项-K admin.secret也可以换成-k ceph.client.admin.keyring。成功之后： 12345678# ll /dev/rbd0brw-rw----. 1 root disk 251, 0 May 10 16:31 /dev/rbd0# ls /dev/rbd/rbd_pool# ls /dev/rbd/rbd_poolfoo 这时候，我们可以使用/dev/rbd0了： 12# mkfs.ext4 /dev/rbd0 # mount /dev/rbd0 /mnt/rbd/ 8. 小结本文实践了使用ceph-deploy安装部署ceph集群的过程，给集群添加了三种类型的客户端，并且解决了一些部署中常见的问题。]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ceph存储引擎之bluestore]]></title>
    <url>%2F2019%2F05%2F07%2Fceph-bluestore%2F</url>
    <content type="text"><![CDATA[​ ceph后端支持多种存储引擎，以插件式的方式来进行管理使用，目前支持filestore，kvstore，memstore以及最新的bluestore，本文介绍的是bluestore的存储方法。 ​ 目前ceph10版本默认使用的filestore，但是因为filestore在写数据前需要先写journal，会有一倍的写放大，并且filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑，因此诞生的bluestore初衷就是为了减少写放大，并针对ssd做优化，而且直接管理裸盘，从理论上进一步减少文件系统如ext4/xfs等部分的开销，目前bluestore还处于开发优化阶段，在jewel版本还是试用版本，并且最新的master相比jewel已经做了大的重构，预期会在后续的大版本中稳定下来成为默认的存储引擎。本文基于master分支对bluestore存储引擎进行分析。 bluestore整体架构 ​ bluestore直接管理裸设备，抛弃了ext4/xfs等本地文件系统，BlockDevice实现在用户态下使用linux aio直接对裸设备进行I/O操作。既然是直接管理裸设备就必然需要进行裸设备的空间管理，对应的就是Allocator，目前支持StupidAllocator和BitmapAllocator两种分配器。 ​ 相关的元数据以kv的形式保存到kv数据库里，默认使用的是rocksdb，由于rocksdb本身是基于文件系统的，不是直接操作裸设备，但是rocksdb也比较灵活，将系统相关的处理抽象成Env，用户可用实现相应的接口，rocksdb默认的Env是PosixEnv，直接对接本地文件系统，为此，bluestore实现了一个BlueRocksEnv，继承自EnvWrapper，来为rocksdb提供底层系统的封装，为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口，在系统启动mount这个文件系统的时候将所有的元数据都加载到内存中，BluesFS的数据和日志文件都通过BlockDevice保存到裸设备上，BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备。 核心模块​ RocksDB： 存储预写式日志、数据对象元数据、Ceph的omap数据信息、以及分配器的元数据（分配器负责决定真正的数据应在什么地方存储）​ BlueRocksEnv： 与RocksDB交互的接口​ BlueFS： 小的文件系统，解决元数据、文件空间及磁盘空间的分配和管理，并实现了rocksdb::Env 接口(存储RocksDB日志和sst文件)。因为rocksdb常规来说是运行在文件系统的顶层，下面是BlueFS。 它是数据存储后端层，RocksDB的数据和BlueStore中的真正数据被存储在同一个块物理设备​ HDD/SSD： 物理块设备，存储实际的数据 ​ rocksdb本身是基于文件系统的，不是直接操作裸设备。它将系统相关的处理抽象成Env，用户可用实现相应的接口（rocksdb默认的Env是PosixEnv，直接对接本地文件系统）。BlueRocksEnv是bluestore实现的一个类，继承自rocksdb::EnvWrapper，来为rocksdb提供底层系统的封装。 ​ 为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口。所有的元数据的修改都记录在BlueFS的日志中，也就是对于BlueFS，元数据的持久化保存在日志中。在系统启动mount这个文件系统时，只需replay日志，就可将所有的元数据都加载到内存中。BluesFS的数据和日志文件都通过块设备保存到裸设备上（BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备）。 ​ bluestore不使用本地文件系统，直接接管裸设备，并且只使用一个原始分区，HDD/SSD所在的物理块设备实现在用户态下使用linux aio直接对裸设备进行I/O操作。由于操作系统支持的aio操作只支持directIO，所以对BlockDevice的写操作直接写入磁盘，并且需要按照page对齐。其内部有一个aio_thread 线程，用来检查aio是否完成。其完成后，通过回调函数aio_callback 通知调用方。 wal &amp; dbBlueFs将整个BlueStore的存储空间分为三个层次 ： 慢速(Slow)空间 主要用于存储对象数据，可由普通大容量机械盘提供，由BlueStore自行管理 高速(DB)空间 存储BlueStore内部产生的元数据，可由普通SSD提供，需求小于（慢速空间）。 超高速(WAL)空间 主要存储RocksDB内部产生的.log文件，可由ＳＳＤ或者ＮＶＲＡＭ等时延相较普通ＳＳＤ更小的设备充当。容量需求和（高速空间）相当，同样由ＢｌｕｅＦｓ直接管理。 wal &amp; db 的大小问题​ 在 ceph bluestore 的情况下，wal 是 RocksDB 的 write-ahead log, 相当于之前的 journal 数据，db 是 RocksDB 的 metadata 信息。在磁盘选择原则是 block.wal &gt; block.db &gt; block。当然所有的数据也可以放到同一块盘上。 ​ 默认情况下， wal 和 db 的大小分别是 512 MB 和 1GB, 现在没有一个好的理论值，好像和 ceph 本身承载的数据类型有关系。 ​ 值得注意的是，如果所有的数据都在单块盘上，那是没有必要指定 wal &amp; db 的大小的。如果 wal &amp; db 是在不同的盘上，由于 wal/db 一般都会分的比较小，是有满的可能性的。如果满了，这些数据会迁移到下一个快的盘上(wal - db - main)。所以最少不会因为数据满了，而造成无法写入。 bluestore元数据 ​ 在之前的存储引擎filestore里，对象的表现形式是对应到文件系统里的文件，默认4MB大小的文件，但是在bluestore里，已经没有传统的文件系统，而是自己管理裸盘，因此需要有元数据来管理对象，对应的就是Onode，Onode是常驻内存的数据结构，持久化的时候会以kv的形式存到rocksdb里。 ​ 在onode里又分为lextent，表示逻辑的数据块，用一个map来记录，一个onode里会存在多个lextent，lextent通过blob的id对应到blob（bluestore_blob_t ），blob里通过pextent对应到实际物理盘上的区域（pextent里就是offset和length来定位物理盘的位置区域）。一个onode里的多个lextent可能在同一个blob里，而一个blob也可能对应到多个pextent。 ​ 另外还有Bnode这个元数据，它是用来表示多个object可能共享extent，目前在做了快照后写I/O触发的cow进行clone的时候会用到。 I/O读写映射逻辑写I/O处理​ 到达bluestore的I/O的offset和length都是对象内（onode）的，offset是相对于这个对象起始位置的偏移，在_do_write里首先就会根据最小分配单位min_alloc_size进行判断，从而将I/O分为对齐和非对齐的。如下图所示： ​ 当一个写请求按照min_alloc_size进行拆分后，就会分为对齐写，对应到do_write_big，非对齐写（即落到某一个min_alloc_size区间的写I/O（对应到do_write_small）。 do_write_big​ 对齐到min_alloc_size的写请求处理起来比较简单，有可能是多个min_alloc_size的大小，在处理时会根据实际大小新生成lextent和blob，这个lextent跨越的区域是min_alloc_size的整数倍，如果这段区间是之前写过的，会将之前的lextent记录下来便于后续的空间回收。 do_write_small​ 在处理落到某个min_alloc_size区间的写请求时，会首先根据offset去查找有没有可以复用的blob，因为最小分配单元是min_alloc_size，默认64KB，如果一个4KB的写I/O就只会用到blob的一部分，blob里剩余的还能放其他的。 1）没有找到可以复用的blob，新生成blob ​ 在处理还还需要根据offset和len是否对齐到block_size（默认是4KB）进行补零对齐的操作，之所以需要补齐是与后续的写盘操作有关，真正写盘时有两种方式，一种是Direct I/O的方式，这种要求偏移和缓冲区都对齐的，另外一种非Direct I/O，即Buffered I/O，这种可以不对齐，但是是写到cache里，然后再sync刷到磁盘上，比如只写了100字节，在内核里是需要先从设备上读出来补齐成一个完整的扇区，然后再刷的，这样反而降低了效率。因此在bluestore里直接处理好对齐，对于后面的写盘来说比较有利，这里对齐到block_size，是个可配置的参数。 ​ 进行对齐补零时就是按照如上图那样把前后对齐到block_size，然后再把对齐后的offset和len作为lextent，进而放到blob里。 2）找到可以复用的blob​ 对于可以复用的blob，也是先按照block_size进行对齐补零的动作，然后再判断是否可以直接使用blob里空闲的空间进行区分做不同的处理。 a）直接写在blob未使用的空间上​ 这种情况下直接新生成lextent放到blob里。 b）覆盖写的情况​ 比如下面的这种情况，写I/O会覆盖部分已经写过的数据。 ​ 对于这种情况的处理如下图：也是需要先处理对齐补零的情况，如果覆盖的区域刚好是已经对齐到block_size，那么就不需要从磁盘读数据，但是如果覆盖的区域没有对齐到block_size，那么就需要把不对齐的那部分读出来，拼成一个对齐的buffer，然后新生成lextent，并且会对原来那个lextent进行调整，会记录需要回收的那部分区域。对于覆盖写的情况，都不是直接写盘，而是通过wal写到rocksdb。 整体写I/O的逻辑​ 之前组内同事画过一个流程图，这里借用一下算是一个简单的总结。 读I/O的处理 ​ 读I/O请求的处理时也是通过寻找相关联的lextent，可能会存在空洞的情况，即读到未写过的数据，这部分就直接补零。 clone及extent共享前面说到Bnode就是用来记录共享的lextent，目前是在做完快照后对原卷进行写I/O会触发cow，从而产生clone操作。clone时就是将原对象的blob从onode-&gt;blob_map移到onode-&gt;bnode-&gt;blob_map，并且将blob id置为负的，并设置共享标记，然后将新的快照对象的onode-&gt;bnode指向原对象的onode-&gt;bnode，并且用原onode里的lextents里的值赋给新的onode的lextents，从而达到共享extent的目的，图示仅供参考。 ​ 在clone完之后，继续对原对象进行写I/O操作时，当碰到共享的blob时就需要跳过，新生成blob，并且取消对原来那部分lextent的引用，在后续的空间释放时的判断依据就是否还有引用。 小结​ 从BlueStore 的设计和实现上看，可以将其理解为用户态下的一个文件系统，同时使用RocksDB来实现BlueStore所有元数据的管理，简化实现。 ​ 对于整块数据的写入，数据直接以aio的方式写入磁盘，再更新RocksDB中数据对象的元数据，避免了filestore的先写日志，后apply到实际磁盘的两次写盘。同时避免了日志元数据的冗余存储占用，因为传统文件系统有他们自己内部的日志和元数据管理机制。 ​ 对于随机IO，直接WAL的形式，写入RocksDB 高性能的KV存储中。 ​ 本文总体上介绍了bluestore的架构、相关元数据及内部I/O映射的逻辑，这还只是bluestore的冰山一角，后续会陆续对bluestore的处理流程、空间分配器、缓存管理、压缩等实现进行分析。]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量进阶]]></title>
    <url>%2F2019%2F04%2F22%2Fpython-%E5%8F%98%E9%87%8F%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[目标 变量的引用 可变和不可变类型 局部变量和全局变量 01. 变量的引用 变量 和 数据 都是保存在 内存 中的 在 Python 中 函数 的 参数传递 以及 返回值 都是靠 引用 传递的 1.1 引用的概念在 Python 中 变量 和 数据 是分开存储的 数据 保存在内存中的一个位置 变量 中保存着数据在内存中的地址 变量 中 记录数据的地址，就叫做 引用 使用 id() 函数可以查看变量中保存数据所在的 内存地址 注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 修改了数据的引用 变量 不再 对之前的数据引用 变量 改为 对新赋值的数据引用 1.2 变量引用 的示例在 Python 中，变量的名字类似于 便签纸 贴在 数据 上 定义一个整数变量 a，并且赋值为 1 代码 图示 a = 1 将变量 a 赋值为 2 代码 图示 a = 2 定义一个整数变量 b，并且将变量 a 的值赋值给 b 代码 图示 b = a 变量 b 是第 2 个贴在数字 2 上的标签 1.3 函数的参数和返回值的传递在 Python 中，函数的 实参/返回值 都是是靠 引用 来传递来的 12345678910111213141516171819def test(num): print("-" * 50) print("%d 在函数内的内存地址是 %x" % (num, id(num))) result = 100 print("返回值 %d 在内存中的地址是 %x" % (result, id(result))) print("-" * 50) return resulta = 10print("调用函数前 内存地址是 %x" % id(a))r = test(a)print("调用函数后 实参内存地址是 %x" % id(a))print("调用函数后 返回值内存地址是 %x" % id(r)) 02. 可变和不可变类型 不可变类型，内存中的数据不允许被修改： 数字类型 int, bool, float, complex, long(2.x) 字符串 str 元组 tuple 可变类型，内存中的数据可以被修改： 列表 list 字典 dict 1234a = 1a = "hello"a = [1, 2, 3]a = [3, 2, 1] 1234567891011121314151617181920demo_list = [1, 2, 3]print("定义列表后的内存地址 %d" % id(demo_list))demo_list.append(999)demo_list.pop(0)demo_list.remove(2)demo_list[0] = 10print("修改数据后的内存地址 %d" % id(demo_list))demo_dict = &#123;"name": "小明"&#125;print("定义字典后的内存地址 %d" % id(demo_dict))demo_dict["age"] = 18demo_dict.pop("name")demo_dict["name"] = "老王"print("修改数据后的内存地址 %d" % id(demo_dict)) 注意：字典的 key 只能使用不可变类型的数据 注意 可变类型的数据变化，是通过 方法 来实现的 如果给一个可变类型的变量，赋值了一个新的数据，引用会修改 变量 不再 对之前的数据引用 变量 改为 对新赋值的数据引用 哈希 (hash) Python 中内置有一个名字叫做 hash(o) 的函数 接收一个 不可变类型 的数据作为 参数 返回 结果是一个 整数 哈希 是一种 算法，其作用就是提取数据的 特征码（指纹） 相同的内容 得到 相同的结果 不同的内容 得到 不同的结果 在 Python 中，设置字典的 键值对 时，会首先对 key 进行 hash 已决定如何在内存中保存字典的数据，以方便 后续 对字典的操作：增、删、改、查 键值对的 key 必须是不可变类型数据 键值对的 value 可以是任意类型的数据 03. 局部变量和全局变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！ 3.1 局部变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 函数执行结束后，函数内部的局部变量，会被系统回收 不同的函数，可以定义相同的名字的局部变量，但是 彼此之间 不会产生影响 局部变量的作用 在函数内部使用，临时 保存 函数内部需要使用的数据 123456789101112131415161718192021def demo1(): num = 10 print(num) num = 20 print("修改后 %d" % num)def demo2(): num = 100 print(num)demo1()demo2()print("over") 局部变量的生命周期 所谓 生命周期 就是变量从 被创建 到 被系统回收 的过程 局部变量 在 函数执行时 才会被创建 函数执行结束后 局部变量 被系统回收 局部变量在生命周期 内，可以用来存储 函数内部临时使用到的数据 3.2 全局变量 全局变量 是在 函数外部定义 的变量，所有函数内部都可以使用这个变量 1234567891011121314151617# 定义一个全局变量num = 10def demo1(): print(num)def demo2(): print(num)demo1()demo2()print("over") 注意：函数执行时，需要处理变量时 会： 首先 查找 函数内部 是否存在 指定名称 的局部变量，如果有，直接使用 如果没有，查找 函数外部 是否存在 指定名称 的全局变量，如果有，直接使用 如果还没有，程序报错！ 1) 函数不能直接修改 全局变量的引用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！ 在函数内部，可以 通过全局变量的引用获取对应的数据 但是，不允许直接修改全局变量的引用 —— 使用赋值语句修改全局变量的值 123456789101112131415161718192021num = 10def demo1(): print("demo1" + "-" * 50) # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num)def demo2(): print("demo2" + "-" * 50) print(num)demo1()demo2()print("over") 注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值 2) 在函数内部修改全局变量的值 如果在函数中需要修改全局变量，需要使用 global 进行声明 1234567891011121314151617181920212223num = 10def demo1(): print("demo1" + "-" * 50) # global 关键字，告诉 Python 解释器 num 是一个全局变量 global num # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num)def demo2(): print("demo2" + "-" * 50) print(num)demo1()demo2()print("over") 3) 全局变量定义的位置 为了保证所有的函数都能够正确使用到全局变量，应该 将全局变量定义在其他函数的上方 1234567891011a = 10def demo(): print("%d" % a) print("%d" % b) print("%d" % c)b = 20demo()c = 30 注意 由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！ 代码结构示意图如下 4) 全局变量命名的建议 为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如： 全局变量名前应该增加 g_ 或者 gl_ 的前缀 提示：具体的要求格式，各公司要求可能会有些差异]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数进阶]]></title>
    <url>%2F2019%2F04%2F22%2Fpython-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[目标 函数参数和返回值的作用 函数的返回值 进阶 函数的参数 进阶 递归函数 01. 函数参数和返回值的作用 函数根据 有没有参数 以及 有没有返回值，可以 相互组合，一共有 4 种 组合形式 无参数，无返回值 无参数，有返回值 有参数，无返回值 有参数，有返回值 定义函数时，是否接收参数，或者是否返回结果，是根据 实际的功能需求 来决定的！ 如果函数 内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部 如果希望一个函数 执行完成后，向外界汇报执行结果，就可以增加函数的返回值 1.1 无参数，无返回值此类函数，不接收参数，也没有返回值，应用场景如下： 只是单纯地做一件事情，例如 显示菜单 在函数内部 针对全局变量进行操作，例如：新建名片，最终结果 记录在全局变量 中 注意： 如果全局变量的数据类型是一个 可变类型，在函数内部可以使用 方法 修改全局变量的内容 —— 变量的引用不会改变 在函数内部，使用赋值语句 才会 修改变量的引用 1.2 无参数，有返回值此类函数，不接收参数，但是有返回值，应用场景如下： 采集数据，例如 温度计，返回结果就是当前的温度，而不需要传递任何的参数 1.3 有参数，无返回值此类函数，接收参数，没有返回值，应用场景如下： 函数内部的代码保持不变，针对 不同的参数 处理 不同的数据 例如 名片管理系统 针对 找到的名片 做 修改、删除 操作 1.4 有参数，有返回值此类函数，接收参数，同时有返回值，应用场景如下： 函数内部的代码保持不变，针对 不同的参数 处理 不同的数据，并且 返回期望的处理结果 例如 名片管理系统 使用 字典默认值 和 提示信息 提示用户输入内容 如果输入，返回输入内容 如果没有输入，返回字典默认值 02. 函数的返回值 进阶 在程序开发中，有时候，会希望 一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理 返回值 是函数 完成工作后，最后 给调用者的 一个结果 在函数中使用 return 关键字可以返回结果 调用函数一方，可以 使用变量 来 接收 函数的返回结果 问题：一个函数执行后能否返回多个结果？ 示例 —— 温度和湿度测量 假设要开发一个函数能够同时返回当前的温度和湿度 先完成返回温度的功能如下： 1234567891011def measure(): """返回当前的温度""" print("开始测量...") temp = 39 print("测量结束...") return tempresult = measure()print(result) 在利用 元组 在返回温度的同时，也能够返回 湿度 改造如下： 123456789def measure(): """返回当前的温度""" print("开始测量...") temp = 39 wetness = 10 print("测量结束...") return (temp, wetness) 提示：如果一个函数返回的是元组，括号可以省略 技巧 在 Python 中，可以 将一个元组 使用 赋值语句 同时赋值给 多个变量 注意：变量的数量需要和元组中的元素数量保持一致 1result = temp, wetness = measure() 03. 函数的参数 进阶3.1. 不可变和可变的参数 问题 1：在函数内部，针对参数使用 赋值语句，会不会影响调用函数时传递的 实参变量？ —— 不会！ 无论传递的参数是 可变 还是 不可变 只要 针对参数 使用 赋值语句，会在 函数内部 修改 局部变量的引用，不会影响到 外部变量的引用 12345678910111213141516171819def demo(num, num_list): print("函数内部") # 赋值语句 num = 200 num_list = [1, 2, 3] print(num) print(num_list) print("函数代码完成")gl_num = 99gl_list = [4, 5, 6]demo(gl_num, gl_list)print(gl_num)print(gl_list) 问题 2：如果传递的参数是 可变类型，在函数内部，使用 方法 修改了数据的内容，同样会影响到外部的数据 12345678910def mutable(num_list): # num_list = [1, 2, 3] num_list.extend([1, 2, 3]) print(num_list)gl_list = [6, 7, 8]mutable(gl_list)print(gl_list) 在 python 中，列表变量调用 += 本质上是在执行列表变量的 extend 方法，不会修改变量的引用 1234567891011121314151617181920def demo(num, num_list): print("函数内部代码") # num = num + num num += num # num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用 # 函数执行结束后，外部数据同样会发生变化 num_list += num_list print(num) print(num_list) print("函数代码完成")gl_num = 9gl_list = [1, 2, 3]demo(gl_num, gl_list)print(gl_num)print(gl_list) 3.2 缺省参数 定义函数时，可以给 某个参数 指定一个默认值，具有默认值的参数就叫做 缺省参数 调用函数时，如果没有传入 缺省参数 的值，则在函数内部使用定义函数时指定的 参数默认值 函数的缺省参数，将常见的值设置为参数的缺省值，从而 简化函数的调用 例如：对列表排序的方法 123456789gl_num_list = [6, 3, 9]# 默认就是升序排序，因为这种应用需求更多gl_num_list.sort()print(gl_num_list)# 只有当需要降序排序时，才需要传递 `reverse` 参数gl_num_list.sort(reverse=True)print(gl_num_list) 指定函数的缺省参数 在参数后使用赋值语句，可以指定参数的缺省值 1234567def print_info(name, gender=True): gender_text = "男生" if not gender: gender_text = "女生" print("%s 是 %s" % (name, gender_text)) 提示 缺省参数，需要使用 最常见的值 作为默认值！ 如果一个参数的值 不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递！ 缺省参数的注意事项1) 缺省参数的定义位置 必须保证 带有默认值的缺省参数 在参数列表末尾 所以，以下定义是错误的！ 1def print_info(name, gender=True, title): 2) 调用带有多个缺省参数的函数 在 调用函数时，如果有 多个缺省参数，需要指定参数名，这样解释器才能够知道参数的对应关系！ 1234567891011121314151617181920def print_info(name, title="", gender=True): """ :param title: 职位 :param name: 班上同学的姓名 :param gender: True 男生 False 女生 """ gender_text = "男生" if not gender: gender_text = "女生" print("%s%s 是 %s" % (title, name, gender_text))# 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！print_info("小明")print_info("老王", title="班长")print_info("小美", gender=False) 3.3 多值参数定义支持多值参数的函数 有时可能需要 一个函数 能够处理的参数 个数 是不确定的，这个时候，就可以使用 多值参数 python 中有 两种 多值参数： 参数名前增加 一个 * 可以接收 元组 参数名前增加 两个 * 可以接收 字典 一般在给多值参数命名时，习惯使用以下两个名字 *args —— 存放 元组 参数，前面有一个 * **kwargs —— 存放 字典 参数，前面有两个 * args 是 arguments 的缩写，有变量的含义 kw 是 keyword 的缩写，kwargs 可以记忆 键值对参数 12345678def demo(num, *args, **kwargs): print(num) print(args) print(kwargs)demo(1, 2, 3, 4, 5, name="小明", age=18, gender=True) 提示：多值参数 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，有利于我们能够读懂大牛的代码 多值参数案例 —— 计算任意多个数字的和需求 定义一个函数 sum_numbers，可以接收的 任意多个整数 功能要求：将传递的 所有数字累加 并且返回累加结果 12345678910def sum_numbers(*args): num = 0 # 遍历 args 元组顺序求和 for n in args: num += n return numprint(sum_numbers(1, 2, 3)) 元组和字典的拆包（知道） 在调用带有多值参数的函数时，如果希望： 将一个 元组变量，直接传递给 args 将一个 字典变量，直接传递给 kwargs 就可以使用 拆包，简化参数的传递，拆包 的方式是： 在 元组变量前，增加 一个 * 在 字典变量前，增加 两个 * 123456789101112def demo(*args, **kwargs): print(args) print(kwargs)# 需要将一个元组变量/字典变量传递给函数对应的参数gl_nums = (1, 2, 3)gl_xiaoming = &#123;"name": "小明", "age": 18&#125;# demo(gl_nums, gl_xiaoming)--&gt;会把 num_tuple 和 xiaoming 作为元组传递个 argsdemo(*gl_nums, **gl_xiaoming) 04. 函数的递归 函数调用自身的 编程技巧 称为递归 4.1 递归函数的特点特点 一个函数 内部 调用自己 函数内部可以调用其他函数，当然在函数内部也可以调用自己 代码特点 函数内部的 代码 是相同的，只是针对 参数 不同，处理的结果不同 当 参数满足一个条件 时，函数不再执行 这个非常重要，通常被称为递归的出口，否则 会出现死循环！ 示例代码 1234567891011def sum_numbers(num): print(num) # 递归的出口很重要，否则会出现死循环 if num == 1: return sum_numbers(num - 1) sum_numbers(3) 4.2 递归案例 —— 计算数字累加需求 定义一个函数 sum_numbers 能够接收一个 num 的整数参数 计算 1 + 2 + … num 的结果 123456789101112def sum_numbers(num): if num == 1: return 1 # 假设 sum_numbers 能够完成 num - 1 的累加 temp = sum_numbers(num - 1) # 函数内部的核心算法就是 两个数字的相加 return num + tempprint(sum_numbers(2)) 提示：递归是一个 编程技巧，初次接触递归会感觉有些吃力！在处理 不确定的循环条件时，格外的有用，例如：遍历整个文件目录的结构]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级变量类型]]></title>
    <url>%2F2019%2F04%2F22%2Fpython-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[目标 列表 元组 字典 字符串 公共方法 变量高级 知识点回顾 Python 中数据类型可以分为 数字型 和 非数字型 数字型 整型 (int) 浮点型（float） 布尔型（bool） 真 True 非 0 数 —— 非零即真 假 False 0 复数型 (complex) 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题 非数字型 字符串 列表 元组 字典 在 Python 中，所有 非数字型变量 都支持以下特点： 都是一个 序列 sequence，也可以理解为 容器 取值 [] 遍历 for in 计算长度、最大/最小值、比较、删除 链接 + 和 重复 * 切片 1. 列表1.1 列表的定义 List（列表） 是 Python 中使用 最频繁 的数据类型，在其他语言中通常叫做 数组 专门用于存储 一串 信息 列表用 [] 定义，数据 之间使用 , 分隔 列表的 索引 从 0 开始 索引 就是数据在 列表 中的位置编号，索引 又可以被称为 下标 注意：从列表中取值时，如果 超出索引范围，程序会报错 1name_list = ["zhangsan", "lisi", "wangwu"] 1.2 列表常用操作 在 ipython3 中定义一个 列表，例如：name_list = [] 输入 name_list. 按下 TAB 键，ipython 会提示 列表 能够使用的 方法 如下： 1234In [1]: name_list.name_list.append name_list.count name_list.insert name_list.reversename_list.clear name_list.extend name_list.pop name_list.sortname_list.copy name_list.index name_list.remove del 关键字（科普） 使用 del 关键字(delete) 同样可以删除列表中元素 del 关键字本质上是用来 将一个变量从内存中删除的 如果使用 del 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了 1del name_list[1] 在日常开发中，要从列表删除数据，建议 使用列表提供的方法 关键字、函数和方法（科普） 关键字 是 Python 内置的、具有特殊意义的标识符 123In [1]: import keywordIn [2]: print(keyword.kwlist)In [3]: print(len(keyword.kwlist)) 关键字后面不需要使用括号 函数 封装了独立功能，可以直接调用 1函数名(参数) 函数需要死记硬背 方法 和函数类似，同样是封装了独立的功能 方法 需要通过 对象 来调用，表示针对这个 对象 要做的操作 1对象.方法名(参数) 在变量后面输入 .，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多 1.3 循环遍历 遍历 就是 从头到尾 依次 从 列表 中获取数据 在 循环体内部 针对 每一个元素，执行相同的操作 在 Python 中为了提高列表的遍历效率，专门提供的 迭代 iteration 遍历 使用 for 就能够实现迭代遍历 12345# for 循环内部使用的变量 in 列表for name in name_list: 循环内部针对列表元素进行操作 print(name) 1.4 应用场景 尽管 Python 的 列表 中可以 存储不同类型的数据 但是在开发中，更多的应用场景是 列表 存储相同类型的数据 通过 迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作 2. 元组2.1 元组的定义 Tuple（元组）与列表类似，不同之处在于元组的 元素不能修改 元组 表示多个元素组成的序列 元组 在 Python 开发中，有特定的应用场景 用于存储 一串 信息，数据 之间使用 , 分隔 元组用 () 定义 元组的 索引 从 0 开始 索引 就是数据在 元组 中的位置编号 1info_tuple = ("zhangsan", 18, 1.75) 创建空元组1info_tuple = () 元组中 只包含一个元素 时，需要 在元素后面添加逗号1info_tuple = (50, ) 2.2 元组常用操作 在 ipython3 中定义一个 元组，例如：info = () 输入 info. 按下 TAB 键，ipython 会提示 元组 能够使用的函数如下： 1info.count info.index 有关 元组 的 常用操作 可以参照上图练习 2.3 循环遍历 取值 就是从 元组 中获取存储在指定位置的数据 遍历 就是 从头到尾 依次 从 元组 中获取数据 12345# for 循环内部使用的变量 in 元组for item in info: 循环内部针对元组元素进行操作 print(item) 在 Python 中，可以使用 for 循环遍历所有非数字型类型的变量：列表、元组、字典 以及 字符串 提示：在实际开发中，除非 能够确认元组中的数据类型，否则针对元组的循环遍历需求并不是很多 2.4 应用场景 尽管可以使用 for in 遍历 元组 但是在开发中，更多的应用场景是： 函数的 参数 和 返回值，一个函数可以接收 任意多个参数，或者 一次返回多个数据 有关 函数的参数 和 返回值，在后续 函数高级 给大家介绍 格式字符串，格式化字符串后面的 () 本质上就是一个元组 让列表不可以被修改，以保护数据安全 123info = ("zhangsan", 18)print("%s 的年龄是 %d" % info) 元组和列表之间的转换 使用 list 函数可以把元组转换成列表 1list(元组) 使用 tuple 函数可以把列表转换成元组 1tuple(列表) 3. 字典3.1 字典的定义 dictionary（字典） 是 除列表以外 Python 之中 最灵活 的数据类型 字典同样可以用来 存储多个数据 通常用于存储 描述一个 物体 的相关信息 和列表的区别 列表 是 有序 的对象集合 字典 是 无序 的对象集合 字典用 {} 定义 字典使用 键值对 存储数据，键值对之间使用 , 分隔 键 key 是索引 值 value 是数据 键 和 值 之间使用 : 分隔 键必须是唯一的 值 可以取任何数据类型，但 键 只能使用 字符串、数字或 元组 1234xiaoming = &#123;"name": "小明", "age": 18, "gender": True, "height": 1.75&#125; 3.2 字典常用操作 在 ipython3 中定义一个 字典，例如：xiaoming = {} 输入 xiaoming. 按下 TAB 键，ipython 会提示 字典 能够使用的函数如下： 12345In [1]: xiaoming.xiaoming.clear xiaoming.items xiaoming.setdefaultxiaoming.copy xiaoming.keys xiaoming.updatexiaoming.fromkeys xiaoming.pop xiaoming.valuesxiaoming.get xiaoming.popitem 有关 字典 的 常用操作 可以参照上图练习 3.3 循环遍历 遍历 就是 依次 从 字典 中获取所有键值对 1234# for 循环内部使用的 `key 的变量` in 字典for k in xiaoming: print("%s: %s" % (k, xiaoming[k])) 提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多 3.4 应用场景 尽管可以使用 for in 遍历 字典 但是在开发中，更多的应用场景是： 使用 多个键值对，存储 描述一个 物体 的相关信息 —— 描述更复杂的数据信息 将 多个字典 放在 一个列表 中，再进行遍历，在循环体内部针对每一个字典进行 相同的处理 1234567card_list = [&#123;"name": "张三", "qq": "12345", "phone": "110"&#125;, &#123;"name": "李四", "qq": "54321", "phone": "10086"&#125; ] 4. 字符串4.1 字符串的定义 字符串 就是 一串字符，是编程语言中表示文本的数据类型 在 Python 中可以使用 一对双引号 &quot; 或者 一对单引号 &#39; 定义一个字符串 虽然可以使用 \&quot; 或者 \&#39; 做字符串的转义，但是在实际开发中： 如果字符串内部需要使用 &quot;，可以使用 &#39; 定义字符串 如果字符串内部需要使用 &#39;，可以使用 &quot; 定义字符串 可以使用 索引 获取一个字符串中 指定位置的字符，索引计数从 0 开始 也可以使用 for 循环遍历 字符串中每一个字符 大多数编程语言都是用 &quot; 来定义字符串 1234string = "Hello Python"for c in string: print(c) 4.2 字符串的常用操作 在 ipython3 中定义一个 字符串，例如：hello_str = &quot;&quot; 输入 hello_str. 按下 TAB 键，ipython 会提示 字符串 能够使用的 方法 如下： 12345678910111213141516In [1]: hello_str.hello_str.capitalize hello_str.isidentifier hello_str.rindexhello_str.casefold hello_str.islower hello_str.rjusthello_str.center hello_str.isnumeric hello_str.rpartitionhello_str.count hello_str.isprintable hello_str.rsplithello_str.encode hello_str.isspace hello_str.rstriphello_str.endswith hello_str.istitle hello_str.splithello_str.expandtabs hello_str.isupper hello_str.splitlineshello_str.find hello_str.join hello_str.startswithhello_str.format hello_str.ljust hello_str.striphello_str.format_map hello_str.lower hello_str.swapcasehello_str.index hello_str.lstrip hello_str.titlehello_str.isalnum hello_str.maketrans hello_str.translatehello_str.isalpha hello_str.partition hello_str.upperhello_str.isdecimal hello_str.replace hello_str.zfillhello_str.isdigit hello_str.rfind 提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！ 1) 判断类型 - 9 方法 说明 string.isspace() 如果 string 中只包含空格，则返回 True string.isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True string.isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True string.isdecimal() 如果 string 只包含数字则返回 True，全角数字 string.isdigit() 如果 string 只包含数字则返回 True，全角数字、⑴、\u00b2 string.isnumeric() 如果 string 只包含数字则返回 True，全角数字，汉字数字 string.istitle() 如果 string 是标题化的(每个单词的首字母大写)则返回 True string.islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True string.isupper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True 2) 查找和替换 - 7 方法 说明 string.startswith(str) 检查字符串是否是以 str 开头，是则返回 True string.endswith(str) 检查字符串是否是以 str 结束，是则返回 True string.find(str, start=0, end=len(string)) 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1 string.rfind(str, start=0, end=len(string)) 类似于 find()，不过是从右边开始查找 string.index(str, start=0, end=len(string)) 跟 find() 方法类似，不过如果 str 不在 string 会报错 string.rindex(str, start=0, end=len(string)) 类似于 index()，不过是从右边开始 string.replace(old_str, new_str, num=string.count(old)) 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 3) 大小写转换 - 5 方法 说明 string.capitalize() 把字符串的第一个字符大写 string.title() 把字符串的每个单词首字母大写 string.lower() 转换 string 中所有大写字符为小写 string.upper() 转换 string 中的小写字母为大写 string.swapcase() 翻转 string 中的大小写 4) 文本对齐 - 3 方法 说明 string.ljust(width) 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 string.rjust(width) 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 string.center(width) 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串 5) 去除空白字符 - 3 方法 说明 string.lstrip() 截掉 string 左边（开始）的空白字符 string.rstrip() 截掉 string 右边（末尾）的空白字符 string.strip() 截掉 string 左右两边的空白字符 6) 拆分和连接 - 5 方法 说明 string.partition(str) 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) string.rpartition(str) 类似于 partition() 方法，不过是从右边开始查找 string.split(str=””, num) 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\r’, ‘\t’, ‘\n’ 和空格 string.splitlines() 按照行(‘\r’, ‘\n’, ‘\r\n’)分隔，返回一个包含各行作为元素的列表 string.join(seq) 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 4.3 字符串的切片 切片 方法适用于 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 1字符串[开始索引:结束索引:步长] 注意： 指定的区间属于 左闭右开 型 [开始索引, 结束索引) =&gt; 开始索引 &gt;= 范围 &lt; 结束索引 从 起始 位开始，到 结束位的前一位 结束（不包含结束位本身) 从头开始，开始索引 数字可以省略，冒号不能省略 到末尾结束，结束索引 数字可以省略，冒号不能省略 步长默认为 1，如果连续切片，数字和冒号都可以省略 索引的顺序和倒序 在 Python 中不仅支持 顺序索引，同时还支持 倒序索引 所谓倒序索引就是 从右向左 计算索引 最右边的索引值是 -1，依次递减 演练需求 截取从 2 ~ 5 位置 的字符串 截取从 2 ~ 末尾 的字符串 截取从 开始 ~ 5 位置 的字符串 截取完整的字符串 从开始位置，每隔一个字符截取字符串 从索引 1 开始，每隔一个取一个 截取从 2 ~ 末尾 - 1 的字符串 截取字符串末尾两个字符 字符串的逆序 答案 123456789101112131415161718192021222324252627282930313233343536373839404142num_str = &quot;0123456789&quot;# 1. 截取从 2 ~ 5 位置 的字符串print(num_str[2:6])---&gt;2345# 2. 截取从 2 ~ `末尾` 的字符串print(num_str[2:])---&gt;23456789# 3. 截取从 `开始` ~ 5 位置 的字符串print(num_str[:6])---&gt;012345# 4. 截取完整的字符串print(num_str[:])---&gt;0123456789# 5. 从开始位置，每隔一个字符截取字符串print(num_str[::2])---&gt;02468# 6. 从索引 1 开始，每隔一个取一个print(num_str[1::2])---&gt;13579# 倒序切片# -1 表示倒数第一个字符print(num_str[-1])---&gt;9# 7. 截取从 2 ~ `末尾 - 1` 的字符串print(num_str[2:-1])---&gt;2345678# 8. 截取字符串末尾两个字符print(num_str[-2:])---&gt;89# 9. 字符串的逆序print(num_str[::-1])---&gt;9876543210 5. 公共方法5.1 Python 内置函数Python 包含了以下内置函数： 函数 描述 备注 len(item) 计算容器中元素个数 del(item) 删除变量 del 有两种方式 max(item) 返回容器中元素最大值 如果是字典，只针对 key 比较 min(item) 返回容器中元素最小值 如果是字典，只针对 key 比较 cmp(item1, item2) 比较两个值，-1 小于/0 相等/1 大于 Python 3.x 取消了 cmp 函数 注意 字符串 比较符合以下规则： “0” &lt; “A” &lt; “a” 5.2 切片 描述 Python 表达式 结果 支持的数据类型 切片 “0123456789”[::-2] “97531” 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 5.3 运算符 运算符 Python 表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * [“Hi!”] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 重复 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 &gt; &gt;= == &lt; &lt;= (1, 2, 3) &lt; (2, 2, 3) True 元素比较 字符串、列表、元组 注意 in 在对 字典 操作时，判断的是 字典的键 in 和 not in 被称为 成员运算符 成员运算符成员运算符用于 测试 序列中是否包含指定的 成员 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False 3 in (1, 2, 3) 返回 True not in 如果在指定的序列中没有找到值返回 True，否则返回 False 3 not in (1, 2, 3) 返回 False 注意：在对 字典 操作时，判断的是 字典的键 5.4 完整的 for 循环语法 在 Python 中完整的 for 循环 的语法如下： 12345for 变量 in 集合: 循环体代码else: 没有通过 break 退出循环，循环结束后，会执行的代码 应用场景 在 迭代遍历 嵌套的数据类型时，例如 一个列表包含了多个字典 需求：要判断 某一个字典中 是否存在 指定的 值 如果 存在，提示并且退出循环 如果 不存在，在 循环整体结束 后，希望 得到一个统一的提示 123456789101112131415161718192021222324252627282930students = [ &#123;"name": "阿土", "age": 20, "gender": True, "height": 1.7, "weight": 75.0&#125;, &#123;"name": "小美", "age": 19, "gender": False, "height": 1.6, "weight": 45.0&#125;,]find_name = "阿土"for stu_dict in students: print(stu_dict) # 判断当前遍历的字典中姓名是否为find_name if stu_dict["name"] == find_name: print("找到了") # 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较 breakelse: print("没有找到")print("循环结束")]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ceph-arm架构分布式编译ceph]]></title>
    <url>%2F2019%2F04%2F14%2Fceph-arm%E6%9E%B6%E6%9E%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E8%AF%91ceph%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[分布式编译集群代码需求​ arm的机器的cpu为2个Processor，内存为2G，而代码的编译是非常吃cpu和内存的操作，cpu少则会引起编译过慢，内存少则可能引起复杂函数编译内存溢出，所以在当前arm架构下，希望能够利用整个机器所有子节点进行并发编译，从而减少编译等待时间，加速版本的编译。​ 本篇方案可以把编译时间从之前的一个白天，控制到1个小时左右。 硬件描述​ 整台物理节点为12个子节点组成，每个子节点都有单独的网卡配置有单独的IP，独立cpu，独立内存，每个子节点都有单独的操作系统，操作系统为Ubuntu 14.04.4 LTS（trusty）。 软件组成​ 本次实践需要用到的软件为distcc和ccache，前者为分布式编译软件，后者为本地一个缓存加速功能，在多次编译过程中可以实现一定的加速，经过测试，distcc能够正常的运行在arm架构下，并且能够与ceph代码的编译进行很好的结合。 实践过程增加本机的swap​ 由于机器的内存只有2g，所以为了避免编译过程的内存溢出，通过增加swap的方式，系统盘的空间比较小，所以在每台机器上面都准备一块盘，用于存放swap的文件，在主节点上也可以存放代码编译文件，因为编译完大概会有十几G的空间占用。增加swap的方法 12345678root@node09:/disk1# dd if=/dev/zero of=swap bs=4M count=1024010240+0 records in10240+0 records out42949672960 bytes (43 GB) copied, 189.642 s, 226 MB/sroot@node09:/disk1# mkswap swapSetting up swapspace version 1, size = 41943036 KiBno label, UUID=599315be-9108-4092-956e-42a846d6b511root@node09:/disk1# swapon swap ​ 本次增加的swap为40G可以根据需要增加，4G可能就能够满足，根据实际情况进行调整，我的/disk1目录是一个挂载盘空间。​ 如果需要持久化swap，就在fstab里面增加自动挂载的相关内容即可 。 调整内核参数1234root@node09:/disk1# echo "vm.swappiness = 80" &gt;&gt; /etc/sysctl.confroot@node09:/disk1# echo "vm.dirty_background_ratio = 1" &gt;&gt;/etc/sysctl.confroot@node09:/disk1# echo "vm.dirty_ratio = 2" &gt;&gt; /etc/sysctl.confroot@node09:/disk1# sysctl -p ​ 上面调整目的是为了尽量回收内存，并且积极使用swap，我在测试过程中配置后没有出现内存溢出问题。 准备12台机器 1172.16.91.11-172.16.91.22 ​ 12个节点中有一台机器是存放原始代码的地方，所有请求都是以这台机器做分发，其他的节点都是接受这个分发请求，本次测试是以172.16.91.11为原始代码编译的地方，在编译过程中，代码会分发到各个机器上，然后在每台机器的/tmp目录下面进行编译，所以需要注意给好/tmp目录权限。​ 在每台机器上面都执行 1root@node02:~# chmod 777 /tmp ​ 着重注意的一点​ 由于操作系统文件系统为ext4，最开始的一次测试我的挂载盘为xfs文件系统，代码放在xfs文件系统上的时候，编译就会报错，因为distcc编译过程中会有一些做链接操作，跨文件系统的链接会失败，编译软件会报错无法创建文件，所以存放代码的地方一定要用ext4文件系统，来保证系统盘和挂载盘文件系统的一致性。 安装编译器​ 下面的软件是所有机器都需要安装的，需要用到的编译软件和分布式编译分发软件12apt-get install gcc g++apt-get install distcc 配置Distcc​ 所有机器上面都配置distcc的端口可以接受请求，并且把端口监听到0.0.0.0​ 打开/etc/default/distcc，设置如下配置项：123STARTDISTCC="true"ALLOWEDNETS="127.0.0.1 172.16.0.0/16"LISTENER="0.0.0.0" ​ 上面的172.16.0.0/16为网段的配置，就是允许这个网段的机器进行连接，这里就写自己机器所在的网段即可 启动distccd123456789root@node02:~# /etc/init.d/distcc restart* Restarting Distributed Compiler Daemon: distccd[ OK ]root@node02:~# ps -aux | grep distccddistccd 6093 0.0 0.0 2352 140 ? SNs 17:11 0:00 /usr/bin/distccd --pid-file=/var/run/distccd.pid --log-file=/var/log/distccd.log --daemon --allow 127.0.0.1 --allow 192.168.0.0/16 --listen 0.0.0.0 --nice 10distccd 6094 0.0 0.0 2352 140 ? SN 17:11 0:00 /usr/bin/distccd --pid-file=/var/run/distccd.pid --log-file=/var/log/distccd.log --daemon --allow 127.0.0.1 --allow 192.168.0.0/16 --listen 0.0.0.0 --nice 10distccd 6097 0.0 0.0 2352 140 ? SN 17:11 0:00 /usr/bin/distccd --pid-file=/var/run/distccd.pid --log-file=/var/log/distccd.log --daemon --allow 127.0.0.1 --allow 192.168.0.0/16 --listen 0.0.0.0 --nice 10distccd 6138 0.0 0.0 2352 140 ? SN 17:11 0:00 /usr/bin/distccd --pid-file=/var/run/distccd.pid --log-file=/var/log/distccd.log --daemon --allow 127.0.0.1 --allow 192.168.0.0/16 --listen 0.0.0.0 --nice 10distccd 6175 0.0 0.0 2352 140 ? SN 17:11 0:00 /usr/bin/distccd --pid-file=/var/run/distccd.pid --log-file=/var/log/distccd.log --daemon --allow 127.0.0.1 --allow 192.168.0.0/16 --listen 0.0.0.0 --nice 10 在所有机器上启动以后，检查进程是否正常 添加主机列表​ 在主节点，也就是存放代码机器进行配置（172.16.91.11），这个只需要在主节点配置即可 123456789101112root@armnode1:~# vim /etc/distcc/hostsroot@node01:/disk2/ceph-10.2.0-src# cat /etc/distcc/hosts# As described in the distcc manpage, this file can be used for a global# list of available distcc hosts.## The list from this file will only be used, if neither the# environment variable DISTCC_HOSTS, nor the file $HOME/.distcc/hosts# contains a valid list of hosts.## Add a list of hostnames in one line, seperated by spaces, here.172.16.91.18 172.16.91.17 172.16.91.16 172.16.91.15 172.16.91.14 172.16.91.13 172.16.91.12 172.16.91.19 172.16.91.20 172.16.91.21 172.16.91.22 172.16.91.11+zeroconf ​ 这里添加的主机列表就是最终会参与编译的机器的IP，本机可以选择参加和不参加都可以，后面会给出性能区别，如果分发出去的代码编译失败，都会在本地重新再编译一次 配置编译参数​ 在进行configure的时候指定编译器，这里指定CC和CCX参数1./configure CC="distcc gcc" CXX="distcc g++" ​ 指定好了以后就可以开始编译了1time make -j11 ​ 观察编译过程，在主节点上执行 12345678910111213root@node01:~# watch distccmon-textroot@node01:~# distccmon-text8039 Compile ErasureCode.cc 172.16.91.12[0]7835 Compile ErasureCodeLrc.cc 172.16.91.13[0]7861 Compile str_map.cc 172.16.91.15[0]7632 Compile ErasureCodeJerasure.cc 172.16.91.16[0]7935 Compile json_spirit_writer.cpp 172.16.91.17[0]8078 Compile ErasureCode.cc 172.16.91.19[0]8112 Compile galois.c 172.16.91.21[0]8028 Compile ErasureCodeShecTableCache.cc 172.16.91.22[0]8074 Preprocesslocalhost[0]7907 Preprocesslocalhost[3]7977 Preprocesslocalhost[6] ​ 可以观察到在其他机器上开始编译了，本机是做的预编译工作 ​ 在其他节点上观察接受的编译请求 12345678910111213141516root@node04:/dist23# tailf /var/log/distccd.logdistccd[12558] (dcc_job_summary) client: 172.16.91.11:45552 COMPILE_OK exit:0 sig:0 core:0 ret:0 time:16542ms g++ test/compressor/compressor_plugin_example.ccdistccd[12674] (dcc_job_summary) client: 172.16.91.11:45574 COMPILE_OK exit:0 sig:0 core:0 ret:0 time:45ms g++ test/erasure-code/ErasureCodePluginMissingEntryPoint.ccdistccd[12549] (dcc_job_summary) client: 172.16.91.11:45822 COMPILE_OK exit:0 sig:0 core:0 ret:0 time:15318ms g++ erasure-code/shec/ErasureCodeShecTableCache.ccdistccd[12554] (dcc_job_summary) client: 172.16.91.11:45870 COMPILE_OK exit:0 sig:0 core:0 ret:0 time:408ms gcc erasure-code/jerasure/gf-complete/src/gf_method.cdistccd[12558] (dcc_job_summary) client: 172.16.91.11:45878 COMPILE_OK exit:0 sig:0 core:0 ret:0 time:1257ms gcc erasure-code/jerasure/gf-complete/src/gf.c ​ 正常的日志应该就是上面这种了 配置ccache（可选配置项）​ 这个属于可选项目，进一步加速多次编译的情况，对首次编译没有加速功能,这个是在主节点上面的配置1root@node01:~#apt-get install ccache ​ 变更缓存目录，这个指定到挂载盘的路径1root@node01:~# export CCACHE_DIR=/disk2/.ccache 检查状态12345678root@node01:/disk2/ceph# ccache -scache directory /disk2/.ccachecache hit (direct) 0cache hit (preprocessed) 0cache miss 0files in cache 0cache size 0 Kbytesmax cache size 1.0 Gbytes ​ 默认缓存1G的大小，如果需要调整（默认可不调整）1root@node01:/disk2/ceph# ccache -M 5G ​ 通过命令指定配置启用ccache，在/root/.bashrc最下面添加123export PATH=/usr/lib/ccache:$PATHexport CCACHE_DIR=/disk2/.ccacheccache \-M 5G ​ 然后执行12root@node01:~# source /root/.bashrcSet cache size limit to 5.0 Gbytes ​ 检查gcc的新路径12root@node01:~# which gcc/usr/lib/ccache/gcc ​ 可以看到已经开始调用ccache的路径的gcc了，如果不想启动，就去掉上面的配置项目，然后新开终端就可以了 性能对比​ 因为每台机器有2个核，在x86上面一般可以是一个核参与一个编译进程，所以这里12台机器会有分发主机自身参与，分发主机自身不参与，每台机器运行一个编译进程，每台机器运行两个进程，一共组合的四种情况，测试的数据如下： ​ real时间是指挂钟时间，也就是命令开始执行到结束的时间，我们主要关心的是这个时间，就取这个时间做对比。 - 单个编译进程 两个编译进程 分发机器参与 62m3.185s 压力过大崩溃 分发机器不参与 60m57.848s 53m59.010s 数据分析： 从上面看两个进程运行的时候大概能加快10%的时间，快了7分钟左右，分发机器不参与的时候，反而更快，也就是推荐配置的时候，放置代码的机器不在分发列表当中，然后根据需要选择单进程和多进程都可以保留测试数据 123456789101112131415161718192021自身参与 然后是make -j 12正在测试make[1]: Leaving directory `/disk2/ceph-10.2.0-src/selinux'real 62m3.185suser 89m6.270ssys 8m43.520sroot@node01:/disk2/ceph-10.2.0-src# time make -j12自身不参与 然后是make -j 22正在测试make[1]: Leaving directory `/disk2/ceph-10.2.0-src/selinux'real 53m59.010suser 86m25.760ssys 8m50.690sroot@node01:/disk2/ceph-10.2.0-src#自身不参与 然后是make -j 11make[1]: Leaving directory `/disk2/ceph-10.2.0-src/selinux'real 60m57.848suser 80m33.230ssys 8m16.860s 整个编译过程可以控制在1小时 一个异常处理​ ceph_dencoder.cc这个函数编译会有bug，编译过程会引起内存溢出，通过查找资料发现，这个不是通过增加内存可以解决的，应该是这一个cc文件的内部函数和arm架构的有冲突，整个代码里面就这个文件有问题，这个并非必要文件，所以可以绕过先，跟研发沟通也是这个文件会出现编译失败的问题，如果到时确实需要用到，可以直接用X86的这个二进制文件即可。1cp src/librados-config.cc src/test/encoding/ceph_dencoder.cc ​ 通过一个本机函数替换方式来让编译一次通过，也可以修改内部代码来实现，这个替换的方式简单一点]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ceph-centos下制作rpm包]]></title>
    <url>%2F2019%2F04%2F12%2Fceph%E5%88%B6%E4%BD%9CRPM%E5%8C%85%2F</url>
    <content type="text"><![CDATA[源码版本​ 本次使用 12.2.12的ceph源码，制作RPM包 准备工作添加RPM源​ 网上搜索 centos的国内源，并写入/etc/yum.repos.d/CentOS-Base.repo文件当中，并执行 yum update更新。 保证上网通畅​ 执行 ping www.baidu.com查看上网是否通畅。 安装编译依赖​ 该环境为centos7.6.1810的环境 123456789101112yum install -y redhat-lsb yum-utilsyum install -y cmake git gcc gcc-c++ python-sphinx libudev-devel libaio-devel libblkid-develyum install -y openldap-devel gperftools-libs google-perftools-devel snappy-devel yum install -y keyutils-libs-devel libcurl-devel nss-devel openssl-devel python-develyum install -y lttng-ust-devel libbabeltrace-devel Cython gperf xfsprogs-devel fuse-develyum install -y python-wheel python-pip python-virtualenv fcgi-develyum install -y java-devel sharutils checkpolicy selinux-policy-devel yum install -y cryptsetup jq libtool libxml2-devel python-nose python-requests yum install -y python-six valgrind-devel xmlstarlet yasm boost-random yum install -y libibverbs-devel python-prettytable python34-devel python34-setuptools yum install -y python34-Cython junit python-mock python-tox pytestyum install -y python3 python3-devel python36-Cython 开始编译​ 解压源码包，并执行以下命令（本步骤是验证编译依赖是否安装完全，若制作RPM包，可跳过此步骤） 1234[root@node106 ~]# cd ceph-12.2.12[root@node106 ~]# sh do_cmake.sh[root@node106 ~]# cd build[root@node106 ~]# make -j5 ​ 编译完成后可以在 build目录下的bin目录下发现编译生成的可执行文件，可以在lib目录下发现编译生成的动态库。 制作RPM包​ 执行下列命令编译RPM包 1234567[root@node106 ~]# RPMdir=`cat ~/.rpmmacros|grep "%_topdir"|awk '&#123;print $2&#125;'` //输出制作rpm包的路径[root@node106 ~]# SOURCEdir=`pwd`[root@node106 ~]# mkdir -p $RPMdir/&#123;BUILD,SPECS,SOURCES,RPMS,SRPMS&#125;[root@node106 ~]# cp ./ceph-12.2.12/ceph.spec $RPMdir/SPECS[root@node106 ~]# cp ./ceph-12.2.12.tar.bz2 $RPMdir/SOURCES[root@node106 ~]# rpmbuild -bb $RPMdir/SPECS/ceph.spec[root@node106 ~]# cp $RPMdir/RPMS $SOURCEdir -r ​ 也可以制作成shell脚本，方便执行 1234567891011121314[root@node106 ~]# cat make-ceph-rpm.sh#!bin/bashset -eRPMdir=`cat ~/.rpmmacros|grep "%_topdir"|awk '&#123;print $2&#125;'` &amp;&amp; echo $RPMdirSOURCEdir=`pwd`if [ ! -e $RPMdir ];then mkdir $RPMdirficd $RPMdirmkdir -p $RPMdir/&#123;BUILD,SPECS,SOURCES,RPMS,SRPMS&#125;cd $SOURCEdircp ./ceph.spec $RPMdir/SPECScp ./ceph-12.2.12.tar.bz2 $RPMdir/SOURCESrpmbuild -bb $RPMdir/SPECS/ceph.spec &amp;&amp; cp $RPMdir/RPMS $SOURCEdir -r]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ceph-ubuntu下制作deb安装包]]></title>
    <url>%2F2019%2F04%2F03%2Fceph%E5%88%B6%E4%BD%9CDEB%E5%8C%85%2F</url>
    <content type="text"><![CDATA[源码版本​ 本次使用 12.2.12的ceph源码，制作DEB包 准备工作添加deb源​ 网上搜索ubuntu的国内源，并写入/etc/apt/sources.list文件当中，并执行 apt-get update更新。 保证上网通畅​ 执行 ping www.baidu.com查看上网是否通畅 安装编译依赖1234567891011121314apt-get install -y aptitude libtool automake pkg-config python-dev cythonapt-get install -y g++ libsnappy-dev libleveldb-dev uuid-dev libblkid-dev libudev-devapt-get install -y libkeyutils-dev libcrypto++-dev libfcgi-dev apt-get install -y libexpat1-dev libcurl4-openssl-dev libfuse-dev apt-get install -y libgoogle-perftools-dev libldap-dev libedit-devapt-get install -y libaio-dev libatomic-ops-dev xfslibs-dev apt-get install -y libboost-dev libbabeltrace-ctf-dev libbabeltrace-devapt-get install -y libboost-iostreams1.58-dev libboost-thread1.58-dev libboost-random1.58-dev libboost-program-options1.58-devapt-get install -y python-pip python-virtualenv python-wheel libssl-devapt-get install -y liblttng-ust-dev dpkg-checkbuilddeps cython3 dh-exec dh-systemd gperfapt-get install -y javahelper jq libibverbs-dev libldap2-dev libnss3-dev libxml2-dev xmlstarletapt-get install -y python-all-dev python-coverage python-cherrypy3 python-nose python-pecan python-prettytable apt-get install -y python-setuptools python-sphinx python-werkzeug python3-all-dev python3-setuptoolsapt-get install -y btrfs-tools cryptsetup default-jdk gdisk git socat valgrind xfslibs-dev 开始编译​ 解压源码包，并执行以下命令（本步骤是验证编译依赖是否安装完全，若制作DEB包，可跳过此步骤） 1234[root@node106 ~]# cd ceph-12.2.12[root@node106 ~]# sh do_cmake.sh[root@node106 ~]# cd build[root@node106 ~]# make -j5 ​ 编译完成后可以在 build目录下的bin目录下发现编译生成的可执行文件，可以在lib目录下发现编译生成的动态库。 制作DEB包注意事项​ 制作DEB包的过程中，在ceph-12.2.12目录下，debian目录下的文件不要全部加可执行权限，否则会报错 ​ 具体见链接：https://ubuntuforums.org/archive/index.php/t-2257684.html 1234567[root@node106 ~]# chmod -R +x ceph-12.2.12/*## 如果在arm64系统编译，去掉ceph-common.install里的usr/lib/ceph/crypto/* [amd64][root@node106 ~]# chmod -R -x debian/*.dirs[root@node106 ~]# chmod -R -x debian/*.install[root@node106 ~]# chmod -R -x debian/*.doc[root@node106 ~]# chmod -R -x debian/*.lintian-overrides[root@node106 ~]# chmod -R -x debian/*.maintscript 编译DEB包​ 执行下列命令编译 deb包 1[root@node106 ~]# dpkg-buildpackage -us -uc -b -j5 ​ 如果编译中断，使用以下命令继续编译，上一步的命令会导致重新编译 1[root@node106 ~]# dpkg-buildpackage -nc 安装修改依赖​ 编译依赖在上面已经安装完成，此步骤是在生成 DEB包的过程中会有安装包因为版本不符合要求。 ​ ubuntu系统我们可以通过网址https://launchpad.net/ubuntu/+source/和网址http://ports.ubuntu.com/pool/main/来查找对应得安装包。 ​ 针对 debhelper这个安装包我们通过修改配置文件达到要求。123[root@node106 ~]# vim debian/control改成debhelper (&gt;&gt; 9)]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++异常]]></title>
    <url>%2F2018%2F09%2F22%2Fc%2B%2B%E9%AB%98%E7%BA%A7-%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[程序的错误大致可以分为三种，分别是语法错误、逻辑错误和运行时错误： 语法错误在编译和链接阶段就能发现，只有100%符合语法规则的代码才能生成可执行程序。语法错误是最容易发现、最容易定位、最容易排除的错误，程序员最不需要担心的就是这种错误。 逻辑错误是说我们编写的代码思路有问题，不能够达到最终的目标，这种错误可以通过调试来解决。 运行时错误是指程序在运行期间发生的错误，例如除数为0、内存分配失败、数组越界、文件不存在等。C++异常（Exception）机制就是为解决运行时错误而引入的。 异常（Exception）机制运行时错误如果放任不管，系统就会执行默认的操作，终止程序运行，也就是我们常说的程序崩溃（Crash）。C++提供了异常（Exception）机制，让我们能够捕获运行时错误，给程序一次“起死回生”的机会，或者至少告诉用户发生了什么再终止程序。 【例1】一个发生运行时错误的程序： 123456789101112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str = "http://c.biancheng.net"; char ch1 = str[100]; //下标越界，ch1为垃圾值 cout &lt;&lt; ch1 &lt;&lt; endl; char ch2 = str.at(100); //下标越界，抛出异常 cout &lt;&lt; ch2 &lt;&lt; endl; return 0;&#125; ​ 运行代码，在控制台输出ch1的值后程序崩溃。下面我们来分析一下原因。 ​ at()是 string类的一个成员函数，它会根据下标来返回字符串的一个字符。与[ ]不同，at()会检查下标是否越界，如果越界就抛出一个异常；而[ ]不做检查，不管下标是多少都会照常访问。 所谓抛出异常，就是报告一个运行时错误，程序员可以根据错误信息来进一步处理。 ​ 上面的代码中，下标100 显然超出了字符串str的长度。由于第6行代码不会检查下标越界，虽然有逻辑错误，但是程序能够正常运行。而第 8行代码则不同，at()函数检测到下标越界会抛出一个异常，这个异常可以由程序员处理，但是我们在代码中并没有处理，所以系统只能执行默认的操作，也即终止程序执行。 捕获异常​ 我们可以借助C++异常机制来捕获上面的异常，避免程序崩溃。捕获异常的语法为：12345try&#123; // 可能抛出异常的语句 &#125;catch(exceptionType variable)&#123; // 处理异常的语句 &#125; ​ try和catch都是C++中的关键字，后跟语句块，不能省略{ }。try中包含可能会抛出异常的语句，一旦有异常抛出就会被后面的catch捕获。从try的意思可以看出，它只是“检测”语句块有没有异常，如果没有发生异常，它就“检测”不到。catch是“抓住”的意思，用来捕获并处理try检测到的异常；如果try语句块没有检测到异常（没有异常抛出），那么就不会执行catch中的语句。 ​ 这就好比，catch告诉try：你去检测一下程序有没有错误，有错误的话就告诉我，我来处理，没有的话就不要理我！ catch关键字后面的exceptionType variable指明了当前catch可以处理的异常类型，以及具体的出错信息。 【例2】修改上面的代码，加入捕获异常的语句： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;exception&gt;using namespace std;int main()&#123; string str = "http://c.biancheng.net"; try&#123; char ch1 = str[100]; cout&lt;&lt;ch1&lt;&lt;endl; &#125;catch(exception e)&#123; cout&lt;&lt;"[1]out of bound!"&lt;&lt;endl; &#125; try&#123; char ch2 = str.at(100); cout&lt;&lt;ch2&lt;&lt;endl; &#125;catch(exception &amp;e)&#123; //exception类位于&lt;exception&gt;头文件中 cout&lt;&lt;"[2]out of bound!"&lt;&lt;endl; &#125; return 0;&#125; 运行结果：([2]out of bound! ​ 可以看出，第一个try没有捕获到异常，输出了一个没有意义的字符（垃圾值）。因为[ ]不会检查下标越界，不会抛出异常，所以即使有错误，try也检测不到。换句话说，发生异常时必须将异常明确地抛出，try才能检测到；如果不抛出来，即使有异常try也检测不到。所谓抛出异常，就是明确地告诉程序发生了什么错误。 ​ 第二个try检测到了异常，并交给catch处理，执行catch中的语句。需要说明的是，异常一旦抛出，会立刻被try检测到，并且不会再执行异常点（异常发生位置）后面的语句。本例中抛出异常的位置是第17行的 at()函数，它后面的cout语句就不会再被执行，所以看不到它的输出。 ​ 说得直接一点，检测到异常后程序的执行流会发生跳转，从异常点跳转到catch 所在的位置，位于异常点之后的、并且在当前try块内的语句就都不会再执行了；即使 catch语句成功地处理了错误，程序的执行流也不会再回退到异常点，所以这些语句永远都没有执行的机会了。本例中，第18行代码就是被跳过的代码。 ​ 执行完catch块所包含的代码后，程序会继续执行catch块后面的代码，就恢复了正常的执行流。 ​ 为了演示「不明确地抛出异常就检测不到异常」，大家不妨将第10行代码改为char ch1 = str[100000000];，访问第100个字符可能不会发生异常，但是访问第 1 亿个字符肯定会发生异常了，这个异常就是内存访问错误。运行更改后的程序，会发现第10行代码产生了异常，导致程序崩溃了，这说明try-catch并没有捕获到这个异常。 ​ 关于「如何抛出异常」，我们将在下节讲解，这里重点是让大家明白异常的处理流程： ​ 抛出（Throw）--&gt; 检测（Try） --&gt; 捕获（Catch） 发生异常的位置​ 异常可以发生在当前的try块中，也可以发生在try块所调用的某个函数中，或者是所调用的函数又调用了另外的一个函数，这个另外的函数中发生了异常。这些异常，都可以被try检测到。 ​ 1) 下面的例子演示了try块中直接发生的异常： 123456789101112131415#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;exception&gt;using namespace std;int main()&#123; try&#123; throw "Unknown Exception"; //抛出异常 cout&lt;&lt;"This statement will not be executed."&lt;&lt;endl; &#125;catch(const char* &amp;e)&#123; cout&lt;&lt;e&lt;&lt;endl; &#125; return 0;&#125; 运行结果：Unknown Exception ​ throw关键字用来抛出一个异常，这个异常会被 try检测到，进而被catch捕获。关于throw的用法，我们将在下节深入讲解，这里大家只需要知道，在try块中直接抛出的异常会被try检测到。 ​ 2) 下面的例子演示了try块中调用的某个函数中发生了异常： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;exception&gt;using namespace std;void func()&#123; throw "Unknown Exception"; //抛出异常 cout&lt;&lt;"[1]This statement will not be executed."&lt;&lt;endl;&#125;int main()&#123; try&#123; func(); cout&lt;&lt;"[2]This statement will not be executed."&lt;&lt;endl; &#125;catch(const char* &amp;e)&#123; cout&lt;&lt;e&lt;&lt;endl; &#125; return 0;&#125; 运行结果：Unknown Exception ​ func()在try块中被调用，它抛出的异常会被try检测到，进而被catch捕获。从运行结果可以看出，func()中的cout和try中的cout都没有被执行。 ​ 3)try块中调用了某个函数，该函数又调用了另外的一个函数，这个另外的函数抛出了异常： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;exception&gt;using namespace std;void func_inner()&#123; throw "Unknown Exception"; //抛出异常 cout&lt;&lt;"[1]This statement will not be executed."&lt;&lt;endl;&#125;void func_outer()&#123; func_inner(); cout&lt;&lt;"[2]This statement will not be executed."&lt;&lt;endl;&#125;int main()&#123; try&#123; func_outer(); cout&lt;&lt;"[3]This statement will not be executed."&lt;&lt;endl; &#125;catch(const char* &amp;e)&#123; cout&lt;&lt;e&lt;&lt;endl; &#125; return 0;&#125; 运行结果：Unknown Exception ​ 发生异常后，程序的执行流会沿着函数的调用链往前回退，直到遇见try才停止。在这个回退过程中，调用链中剩下的代码（所有函数中未被执行的代码）都会被跳过，没有执行的机会了。 异常类型以及多级catch匹配首先来回顾一下上节讲到的try-catch的用法：12345try&#123; // 可能抛出异常的语句 &#125;catch(exceptionType variable)&#123; // 处理异常的语句 &#125; ​ 我们还遗留下一个问题，就是catch关键字后边的exceptionType variable，这节就来详细分析一下。 ​ exceptionType是异常类型，它指明了当前的 catch 可以处理什么类型的异常；variable`是一个变量，用来接收异常信息。当程序抛出异常时，会创建一份数据，这份数据包含了错误信息，程序员可以根据这些信息来判断到底出了什么问题，接下来怎么处理。 ​ 异常既然是一份数据，那么就应该有数据类型。C++规定，异常类型可以是int、char、float、bool等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型。C++语言本身以及标准库中的函数抛出的异常，都是exception类或其子类的异常。也就是说，抛出异常时，会创建一个exception类或其子类的对象。 ​ exceptionType variable和函数的形参非常类似，当异常发生后，会将异常数据传递给variable这个变量，这和函数传参的过程类似。当然，只有跟exceptionType类型匹配的异常数据才会被传递给variable，否则 catch不会接收这份异常数据，也不会执行catch块中的语句。换句话说，catch不会处理当前的异常。 ​ 我们可以将catch看做一个没有返回值的函数，当异常发生后catch会被调用，并且会接收实参（异常数据）。 但是catch和真正的函数调用又有区别： 真正的函数调用，形参和实参的类型必须要匹配，或者可以自动转换，否则在编译阶段就报错了。 而对于catch，异常是在运行阶段产生的，它可以是任何类型，没法提前预测，所以不能在编译阶段判断类型是否正确，只能等到程序运行后，真的抛出异常了，再将异常类型和catch能处理的类型进行匹配，匹配成功的话就“调用”当前的catch，否则就忽略当前的catch。 总起来说，catch 和真正的函数调用相比，多了一个「在运行阶段将实参和形参匹配」的过程。 另外需要注意的是，如果不希望catch处理异常数据，也可以将variable省略掉，也即写作：12345try&#123; // 可能抛出异常的语句 &#125;catch(exceptionType)&#123; // 处理异常的语句 &#125; ​ 这样只会将异常类型和catch所能处理的类型进行匹配，不会传递异常数据了。 多级catch​ 前面的例子中，一个try对应一个catch，这只是最简单的形式。其实，一个try后面可以跟多个catch： 1234567891011try&#123; //可能抛出异常的语句&#125;catch (exception_type_1 e)&#123; //处理异常的语句&#125;catch (exception_type_2 e)&#123; //处理异常的语句&#125;//其他的catchcatch (exception_type_n e)&#123; //处理异常的语句&#125; ​ 当异常发生时，程序会按照从上到下的顺序，将异常类型和catch所能接收的类型逐个匹配。一旦找到类型匹配的catch就停止检索，并将异常交给当前的catch处理（其他的catch不会被执行）。如果最终也没有找到匹配的catch，就只能交给系统处理，终止程序的运行。 下面的例子演示了多级catch的使用： 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Base&#123; &#125;;class Derived: public Base&#123; &#125;;int main()&#123; try&#123; throw Derived(); //抛出自己的异常类型，实际上是创建一个Derived类型的匿名对象 cout&lt;&lt;"This statement will not be executed."&lt;&lt;endl; &#125;catch(int)&#123; cout&lt;&lt;"Exception type: int"&lt;&lt;endl; &#125;catch(char *)&#123; cout&lt;&lt;"Exception type: cahr *"&lt;&lt;endl; &#125;catch(Base)&#123; //匹配成功（向上转型） cout&lt;&lt;"Exception type: Base"&lt;&lt;endl; &#125;catch(Derived)&#123; cout&lt;&lt;"Exception type: Derived"&lt;&lt;endl; &#125; return 0;&#125; 运行结果：Exception type: Base 在catch中，我们只给出了异常类型，没有给出接收异常信息的变量。 ​ 本例中，我们定义了一个基类Base，又从Base派生类出了Derived。抛出异常时，我们创建了一个Derived类的匿名对象，也就是说，异常的类型是Derived。 ​ 我们期望的是，异常被catch(Derived)捕获，但是从输出结果可以看出，异常提前被catch(Base)捕获了，这说明catch在匹配异常类型时发生了向上转型（Upcasting） catch在匹配过程中的类型转换​ C/C++中存在多种多样的类型转换，以普通函数（非模板函数）为例，发生函数调用时，如果实参和形参的类型不是严格匹配，那么会将实参的类型进行适当的转换，以适应形参的类型，这些转换包括： 算数转换：例如int转换为float，char转换为int，double转换为int等。 向上转型：也就是派生类向基类的转换。 const转换：也即将非const类型转换为const类型，例如将char *转换为const char *。 数组或函数指针转换：如果函数形参不是引用类型，那么数组名会转换为数组指针，函数名也会转换为函数指针。 用户自定的类型转换。 catch在匹配异常类型的过程中，也会进行类型转换，但是这种转换受到了更多的限制，仅能进行「向上转型」、「const 转换」和「数组或函数指针转换」，其他的都不能应用于 catch。 ​ 向上转型在上面的例子中已经发生了，下面的例子演示了const 转换以及数组和指针的转换： 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int nums[] = &#123;1, 2, 3&#125;; try&#123; throw nums; cout&lt;&lt;"This statement will not be executed."&lt;&lt;endl; &#125;catch(const int *)&#123; cout&lt;&lt;"Exception type: const int *"&lt;&lt;endl; &#125; return 0;&#125; 运行结果：Exception type: const int * ​ nums本来的类型是int [3]，但是catch中没有严格匹配的类型，所以先转换为int *，再转换为const int *。 throw（抛出异常）详解​ C++异常处理的流程，具体为： 抛出（Throw）--&gt; 检测（Try） --&gt; 捕获（Catch） ​ 异常必须显式地抛出，才能被检测和捕获到；如果没有显式的抛出，即使有异常也检测不到。 ​ 在C++中，我们使用throw关键字来显式地抛出异常，它的用法为：1throw exceptionData; ​ exceptionData是“异常数据”的意思，它可以包含任意的信息，完全有程序员决定。exceptionData可以是 int、float、bool等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型，请看下面的例子： 12345678910char str[] = "http://c.biancheng.net";char *pstr = str;class Base&#123;&#125;;Base obj;throw 100; //int 类型throw str; //数组类型throw pstr; //指针类型throw obj; //对象类型 一个动态数组的例子​ C/C++规定，数组一旦定义后，它的长度就不能改变了；换句话说，数组容量不能动态地增大或者减小。这样的数组称为静态数组（Static array）。静态数组有时候会给编码代码不便，我们可以通过自定义的Array 类来实现动态数组（Dynamic array）。所谓动态数组，是指数组容量能够在使用的过程中随时增大或减小。 ​ 下面这段代码虽然有点长，但它是一个典型的使用异常的场景，请大家耐心阅读。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;//自定义的异常类型class OutOfRange&#123;public: OutOfRange(): m_flag(1)&#123; &#125;; OutOfRange(int len, int index): m_len(len), m_index(index), m_flag(2)&#123; &#125;public: void what() const; //获取具体的错误信息private: int m_flag; //不同的flag表示不同的错误 int m_len; //当前数组的长度 int m_index; //当前使用的数组下标&#125;;void OutOfRange::what() const &#123; if(m_flag == 1)&#123; cout&lt;&lt;"Error: empty array, no elements to pop."&lt;&lt;endl; &#125;else if(m_flag == 2)&#123; cout&lt;&lt;"Error: out of range( array length "&lt;&lt;m_len&lt;&lt;", access index "&lt;&lt;m_index&lt;&lt;" )"&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;"Unknown exception."&lt;&lt;endl; &#125;&#125;//实现动态数组class Array&#123;public: Array(); ~Array()&#123; free(m_p); &#125;;public: int operator[](int index) const; //获取数组元素 int push(int ele); //在末尾插入数组元素 int pop(); //在末尾删除数组元素 int length() const&#123; return m_len; &#125;; //获取数组长度private: int m_len; //数组长度 int m_capacity; //当前的内存能容纳多少个元素 int *m_p; //内存指针private: static const int m_stepSize = 50; //每次扩容的步长&#125;;Array::Array()&#123; m_p = (int*)malloc( sizeof(int) * m_stepSize ); m_capacity = m_stepSize; m_len = 0;&#125;int Array::operator[](int index) const &#123; if( index&lt;0 || index&gt;=m_len )&#123; //判断是否越界 throw OutOfRange(m_len, index); //抛出异常（创建一个匿名对象） &#125; return *(m_p + index);&#125;int Array::push(int ele)&#123; if(m_len &gt;= m_capacity)&#123; //如果容量不足就扩容 m_capacity += m_stepSize; m_p = (int*)realloc( m_p, sizeof(int) * m_capacity ); //扩容 &#125; *(m_p + m_len) = ele; m_len++; return m_len-1;&#125;int Array::pop()&#123; if(m_len == 0)&#123; throw OutOfRange(); //抛出异常（创建一个匿名对象） &#125; m_len--; return *(m_p + m_len);&#125;//打印数组元素void printArray(Array &amp;arr)&#123; int len = arr.length(); //判断数组是否为空 if(len == 0)&#123; cout&lt;&lt;"Empty array! No elements to print."&lt;&lt;endl; return; &#125; for(int i=0; i&lt;len; i++)&#123; if(i == len-1)&#123; cout&lt;&lt;arr[i]&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;arr[i]&lt;&lt;", "; &#125; &#125;&#125;int main()&#123; Array nums; //向数组中添加十个元素 for(int i=0; i&lt;10; i++)&#123; nums.push(i); &#125; printArray(nums); //尝试访问第20个元素 try&#123; cout&lt;&lt;nums[20]&lt;&lt;endl; &#125;catch(OutOfRange &amp;e)&#123; e.what(); &#125; //尝试弹出20个元素 try&#123; for(int i=0; i&lt;20; i++)&#123; nums.pop(); &#125; &#125;catch(OutOfRange &amp;e)&#123; e.what(); &#125; printArray(nums); return 0;&#125; 运行结果：0, 1, 2, 3, 4, 5, 6, 7, 8, 9Error: out of range( array length 10, access index 20 )Error: empty array, no elements to pop.Empty array! No elements to print. ​ Array类实现了动态数组，它的主要思路是：在创建对象时预先分配出一定长度的内存（通过malloc()分配），内存不够用时就再扩展内存（通过realloc() 重新分配）。Array数组只能在尾部一个一个地插入（通过push()插入）或删除（通过pop()删除）元素。 ​ 我们通过重载过的[ ]运算符来访问数组元素，如果下标过小或过大，就会抛出异常（第53行代码）；在抛出异常的同时，我们还记录了当前数组的长度和要访问的下标。 ​ 在使用pop()删除数组元素时，如果当前数组为空，也会抛出错误。 throw用作异常规范​ throw关键字除了可以用在函数体中抛出异常，还可以用在函数头和函数体之间，指明当前函数能够抛出的异常类型，这称为异常规范（Exception specification），有些教程也称为异常指示符或异常列表。请看下面的例子：1double func (char param) throw (int); ​ 这条语句声明了一个名为func的函数，它的返回值类型为double，有一个char类型的参数，并且只能抛出int类型的异常。如果抛出其他类型的异常，try将无法捕获，只能终止程序。 ​ 如果函数会抛出多种类型的异常，那么可以用逗号隔开：1double func (char param) throw (int, char, exception); ​ 如果函数不会抛出任何异常，那么( )中什么也不写：1double func (char param) throw (); ​ 如此，func()函数就不能抛出任何类型的异常了，即使抛出了，try也检测不到。 1) 虚函数中的异常规范​ C++规定，派生类虚函数的异常规范必须与基类虚函数的异常规范一样严格，或者更严格。只有这样，当通过基类指针（或者引用）调用派生类虚函数时，才能保证不违背基类成员函数的异常规范。请看下面的例子： 123456789101112class Base&#123;public: virtual int fun1(int) throw(); virtual int fun2(int) throw(int); virtual string fun3() throw(int, string);&#125;;class Derived:public Base&#123;public: int fun1(int) throw(int); //错！异常规范不如 throw() 严格 int fun2(int) throw(int); //对！有相同的异常规范 string fun3() throw(string); //对！异常规范比 throw(int,string) 更严格&#125; 2) 异常规范与函数定义和函数声明​ C++规定，异常规范在函数声明和函数定义中必须同时指明，并且要严格保持一致，不能更加严格或者更加宽松。 ​ 请看下面的几组函数： 1234567891011//错！定义中有异常规范，声明中没有void func1();void func1() throw(int) &#123; &#125;//错！定义和声明中的异常规范不一致void func2() throw(int);void func2() throw(int, bool) &#123; &#125;//对！定义和声明中的异常规范严格一致void func3() throw(float, char*);void func3() throw(float, char*) &#123; &#125; 请抛弃异常规范，不要再使用它​ 异常规范的初衷是好的，它希望让程序员看到函数的定义或声明后，立马就知道该函数会抛出什么类型的异常，这样程序员就可以使用 try-catch来捕获了。如果没有异常规范，程序员必须阅读函数源码才能知道函数会抛出什么异常。 ​ 不过这有时候也不容易做到。例如，func_outer()函数可能不会引发异常，但它调用了另外一个函数 func_inner()，这个函数可能会引发异常。再如，您编写的函数调用了老式的库函数，此时不会引发异常，但是库更新以后这个函数却引发了异常。总之，异常规范的初衷实现起来有点困难，所以大家达成的一致意见是，最好不要使用异常规范。 ​ 异常规范是C++98新增的一项功能，但是后来的C++11已经将它抛弃了，不再建议使用。 ​ 另外，各个编译器对异常规范的支持也不一样，请看下面的代码： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;exception&gt;using namespace std;void func()throw(char*, exception)&#123; throw 100; cout&lt;&lt;"[1]This statement will not be executed."&lt;&lt;endl;&#125;int main()&#123; try&#123; func(); &#125;catch(int)&#123; cout&lt;&lt;"Exception type: int"&lt;&lt;endl; &#125; return 0;&#125; ​ 在GCC下，这段代码运行到第 7 行时程序会崩溃。虽然func()函数中发生了异常，但是由于throw限制了函数只能抛出char*、exception类型的异常，所以 try-catch将捕获不到异常，只能交给系统处理，终止程序。​ 在Visual C++下，输出结果为Exception type: int，这说明异常被成功捕获了。在 Visual C++中使用异常规范虽然没有语法错误，但是也没有任何效果，Visual C++会直接忽略异常规范的限制，函数可以抛出任何类型的异常。 exception类：C++标准异常的基类​ C++语言本身或者标准库抛出的异常都是exception的子类，称为标准异常（Standard Exception）。你可以通过下面的语句来捕获所有的标准异常： 12345try&#123; //可能抛出异常的语句&#125;catch(exception &amp;e)&#123; //处理异常的语句&#125; ​ 之所以使用引用，是为了提高效率。如果不使用引用，就要经历一次对象拷贝（要调用拷贝构造函数）的过程。 ​ exception类位于&lt;exception&gt;头文件中，它被声明为： 12345678class exception&#123;public: exception () throw(); //构造函数 exception (const exception&amp;) throw(); //拷贝构造函数 exception&amp; operator= (const exception&amp;) throw(); //运算符重载 virtual ~exception() throw(); //虚析构函数 virtual const char* what() const throw(); //虚函数&#125; ​ 这里需要说明的是what()函数。what()函数返回一个能识别异常的字符串，正如它的名字“what”一样，可以粗略地告诉你这是什么异常。不过C++标准并没有规定这个字符串的格式，各个编译器的实现也不同，所以what()的返回值仅供参考。 下图展示了exception类的继承层次： 图：exception 类的继承层次以及它们所对应的头文件 先来看一下exception类的直接派生类： 异常名称 说 明 logic_error 逻辑错误。 runtime_error 运行时错误。 bad_alloc 使用new或new[ ]分配内存失败时抛出的异常。 bad_typeid 使用typeid 操作一个NULL指针，而且该指针是带有虚函数的类，这时抛出bad_typeid异常。 bad_cast 使用dynamic_cast转换失败时抛出的异常。 ios_base::failure io过程中出现的异常。 bad_exception 这是个特殊的异常，如果函数的异常列表里声明了bad_exception异常，当函数内部抛出了异常列表中没有的异常时，如果调用的unexpected()函数中抛出了异常，不论什么类型，都会被替换为bad_exception类型。 logic_error的派生类： 异常名称 说 明 length_error 试图生成一个超出该类型最大长度的对象时抛出该异常，例如vector的resize 操作。 domain_error 参数的值域错误，主要用在数学函数中，例如使用一个负值调用只能操作非负数的函数。 out_of_range 超出有效范围。 invalid_argument 参数不合适。在标准库中，当利用string对象构造 bitset时，而 string中的字符不是0 或1的时候，抛出该异常。 runtime_error的派生类： 异常名称 说 明 range_error 计算结果超出了有意义的值域范围。 overflow_error 算术计算上溢。 underflow_error 算术计算下溢。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++类型转换]]></title>
    <url>%2F2018%2F09%2F17%2Fc%2B%2B%E9%AB%98%E7%BA%A7-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[C++类型转换​ 类型转换(cast)是将一种数据类型转换成另一种数据类型。例如，如果将一个整型值赋给一个浮点类型的变量，编译器会暗地里将其转换成浮点类型。 ​ 转换是非常有用的，但是它也会带来一些问题，比如在转换指针时，我们很可能将其转换成一个比它更大的类型，但这可能会破坏其他的数据。 ​ 应该小心类型转换，因为转换也就相当于对编译器说：忘记类型检查，把它看做其他的类型。 ​ 一般情况下，尽量少的去使用类型转换，除非用来解决非常特殊的问题。 ​ 标准c++提供了一个显示的转换的语法，来替代旧的C风格的类型转换。 ​ 使用C风格的强制转换可以把想要的任何东西转换成我们需要的类型。那为什么还需要一个新的C++类型的强制转换呢？ ​ 新类型的强制转换可以提供更好的控制强制转换过程，允许控制各种不同种类的强制转换。C++风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么。程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的。 静态转换(static_cast) 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的； 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。 用于基本数据类型之间的转换，如把int转换成char，把char转换成int。这种转换的安全性也要开发人员来保证。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Animal&#123;&#125;;class Dog : public Animal&#123;&#125;;class Other&#123;&#125;;//基础数据类型转换void test01()&#123; char a = 'a'; double b = static_cast&lt;double&gt;(a);&#125;//继承关系指针互相转换void test02()&#123; //继承关系指针转换 Animal* animal01 = NULL; Dog* dog01 = NULL; //子类指针转成父类指针,安全 Animal* animal02 = static_cast&lt;Animal*&gt;(dog01); //父类指针转成子类指针，不安全 Dog* dog02 = static_cast&lt;Dog*&gt;(animal01);&#125;//继承关系引用相互转换void test03()&#123; Animal ani_ref; Dog dog_ref; //继承关系指针转换 Animal&amp; animal01 = ani_ref; Dog&amp; dog01 = dog_ref; //子类指针转成父类指针,安全 Animal&amp; animal02 = static_cast&lt;Animal&amp;&gt;(dog01); //父类指针转成子类指针，不安全 Dog&amp; dog02 = static_cast&lt;Dog&amp;&gt;(animal01);&#125;//无继承关系指针转换void test04()&#123; Animal* animal01 = NULL; Other* other01 = NULL; //转换失败 //Animal* animal02 = static_cast&lt;Animal*&gt;(other01);&#125; 动态转换(dynamic_cast)​ 用reinterpret_cast可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL指针。 ​ dynamic_cast 是通过“运行时类型检查”来保证安全性的。dynamic_cast不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用reinterpret_cast来完成。 dynamic_cast主要用于类层次间的上行转换和下行转换； 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的； 在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Animal &#123;public: virtual void ShowName() = 0;&#125;;class Dog : public Animal&#123; virtual void ShowName()&#123; cout &lt;&lt; "I am a dog!" &lt;&lt; endl; &#125;&#125;;class Other &#123;public: void PrintSomething()&#123; cout &lt;&lt; "我是其他类!" &lt;&lt; endl; &#125;&#125;;//普通类型转换void test01()&#123; //不支持基础数据类型 int a = 10; //double a = dynamic_cast&lt;double&gt;(a);&#125;//继承关系指针void test02()&#123; Animal* animal01 = NULL; Dog* dog01 = new Dog; //子类指针转换成父类指针 可以 Animal* animal02 = dynamic_cast&lt;Animal*&gt;(dog01); animal02-&gt;ShowName(); //父类指针转换成子类指针 不可以 //Dog* dog02 = dynamic_cast&lt;Dog*&gt;(animal01);&#125;//继承关系引用void test03()&#123; Dog dog_ref; Dog&amp; dog01 = dog_ref; //子类引用转换成父类引用 可以 Animal&amp; animal02 = dynamic_cast&lt;Animal&amp;&gt;(dog01); animal02.ShowName();&#125;//无继承关系指针转换void test04()&#123; Animal* animal01 = NULL; Other* other = NULL; //不可以 //Animal* animal02 = dynamic_cast&lt;Animal*&gt;(other);&#125; 常量转换(const_cast)该运算符用来修改类型的const属性。 常量指针被转化成非常量指针，并且仍然指向原来的对象； 常量引用被转换成非常量引用，并且仍然指向原来的对象； 注意:不能直接对非指针和非引用的变量使用const_cast操作符去直接移除它的const。 12345678910111213141516171819202122//常量指针转换成非常量指针void test01()&#123; const int* p = NULL; int* np = const_cast&lt;int*&gt;(p); int* pp = NULL; const int* npp = const_cast&lt;const int*&gt;(pp); const int a = 10; //不能对非指针或非引用进行转换 //int b = const_cast&lt;int&gt;(a); &#125;//常量引用转换成非常量引用void test02()&#123; int num = 10; int &amp; refNum = num; const int&amp; refNum2 = const_cast&lt;const int&amp;&gt;(refNum); &#125; 重新解释转换(reinterpret_cast)​ 这是最不安全的一种转换机制，最有可能出问题。 ​ 主要用于将一种数据类型从一种类型转换为另一种类型。它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针. ​ reinterpret_cast用法示例如下： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class A&#123;public: int i; int j; A(int n):i(n),j(n) &#123; &#125;&#125;;int main()&#123; A a(100); int &amp;r = reinterpret_cast&lt;int&amp;&gt;(a); //强行让 r 引用 a r = 200; //把 a.i 变成了 200 cout &lt;&lt; a.i &lt;&lt; "," &lt;&lt; a.j &lt;&lt; endl; // 输出 200,100 int n = 300; A *pa = reinterpret_cast&lt;A*&gt; ( &amp; n); //强行让 pa 指向 n pa-&gt;i = 400; // n 变成 400 pa-&gt;j = 500; //此条语句不安全，很可能导致程序崩溃 cout &lt;&lt; n &lt;&lt; endl; // 输出 400 long long la = 0x12345678abcdLL; pa = reinterpret_cast&lt;A*&gt;(la); //la太长，只取低32位0x5678abcd拷贝给pa unsigned int u = reinterpret_cast&lt;unsigned int&gt;(pa);//pa逐个比特拷贝到u cout &lt;&lt; hex &lt;&lt; u &lt;&lt; endl; //输出 5678abcd typedef void (* PF1) (int); typedef int (* PF2) (int,char *); PF1 pf1; PF2 pf2; pf2 = reinterpret_cast&lt;PF2&gt;(pf1); //两个不同类型的函数指针之间可以互相转换&#125; 程序的输出结果是：200, 1004005678abed ​ 第19行的代码不安全，因为在编译器看来，pa-&gt;j的存放位置就是n后面的4个字节。 本条语句会向这 4个字节中写入 500。但这4个字节不知道是用来存放什么的，贸然向其中写入可能会导致程序错误甚至崩溃。 ​ 上面程序中的各种转换都没有实际意义，只是为了演示reinteipret_cast的用法而已。在编写黑客程序、病毒或反病毒程序时，也许会用到这样怪异的转换。 ​ reinterpret_cast体现了C++语言的设计思想：用户可以做任何操作，但要为自己的行为负责。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++STL库函数set]]></title>
    <url>%2F2018%2F09%2F14%2Fc%2B%2B-STL%E5%BA%93%E5%87%BD%E6%95%B0set%E5%92%8Cmultiset%2F</url>
    <content type="text"><![CDATA[set/multiset容器set/multiset容器基本概念set容器基本概念​ Set的特性是：所有元素都会根据元素的键值自动被排序。Set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值。Set不允许两个元素有相同的键值。 ​ 我们可以通过set的迭代器改变set元素的值吗？不行，因为set元素值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。换句话说，set的iterator是一种const_iterator。 ​ set拥有和list某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外。 multiset容器基本概念​ multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。 set/multiset定义multiset定义​ 不能直接修改multiset容器中元素的值。因为元素被修改后，容器并不会自动重新调整顺序，于是容器的有序性就会被破坏，再在其上进行查找等操作就会得到错误的结果。因此，如果要修改multiset容器中某个元素的值，正确的做法是先删除该元素，再插入新元素。 ​ 使用multiset必须包含头文件&lt;set&gt;。multiset类模板的定义如下：123template &lt;class Key, class Pred = less&lt;Key&gt;, class B = allocator&lt;Key&gt; &gt; class multiset &#123; ... &#125;; ​ 该模板有三个类型参数：Key、Pred和B。类型参数可以有默认值，默认值就是某种类型。例如，Pred类型参数的默认值就是less&lt;Key&gt;类型，B的默认值就是allocator&lt;Key&gt;类型。第三个类型参数极少用到，一般都用默认值，因此这里不做介绍。 ​ 第一个类型参数说明multiset容器中的每个元素都是Key类型的。第二个类型参数Pred用于指明容器中元素的排序规则，在被实例化后，Pred 可以是函数对象类，也可以是函数指针类型。 ​ multiset内部在排序时定义了一个变量Pred op，根据表达式op(x, y)来比较两个元素x、y的大小。该表达式的值为true，则说明x比y小。Pred的默认值是less&lt;Key&gt;，less是STL中的函数对象类模板，其定义如下： 123456template &lt;class_Tp&gt;struct less&#123; bool operator() (const _Tp &amp;__x, const _Tp &amp;__y) const &#123; return __x &lt; __y; &#125;&#125;; ​ 这说明，在默认情况下，multiset容器中的元素是用&lt;运算符比较大小的。例如，假设A是一个类的名字，可以定义一个如下的容器对象：1multiset &lt;A&gt; s; ​ 由于multiset的类型参数可以使用默认值，因此上面的语句等价于：1multiset &lt; int, less&lt;A&gt;, allocator&lt;A&gt; &gt; s; ​ 模板类multiset &lt; A, less&lt;A&gt;, allocator&lt;A&gt; &gt;的insert成员函数可以用来插入一个元素。 插入过程中需要进行元素之间的比较，可以认为insert成员函数中定义了一个变量less &lt;A&gt; op，用op(x, y)来比较元素x、y的大小。归根到底，还是用&lt;运算符比较x、y的大小。 因此，&lt;运算符必须经过适当重载，才可以向multiset &lt;A&gt;容器中插人元素。 ​ 下面的程序 会编译出错： 1234567#include &lt;set&gt;using namespace std;class A&#123;&#125;;int main()&#123; multiset &lt;A&gt; a; a.insert( A() ); //编译出错，因为不能用“&lt;”运算符比较两个A对象&#125; set定义​ 使用set必须包含头文件&lt;set&gt;。set的定义如下：1template &lt; class Key, class Pred = less&lt;Key&gt;, class A = allocator&lt;Key&gt; &gt; class set &#123;...&#125; ​ 由于不能有重复元素，所以set中插入单个元素的insert成员函数与multiset中的有所不同，其原型如下：1pair&lt;iterator, bool&gt; insert(const T &amp; val); ​ 如果set的insert成员函数的返回值是pair模板类对象x，如果x.second为true，则说明插入成功，此时x.first就是指向被插入元素的迭代器；如果x.second为false，则说明要插入的元素已在容器中，此时x.first就是指向原有那个元素的迭代器。 ​ 关联容器的equal_range成员函数的返回值也是pair模板类对象，其原型如下：1pair&lt;iterator, iterator&gt; equal_range(const T &amp; val); ​ 返回值对象中的first就是lower_bound的值，second就是upper_bound的值。 set/multiset实现原理set和multiset的底层实现是红黑树，红黑树为平衡二叉树的一种。 树的简单知识： ​ 二叉树就是任何节点最多只允许有两个子节点。分别是左子结点和右子节点。 ​ 二叉搜索树，是指二叉树中的节点按照一定的规则进行排序，使得对二叉树中元素访问更加高效。二叉搜索树的放置规则是：任何节点的元素值一定大于其左子树中的每一个节点的元素值，并且小于其右子树的值。因此从根节点一直向左走，一直到无路可走，即得到最小值，一直向右走，直至无路可走，可得到最大值。那么在二叉搜索树中找到最大元素和最小元素是非常简单的事情。下图为二叉搜索树： 上面我们介绍了二叉搜索树，那么当一个二叉搜索树的左子树和右子树不平衡的时候，那么搜索依据上图表示，搜索`9`所花费的时间要比搜索`17`所花费的时间要多，由于我们的输入或者经过我们插入或者删除操作，二叉树失去平衡，造成搜索效率降低。 ​ 所以我们有了一个平衡二叉树的概念，所谓的平衡不是指的完全平衡。 ​ RB-tree(红黑树)为二叉树的一种。 set/multiset常用API 成员函数或成员函数模板 作 用 iterator find (const T &amp; val); 在容器中查找值为val的元素，返回其迭代器。如果找不到，返 回end() iterator insert( const T &amp; val); 将val插入容器中并返回其迭代器 void insert(iterator first, iterator last); 将区间[first, last)中的元素插人容器 int count( const T &amp; val); 统计有多少个元素的值和val相等 iterator lower_bound( const T &amp; val); 查找一个最大的位置 it，使得[begin(), it)中所有的元素者比val小 iterator upper_bound( const T &amp; val); 查找一个最小的位置it，使得[it, end())中所有的元素都比val大 pair &lt;iterator, iterator &gt; equal_range (const T &amp; val); 同时求得lower_bound 和upper_bound iterator erase(iterator it); 删除it指向的元素，返回其后面的元素的迭代器（Visual Studio 2010中如此，但是在C++标准和Dev C++中，返回值不是这样） iterator erase(iterator first, iterator last); 删除区间[first, last)，返回last（Visual Studio 2010中如此，但是在 C++标准和 Dev C++中，返回值不是这样）multiset及 set中的find和 count并不是用==运算符比较元素是否和待查找的值相等的。它们进行比较的原则是：如果x比y小和y比x小同时为假，就认为x和y相等。 set/multiset构造函数123set&lt;T&gt; st; //set默认构造函数：mulitset&lt;T&gt; mst; //multiset默认构造函数: set(const set &amp;st); //拷贝构造函数 set/multiset赋值操作12set&amp; operator=(const set &amp;st); //重载等号操作符swap(st); //交换两个集合容器 set/multiset大小操作12size(); //返回容器中元素的数目empty(); //判断容器是否为空 set/multiset插入和删除操作12345insert(elem); //在容器中插入元素。clear(); //清除所有元素erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。erase(beg, end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。erase(elem); //删除容器中值为elem的元素。 set/multiset查找操作12345find(key); //查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();count(key); //查找键key的元素个数lower_bound(keyElem); //返回第一个key&gt;=keyElem元素的迭代器。upper_bound(keyElem); //返回第一个key&gt;keyElem元素的迭代器。equal_range(keyElem); //返回容器中key与keyElem相等的上下限的两个迭代器。 multiset的用法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;set&gt; //使用multiset须包含此头文件using namespace std;template &lt;class T&gt;void Print(T first, T last)&#123; for (; first != last; ++first) cout &lt;&lt; *first &lt;&lt; " "; cout &lt;&lt; endl;&#125;class A&#123;private: int n;public: A(int n_) &#123; n = n_; &#125; friend bool operator &lt; (const A &amp; a1, const A &amp; a2) &#123; return a1.n &lt; a2.n; &#125; friend ostream &amp; operator &lt;&lt; (ostream &amp; o, const A &amp; a2) &#123; o &lt;&lt; a2.n; return o; &#125; friend class MyLess;&#125;;class MyLess&#123;public: bool operator() (const A &amp; a1, const A &amp; a2) //按个位数比较大小 &#123; return (a1.n % 10) &lt; (a2.n % 10); &#125;&#125;;typedef multiset &lt;A&gt; MSET1; //MSET1 用“&lt;”运算符比较大小typedef multiset &lt;A, MyLess&gt; MSET2; //MSET2 用 MyLess::operator() 比较大小int main()&#123; const int SIZE = 6; A a[SIZE] = &#123; 4, 22, 19, 8, 33, 40 &#125;; MSET1 m1; m1.insert(a, a + SIZE); m1.insert(22); cout &lt;&lt; "1)" &lt;&lt; m1.count(22) &lt;&lt; endl; //输出 1)2 cout &lt;&lt; "2)"; Print(m1.begin(), m1.end()); //输出 2)4 8 19 22 22 33 40 MSET1::iterator pp = m1.find(19); if (pp != m1.end()) //条件为真说明找到 cout &lt;&lt; "found" &lt;&lt; endl; //本行会被执行，输出 found cout &lt;&lt; "3)"; cout &lt;&lt; *m1.lower_bound(22) &lt;&lt; "," &lt;&lt; *m1.upper_bound(22) &lt;&lt; endl; //输出 3)22,33 pp = m1.erase(m1.lower_bound(22), m1.upper_bound(22)); //pp指向被删元素的下一个元素 cout &lt;&lt; "4)"; Print(m1.begin(), m1.end()); //输出 4)4 8 19 33 40 cout &lt;&lt; "5)"; cout &lt;&lt; *pp &lt;&lt; endl; //输出 5)33 MSET2 m2; //m2中的元素按n的个位数从小到大排序 m2.insert(a, a + SIZE); cout &lt;&lt; "6)"; Print(m2.begin(), m2.end()); //输出 6)40 22 33 4 8 19 return 0;&#125; ​ 第33行，MSET2类的排序规则和MSET1不同。MSET2用MyLess定义排序规则，即n的个位数小的元素排在前面。 ​ 第49、50行，lower_bound返回的迭代器指向第一个22，upper_bound返回的迭代器指向 33。 ​ 第52行，删除所有值为22 的元素。erase成员函数删除一个元素后，返回下一个元素的迭代器应该是很合理的，但是C++标准委员会认为，返回下一个元素的迭代器也是需要时间开销的，如果程序员不想要这个返回值，那么这个开销就是浪费的——因此在遵循C++标准的Dev C++ 中，本行无法编译通过。但是微软公司认为应该对这一点做出改进，因此Visual Studio 2010将erase 成员函数处理成返回被删元素下一个元素的迭代器。 set的用法123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;set&gt; //使用set须包含此文件using namespace std;int main()&#123; typedef set&lt;int&gt;::iterator IT; int a[5] = &#123; 3,4,6,1,2 &#125;; set&lt;int&gt; st(a,a+5); // st里是 1 2 3 4 6 pair&lt; IT,bool&gt; result; result = st.insert(5); // st变成 1 2 3 4 5 6 if(result.second) //插入成功则输出被插入元素 cout &lt;&lt; * result.first &lt;&lt; " inserted" &lt;&lt; endl; //输出: 5 inserted if(st.insert(5).second) cout &lt;&lt; * result.first &lt;&lt; endl; else cout &lt;&lt; * result.first &lt;&lt; " already exists" &lt;&lt; endl; //输出 5 already exists pair&lt;IT,IT&gt; bounds = st.equal_range(4); cout &lt;&lt; * bounds.first &lt;&lt; "," &lt;&lt; * bounds.second ; //输出：4,5 return 0;&#125; 程序的输出结果是：5 inserted5 already exists4,5 指定set排序规则12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//插入操作返回值void test01()&#123; set&lt;int&gt; s; pair&lt;set&lt;int&gt;::iterator,bool&gt; ret = s.insert(10); if (ret.second)&#123; cout &lt;&lt; "插入成功:" &lt;&lt; *ret.first &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; "插入失败:" &lt;&lt; *ret.first &lt;&lt; endl; &#125; ret = s.insert(10); if(ret.second)&#123; cout &lt;&lt; "插入成功:" &lt;&lt; *ret.first &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; "插入失败:" &lt;&lt; *ret.first &lt;&lt; endl; &#125;&#125;struct MyCompare02&#123; bool operator()(int v1,int v2)&#123; return v1 &gt; v2; &#125;&#125;;//set从大到小void test02()&#123; srand((unsigned int)time(NULL)); //我们发现set容器的第二个模板参数可以设置排序规则，默认规则是less&lt;_Kty&gt; set&lt;int, MyCompare02&gt; s; for (int i = 0; i &lt; 10;i++)&#123; s.insert(rand() % 100); &#125; for (set&lt;int, MyCompare02&gt;::iterator it = s.begin(); it != s.end(); it ++)&#123; cout &lt;&lt; *it &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125;//set容器中存放对象class Person&#123;public: Person(string name,int age)&#123; this-&gt;mName = name; this-&gt;mAge = age; &#125;public: string mName; int mAge;&#125;;struct MyCompare03&#123; bool operator()(const Person&amp; p1,const Person&amp; p2)&#123; return p1.mAge &gt; p2.mAge; &#125;&#125;;void test03()&#123; set&lt;Person, MyCompare03&gt; s; Person p1("aaa", 20); Person p2("bbb", 30); Person p3("ccc", 40); Person p4("ddd", 50); s.insert(p1); s.insert(p2); s.insert(p3); s.insert(p4); for (set&lt;Person, MyCompare03&gt;::iterator it = s.begin(); it != s.end(); it++)&#123; cout &lt;&lt; "Name:" &lt;&lt; it-&gt;mName &lt;&lt; " Age:" &lt;&lt; it-&gt;mAge &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++STL库函数map]]></title>
    <url>%2F2018%2F09%2F11%2Fc%2B%2B-STL%E5%BA%93%E5%87%BD%E6%95%B0map%E5%92%8Cmultimap%2F</url>
    <content type="text"><![CDATA[map/multimap容器map/multimap基本概念​ map的特性是，所有元素都会根据元素的键值自动排序。map所有的元素都是pair，同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。 ​ 我们可以通过map的迭代器改变map的键值吗？答案是不行，因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，那么是可以的。 ​ map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。 ​ multimap和map的操作类似，唯一区别multimap键值可重复。 ​ map和multimap都是以红黑树为底层实现机制。 map/multimap定义multimap定义​ 使用multimap 必须包含头文件map。multimap的定义如下：1234567template &lt; class Key, class T, class Pred = less&lt;Key&gt;, class A = allocator&lt;T&gt; &gt; class multimap &#123; ... typedef pair &lt;const Key, T&gt; value_type; ... &#125;; ​ multimap中的元素都是pair模板类的对象。元素的first成员变量也叫“关键字”，second成员变量也叫“值”。multimap容器中的元素是按关键字从小到大排序的。默认情况下，元素的关键之间用less &lt;Key&gt; 比较大小，也就是用&lt;运算符比较大小。multimap允许多个元素的关键字相同。 ​ multimap中的value_type实际上就表示容器中元素的类型。C++允许在类的内部定义类型。 map定义​ 要使用map，必须包含头文件&lt;map&gt;。map的定义如下：123456template &lt; class Key, class T, class Pred = less&lt;Key&gt;, class A = allocator&lt;T&gt; &gt; class map&#123; ... typedef pair&lt; const Key, T &gt; value_type; ... &#125;; ​ map和multimap十分类似，区别在于map容器中元素的关键字不能重复。multimap有的成员函数，map都有。此外，map还有成员函数operator[]：1T &amp; operator[] (Key k); ​ 该成员函数返回first值为k的元素的second部分的引用。如果容器中没有元素的first值等于k，则自动添加一个first值为k的元素。如果该元素的second成员变量是一个对象，则用无参构造函数对其初始化。 map/multimap常用API 成员函数或成员函数模板 作 用 iterator find( const Key &amp; val); 在容器中查找关键字等于val 的元素，返回其迭代器；如果找不到，返回end() iterator insert (pair &lt;Key, T&gt; const &amp;p); 将pair 对象p插入容器中并返回其迭代器 void insert(iterator first, iterator last); 将区间[first, last)插入容器 int count( const Key &amp; val); 统计有多少个元素的关键字和val相等 iterator lower_bound( const Key &amp; val); 查找一个最大的位置it，使得[begin( ), it)中所有的元素的关键字都比val小 iterator upper_bound(const Key &amp; val); 查找一个最小的位置it，使得[it, end())中所有的元素的关键字都比val大 pair &lt; iterator, iterator &gt; equal_range (const Key &amp; val); 同时求得lower_bound和upper_bound iterator erase(iterator it); 删除it指向的元素，返回其后面的元素的迭代器（Visual Studio 2010中如此，但是在C++标准和Dev C++中，返回值不是这样） iterator erase(iterator first, iterator last); 删除区间[first, last)，返回last（Visual Studio 2010中如此，但是在C++标准和Dev C++中，返回值不是这样） ​ multimap及map中的find和count不用==运算符比较两个关键字是否相等。如果x比y小和y比x小同时为假，就认为 x和y相等。 map/multimap构造函数12map&lt;T1, T2&gt; mapTT; //map默认构造函数: map(const map &amp;mp); //拷贝构造函数 map/multimap赋值操作12map&amp; operator=(const map &amp;mp); //重载等号操作符swap(mp); //交换两个集合容器 map/multimap大小操作12size(); //返回容器中元素的数目empty(); //判断容器是否为空 map/multimap插入数据元素操作123456789101112map.insert(...); //往容器插入元素，返回pair&lt;iterator,bool&gt;map&lt;int, string&gt; mapStu;// 第一种 通过pair的方式插入对象mapStu.insert(pair&lt;int, string&gt;(3, "小张"));// 第二种 通过pair的方式插入对象mapStu.inset(make_pair(-1, "校长"));// 第三种 通过value_type的方式插入对象mapStu.insert(map&lt;int, string&gt;::value_type(1, "小李"));// 第四种 通过数组的方式插入值mapStu[3] = "小刘";mapStu[5] = "小王"; map/multimap删除操作1234clear(); //删除所有元素erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。erase(beg,end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。erase(keyElem); //删除容器中key为keyElem的对组。 map/multimap查找操作12345find(key); //查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();count(keyElem); //返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。lower_bound(keyElem); //返回第一个key&gt;=keyElem元素的迭代器。upper_bound(keyElem); //返回第一个key&gt;keyElem元素的迭代器。equal_range(keyElem); //返回容器中key与keyElem相等的上下限的两个迭代器。 multimap用法案例一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;//multimap 案例//公司今天招聘了 5 个员工，5 名员工进入公司之后，需要指派员工在那个部门工作//人员信息有: 姓名 年龄 电话 工资等组成//通过 Multimap 进行信息的插入 保存 显示//分部门显示员工信息 显示全部员工信息#define SALE_DEPATMENT 1 //销售部门#define DEVELOP_DEPATMENT 2 //研发部门#define FINACIAL_DEPATMENT 3 //财务部门#define ALL_DEPATMENT 4 //所有部门//员工类class person&#123;public: string name; //员工姓名 int age; //员工年龄 double salary; //员工工资 string tele; //员工电话&#125;;//创建5个员工void CreatePerson(vector&lt;person&gt;&amp; vlist)&#123; string seed = "ABCDE"; for (int i = 0; i &lt; 5; i++)&#123; person p; p.name = "员工"; p.name += seed[i]; p.age = rand() % 30 + 20; p.salary = rand() % 20000 + 10000; p.tele = "010-8888888"; vlist.push_back(p); &#125;&#125;//5名员工分配到不同的部门void PersonByGroup(vector&lt;person&gt;&amp; vlist, multimap&lt;int, person&gt;&amp; plist)&#123; int operate = -1; //用户的操作 for (vector&lt;person&gt;::iterator it = vlist.begin(); it != vlist.end(); it++)&#123; cout &lt;&lt; "当前员工信息:" &lt;&lt; endl; cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;name &lt;&lt; " 年龄:" &lt;&lt; it-&gt;age &lt;&lt; " 工资:" &lt;&lt; it-&gt;salary &lt;&lt; " 电话：" &lt;&lt; it-&gt;tele &lt;&lt; endl; cout &lt;&lt; "请对该员工进行部门分配(1 销售部门, 2 研发部门, 3 财务部门):" &lt;&lt; endl; scanf("%d", &amp;operate); while (true)&#123; if (operate == SALE_DEPATMENT)&#123; //将该员工加入到销售部门 plist.insert(make_pair(SALE_DEPATMENT, *it)); break; &#125; else if (operate == DEVELOP_DEPATMENT)&#123; plist.insert(make_pair(DEVELOP_DEPATMENT, *it)); break; &#125; else if (operate == FINACIAL_DEPATMENT)&#123; plist.insert(make_pair(FINACIAL_DEPATMENT, *it)); break; &#125; else&#123; cout &lt;&lt; "您的输入有误，请重新输入(1 销售部门, 2 研发部门, 3 财务部门):" &lt;&lt; endl; scanf("%d", &amp;operate); &#125; &#125; &#125; cout &lt;&lt; "员工部门分配完毕!" &lt;&lt; endl; cout &lt;&lt; "***********************************************************" &lt;&lt; endl;&#125;//打印员工信息void printList(multimap&lt;int, person&gt;&amp; plist, int myoperate)&#123; if (myoperate == ALL_DEPATMENT)&#123; for (multimap&lt;int, person&gt;::iterator it = plist.begin(); it != plist.end(); it++)&#123; cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;second.name &lt;&lt; " 年龄:" &lt;&lt; it-&gt;second.age &lt;&lt; " 工资:" &lt;&lt; it-&gt;second.salary &lt;&lt; " 电话：" &lt;&lt; it-&gt;second.tele &lt;&lt; endl; &#125; return; &#125; multimap&lt;int, person&gt;::iterator it = plist.find(myoperate); int depatCount = plist.count(myoperate); int num = 0; if (it != plist.end())&#123; while (it != plist.end() &amp;&amp; num &lt; depatCount)&#123; cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;second.name &lt;&lt; " 年龄:" &lt;&lt; it-&gt;second.age &lt;&lt; " 工资:" &lt;&lt; it-&gt;second.salary &lt;&lt; " 电话：" &lt;&lt; it-&gt;second.tele &lt;&lt; endl; it++; num++; &#125; &#125;&#125;//根据用户操作显示不同部门的人员列表void ShowPersonList(multimap&lt;int, person&gt;&amp; plist, int myoperate)&#123; switch (myoperate) &#123; case SALE_DEPATMENT: printList(plist, SALE_DEPATMENT); break; case DEVELOP_DEPATMENT: printList(plist, DEVELOP_DEPATMENT); break; case FINACIAL_DEPATMENT: printList(plist, FINACIAL_DEPATMENT); break; case ALL_DEPATMENT: printList(plist, ALL_DEPATMENT); break; &#125;&#125;//用户操作菜单void PersonMenue(multimap&lt;int, person&gt;&amp; plist)&#123; int flag = -1; int isexit = 0; while (true)&#123; cout &lt;&lt; "请输入您的操作((1 销售部门, 2 研发部门, 3 财务部门, 4 所有部门, 0退出)：" &lt;&lt; endl; scanf("%d", &amp;flag); switch (flag) &#123; case SALE_DEPATMENT: ShowPersonList(plist, SALE_DEPATMENT); break; case DEVELOP_DEPATMENT: ShowPersonList(plist, DEVELOP_DEPATMENT); break; case FINACIAL_DEPATMENT: ShowPersonList(plist, FINACIAL_DEPATMENT); break; case ALL_DEPATMENT: ShowPersonList(plist, ALL_DEPATMENT); break; case 0: isexit = 1; break; default: cout &lt;&lt; "您的输入有误，请重新输入!" &lt;&lt; endl; break; &#125; if (isexit == 1)&#123; break; &#125; &#125;&#125;int main()&#123; vector&lt;person&gt; vlist; //创建的5个员工 未分组 multimap&lt;int, person&gt; plist; //保存分组后员工信息 //创建5个员工 CreatePerson(vlist); //5名员工分配到不同的部门 PersonByGroup(vlist, plist); //根据用户输入显示不同部门员工信息列表 或者 显示全部员工的信息列表 PersonMenue(plist); system("pause"); return EXIT_SUCCESS;&#125; 案例二​ 例题：一个学生成绩录入和查询系统接受以下两种输入：1) Add name id score2) Query score ​ name是一个字符串，其中不包含空格，表示学生姓名。id是一个整数，表示学号。score是一个整数，表示分数。学号不会重复，分数和姓名都可能重复。 两种输入交替出现。 第一种输入表示要添加一个学生的信息，碰到这种输入，就记下学生的姓名、id和分数。 第二种输入表示要查询分数为score的学生的信息，碰到这种输入，就输出已有记录中分数比查询分数低的最高分获得者的姓名、学号和分数。如果有多个学生满足条件，则输出学号最大的学生的信息。如果找不到满足条件的学生，则输出“Nobody”。 输入样例： Add Jack 12 78Query 78Query 81Add Percy 9 81Add Marry 8 81Query 82Add Tom 11 79Query 80Query 81 输出结果样例：NobodyJack 12 78Percy 9 81Tom 11 79Tom 11 79 ​ 此题如果用vector存放所有学生的信息，然后进行顺序查找的话，在学生数量很大和查询很多的情况下非常费时，因为顺序查找的时间复杂度是O(n)。将vector排序后再查找也不行，因为会不断插入新元素，每次插入新元素就要进行元素的移动，而这一步骤的时间复杂度是O(n)，这会导致效率低下。 ​ 下面程序的思路是用multimap存放学生信息，使学生信息按照分数排序。 ​ 要添加学生时，就用insert成员函数插入学生记录，这步操作的时间复杂度是O(log(n))。 ​ 输入一个要查询的分数score时，就用lower_bound求得该分数对应的下界——迭代器p（这一步的时间复杂度是O(log(n)）。*p这个元素的分数是大于或等于score的，往前再找一个元素，其分数就是低于score 的最高分了。继续往前遍历所有等于该分数的元素，找出id最大的元素输出即可。 解题程序如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;map&gt; //使用multimap需要包含此头文件#include &lt;string&gt;using namespace std;class CStudent&#123;public: struct CInfo //类的内部还可以定义类 &#123; int id; string name; &#125;; int score; CInfo info; //学生的其他信息&#125;;typedef multimap &lt;int, CStudent::CInfo&gt; MAP_STD;int main()&#123; MAP_STD mp; CStudent st; string cmd; while (cin &gt;&gt; cmd) &#123; if (cmd == "Add") &#123; cin &gt;&gt; st.info.name &gt;&gt; st.info.id &gt;&gt; st.score; mp.insert(MAP_STD::value_type(st.score, st.info)); &#125; else if (cmd == "Query") &#123; int score; cin &gt;&gt; score; MAP_STD::iterator p = mp.lower_bound(score); if (p != mp.begin()) &#123; --p; score = p-&gt;first; //比要查询分数低的最高分 MAP_STD::iterator maxp = p; int maxId = p-&gt;second.id; for (; p != mp.begin() &amp;&amp; p-&gt;first == score; --p) &#123; //遍历所有成绩和score相等的学生 if (p-&gt;second.id &gt; maxId) &#123; maxp = p; maxId = p-&gt;second.id; &#125; &#125; if (p-&gt;first == score) &#123; //如果上面的循环因为 p == mp.begin() //而终止，则p指向的元素还要处理 if (p-&gt;second.id &gt; maxId) &#123; maxp = p; maxId = p-&gt;second.id; &#125; &#125; cout &lt;&lt; maxp-&gt;second.name &lt;&lt; " " &lt;&lt; maxp-&gt;second.id &lt;&lt; " " &lt;&lt; maxp-&gt;first &lt;&lt; endl; &#125; else //lower_bound 的结果就是 begin，说明没有分数比查询分数低 cout &lt;&lt; "Nobody" &lt;&lt; endl; &#125; &#125; return 0;&#125; ​ multimap容器中的元素必须是pair类模板对象。本题需要用multimap来存放学生信息，然而学生信息由三部分组成：姓名、学号、分数，解决的办法就是将用于排序的score作为一个成员变量，而且把其他部分一起作为一个CInfo对象，这样，第16行实例化出来的类multimap &lt;int, CStudent::CInfo&gt;中的元素的类型就会是如下pair模板类：12345class pair &lt;int, CStudent::CInfo&gt; &#123; int first; //对应于CStudent::score CStudent::CInfo second; //对应于 CStudent::info &#125;; ​ 第26行如下：1mp.insert( MAP_STD::value_type(st.score, st.info) ); ​ 参看multimap的定义，MAP_STD::value_type就是容器中元素的类型，该类型是pair &lt;int, CStudent::CInfo&gt;。类型名后面跟构造函数的参数表就代表一个对象。因此，此条语句生成了一个pair &lt;int, CStudent::CInfo&gt;对象并将其插入multimap容器中。该对象内部存放的信息和st相同，first对应于st.score，second对应于st.info。 ​ 第31行，lower_bound的返回结果p满足以下条件：[begin(), p)中的分数都比查询分数低，但是*p的分数不比查询分数低。所以执行--p操作之后，*p的分数就是低于查询分数的最高分了。 map的用法123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;map&gt; //使用map需要包含此头文件using namespace std;template &lt;class T1,class T2&gt;ostream &amp; operator &lt;&lt;(ostream &amp; o,const pair&lt;T1,T2&gt; &amp; p)&#123; //将pair对象输出为 (first,second)形式 o &lt;&lt; "(" &lt;&lt; p.first &lt;&lt; "," &lt;&lt; p.second &lt;&lt; ")"; return o;&#125;template&lt;class T&gt;void Print(T first,T last)&#123;//打印区间[first,last) for( ; first != last; ++ first) cout &lt;&lt; * first &lt;&lt; " "; cout &lt;&lt; endl;&#125;typedef map&lt;int,double,greater&lt;int&gt; &gt; MYMAP; //此容器关键字是整型，元素按关键字从大到小排序int main()&#123; MYMAP mp; mp.insert(MYMAP::value_type(15,2.7)); pair&lt;MYMAP::iterator,bool&gt; p = mp.insert(make_pair(15,99.3)); if(!p.second) cout &lt;&lt; * (p.first) &lt;&lt; " already exists" &lt;&lt; endl; //会输出 cout &lt;&lt; "1) " &lt;&lt; mp.count(15) &lt;&lt; endl; //输出 1) 1 mp.insert(make_pair(20,9.3)); cout &lt;&lt; "2) " &lt;&lt; mp[40] &lt;&lt; endl;//如果没有关键字为40的元素，则插入一个 cout &lt;&lt; "3) ";Print(mp.begin(),mp.end());//输出：3) (40,0)(20,9.3)(15,2.7) mp[15] = 6.28; //把关键字为15的元素值改成6.28 mp[17] = 3.14; //插入关键字为17的元素，并将其值设为3.14 cout &lt;&lt; "4) ";Print(mp.begin(),mp.end()); return 0;&#125; 程序的输出结果如下：(15,2.7) already exists1) 12) 03) (40,0) (20,9.3) (15,2.7)4) (40,0) (20,9.3) (17,3.14) (15,6.28) ​ 第17行的greater &gt;最右边的两个&gt;之间要有空格，否则Dev C++会将它们当作右移运算符，导致编译出错。在Visual Studio 2010中无此问题。 ​ 第22行用STL中的函数模板make_pair生成一个pair模板类对象插入mp中。 ​ 第23行，如果插入成功，p.second的值会是true。显然这里不能成功，因为map不允许关键字重复。因为关键字重复而插入失败时，p.first 就指向容器中关键字相同的那个元素。 ​ 第27行要访问关键字为40的元素。在没有这个元素的情况下，一个关键字为40、值为0的元素被自动插入容器。mp[40]等价于mp.operator[](40);，其返回值是关键字为40的那个元素（不论是原有的还是新插入的）的second成员变量的引用。第29行和第30行的道理与此类似。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++STL-pair类模板]]></title>
    <url>%2F2018%2F09%2F10%2Fc%2B%2B-STL-pair%E7%B1%BB%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[在学习关联容器之前，首先要了解STL中的pair 类模板，因为关联容器的一些成员函数的返回值是pair对象，而且map和multimap容器中的元素都是pair对象。pair的定义如下： 12345678910template &lt;class_Tl, class_T2&gt;struct pair&#123; _T1 first; _T2 second; pair(): first(), second() &#123;&#125; //用无参构造函数初始化 first 和 second pair(const _T1 &amp;__a, const _T2 &amp;__b): first(__a), second(__b) &#123;&#125; template &lt;class_U1, class_U2&gt; pair(const pair &lt;_U1, _U2&gt; &amp;__p): first(__p.first), second(__p.second) &#123;&#125;&#125;; ​ pair实例化出来的类都有两个成员变量，一个是first, 一个是second。 ​ STL中还有一个函数模板make_pair，其功能是生成一个pair模板类对象。make_pair的源代码如下： 12345template &lt;class T1, class T2&gt;pair&lt;T1, T2 &gt; make_pair(T1 x, T2 y)&#123; return ( pair&lt;T1, T2&gt; (x, y) );&#125; ​ 下面的程序演示了pair和make_pair的用法。 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; pair&lt;int,double&gt; p1; cout &lt;&lt; p1.first &lt;&lt; "," &lt;&lt; p1.second &lt;&lt; endl; //输出 0,0 pair&lt;string,int&gt; p2("this",20); cout &lt;&lt; p2.first &lt;&lt; "," &lt;&lt; p2.second &lt;&lt; endl; //输出 this,20 pair&lt;int,int&gt; p3(pair&lt;char,char&gt;('a','b')); cout &lt;&lt; p3.first &lt;&lt; "," &lt;&lt; p3.second &lt;&lt; endl; //输出 97,98 pair&lt;int,string&gt; p4 = make_pair(200,"hello"); cout &lt;&lt; p4.first &lt;&lt; "," &lt;&lt; p4.second &lt;&lt; endl; //输出 200,hello return 0;&#125; ​ pair模板中的第三个构造函数是函数模板，参数必须是一个pair模板类对象的引用。程序中第11行的p3就是用这个构造函数初始化的。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++STL库函数bitset]]></title>
    <url>%2F2018%2F09%2F01%2Fc%2B%2B-STL%E5%BA%93%E5%87%BD%E6%95%B0bitset%2F</url>
    <content type="text"><![CDATA[bitset模板类由若干个位（bit）组成，它提供一些成员函数，使程序员不必通过位运算就能很方便地访问、修改其中的任意一位。bitset 模板类在头文件&lt;bitset&gt;中定义如下： 12345template &lt;size_t N&gt; class bitset &#123; ... &#125;; ​ size_t可看作unsigned int。将bitset实例化时，N必须是一个整型常数。例如： 1bitset &lt;40&gt; bst; ​ 则bst是一个由40个位组成的对象，用bitset的成员函数可以方便地访问其中任意一位。bitset 中的位从0开始编号，第0位是最右边的位。 bitset 有许多成员函数，有些成员函数执行的就是类似于位运算的操作。bitset成员函数列表如下：|成员函数|功能||————|————-|| bitset &lt;N&gt; &amp; operator &amp;= (const bitset &lt;N&gt; &amp;rhs); |和另一个bitset对象进行与操作|| bitset &lt;N&gt; &amp; operator|=(const bitset &lt;N&gt; &amp;rhs); | 和另一个bitset 对象进行或操作 || bitset &lt;N&gt; &amp; operator ^= (const bitset &lt;N&gt; &amp;rhs); | 和另一个bitset对象进行异或操作 || bitset &lt;N&gt; &amp; operator &lt;&lt;= (size_t num); |左移num位|| bitset &lt;N&gt; &amp; operator &gt;&gt;= (size_t num); |右移num位|| bitset &lt;N&gt; &amp; set(); |将所有位全部设成1|| bitset &lt;N&gt; &amp; set(size_t pos, bool val = true); |将第pos位设为val|| bitset &lt;N&gt; &amp; reset(); |将所有位全部设成0|| bitset &lt;N&gt; &amp; reset (size_t pos); |将第pos 位设成 0|| bitset &lt;N&gt; &amp; flip(); |将所有位翻转（0变成1，1变成0）|| bitset &lt;N&gt; &amp; flip(size_t pos); |翻转第pos位|| reference operator[] (size_t pos); |返回对第pos位的引用|| bool operator[] (size_t pos) const; |返回第pos位的值|| reference at(size_t pos); |返回对第pos位的引用|| bool at (size_t pos) const; |返回第pos位的值|| unsigned long to_ulong() const; |将对象中的0、1串转换成整数|| string to_string () const; |将对象中的0、1串转换成字符串|| size_t count() const; |计算1的个数|| size_t size () const; |返回总位数|| bool operator == (const bitset &lt;N&gt; &amp; rhs) const; ||| bool operator != (const bitset &lt;N&gt; &amp; rhs) const; ||| bool test(size_t pos) const; |测试第pos位是否为1|| bool any() const; |判断是否有某位为1|| bool none() const; |判断是否全部为0|| bitset &lt;N&gt; operator &lt;&lt; (size_t pos) const; |返回左移pos位后的结果|| bitset &lt;N&gt; operator &gt;&gt; (size_t pos) const; |返回右移pos位后的结果|| bitset &lt;N&gt; operator ~ (); |返回取反后的结果|| bitset &lt;N&gt; operator &amp; (const bitset &lt;N&gt; &amp; rhs) const; |返回和另一个bitset 对象rhs进行与运算的结果|| bitset &lt;N&gt; operator | (const bitset &lt;N&gt; &amp; rhs) const; |返回和另一个bitset对象rhs进行或运算的结果|| bitset &lt;N&gt; operator ^ (const bitset &lt;N&gt; &amp; rhs) const; |返回和另一个bitset对象rhs进行异或运算的结果| 下面的程序演示了bitset的用法。 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;bitset&gt;#include &lt;string&gt;using namespace std;int main()&#123; bitset&lt;7&gt; bst1; bitset&lt;7&gt; bst2; cout &lt;&lt; "1) " &lt;&lt; bst1 &lt;&lt; endl; //输出 1) 0000000 bst1.set(0,1);//将第0位变成1，bst1变为 0000001 cout &lt;&lt; "2) " &lt;&lt; bst1 &lt;&lt; endl; //输出 2) 0000001 bst1 &lt;&lt;= 4; //左移4位，变为 0010000 cout &lt;&lt; "3) " &lt;&lt; bst1 &lt;&lt; endl; //输出 3) 0010000 bst2.set(2);//第二位设置为1，bst2变成 0000100 bst2 |=bst1; // bst2变成 0010100 cout &lt;&lt; "4) " &lt;&lt; bst2 &lt;&lt; endl; //输出 4) 0010100 cout &lt;&lt; "5) " &lt;&lt; bst2.to_ulong () &lt;&lt; endl; //输出 5) 20 bst2.flip(); //每一位都取反，bst2变成 1101011 bst1.set(3); //bst1变成 0011000 bst2.flip(6); //bst2变成 0101011 bitset&lt;7&gt; bst3 = bst2^ bst1;//bst3 变成 0110011 cout &lt;&lt; "6) " &lt;&lt; bst3 &lt;&lt; endl; //输出 6) 0110011 cout &lt;&lt; "7) " &lt;&lt; bst3[3] &lt;&lt; "," &lt;&lt; bst3[4] &lt;&lt; endl; //输出 7) 0,1 return 0;&#125;]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++STL库函数string]]></title>
    <url>%2F2018%2F08%2F28%2Fc%2B%2B-STL%E5%BA%93%E5%87%BD%E6%95%B0string%2F</url>
    <content type="text"><![CDATA[string容器string容器基本概念​ C风格字符串(以空字符结尾的字符数组)太过复杂难于掌握，不适合大程序的开发，所以C++标准库定义了一种string类，定义在头文件&lt;string&gt;。 ​ string类是 STL中basic_string模板实例化得到的模板类。其定义如下：1typedef basic_string &lt;char&gt; string; String和c风格字符串对比： Char*是一个指针，String是一个类 string封装了char*，管理这个字符串，是一个char*型的容器。 String封装了很多实用的成员方法 查找find，拷贝copy，删除delete替换replace，插入insert 不用考虑内存释放和越界 string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。 string容器常用操作string 构造函数12345string(); //创建一个空的字符串 例如: string str; string(const string&amp; str); //使用一个string对象初始化另一个string对象string(const char* s); //使用字符串s初始化string(int n, char c); //使用n个字符c初始化 string s4("12345", 1, 3); //s4 = "234"，即 "12345" 的从下标 1 开始，长度为 3 的子串 ​ string类没有接收一个整型参数或一个字符型参数的构造函数。下面的两种写法是错误的： 12string s1('K');string s2(123); string基本赋值操作12345678string&amp; operator=(const char* s); //char*类型字符串 赋值给当前的字符串string&amp; operator=(const string &amp;s); //把字符串s赋给当前的字符串string&amp; operator=(char c); //字符赋值给当前的字符串string&amp; assign(const char *s); //把字符串s赋给当前的字符串string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串string&amp; assign(const string &amp;s); //把字符串s赋给当前字符串string&amp; assign(int n, char c); //用n个字符c赋给当前字符串string&amp; assign(const string &amp;s, int start, int n); //将s从start开始n个字符赋值给字符串 string存取字符操作12char&amp; operator[](int n);//通过[]方式取字符char&amp; at(int n);//通过at方法获取字符 提示: ​ 为了修改string字符串的内容，下标操作符[]和at都会返回字符的引用。但当字符串的内存被重新分配之后，可能发生错误 1234567891011121314151617string s = "abcdefg";char&amp; a = s[2];char&amp; b = s[3];a = '1';b = '2';cout &lt;&lt; s &lt;&lt; endl;cout &lt;&lt; (int*)s.c_str() &lt;&lt; endl;s = "pppppppppppppppppppppppp";//a = '1';//b = '2';cout &lt;&lt; s &lt;&lt; endl;cout &lt;&lt; (int*)s.c_str() &lt;&lt; endl; string求字符串的长度length成员函数返回字符串的长度。size成员函数可以实现同样的功能。 string拼接操作12345678string&amp; operator+=(const string&amp; str);//重载+=操作符string&amp; operator+=(const char* str);//重载+=操作符string&amp; operator+=(const char c);//重载+=操作符string&amp; append(const char *s);//把字符串s连接到当前字符串结尾string&amp; append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾string&amp; append(const string &amp;s);//同operator+=()string&amp; append(const string &amp;s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾string&amp; append(int n, char c);//在当前字符串结尾添加n个字符c string查找和替换12345678910int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置int find(const char c, int pos = 0) const; //查找字符c第一次出现位置int rfind(const string&amp; str, int pos = npos) const;//查找str最后一次位置,从pos开始查找int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找int rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串strstring&amp; replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s 示例 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s1("Source Code"); int n; if ((n = s1.find('u')) != string::npos) //查找 u 出现的位置 cout &lt;&lt; "1) " &lt;&lt; n &lt;&lt; "," &lt;&lt; s1.substr(n) &lt;&lt; endl; //输出 l)2,urce Code if ((n = s1.find("Source", 3)) == string::npos) //从下标3开始查找"Source"，找不到 cout &lt;&lt; "2) " &lt;&lt; "Not Found" &lt;&lt; endl; //输出 2) Not Found if ((n = s1.find("Co")) != string::npos) //查找子串"Co"。能找到，返回"Co"的位置 cout &lt;&lt; "3) " &lt;&lt; n &lt;&lt; ", " &lt;&lt; s1.substr(n) &lt;&lt; endl; //输出 3) 7, Code if ((n = s1.find_first_of("ceo")) != string::npos) //查找第一次出现或 'c'、'e'或'o'的位置 cout &lt;&lt; "4) " &lt;&lt; n &lt;&lt; ", " &lt;&lt; s1.substr(n) &lt;&lt; endl; //输出 4) l, ource Code if ((n = s1.find_last_of('e')) != string::npos) //查找最后一个 'e' 的位置 cout &lt;&lt; "5) " &lt;&lt; n &lt;&lt; ", " &lt;&lt; s1.substr(n) &lt;&lt; endl; //输出 5) 10, e if ((n = s1.find_first_not_of("eou", 1)) != string::npos) //从下标1开始查找第一次出现非 'e'、'o' 或 'u' 字符的位置 cout &lt;&lt; "6) " &lt;&lt; n &lt;&lt; ", " &lt;&lt; s1.substr(n) &lt;&lt; endl; //输出 6) 3, rce Code return 0;&#125; string比较操作1234567/*compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。比较区分大小写，比较时参考字典顺序，排越前面的越小。大写的A比小写的a小。*/int compare(const string &amp;s) const;//与字符串s比较int compare(const char *s) const;//与字符串s比较 string子串1string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串 string插入和删除操作1234string&amp; insert(int pos, const char* s); //插入字符串string&amp; insert(int pos, const string&amp; str); //插入字符串string&amp; insert(int pos, int n, char c);//在指定位置插入n个字符cstring&amp; erase(int pos, int n = npos);//删除从Pos开始的n个字符 string和c-style字符串转换123456//string 转 char*string str = "itcast";const char* cstr = str.c_str();//char* 转 string char* s = "itcast";string str(s); 提示: ​ 在c++中存在一个从const char*到string的隐式类型转换，却不存在从一个string对象到C_string的自动类型转换。对于string类型的字符串，可以通过c_str()函数返回string对象对应的C_string。 ​ 通常，程序员在整个程序中应坚持使用string类对象，直到必须将内容转化为char*时才将其转换为C_string.]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++STL库函数stack]]></title>
    <url>%2F2018%2F08%2F26%2Fc%2B%2B-STL%E5%BA%93%E5%87%BD%E6%95%B0stack%2F</url>
    <content type="text"><![CDATA[stack容器stack容器基本概念​ stack是一种先进后出(First In Last Out，FILO)的数据结构，它只有一个出口，形式如图所示。stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。 ​ 有元素推入栈的操作称为：push，将元素推出stack的操作称为pop。 ​ stack的定义如下：1234template &lt; class T, class Cont == deque &lt;T&gt; &gt; class stack&#123; ... &#125;; ​ 第二个参数表明，在默认情况下，stack就是用deque实现的。当然，也可以指定用vector或list实现。 ​ 虽然stack使用顺序容器实现，但它不提供顺序容器具有的成员函数。除了size、empty这两个所有容器都有的成员函数外，stack还有以下三个成员函数。 stack没有迭代器​ Stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。Stack不提供遍历功能，也不提供迭代器。 stack常用API 成员函数 功 能 void pop(); 弹出（即删除）栈顶元素 T &amp;top(); 返回栈顶元素的引用。通过此函数可以读取栈顶元素的值，也可以修改栈顶元素 void push (const T &amp;x); 将x压入栈顶 stack构造函数12stack&lt;T&gt; stkT; //stack采用模板类实现， stack对象的默认构造形式： stack(const stack &amp;stk); //拷贝构造函数 stack赋值操作1stack&amp; operator=(const stack &amp;stk); //重载等号操作符 stack数据存取操作123push(elem); //向栈顶添加元素pop(); //从栈顶移除第一个元素top(); //返回栈顶元素 stack大小操作12empty(); //判断堆栈是否为空size(); //返回堆栈的大小 stack案例例题：编写程序，输入一个十进制数n和进制k（k≤10），输出n对应的k进制数。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;stack&gt; //使用stack需要包含此头文件using namespace std;int main()&#123; int n, k; stack &lt;int&gt; stk; cin &gt;&gt; n &gt;&gt; k; //将n转换为k进制数 if (n == 0) &#123; cout &lt;&lt; 0; return 0; &#125; while (n) &#123; stk.push(n%k); n /= k; &#125; while (!stk.empty()) &#123; cout &lt;&lt; stk.top(); stk.pop(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++STL库函数queue]]></title>
    <url>%2F2018%2F08%2F25%2Fc%2B%2B-STL%E5%BA%93%E5%87%BD%E6%95%B0queue%2F</url>
    <content type="text"><![CDATA[queue/priority_queue容器queue容器基本概念​ queue就是“队列”。队列是先进先出的，和排队类似。队头的访问和删除操作只能在队头进行，添加操作只能在队尾进行。不能访问队列中间的元素。 ​ queue可以用list和deque实现，默认情况下用deque实现。 ​ queue的定义如下：1234template &lt; class T, class Cont = deque&lt;T&gt; &gt; class queue&#123; ... &#125;; ​ queue 同样也有和stack类似的push、pop、top函数。区别在于，queue的push发生在队尾，pop和top发生在队头。 priority_queue容器基本概念​ priority_queue是“优先队列”。它和普通队列的区别在于，优先队列的队头元素总是最大的——即执行pop操作时，删除的总是最大的元素；执行top操作时，返回的是最大元素的引用。 ​ priority_queue 可以用 vector和deque实现，默认情况下用vector实现。 ​ priority_queue默认的元素比较器是less &lt;T&gt;。也就是说，在默认情况下，要放入priority_queue的元素必须是能用“&lt;”运算符进行比较的，而且priority _queue保证以下条件总是成立：对于队头的元素x和任意非队头的元素y，表达式“x&lt;y”必为false。 ​ priority_queue 定义如下：1234template &lt; class T, class Container = vector &lt;T&gt;, class Compare = less&lt;T&gt; &gt; class priority_queue&#123; ... &#125;; ​ priority_queue的第三个类型参数可以用来指定排序规则。 ​ 和set/multiset不同，priority_queue是使用“堆排序”技术实现的，其内部并非完全有序，但却能确保最大元素总在队头。因此，priority_queue特别适用于“不停地在一堆元素中取走最大的元素”这种情况。 ​ priority_queue插入和删除元素的复杂度都是O(log(n))。虽然用set/multiset也能完成此项工作，但是priority_queue比它们略快一些。 ​ priority_queue队头的元素只能被查看或者修改，不能被删除。 queue/priority_queue没有迭代器​ queue所有元素的进出都必须符合”先进先出”的条件，只有queue的顶端元素，才有机会被外界取用。queue不提供遍历功能，也不提供迭代器。 queue/priority_queue常用APIqueue/priority_queue构造函数12queue&lt;T&gt; queT; //queue采用模板类实现，queue对象的默认构造形式：queue(const queue &amp;que); //拷贝构造函数 queue/priority_queue存取、插入和删除操作1234push(elem); //往队尾添加元素pop(); //从队头移除第一个元素back(); //返回最后一个元素front(); //返回第一个元素 queue/priority_queue赋值操作1queue&amp; operator=(const queue &amp;que); //重载等号操作符 queue/priority_queue大小操作12empty(); //判断队列是否为空size(); //返回队列的大小 priority_queue用法123456789101112131415161718192021#include &lt;queue&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; priority_queue&lt;double&gt; pq1; pq1.push(3.2); pq1.push(9.8); pq1.push(9.8); pq1.push(5.4); while(!pq1.empty()) &#123; cout &lt;&lt; pq1.top() &lt;&lt; " "; pq1.pop(); &#125; //上面输出 9.8 9.8 5.4 3.2 cout &lt;&lt; endl; priority_queue&lt;double,vector&lt;double&gt;,greater&lt;double&gt; &gt; pq2; pq2.push(3.2); pq2.push(9.8); pq2.push(9.8); pq2.push(5.4); while(!pq2.empty()) &#123; cout &lt;&lt; pq2.top() &lt;&lt; " "; pq2.pop(); &#125; //上面输出 3.2 5.4 9.8 9.8 return 0;&#125; ​ 程序的输出结果是：9.8 9.8 5.4 3.23.2 5.4 9.8 9.8 ​ pq2的排序规则和pq1相反，因此元素出队的顺序也相反。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++STL库函数list]]></title>
    <url>%2F2018%2F08%2F22%2Fc%2B%2B-STL%E5%BA%93%E5%87%BD%E6%95%B0list%2F</url>
    <content type="text"><![CDATA[list容器list容器基本概念​ 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 ​ 相较于vector的连续线性空间，list就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。 ​ list和vector是两个最常被使用的容器。 ​ list容器是一个双向链表。 采用动态存储分配，不会造成内存浪费和溢出 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素 链表灵活，但是空间和时间额外耗费较大 list容器的迭代器​ list容器不能像vector一样以普通指针作为迭代器，因为其节点不能保证在同一块连续的内存空间上。list迭代器必须有能力指向list的节点，并有能力进行正确的递增、递减、取值、成员存取操作。所谓”list正确的递增，递减、取值、成员取用”是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取的是节点的成员。 ​ 由于list是一个双向链表，迭代器必须能够具备前移、后移的能力，所以list容器提供的是Bidirectional Iterators. ​ list有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效，甚至list元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。 list容器的数据结构​ list容器不仅是一个双向链表，而且还是一个循环的双向链表。 12345678910111213141516171819202122232425#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;int main()&#123; list&lt;int&gt; myList; for (int i = 0; i &lt; 10; i ++)&#123; myList.push_back(i); &#125; list&lt;int&gt;::_Nodeptr node = myList._Myhead-&gt;_Next; for (int i = 0; i &lt; myList._Mysize * 2;i++)&#123; cout &lt;&lt; "Node:" &lt;&lt; node-&gt;_Myval &lt;&lt; endl; node = node-&gt;_Next; if (node == myList._Myhead)&#123; node = node-&gt;_Next; &#125; &#125; system("pause"); return EXIT_SUCCESS;&#125; list常用API 成员函数或成员函数模板 作 用 void push_front(const T &amp; val) 将val插入链表最前面 void pop_front() 删除链表最前面的元素 void sort() 将链表从小到大排序 void remove (const T &amp; val) 删除和val相等的元素 remove_if 删除符合某种条件的元素 void unique() 删除所有和前一个元素相等的元素 void merge(list &lt;T&gt; &amp;x) 将链表x合并进来并清空x。要求链表自身和x都是有序的 void splice(iterator i, list &lt;T&gt; &amp;x, iterator first, iterator last) 在位置i前面插入链表x中的区间[first, last)，并在链表 x 中删除该区间。链表自身和链表x可以是同一个链表，只要i不在[first, last)中即可 ​ STL中的算法sort可以用来对vector和deque排序，它需要随机访问迭代器的支持。因为list不支持随机访问迭代器，所以不能用算法sort对list容器排序。因此，list容器引入了sort成员函数以完成排序。 list构造函数1234list&lt;T&gt; lstT; //list采用采用模板类实现,对象的默认构造形式：list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。list(n,elem); //构造函数将n个elem拷贝给本身。list(const list &amp;lst); //拷贝构造函数。 list数据元素插入和删除操作1234567891011push_back(elem); //在容器尾部加入一个元素pop_back(); //删除容器中最后一个元素push_front(elem); //在容器开头插入一个元素pop_front(); //从容器开头移除第一个元素insert(pos,elem); //在pos位置插elem元素的拷贝，返回新数据的位置。insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。clear(); //移除容器的所有数据erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。erase(pos); //删除pos位置的数据，返回下一个数据的位置。remove(elem); //删除容器中所有与elem值匹配的元素。 list大小操作123456size(); //返回容器中元素的个数empty(); //判断容器是否为空resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除。resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除。 list赋值操作1234assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。assign(n, elem); //将n个elem拷贝赋值给本身。list&amp; operator=(const list &amp;lst); //重载等号操作符swap(lst); //将lst与本身的元素互换。 list数据的存取12front(); //返回第一个元素。back(); //返回最后一个元素。 list反转排序12reverse(); //反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。sort(); //list排序 list案例list的示例程序如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;list&gt; //使用 list 需要包含此头文件#include &lt;iostream&gt;#include &lt;algorithm&gt; //使用STL中的算法需要包含此头文件using namespace std;class A &#123;private: int n;public: A(int n_) &#123; n = n_; &#125; friend bool operator &lt; (const A &amp; a1, const A &amp; a2); friend bool operator == (const A &amp; a1, const A &amp; a2); friend ostream &amp; operator &lt;&lt; (ostream &amp; o, const A &amp; a);&#125;;bool operator &lt; (const A &amp; a1, const A &amp; a2) &#123; return a1.n &lt; a2.n;&#125;bool operator == (const A &amp; a1, const A &amp; a2) &#123; return a1.n == a2.n;&#125;ostream &amp; operator &lt;&lt; (ostream &amp; o, const A &amp; a) &#123; o &lt;&lt; a.n; return o;&#125;template &lt;class T&gt;void print(T first, T last)&#123; for (; first != last; ++first) cout &lt;&lt; *first &lt;&lt; " "; cout &lt;&lt; endl;&#125;int main()&#123; A a[5] = &#123; 1, 3, 2, 4, 2 &#125;; A b[7] = &#123; 10, 30, 20, 30, 30, 40, 40 &#125;; list&lt;A&gt; lst1(a, a + 5), lst2(b, b + 7); lst1.sort(); cout &lt;&lt; "1)"; print(lst1.begin(), lst1.end()); //输出：1)1 2 2 3 4 lst1.remove(2); //删除所有和A(2)相等的元素 cout &lt;&lt; "2)"; print(lst1.begin(), lst1.end()); //输出：2)1 3 4 lst2.pop_front(); //删除第一个元素 cout &lt;&lt; "3)"; print(lst2.begin(), lst2.end()); //输出：3)30 20 30 30 40 40 lst2.unique(); //删除所有和前一个元素相等的元素 cout &lt;&lt; "4)"; print(lst2.begin(), lst2.end()); //输出：4)30 20 30 40 lst2.sort(); lst1.merge(lst2); //合并 lst2 到 lst1 并清空 lst2 cout &lt;&lt; "5)"; print(lst1.begin(), lst1.end()); //输出：5)1 3 4 20 30 30 40 cout &lt;&lt; "6)"; print(lst2.begin(), lst2.end()); //lst2是空的，输出：6) lst1.reverse(); //将 lst1 前后颠倒 cout &lt;&lt; "7)"; print(lst1.begin(), lst1.end()); //输出 7)40 30 30 20 4 3 1 lst2.insert(lst2.begin(), a + 1, a + 4); //在 lst2 中插入 3,2,4 三个元素 list &lt;A&gt;::iterator p1, p2, p3; p1 = find(lst1.begin(), lst1.end(), 30); p2 = find(lst2.begin(), lst2.end(), 2); p3 = find(lst2.begin(), lst2.end(), 4); lst1.splice(p1, lst2, p2, p3); //将[p2, p3)插入p1之前，并从 lst2 中删除[p2,p3) cout &lt;&lt; "8)"; print(lst1.begin(), lst1.end()); //输出：8)40 2 30 30 20 4 3 1 cout &lt;&lt; "9)"; print(lst2.begin(), lst2.end()); //输出：9)3 4 return 0;&#125; 【实例】用list解决约瑟夫问题。​ 约瑟夫问题是：有n只猴子，按顺时针方向围成一圈选大王（编号为1~n），从第1号开始报数，一直数到m，数到m的猴子退到圈外，剩下的猴子再接着从1开始报数。就这样，直到圈内只剩下一只猴子时，这个猴子就是猴王。编程求输入n、m 后，输出最后猴王的编号。 ​ 输入数据：每行是用空格分开的两个整数，第一个是n，第二个是m（0&lt;m, n&lt;=1 000 000）。最后一行是：0 0 ​ 输出要求：对于每行输入数据（最后一行除外），输出数据也是一行，即最后猴王的编号。 输入样例：6 212 48 30 0 输出样例：517 示例程序如下： 123456789101112131415161718192021222324252627282930#include &lt;list&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; list&lt;int&gt; monkeys; int n, m; while (true) &#123; cin &gt;&gt; n &gt;&gt; m; if (n == 0 &amp;&amp; m == 0) break; monkeys.clear(); //清空list容器 for (int i = 1; i &lt;= n; ++i) //将猴子的编号放入list monkeys.push_back(i); list&lt;int&gt;::iterator it = monkeys.begin(); while (monkeys.size() &gt; 1) &#123; //只要还有不止一只猴子，就要找一只猴子让其出列 for (int i = 1; i &lt; m; ++i) &#123; //报数 ++it; if (it == monkeys.end()) it = monkeys.begin(); &#125; it = monkeys.erase(it); //删除元素后，迭代器失效， //要重新让迭代器指向被删元素的后面 if (it == monkeys.end()) it = monkeys.begin(); &#125; cout &lt;&lt; monkeys.front() &lt;&lt; endl; //front返回第一个元素的引用 &#125; return 0;&#125; ​ erase成员函数返回被删除元素后面那个元素的迭代器。如果被删除的是最后一个元素，则返回end()。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++STL库函数deque]]></title>
    <url>%2F2018%2F08%2F20%2Fc%2B%2B-STL%E5%BA%93%E5%87%BD%E6%95%B0deque%2F</url>
    <content type="text"><![CDATA[deque容器deque容器基本概念​ vector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受。 `deque`容器和`vector`容器最大的差异，一在于`deque`允许使用常数项时对头端进行元素的插入和删除操作。二在于`deque`没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像`vector`那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在`deque`身上是不会发生的。也因此，`deque`没有必须要提供所谓的空间保留(`reserve`)功能. ​ 虽然deque容器也提供了Random Access Iterator，但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque。 deque容器实现原理​ deque容器是连续的空间，至少逻辑上看来如此，连续现行空间总是令我们联想到array和vector，array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间三步骤，如果不是vector每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。 ​ deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。 ​ 既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。deque代码的实现远比vector或list都多得多。 ​ deque采取一块所谓的map(注意，不是STL的map容器)作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体。 deque常用APIdeque构造函数1234deque&lt;T&gt; deqT; //默认构造形式deque(beg, end); //构造函数将[beg, end)区间中的元素拷贝给本身。deque(n, elem); //构造函数将n个elem拷贝给本身。deque(const deque &amp;deq); //拷贝构造函数。 deque赋值操作1234assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。assign(n, elem); //将n个elem拷贝赋值给本身。deque&amp; operator=(const deque &amp;deq); //重载等号操作符 swap(deq); // 将deq与本身的元素互换 deque大小操作1234deque.size(); //返回容器中元素的个数deque.empty(); //判断容器是否为空deque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。 deque双端插入和删除操作1234push_back(elem); //在容器尾部添加一个数据push_front(elem); //在容器头部插入一个数据pop_back(); //删除容器最后一个数据pop_front(); //删除容器第一个数据 deque数据存取1234at(idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range。operator[]; //返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。front(); //返回第一个数据。back(); //返回最后一个数据 deque插入操作123insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 deque删除操作123clear(); //移除容器的所有数据erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。erase(pos); //删除pos位置的数据，返回下一个数据的位置。 案例（作业）12345678/* 有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。 //1. 创建五名选手，放到vector中 //2. 遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中 //3. sort算法对deque容器中分数排序，pop_back pop_front去除最高和最低分 //4. deque容器遍历一遍，累加分数，累加分数/d.size() //5. person.score = 平均分*/]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++STL库函数vector]]></title>
    <url>%2F2018%2F08%2F18%2Fc%2B%2B-STL%E5%BA%93%E5%87%BD%E6%95%B0vector%2F</url>
    <content type="text"><![CDATA[vector容器2.1 vector容器基本概念​ vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间的运用的灵活性。 ​ Array是静态空间，一旦配置了就不能改变，要换大一点或者小一点的空间，可以，一切琐碎得由自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。 ​ Vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必害怕空间不足而一开始就要求一个大块头的array了。 ​ Vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，一旦vector旧空间满了，如果客户每新增一个元素，vector内部只是扩充一个元素的空间，实为不智，因为所谓的扩充空间(不论多大)，一如刚所说，是”配置新空间-数据移动-释放旧空间”的大工程，时间成本很高，应该加入某种未雨绸缪的考虑，稍后我们便可以看到vector的空间配置策略。 2.2 vector迭代器​ Vector维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为vector的迭代器，因为vector迭代器所需要的操作行为，如operaroe*， operator-&gt;，operator++， operator--，operator+，operator-，operator+=，operator-=，普通指针天生具备。Vector支持随机存取，而普通指针正有着这样的能力。所以vector提供的是随机访问迭代器(Random Access Iterators). 根据上述描述，如果我们写如下的代码：12Vector&lt;int&gt;::iterator it1;Vector&lt;Teacher&gt;::iterator it2; it1的型别其实就是int*，it2的型别其实就是Teacher *. 1234567891011121314151617#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10;i ++)&#123; v.push_back(i); cout &lt;&lt; v.capacity() &lt;&lt; endl; // v.capacity()容器的容量 &#125; system("pause"); return EXIT_SUCCESS;&#125; 2.3 vector的数据结构​ Vector所采用的数据结构非常简单，线性连续空间，它以两个迭代器_Myfirst和_Mylast分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器_Myend指向整块连续内存空间的尾端。 ​ 为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求大一些，以备将来可能的扩充，这边是容量的概念。换句话说，一个vector的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得另觅居所。 ​ 注意： 所谓动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间)，而是一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。这是程序员容易犯的一个错误，务必小心。 2.4 vector常用API操作​ vector有很多成员函数，常用的如表1所示。 成员函数 作 用 vector() 无参构造函数，将容器初始化为空 vector(int n) 将容器初始化为有 n个元素 vector(int n, const T &amp;val) 假定元素的类型是T，此构造函数将容器初始化为有n个元素，每 个元素的值都是val vector(iterator first, iterator last) first和last可以是其他容器的迭代器。一般来说，本构造函数初始化的结果就是将vector容器的内容变成与其他容器上的区间[first, last)—致 void clear() 删除所有元素 bool empty() 判断容器是否为空 void pop_back() 删除容器末尾的元素 void push_back( const T &amp;val) 将val添加到容器末尾 int size() 返回容器中元素的个数 T &amp;front() 返回容器中第一个元素的引用 T &amp;back() 返回容器中最后一个元素的引用 iterator insert(iterator i, const T &amp;val) 将val插入迭代器i指向的位置，返回i iterator insert( iterator i, iterator first, iterator last) 将其他容器上的区间[first, last) 中的元素插入迭代器i指向的位置 iterator erase(iterator i) 删除迭代器i指向的元素，返回值是被删元素后面的元素的迭代器 iterator erase(iterator first, iterator last) 删除容器中的区间[first, last) void swap( vector &lt;T&gt; &amp; v) 将容器自身的内容和另一个同类型的容器v互换 2.4.1 vector构造函数12345678vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数vector(v.begin(), v.end()); //将v[begin(), end())区间中的元素拷贝给本身。vector(n, elem); //构造函数将n个elem拷贝给本身。vector(const vector &amp;vec); //拷贝构造函数。//例子 使用第二个构造函数 我们可以...int arr[] = &#123;2,3,4,1,9&#125;;vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int)); 2.4.2 vector常用赋值操作1234assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。assign(n, elem); //将n个elem拷贝赋值给本身。vector&amp; operator=(const vector &amp;vec);//重载等号操作符swap(vec);// 将vec与本身的元素互换。 2.4.3 vector大小操作12345678size(); //返回容器中元素的个数empty(); //判断容器是否为空resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除。resize(int num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除。capacity(); //容器的容量reserve(int len); //容器预留len个元素长度，预留位置不初始化，元素不可访问。 2.4.4 vector数据存取操作1234at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。operator[]; //返回索引idx所指的数据，越界时，运行直接报错front(); //返回容器中第一个数据元素back(); //返回容器中最后一个数据元素 2.4.5 vector插入和删除操作123456insert(const_iterator pos, int count,ele); //迭代器指向位置pos插入count个元素ele.push_back(ele); //尾部插入元素elepop_back(); //删除最后一个元素erase(const_iterator start, const_iterator end); //删除迭代器从start到end之间的元素erase(const_iterator pos); //删除迭代器指向的元素clear(); //删除容器中所有元素 2.5 vector案例2.5.1 vector基础用法123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt; //使用vector需要包含此头文件using namespace std;template &lt;class T&gt;void printVector(const vector &lt;T&gt; &amp; v)&#123; //用于输出vector容器的全部元素的函数模板 typename vector &lt;T&gt;::const_iterator i; //typename 用来说明 vector &lt;T&gt;::const_iterator 是一个类型，在 Visual Studio 中不写也可以 for (i = v.begin(); i != v.end(); ++i) cout &lt;&lt; *i &lt;&lt; " "; cout &lt;&lt; endl;&#125;int main()&#123; int a[5] = &#123; 1, 2, 3, 4, 5 &#125;; vector &lt;int&gt; v(a, a + 5); //将数组a的内容放入 cout &lt;&lt; "1) " &lt;&lt; v.end() - v.begin() &lt;&lt; endl; //两个随机迭代器可以相减，输出：1)5 cout &lt;&lt; "2)"; printVector(v); //输出：2)1 2 3 4 5 v.insert(v.begin() + 2, 13); //在 begin()+2 位置插人 13 cout &lt;&lt; "3)"; printVector(v); //输出：3)1 2 13 3 4 5 v.erase(v.begin() + 2); //删除位于 begin()+2 位置的元素 cout &lt;&lt; "4)"; printVector(v); //输出：4)1 2 3 4 5 vector&lt;int&gt; v2(4, 100); //v2 有 4 个元素，都是 100 v2.insert(v2.begin(), v.begin() + 1, v.begin() + 3); //将v的一段插入v2开头 cout &lt;&lt; "5)v2:"; printVector(v2); //输出：5)v2: 2 3 100 100 100 100 v.erase(v.begin() + 1, v.begin() + 3); //删除 v 上的一个区间，即 [2,3) cout &lt;&lt; "6)"; printVector(v); //输出：6)1 4 5 return 0;&#125; 2.5.2 巧用swap，收缩内存空间12345678910111213141516171819202122232425262728293031#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 100000;i ++)&#123; v.push_back(i); &#125; cout &lt;&lt; "capacity:" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; "size:" &lt;&lt; v.size() &lt;&lt; endl; //此时 通过resize改变容器大小 v.resize(10); cout &lt;&lt; "capacity:" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; "size:" &lt;&lt; v.size() &lt;&lt; endl; //容量没有改变 vector&lt;int&gt;(v).swap(v); cout &lt;&lt; "capacity:" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; "size:" &lt;&lt; v.size() &lt;&lt; endl; system("pause"); return EXIT_SUCCESS;&#125; 2.5.3 reserve预留空间123456789101112131415161718192021222324252627#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; //预先开辟空间 v.reserve(100000); int* pStart = NULL; int count = 0; for (int i = 0; i &lt; 100000;i ++)&#123; v.push_back(i); if (pStart != &amp;v[0])&#123; pStart = &amp;v[0]; count++; &#125; &#125; cout &lt;&lt; "count:" &lt;&lt; count &lt;&lt; endl; system("pause"); return EXIT_SUCCESS;&#125;]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++STL库函数概述]]></title>
    <url>%2F2018%2F08%2F16%2Fc%2B%2B-STL%E5%BA%93%E5%87%BD%E6%95%B0%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[STL概论​ 长久以来，软件界一直希望建立一种可重复利用的东西，以及一种得以制造出”可重复运用的东西”的方法，让程序员的心血不止于随时间的迁移，人事异动而烟消云散，从函数(functions)，类别(classes)，函数库(function libraries)，类别库(class libraries)、各种组件，从模块化设计，到面向对象(object oriented)，为的就是复用性的提升。 ​ 复用性必须建立在某种标准之上。但是在许多环境下，就连软件开发最基本的数据结构(data structures) 和算法(algorithm)都未能有一套标准。大量程序员被迫从事大量重复的工作，竟然是为了完成前人已经完成而自己手上并未拥有的程序代码，这不仅是人力资源的浪费，也是挫折与痛苦的来源。 ​ 为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性(相互合作性，interoperability)，诞生了STL。 STL基本概念​ STL(Standard Template Library，标准模板库)，是惠普实验室开发的一系列软件的统称。现在主要出现在c++中，但是在引入c++之前该技术已经存在很长时间了。​ STL从广义上分为: 容器(container) 、算法(algorithm) 、迭代器(iterator)，容器和算法之间通过迭代器进行无缝连接。STL 几乎所有的代码都采用了模板类或者模板函数，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。STL(Standard Template Library)标准模板库，在我们c++标准程序库中隶属于STL的占到了 80%以上。 STL六大组件简介​ STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。 ​ 容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据，从实现角度来看，STL容器是一种class template。 ​ 算法：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte. ​ 迭代器：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-&gt; , operator++,operator--等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。 ​ 仿函数：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template ​ 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。 ​ 空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte. ​ STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。 STL优点​ STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。 ​ STL 的一个重要特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”，以使算法可以和容器交互运作 ​ 程序员可以不用思考STL具体的实现过程，只要能够熟练使用 STL 就 OK 了。这样他们就可以把精力放在程序开发的别的方面。 STL 具有高可重用性，高性能，高移植性，跨平台的优点。 高可重用性：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。 高性能：如map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。 高移植性：如在项目A 上用 STL 编写的模块，可以直接移植到项目 B 上。 STL三大组件容器容器，置物之所也。 ​ 研究数据的特定排列方式，以利于搜索或排序或其他特殊目的，这一门学科我们称为数据结构。大学信息类相关专业里面，与编程最有直接关系的学科，首推数据结构与算法。几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL容器就是将运用最广泛的一些数据结构实现出来。 ​ 常用的数据结构：可变长动态数组 (vector)，双向链表(list)，tree(树)，栈(stack)，双端队列(deque)，集合(set)，映射表(map)，根据数据在容器中的排列特性，这些数据分为序列式容器和关联式容器两种。 序列式容器是指元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置（尾部、头部或中间某处）插入，元素就会位于什么位置。可变长动态数组 (vector)，双端队列(deque)，双向链表(list)。 关联式容器内的元素是排序的。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。 ​ 默认情况下，关联容器中的元素是从小到大排序（或按关键字从小到大排序）的，而且用&lt;运算符比较元素或关键字大小。因为是排好序的，所以关联容器在查找时具有非常好的性能。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。其包括set、multiset、 map、multimap容器 除了以上两类容器外，STL还在两类容器的基础上屏蔽一部分功能，突出或增加另一部分功能，实现了三种容器适配器：栈stack、队列queue、优先级队列priority_queue。 容器都是类模板。它们实例化后就成为容器类。用容器类定义的对象称为容器对象。 ​ 例如，vector是一个容器类的名字，vector&lt;int&gt; a;就定义了一个容器对象a，a代表一个长度可变的数组，数组中的每个元素都是int类型的变量；vector&lt;double&gt; b;定义了另一个容器对象b，a和b的类型是不同的。 ​ 任何两个容器对象，只要它们的类型相同，就可以用&lt;、&lt;=、&gt;、&gt;=、==、!=进行词典式的比较运算。假设a、b是两个类型相同的容器对象，这些运算符的运算规则如下。 a == b：若a和b中的元素个数相同，且对应元素均相等，则a == b的值为true，否则值为 false。元素是否相等是用==运算符进行判断的。 a&lt;b：规则类似于词典中两个单词比较大小，从头到尾依次比较每个元素，如果发生a中的元素小于b中的元素的情况，则a&lt;b的值为true；如果没有发生b中的元素小于a中的元素的情况，且a中的元素个数比b少，a&lt;b的值也为true；其他情况下值为false。元素比较大小是通过&lt;运算符进行的。 a != b：等价于!(a == b)。 a &gt; b：等价于b &lt; a。 a &lt;= b：等价于!(b &lt; a)。 a &gt;= b：等价于!(a &lt; b)。 所有容器都有以下两个成员函数： int size()：返回容器对象中元素的个数。 bool empty()：判断容器对象是否为空。 顺序容器和关联容器还有以下成员函数： begin()：返回指向容器中第一个元素的迭代器。 end()：返回指向容器中最后一个元素后面的位置的迭代器。 rbegin()：返回指向容器中最后一个元素的反向迭代器。 rend()：返回指向容器中第一个元素前面的位置的反向迭代器。 erase(...)：从容器中删除一个或几个元素。 clear()：从容器中删除所有元素。 如果一个容器是空的，则begin()和end()的返回值相等，rbegin()和rend()的返回值也相等。 顺序容器还有以下常用成员函数： front()：返回容器中第一个元素的引用。 back()：返回容器中最后一个元素的引用。 push_back()：在容器末尾增加新元素。 pop_back()：删除容器末尾的元素。 insert(...)：插入一个或多个元素。 算法​ STL 提供能在各种容器中通用的算法，如插入、删除、查找、排序等。算法就是函数模板。算法通过迭代器来操纵容器中的元素。 ​ 许多算法操作的是容器上的一个区间（也可以是整个容器），因此需要两个参数，一个是区间起点元素的迭代器，另一个是区间终点元素的后面一个元素的迭代器。例如，排序和查找算法都需要这两个参数来指明待排序或待查找的区间。 ​ 有的算法返回一个迭代器。例如，find算法在容器中查找一个元素，并返回一个指向该元素的迭代器。 ​ 算法可以处理容器，也可以处理普通的数组。 有的算法会改变其所作用的容器。例如： copy：将一个容器的内容复制到另一个容器。 remove：在容器中删除一个元素。 random_shuffle：随机打乱容器中的元素。 fill：用某个值填充容器。 有的算法不会改变其所作用的容器。例如： find：在容器中查找元素。 count_if：统计容器中符合某种条件的元素的个数。 STL中的大部分常用算法都在头文件algorithm中定义。此外，头文件numeric中也有一些算法。 ​ 下面介绍一个常用算法find。find算法和其他算法一样都是函数模板。find 模板的原型如下： 12template &lt;class InIt, class T&gt;InIt find(InIt first, InIt last, const T&amp; val); ​ 其功能可以是在迭代器first、last指定的容器的一个区间[first, last)中，按顺序查找和val 相等的元素。如果找到，就返回该元素的迭代器；如果找不到，就返回last。 [first, last)这个区间是一个左闭右开的区间，即last指向的元素其实不在此区间内。 ​ find模板使用==运算符判断元素是否相等。因此，如果[first, last)区间中存放的是对象，则==运算符应该被适当重载，使得两个对象可以用==运算符比较。 ​ 演示find用法的程序如下： 1234567891011121314151617181920212223242526#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; int a[10] = &#123;10,20,30,40&#125;; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4); //此后v里放着4个元素：1,2,3,4 vector&lt;int&gt;::iterator p; p = find(v.begin(),v.end(),3); //在v中查找3 if(p != v.end()) //若找不到,find返回 v.end() cout &lt;&lt; "1) " &lt;&lt; * p &lt;&lt; endl; //找到了 p = find(v.begin(),v.end(),9); if(p == v.end()) cout &lt;&lt; "not found " &lt;&lt; endl; //没找到 p = find(v.begin()+1,v.end()-1,4); //在,3 这两个元素中查找4 cout &lt;&lt; "2) " &lt;&lt; * p &lt;&lt; endl; int * pp = find(a,a+4,20); if(pp == a + 4) cout &lt;&lt; "not found" &lt;&lt; endl; else cout &lt;&lt; "3) " &lt;&lt;* pp &lt;&lt; endl;&#125; 程序的输出结果是：1) 3 not found2) 43) 20 第13行，要查找的区间是[v.begin(), v.end( ))，v.end()不在查找范围内，因此没有问题。本行的查找会成功，因此p指向找到的元素3。 第19行，因为要查找的区间是[v.begin()+l，v.end()-1)，这个区间中只有2、3这两个元素，因此查找会失败，p的值变为v.end() - 1，因此p正好指向4这个元素。 第21行，数组a是一个容器。数组名a的类型是int *，可以做迭代器使用，表达式a+4的类型也是int*，因此也能做迭代器。本次调用find,查找区间是[a, a+4)，即数组a的前4个元素。如果查找失败，find就会返回a+4。 ​ STL中还有一个常用的算法sort，用于对容器排序，其原型为： 12template&lt;class_RandIt&gt;void sort(_RandIt first, _RandIt last); ​ 该算法可以用来对区间[first, last)从小到大进行排序。下面两行程序就能对数组a排序： 12int a[4] = &#123;3, 4, 2, 1&#125;;sort(a, a+4); 迭代器​ 迭代器(iterator)是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。在&lt;&lt;Design Patterns&gt;&gt;一书中提供了23中设计模式的完整描述，其中iterator模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。 ​ 迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器(container)和算法(algorithms)分开，彼此独立设计，最后再一贴胶着剂将他们撮合在一起。从技术角度来看，容器和算法的泛型化并不困难，c++的class template和function template可分别达到目标，如果设计出两这个之间的良好的胶着剂，才是大难题。 迭代器按照定义方式分成以下四种。 正向迭代器，定义方法如下： 容器类名::iterator 迭代器名; 常量正向迭代器，定义方法如下： 容器类名::const_iterator 迭代器名; 反向迭代器，定义方法如下： 容器类名::reverse_iterator 迭代器名; 常量反向迭代器，定义方法如下： 容器类名::const_reverse_iterator 迭代器名; 迭代器用法示例​ 通过迭代器可以读取它指向的元素，*迭代器名就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。 迭代器都可以进行++操作。反向迭代器和正向迭代器的区别在于： 对正向迭代器进行++操作时，迭代器会指向容器中的后一个元素； 而对反向迭代器进行++操作时，迭代器会指向容器中的前一个元素。 下面的程序演示了如何通过迭代器遍历一个vector容器中的所有元素。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; //v是存放int类型变量的可变长数组，开始时没有元素 for (int n = 0; n&lt;5; ++n) v.push_back(n); //push_back成员函数在vector容器尾部添加一个元素 vector&lt;int&gt;::iterator i; //定义正向迭代器 for (i = v.begin(); i != v.end(); ++i) &#123; //用迭代器遍历容器 cout &lt;&lt; *i &lt;&lt; " "; //*i 就是迭代器i指向的元素 *i *= 2; //每个元素变为原来的2倍 &#125; cout &lt;&lt; endl; //用反向迭代器遍历容器 for (vector&lt;int&gt;::reverse_iterator j = v.rbegin(); j != v.rend(); ++j) cout &lt;&lt; *j &lt;&lt; " "; return 0;&#125; 程序的输出结果是：0 1 2 3 48 6 4 2 0 ​ 第10行，begin成员函数返回指向容器中第一个元素的迭代器。++i使得i指向容器中的下一个元素。end成员函数返回的不是指向最后一个元素的迭代器，而是指向最后一个元素后面的位置的迭代器，因此循环的终止条件是i != v.end()。 ​ 第16行定义了反向迭代器用以遍历容器。反向迭代器进行++操作后，会指向容器中的上一个元素。rbegin 成员函数返回指向容器中最后一个元素的迭代器，rend成员函数返回指向容器中第一个元素前面的位置的迭代器，因此本循环实际上是从后往前遍历整个数组。 ​ 如果迭代器指向了容器中最后一个元素的后面或第一个元素的前面，再通过该迭代器访问元素，就有可能导致程序崩溃，这和访问NULL或未初始化的指针指向的地方类似。 ​ 第10行和第16行，写++i、++j相比于写i++、j++，程序的执行速度更快。回顾++被重载成前置和后置运算符的例子如下： 1234567891011CDemo CDemo::operator++ ()&#123; //前置++ ++n; return *this;&#125;CDemo CDemo::operator ++(int k)&#123; //后置++ CDemo tmp(*this); //记录修改前的对象 n++; return tmp; //返回修改前的对象&#125; ​ 后置++要多生成一个局部对象tmp，因此执行速度比前置的慢。同理，迭代器是一个对象，STL在重载迭代器的++运算符时，后置形式也比前置形式慢。在次数很多的循环中，++i和i++可能就会造成运行时间上可观的差别了。因此，对循环控制变量i，要养成写++i、不写i++的习惯。 ​ 注意，容器适配器stack、queue和priority_queue没有迭代器。容器适配器有一些成员函数，可以用来对元素进行访问。 迭代器的功能分类​ 不同容器的迭代器，其功能强弱有所不同。容器的迭代器的功能强弱，决定了该容器是否支持STL中的某种算法。例如，排序算法需要通过随机访问迭代器来访问容器中的元素，因此有的容器就不支持排序算法。 ​ 常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问五种，这里只介绍常用的三种。 正向迭代器。假设p是一个正向迭代器，则p支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用==和!=运算符进行比较。 双向迭代器。双向迭代器具有正向迭代器的全部功能。除此之外，若p是一个双向迭代器，则--p和p--都是有定义的。--p使得p朝和++p相反的方向移动。 随机访问迭代器。随机访问迭代器具有双向迭代器的全部功能。若p是一个随机访问迭代器，i是一个整型变量或常量，则p还支持以下操作： p+=i：使得p往后移动i个元素。 p-=i：使得p 往前移动i个元素。 p+i：返回p后面第i个元素的迭代器。 p-i：返回p前面第i个元素的迭代器。 p[i]：返回p后面第i个元素的引用。 ​ 此外，两个随机访问迭代器` p1`、`p2 `还可以用` &lt;`、`&gt;`、`&lt;=`、`&gt;= `运算符进行比较。`p1&lt;p2`的含义是：`p1 `经过若干次（至少一次）`++`操作后，就会等于` p2`。其他比较方式的含义与此类似。 ​ 对于两个随机访问迭代器` p1`、`p2`，表达式`p2-p1`也是有定义的，其返回值是` p2 `所指向元素和` p1 `所指向元素的序号之差（也可以说是` p2 `和` p1 `之间的元素个数减一）。 表1所示为不同容器的迭代器的功能。 容器 迭代器功能 vector 随机访问 deque 随机访问 list 双向 set / multiset 双向 map / multimap 双向 stack 不支持迭代器 queue 不支持迭代器 priority_queue 不支持迭代器 ​ 例如，vector的迭代器是随机迭代器，因此遍历vector容器有以下几种做法。下面的程序中，每个循环演示了一种做法。 【实例】遍历vector容器。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v(100); //v被初始化成有100个元素 for(int i = 0;i &lt; v.size() ; ++i) //size返回元素个数 cout &lt;&lt; v[i]; //像普通数组一样使用vector容器 vector&lt;int&gt;::iterator i; for(i = v.begin(); i != v.end (); ++i) //用 != 比较两个迭代器 cout &lt;&lt; * i; for(i = v.begin(); i &lt; v.end ();++i) //用 &lt; 比较两个迭代器 cout &lt;&lt; * i; i = v.begin(); while(i &lt; v.end()) &#123; //间隔一个输出 cout &lt;&lt; * i; i += 2; // 随机访问迭代器支持 "+= 整数" 的操作 &#125;&#125; ​ list容器的迭代器是双向迭代器。假设v和i的定义如下： 12list&lt;int&gt; v;list&lt;int&gt;::const_iterator i; ​ 则以下代码是合法的： 12for(i=v.begin(); i!=v.end(); ++i)cout &lt;&lt; *i; ​ 以下代码则不合法： 12for(i=v.begin(); i&lt;v.end(); ++i)cout &lt;&lt; *i; ​ 因为双向迭代器不支持用“&lt;”进行比较。以下代码也不合法： 12for(int i=0; i&lt;v.size(); ++i)cout &lt;&lt; v[i]; ​ 因为list不支持随机访问迭代器的容器，也不支持用下标随机访问其元素。 在`C++`中，数组也是容器。数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组` int a[10]`，`int * `类型的指针就是其迭代器。则` a`、`a+1`、`a+2`都是`a`的迭代器。 迭代器的辅助函数STL中有用于操作迭代器的三个函数模板，它们是： advance(p, n)：使迭代器p向前或向后移动n个元素。 distance(p, q)：计算两个迭代器之间的距离，即迭代器p经过多少次+ +操作后和迭代器q相等。如果调用时p已经指向q的后面，则这个函数会陷入死循环。 iter_swap(p, q)：用于交换两个迭代器p、q指向的值。 要使用上述模板，需要包含头文件algorithm。下面的程序演示了这三个函数模板的 用法。 1234567891011121314151617181920212223#include &lt;list&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt; //要使用操作迭代器的函数模板，需要包含此文件using namespace std;int main()&#123; int a[5] = &#123; 1, 2, 3, 4, 5 &#125;; list &lt;int&gt; lst(a, a+5); list &lt;int&gt;::iterator p = lst.begin(); advance(p, 2); //p向后移动两个元素，指向3 cout &lt;&lt; "1)" &lt;&lt; *p &lt;&lt; endl; //输出 1)3 advance(p, -1); //p向前移动一个元素，指向2 cout &lt;&lt; "2)" &lt;&lt; *p &lt;&lt; endl; //输出 2)2 list&lt;int&gt;::iterator q = lst.end(); q--; //q 指向 5 cout &lt;&lt; "3)" &lt;&lt; distance(p, q) &lt;&lt; endl; //输出 3)3 iter_swap(p, q); //交换 2 和 5 cout &lt;&lt; "4)"; for (p = lst.begin(); p != lst.end(); ++p) cout &lt;&lt; *p &lt;&lt; " "; return 0;&#125; 程序的输出结果是：1) 32) 23) 34) 1 5 3 4 2 STL容器使用时机 vector deque list set multiset map multimap 典型内存结构 单端数组 双端数组 双向链表 二叉树 二叉树 二叉树 二叉树 可随机存取 是 是 否 否 否 对key而言：不是 否 元素搜寻速度 慢 慢 非常慢 快 快 对key而言：快 对key而言：快 元素安插移除 尾端 头尾两端 任何位置 - - - - vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。 deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。 vector与deque的比较： vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置却是不固定的。 如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。 deque支持头部的快速插入与快速移除，这是deque的优点。 list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。 set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++类模板]]></title>
    <url>%2F2018%2F08%2F15%2Fc%2B%2B%E6%A8%A1%E6%9D%BF3-%E7%B1%BB%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[类模板类模板的显式具体化​ 下面的函数模板，它用来获取两个变量中较大的一个： 123template&lt;class T&gt; const T&amp; Max(const T&amp; a, const T&amp; b)&#123; return a &gt; b ? a : b;&#125; ​ 请读者注意a &gt; b这条语句，&gt;能够用来比较 int、float、char等基本类型数据的大小，但是却不能用来比较结构体变量、对象以及数组的大小，因为我们并没有针对结构体、类和数组重载&gt;。另外，该函数模板虽然可以用于指针，但比较的是地址大小，而不是指针指向的数据，所以也没有现实的意义。 ​ 模板是一种泛型技术，它能接受的类型是宽泛的、没有限制的，并且对这些类型使用的算法都是一样的（函数体或类体一样）。但是现在我们希望改变这种“游戏规则”，让模板能够针对某种具体的类型使用不同的算法（函数体或类体不同），这在C++中是可以做到的，这种技术称为模板的显示具体化（Explicit Specialization）。 ​ 函数模板和类模板都可以显示具体化。除了函数模板，类模板也可以显示具体化，并且它们的语法是类似的。 ​ 在C++类模板一节中我们定义了一个Point类，用来输出不同类型的坐标。在输出结果中，横坐标x和纵坐标y是以逗号,为分隔的，但是由于个人审美的不同，我希望当x和y都是字符串时以|为分隔，是数字或者其中一个是数字时才以逗号,为分隔。为了满足我这种奇葩的要求，可以使用显示具体化技术对字符串类型的坐标做特殊处理。 下面的例子演示了如何对Point类进行显示具体化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;//类模板template&lt;class T1, class T2&gt; class Point&#123;public: Point(T1 x, T2 y): m_x(x), m_y(y)&#123; &#125;public: T1 getX() const&#123; return m_x; &#125; void setX(T1 x)&#123; m_x = x; &#125; T2 getY() const&#123; return m_y; &#125; void setY(T2 y)&#123; m_y = y; &#125; void display() const;private: T1 m_x; T2 m_y;&#125;;template&lt;class T1, class T2&gt; //这里要带上模板头void Point&lt;T1, T2&gt;::display() const&#123; cout&lt;&lt;"x="&lt;&lt;m_x&lt;&lt;", y="&lt;&lt;m_y&lt;&lt;endl;&#125;//类模板的显示具体化（针对字符串类型的显示具体化）template&lt;&gt; class Point&lt;char*, char*&gt;&#123;public: Point(char *x, char *y): m_x(x), m_y(y)&#123; &#125;public: char *getX() const&#123; return m_x; &#125; void setX(char *x)&#123; m_x = x; &#125; char *getY() const&#123; return m_y; &#125; void setY(char *y)&#123; m_y = y; &#125; void display() const;private: char *m_x; //x坐标 char *m_y; //y坐标&#125;;//这里不能带模板头template&lt;&gt;void Point&lt;char*, char*&gt;::display() const&#123; cout&lt;&lt;"x="&lt;&lt;m_x&lt;&lt;" | y="&lt;&lt;m_y&lt;&lt;endl;&#125;int main()&#123; ( new Point&lt;int, int&gt;(10, 20) ) -&gt; display(); ( new Point&lt;int, char*&gt;(10, "东京180度") ) -&gt; display(); ( new Point&lt;char*, char*&gt;("东京180度", "北纬210度") ) -&gt; display(); return 0;&#125; 运行结果：x=10, y=20x=10, y=东京180度x=东京180度 | y=北纬210度 ​ 请读者注意第25行代码，Point表明了要将类型参数T1、T2都具体化为char*类型，原来使用T1、T2的位置都应该使用char*替换。Point类有两个类型参数T1、T2，并且都已经被具体化了，所以整个类模板就不再有类型参数了，模板头应该写作template&lt;&gt;。 ​ 再来对比第19、40行代码，可以发现，当在类的外部定义成员函数时，普通类模板的成员函数前面要带上模板头，而具体化的类模板的成员函数前面不能带模板头。 部分显式具体化​ 在上面的显式具体化例子中，我们为所有的类型参数都提供了实参，所以最后的模板头为空，也即template&lt;&gt;。另外C++还允许只为一部分类型参数提供实参，这称为部分显式具体化。 ​ 部分显式具体化只能用于类模板，不能用于函数模板。 ​ 仍然以Point为例，假设我现在希望“只要横坐标x是字符串类型”就以|来分隔输出结果，而不管纵坐标 y是什么类型，这种要求就可以使用部分显式具体化技术来满足。请看下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;//类模板template&lt;class T1, class T2&gt; class Point&#123;public: Point(T1 x, T2 y): m_x(x), m_y(y)&#123; &#125;public: T1 getX() const&#123; return m_x; &#125; void setX(T1 x)&#123; m_x = x; &#125; T2 getY() const&#123; return m_y; &#125; void setY(T2 y)&#123; m_y = y; &#125; void display() const;private: T1 m_x; T2 m_y;&#125;;template&lt;class T1, class T2&gt; //这里需要带上模板头void Point&lt;T1, T2&gt;::display() const&#123; cout&lt;&lt;"x="&lt;&lt;m_x&lt;&lt;", y="&lt;&lt;m_y&lt;&lt;endl;&#125;//类模板的部分显示具体化template&lt;typename T2&gt; class Point&lt;char*, T2&gt;&#123;public: Point(char *x, T2 y): m_x(x), m_y(y)&#123; &#125;public: char *getX() const&#123; return m_x; &#125; void setX(char *x)&#123; m_x = x; &#125; T2 getY() const&#123; return m_y; &#125; void setY(T2 y)&#123; m_y = y; &#125; void display() const;private: char *m_x; //x坐标 T2 m_y; //y坐标&#125;;template&lt;typename T2&gt; //这里需要带上模板头void Point&lt;char*, T2&gt;::display() const&#123; cout&lt;&lt;"x="&lt;&lt;m_x&lt;&lt;" | y="&lt;&lt;m_y&lt;&lt;endl;&#125;int main()&#123; ( new Point&lt;int, int&gt;(10, 20) ) -&gt; display(); ( new Point&lt;char*, int&gt;("东京180度", 10) ) -&gt; display(); ( new Point&lt;char*, char*&gt;("东京180度", "北纬210度") ) -&gt; display(); return 0;&#125; 运行结果：x=10, y=20x=东京180度 | y=10x=东京180度 | y=北纬210度 ​ 本例中，T1对应横坐标x的类型，我们将T1具体化为char*，第25行代码就是类模板的部分显示具体化。 ​ 模板头template中声明的是没有被具体化的类型参数；类名Point列出了所有类型参数，包括未被具体化的和已经被具体化的。 ​ 类名后面之所以要列出所有的类型参数，是为了让编译器确认“到底是第几个类型参数被具体化了”，如果写作template class Point，编译器就不知道char*代表的是第一个类型参数，还是第二个类型参数。 类模板中使用非类型参数​ 模板是一种泛型技术，目的是将数据的类型参数化，以增强C++语言（强类型语言）的灵活性。C++对模板的支持非常自由，模板中除了可以包含类型参数，还可以包含非类型参数，例如： 12template&lt;typename T, int N&gt; class Demo&#123; &#125;;template&lt;class T, int N&gt; void func(T (&amp;arr)[N]); ​ T是一个类型参数，它通过class或typename关键字指定。N是一个非类型参数，用来传递数据的值，而不是类型，它和普通函数的形参一样，都需要指明具体的类型。类型参数和非类型参数都可以用在函数体或者类体中。 ​ 当调用一个函数模板或者通过一个类模板创建对象时，非类型参数会被用户提供的、或者编译器推断出的值所取代。 ​ C/C++规定，数组一旦定义后，它的长度就不能改变了；换句话说，数组容量不能动态地增大或者减小。这样的数组称为静态数组（Static array）。静态数组有时候会给编码代码不便，我们可以通过自定义的Array类来实现动态数组（Dynamic array）。所谓动态数组，是指数组容量能够在使用的过程中随时增大或减小。 动态数组的完整实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;template&lt;typename T, int N&gt;class Array&#123;public: Array(); ~Array();public: T &amp; operator[](int i); //重载下标运算符[] int length() const &#123; return m_length; &#125; //获取数组长度 bool capacity(int n); //改变数组容量private: int m_length; //数组的当前长度 int m_capacity; //当前内存的容量（能容乃的元素的个数） T *m_p; //指向数组内存的指针&#125;;template&lt;typename T, int N&gt;Array&lt;T, N&gt;::Array()&#123; m_p = new T[N]; m_capacity = m_length = N;&#125;template&lt;typename T, int N&gt;Array&lt;T, N&gt;::~Array()&#123; delete[] m_p;&#125;template&lt;typename T, int N&gt;T &amp; Array&lt;T, N&gt;::operator[](int i)&#123; if(i&lt;0 || i&gt;=m_length)&#123; cout&lt;&lt;"Exception: Array index out of bounds!"&lt;&lt;endl; &#125; return m_p[i];&#125;template&lt;typename T, int N&gt;bool Array&lt;T, N&gt;::capacity(int n)&#123; if(n &gt; 0)&#123; //增大数组 int len = m_length + n; //增大后的数组长度 if(len &lt;= m_capacity)&#123; //现有内存足以容纳增大后的数组 m_length = len; return true; &#125;else&#123; //现有内存不能容纳增大后的数组 T *pTemp = new T[m_length + 2 * n * sizeof(T)]; //增加的内存足以容纳 2*n 个元素 if(pTemp == NULL)&#123; //内存分配失败 cout&lt;&lt;"Exception: Failed to allocate memory!"&lt;&lt;endl; return false; &#125;else&#123; //内存分配成功 memcpy( pTemp, m_p, m_length*sizeof(T) ); delete[] m_p; m_p = pTemp; m_capacity = m_length = len; &#125; &#125; &#125;else&#123; //收缩数组 int len = m_length - abs(n); //收缩后的数组长度 if(len &lt; 0)&#123; cout&lt;&lt;"Exception: Array length is too small!"&lt;&lt;endl; return false; &#125;else&#123; m_length = len; return true; &#125; &#125;&#125;int main()&#123; Array&lt;int, 5&gt; arr; //为数组元素赋值 for(int i=0, len=arr.length(); i&lt;len; i++)&#123; arr[i] = 2*i; &#125; //第一次打印数组 for(int i=0, len=arr.length(); i&lt;len; i++)&#123; cout&lt;&lt;arr[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; //扩大容量并为增加的元素赋值 arr.capacity(8); for(int i=5, len=arr.length(); i&lt;len; i++)&#123; arr[i] = 2*i; &#125; //第二次打印数组 for(int i=0, len=arr.length(); i&lt;len; i++)&#123; cout&lt;&lt;arr[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; //收缩容量 arr.capacity(-4); //第三次打印数组 for(int i=0, len=arr.length(); i&lt;len; i++)&#123; cout&lt;&lt;arr[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; return 0;&#125; 运行结果：0 2 4 6 80 2 4 6 8 10 12 14 16 18 20 22 240 2 4 6 8 10 12 14 16 ​ Array是一个类模板，它有一个类型参数T和一个非类型参数N，T指明了数组元素的类型，N指明了数组长度。 ​ capacity()成员函数是Array类的关键，它使得数组容量可以动态地增加或者减小。传递给它一个正数时，数组容量增大；传递给它一个负数时，数组容量减小。 ​ 之所以能通过[ ]来访问数组元素，是因为在Array类中以成员函数的形式重载了[ ]运算符，并且返回值是数组元素的引用。如果直接返回数组元素的值，那么将无法给数组元素赋值。 非类型参数的限制​ 非类型参数的类型不能随意指定，它受到了严格的限制，只能是一个整数，或者是一个指向对象或函数的指针（也可以是引用）。 1) 当非类型参数是一个整数时，传递给它的实参，或者由编译器推导出的实参必须是一个常量表达式，例如10、2 * 30、18 + 23 - 4等，但不能是n、n + 10、n + m等（n和m都是变量）。 对上面的 Array 类，以下创建对象的方式是错误的： 123int len;cin&gt;&gt;len;Array&lt;int, len&gt; arr; 这种情况，编译器推导出来的实参是len，是一个变量，而不是常量。 2) 当非类型参数是一个指针（引用）时，绑定到该指针的实参必须具有静态的生存期；换句话说，实参必须存储在虚拟地址空间中的静态数据区。局部变量位于栈区，动态创建的对象位于堆区，它们都不能用作实参。 类模板实例化​ 模板（Templet）并不是真正的函数或类，它仅仅是编译器用来生成函数或类的一张“图纸”。模板不会占用内存，最终生成的函数或者类才会占用内存。由模板生成函数或类的过程叫做模板的实例化（Instantiate），相应地，针对某个类型生成的特定版本的函数或类叫做模板的一个实例（Instantiation）。 ​ 模板也可以看做是编译器的一组指令，它命令编译器生成我们想要的代码。 ​ 模板的实例化是按需进行的，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码。也就是说，编译器会根据传递给类型参数的实参（也可以是编译器自己推演出来的实参）来生成一个特定版本的函数或类，并且相同的类型只生成一次。实例化的过程也很简单，就是将所有的类型参数用实参代替。 ​ 类模板的实例化，通过类模板创建对象时并不会实例化所有的成员函数，只有等到真正调用它们时才会被实例化；如果一个成员函数永远不会被调用，那它就永远不会被实例化。这说明类的实例化是延迟的、局部的，编译器并不着急生成所有的代码。 ​ 通过类模板创建对象时，一般只需要实例化成员变量和构造函数。成员变量被实例化后就能够知道对象的大小了（占用的字节数），构造函数被实例化后就能够知道如何初始化了；对象的创建过程就是分配一块大小已知的内存，并对这块内存进行初始化。 ​ 请看下面的例子： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;template&lt;class T1, class T2&gt;class Point&#123;public: Point(T1 x, T2 y): m_x(x), m_y(y)&#123; &#125;public: T1 getX() const&#123; return m_x; &#125; void setX(T1 x)&#123; m_x = x; &#125; T2 getY() const&#123; return m_y; &#125;; void setY(T2 y)&#123; m_y = y; &#125;; void display() const;private: T1 m_x; T2 m_y;&#125;;template&lt;class T1, class T2&gt;void Point&lt;T1, T2&gt;::display() const&#123; cout&lt;&lt;"x="&lt;&lt;m_x&lt;&lt;", y="&lt;&lt;m_y&lt;&lt;endl;&#125;int main()&#123; Point&lt;int, int&gt; p1(10, 20); p1.setX(40); p1.setY(50); cout&lt;&lt;"x="&lt;&lt;p1.getX()&lt;&lt;", y="&lt;&lt;p1.getY()&lt;&lt;endl; Point&lt;char*, char*&gt; p2("东京180度", "北纬210度"); p2.display(); return 0;&#125; 运行结果：x=40, y=50x=东京180度, y=北纬210度 ​ p1调用了所有的成员函数，整个类会被完整地实例化。p2只调用了构造函数和display()函数，剩下的 get函数和set函数不会被实例化。 ​ 值得提醒的是，Point和Point是两个相互独立的类，它们的类型是不同的，不能相互兼容，也不能自动地转换类型，所以诸如p1 = p2;这样的语句是错误的，除非重载了=运算符。 将类模板的声明和实现分散到不同的文件​ 总起来说，不管是函数还是类，声明和定义（实现）的分离其实是一回事，都是将函数定义放到其他文件中，最终要解决的问题也只有一个，就是把函数调用和函数定义对应起来（找到函数定义的地址，并填充到函数调用处），而保证完成这项工作的就是链接器。 ​ 基于传统的编程思维，初学者往往也会将模板（函数模板和类模板）的声明和定义分散到不同的文件中，以期达到「模块化编程」的目的。但事实证明这种做法是不对的，**程序员惯用的做法是将模板的声明和定义都放到头文件中。 ​ 我们看一个类模板的反面教材，它将类模板的声明和实现分别放到了头文件和源文件。 point.h源码： 12345678910111213141516171819#ifndef _POINT_H#define _POINT_Htemplate&lt;class T1, class T2&gt;class Point&#123;public: Point(T1 x, T2 y): m_x(x), m_y(y)&#123; &#125;public: T1 getX() const&#123; return m_x; &#125; void setX(T1 x)&#123; m_x = x; &#125; T2 getY() const&#123; return m_y; &#125;; void setY(T2 y)&#123; m_y = y; &#125;; void display() const;private: T1 m_x; T2 m_y;&#125;;#endif point.cpp源码： 12345678#include &lt;iostream&gt;#include "point.h"using namespace std;template&lt;class T1, class T2&gt;void Point&lt;T1, T2&gt;::display() const&#123; cout&lt;&lt;"x="&lt;&lt;m_x&lt;&lt;", y="&lt;&lt;m_y&lt;&lt;endl;&#125; main.cpp源码： 123456789101112131415#include &lt;iostream&gt;#include "point.h"using namespace std;int main()&#123; Point&lt;int, int&gt; p1(10, 20); p1.setX(40); p1.setY(50); cout&lt;&lt;"x="&lt;&lt;p1.getX()&lt;&lt;", y="&lt;&lt;p1.getY()&lt;&lt;endl; Point&lt;char*, char*&gt; p2("东京180度", "北纬210度"); p2.display(); return 0;&#125; ​ 该工程包含了两个源文件和一个头文件，point.h中声明了类模板，point.cpp中对类模板进行了实现，main.cpp中通过类模板创建了对象，并调用了成员函数，这是典型的将类的声明和实现分离的编程模式。 ​ 运行上面的程序，会产生一个链接错误，意思是无法通过p2调用Point::display() const这个函数。 ​ 类模板声明位于point.h中，它包含了所有成员变量的定义以及构造函数、get函数、set函数的定义，这些信息足够创建出一个完整的对象了，并且可以通过对象调用get函数和set函数，所以main.cpp的前11 行代码都不会报错。而第12行代码调用了display()函数，该函数的定义位于point.cpp文件中，并且point.cpp中也没有生成对应的实例，所以会在链接期间抛出错误。 类模板的显式实例化​ 前面讲到的模板的实例化是在调用函数或者创建对象时由编译器自动完成的，不需要程序员引导，因此称为隐式实例化。相对应的，我们也可以通过代码明确地告诉编译器需要针对哪个类型进行实例化，这称为显式实例化。 ​ 编译器在实例化的过程中需要知道模板的所有细节：对于函数模板，也就是函数定义；对于类模板，需要同时知道类声明和类定义。我们必须将显式实例化的代码放在包含了模板定义的源文件中，而不是仅仅包含了模板声明的头文件中。 ​ 显式实例化的一个好处是，可以将模板的声明和定义（实现）分散到不同的文件中了。 ​ 类模板的显式实例化和函数模板类似。以上节的Point类为例，针对char*类型的显式实例化（定义形式）代码为：1template class Point&lt;char*, char*&gt;; 相应地，它的声明形式为：1extern template class Point&lt;char*, char*&gt;; ​ 不管是声明还是定义，都要带上class关键字，以表明这是针对类模板的。 ​ 另外需要注意的是，显式实例化一个类模板时，会一次性实例化该类的所有成员，包括成员变量和成员函数。 ​ 有了类模板的显式实例化，就可以将类模板的声明和定义分散到不同的文件中了，下面我们就来修复上节的代码。 ​ point.cpp源文件： 123456789101112#include &lt;iostream&gt;#include "point.h"using namespace std;template&lt;class T1, class T2&gt;void Point&lt;T1, T2&gt;::display() const&#123; cout&lt;&lt;"x="&lt;&lt;m_x&lt;&lt;", y="&lt;&lt;m_y&lt;&lt;endl;&#125;//显式实例化定义template class Point&lt;char*, char*&gt;;template class Point&lt;int, int&gt;; point.h源码： 12345678910111213141516171819#ifndef _POINT_H#define _POINT_Htemplate&lt;class T1, class T2&gt;class Point&#123;public: Point(T1 x, T2 y): m_x(x), m_y(y)&#123; &#125;public: T1 getX() const&#123; return m_x; &#125; void setX(T1 x)&#123; m_x = x; &#125; T2 getY() const&#123; return m_y; &#125;; void setY(T2 y)&#123; m_y = y; &#125;; void display() const;private: T1 m_x; T2 m_y;&#125;;#endif main.cpp源码： 12345678910111213141516171819#include &lt;iostream&gt;#include "point.h"using namespace std;//显式实例化声明（也可以不写）extern template class Point&lt;char*, char*&gt;;extern template class Point&lt;int, int&gt;;int main()&#123; Point&lt;int, int&gt; p1(10, 20); p1.setX(40); p1.setY(50); cout&lt;&lt;"x="&lt;&lt;p1.getX()&lt;&lt;", y="&lt;&lt;p1.getY()&lt;&lt;endl; Point&lt;char*, char*&gt; p2("东京180度", "北纬210度"); p2.display(); return 0;&#125; 总结​ 函数模板和类模板的实例化语法是类似的，我们不妨对它们做一下总结：12extern template declaration; //实例化声明template declaration; //实例化定义 ​ 对于函数模板来说，declaration就是一个函数原型；对于类模板来说，declaration就是一个类声明。 显式实例化的缺陷​ C++支持显式实例化的目的是为「模块化编程」提供一种解决方案，这种方案虽然有效，但是也有明显的缺陷：程序员必须要在模板的定义文件（实现文件）中对所有使用到的类型进行实例化。这就意味着，每次更改了模板使用文件（调用函数模板的文件，或者通过类模板创建对象的文件），也要相应地更改模板定义文件，以增加对新类型的实例化，或者删除无用类型的实例化。 ​ 一个模板可能会在多个文件中使用到，要保持这些文件的同步更新是非常困难的。而对于库的开发者来说，他不能提前假设用户会使用哪些类型，所以根本就无法使用显式实例化，只能将模板的声明和定义（实现）全部放到头文件中；C++标准库几乎都是用模板来实现的，这些模板的代码也都位于头文件中。 ​ 总起来说，如果我们开发的模板只有我们自己使用，那也可以勉强使用显式实例化；如果希望让其他人使用（例如库、组件等），那只能将模板的声明和定义都放到头文件中了。 类模板与继承详解​ 类模板和类模板之间、类模板和类之间可以互相继承。它们之间的派生关系有以下四种情况。 类模板从类模板派生​ 示例程序： 123456789101112131415161718192021template &lt;class T1, class T2&gt;class A&#123; Tl v1; T2 v2;&#125;;template &lt;class T1, class T2&gt;class B : public A &lt;T2, T1&gt;&#123; T1 v3; T2 v4;&#125;;template &lt;class T&gt;class C : public B &lt;T, T&gt;&#123; T v5;&#125;;int main()&#123; B&lt;int, double&gt; obj1; C&lt;int&gt; obj2; return 0;&#125; ​ 编译到第18行，编译器用int替换类模板B中的T1，用double 替换T2，生成B&lt;int, double&gt;类如下： 1234class B &lt;int, double&gt;: public A &lt;double, int&gt;&#123; int v3; double v4;&#125;; ​ B &lt;int, double&gt;的基类是A &lt;double, int&gt;。于是编译器就要用double替换类模板A中的T1，用int替换T2，生成A&lt;double, int&gt;类如下： 1234class A &lt;double, int&gt;&#123; double v1; int v2;&#125;; ​ 编译到第19行，编译器生成类C&lt;int&gt;，还有C&lt;int&gt;的直接基类B&lt;int, int&gt;，以及B&lt;int, int&gt;的基类A&lt;int, int&gt;。 类模板从模板类派生​ 示例程序： 1234567891011121314151617template&lt;class T1, class T2&gt;class A&#123; T1 v1; T2 v2; &#125;;template &lt;class T&gt;class B: public A &lt;int, double&gt;&#123; T v;&#125;;int main() &#123; B &lt;char&gt; obj1; return 0; &#125; ​ 第4行，A&lt;int, double&gt;是一个具体的类的名字，而且它是一个模板类，因此说类模板B是从模板类派生而来的。 ​ 编译器编译到第5行Bobj1;时会自动生成两个模板类：A&lt;int, double&gt;和B&lt;char&gt;。 类模板从普通类派生​ 示例程序： 12345678910111213141516class A&#123; int v1; &#125;;template&lt;class T&gt;class B: public A&#123; T v; &#125;;int main ()&#123; B &lt;char&gt; obj1; return 0; &#125; 普通类从模板类派生​ 示例程序： 1234567891011121314151617template &lt;class T&gt;class A&#123; T v1; int n; &#125;;class B: public A &lt;int&gt; &#123; double v; &#125;;int main() &#123; B obj1; return 0; &#125; 类模板与友元详解​ 下面我们分四种情况分别讨论。 函数、类、类的成员函数作为类模板的友元​ 函数、类、类的成员函数都可以作为类模板的友元。程序示例如下： 123456789101112131415161718192021222324void Func1() &#123; &#125;class A &#123; &#125;;class B&#123;public: void Func() &#123; &#125;&#125;;template &lt;class T&gt;class Tmpl&#123; friend void Func1(); friend class A; friend void B::Func();&#125;;int main()&#123; Tmpl&lt;int&gt; i; Tmpl&lt;double&gt; f; return 0;&#125; ​ 类模板实例化时，除了类型参数被替换外，其他所有内容都原样保留，因此任何从Tmp1实例化得到的类都包含上面三条友元声明，因而也都会把Func1、类A和B::Func当作友元。 函数模板作为类模板的友元​ 之前我们定义了Pair模板，将&lt;&lt;运算符重载为一个函数模板，并将该函数模板作为Pair模板的友元，这样，任何从Pair模板实例化得到的对象都能用&lt;&lt;运算符通过cout输出。 程序代码如下（函数模板作为类模板的友元）： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;template &lt;class T1, class T2&gt;class Pair&#123;private: T1 key; //关键字 T2 value; //值public: Pair(T1 k, T2 v) : key(k), value(v) &#123; &#125;; bool operator &lt; (const Pair&lt;T1, T2&gt; &amp; p) const; template &lt;class T3, class T4&gt; friend ostream &amp; operator &lt;&lt; (ostream &amp; o, const Pair&lt;T3, T4&gt; &amp; p);&#125;;template &lt;class T1, class T2&gt;bool Pair &lt;T1, T2&gt;::operator&lt; (const Pair&lt;T1, T2&gt; &amp; p) const&#123; //“小”的意思就是关键字小 return key &lt; p.key;&#125;template &lt;class Tl, class T2&gt;ostream &amp; operator &lt;&lt; (ostream &amp; o, const Pair&lt;T1, T2&gt; &amp; p)&#123; o &lt;&lt; "(" &lt;&lt; p.key &lt;&lt; "," &lt;&lt; p.value &lt;&lt; ")"; return o;&#125;int main()&#123; Pair&lt;string, int&gt; student("Tom", 29); Pair&lt;int, double&gt; obj(12, 3.14); cout &lt;&lt; student &lt;&lt; " " &lt;&lt; obj; return 0;&#125; 程序的输出结果是：(Torn, 29) (12, 3.14) ​ 第13、14行将函数模板operator&lt;&lt;声明为类模板Pair 的友元。在Visual Studio中，这两行也可以用下面的写法替代：1friend ostream &amp; operator&lt;&lt; &lt;T1, T2&gt;(ostream &amp; o, const Pair&lt;T1, T2&gt; &amp; p); ​ 但在Dev C ++中，替代后编译就无法通过了。 ​ 编译本程序时，编译器自动生成了两个operator &lt;&lt;函数，它们的原型分别是：12ostream &amp; operator &lt;&lt; (ostream &amp; o, const Pair&lt;string, int&gt; &amp; p);ostream &amp; operator &lt;&lt; (ostream &amp; o, const Pair&lt;int, double&gt; &amp; p); ​ 前者是Pair &lt;string, int&gt; 类的友元，但不是Pair&lt;int, double&gt;类的友元；后者是Pair&lt;int, double&gt;类的友元，但不是Pair&lt;string, int&gt;类的友元。 函数模板作为类的友元​ 实际上，类也可以将函数模板声明为友元。程序示例如下： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class A&#123; int v;public: A(int n) :v(n) &#123; &#125; template &lt;class T&gt; friend void Print(const T &amp; p);&#125;;template &lt;class T&gt;void Print(const T &amp; p)&#123; cout &lt;&lt; p.v;&#125;int main()&#123; A a(4); Print(a); return 0;&#125; 程序的输出结果是：4 ​ 编译器编译到第19行Print(a);时，就从Print模板实例化出一个Print函数，原型如下：1void Print(const A &amp; p); ​ 这个函数本来不能访问p的私有成员。但是编译器发现，如果将类A的友元声明中的T换成A，就能起到将该Print函数声明为友元的作用，因此编译器就认为该Print函数是类A的友元。 类模板作为类模板的友元一个类模板还可以将另一个类模板声明为友元。程序示例如下： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;template&lt;class T&gt;class A&#123;public: void Func(const T &amp; p) &#123; cout &lt;&lt; p.v; &#125;&#125;;template &lt;class T&gt;class B&#123;private: T v;public: B(T n) : v(n) &#123; &#125; template &lt;class T2&gt; friend class A; //把类模板A声明为友元&#125;;int main()&#123; B&lt;int&gt; b(5); A&lt; B&lt;int&gt; &gt; a; //用B&lt;int&gt;替换A模板中的 T a.Func(b); return 0;&#125; 程序的输出结果是：5 ​ 在本程序中，A&lt; B&lt;int&gt; &gt;类成为B&lt;int&gt;类的友元。 类模板中的静态成员​ 类模板中可以定义静态成员，从该类模板实例化得到的所有类都包含同样的静态成员。 ​ 程序示例如下： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class A&#123;private: static int count;public: A() &#123; count ++; &#125; ~A() &#123; count -- ; &#125;; A(A &amp;) &#123; count ++ ; &#125; static void PrintCount() &#123; cout &lt;&lt; count &lt;&lt; endl; &#125;&#125;;template&lt;&gt; int A&lt;int&gt;::count = 0;template&lt;&gt; int A&lt;double&gt;::count = 0;int main()&#123; A&lt;int&gt; ia; A&lt;double&gt; da; ia.PrintCount(); da.PrintCount(); return 0;&#125; 程序的输出结果是：11 ​ 第14 行和第15行，对静态成员变量在类外部加以声明是必需的。在Visual Studio 2008 中，这两行也可以简单地写成：12int A&lt;int&gt;::count = 0;int A&lt;double&gt;::count = 0; ​ A&lt;int&gt;和A&lt;double&gt;是两个不同的类。虽然它们都有静态成员变量count，但是显然，A&lt;int&gt;的对象ia和A&lt;double&gt; 的对象 da不会共享一份count。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++STL函数对象]]></title>
    <url>%2F2018%2F08%2F15%2Fc%2B%2B-STL%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[如果一个类将()运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象。函数对象是一个对象，但是使用的形式看起来像函数调用，实际上也执行了函数调用，因而得名。 ​ 下面是一个函数对象的例子。 123456789101112131415161718#include &lt;iostream&gt;using namespace std;class CAverage&#123;public: double operator()(int a1, int a2, int a3) &#123; //重载()运算符 return (double)(a1 + a2 + a3) / 3; &#125;&#125;;int main()&#123; CAverage average; //能够求三个整数平均数的函数对象 cout &lt;&lt; average(3, 2, 3); //等价于 cout &lt;&lt; average.operator(3, 2, 3); return 0;&#125; ​ 程序的输出结果是：2. 66667 ​ ()是目数不限的运算符，因此重载为成员函数时，有多少个参数都可以。 ​ average是一个对象，average(3, 2, 3)实际上就是average.operator(3, 2, 3)，这使得average看上去像函数的名字，故称其为函数对象。 函数对象在accumulate算法中的应用​ STL中有以下实现“累加”功能的算法（函数模板）：12template &lt;class InIt, class T, class Pred&gt; T accumulate(InIt first, InIt last, T val, Pred op); ​ 该模板的功能是对[first, last)中的每个迭代器I执行val = op(val, *I)，返回最终的val。在numeric头文件中 accumulate的源代码如下： 1234567template &lt;class InIt, class T, class Pred&gt;T accumulate(InIt first, Init last, T init, Pred op)&#123; for (; first != last; ++first) init = op(init, *first); return init;&#125;; ​ 此模板被实例化后，op(init, *first)必须要有定义，则op只能是函数指针或者函数对象。因此调用该 accmulate模板时，形参op对应的实参只能是函数名、函数指针或者函数对象。 下面的程序通过`accumulate`模板求一个`vector`中元素的平方和，其中用到了函数对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;numeric&gt; //accumulate 在此头文件定义using namespace std;template &lt;class T&gt;void PrintInterval(T first, T last)&#123; //输出区间[first,last)中的元素 for (; first != last; ++first) cout &lt;&lt; *first &lt;&lt; " "; cout &lt;&lt; endl;&#125;int SumSquares(int total, int value)&#123; return total + value * value;&#125;template&lt;class T&gt;class SumPowers&#123;private: int power;public: SumPowers(int p) :power(p) &#123; &#125; const T operator() (const T &amp; total, const T &amp; value) &#123; //计算 value的power次方，加到total上 T v = value; for (int i = 0; i &lt; power - 1; ++i) v = v * value; return total + v; &#125;&#125;;int main()&#123; const int SIZE = 10; int a1[] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;; vector&lt;int&gt; v(a1, a1 + SIZE); cout &lt;&lt; "1) "; PrintInterval(v.begin(), v.end()); int result = accumulate(v.begin(), v.end(), 0, SumSquares); cout &lt;&lt; "2) 平方和：" &lt;&lt; result &lt;&lt; endl; result = accumulate(v.begin(), v.end(), 0, SumPowers&lt;int&gt;(3)); cout &lt;&lt; "3) 立方和：" &lt;&lt; result &lt;&lt; endl; result = accumulate(v.begin(), v.end(), 0, SumPowers&lt;int&gt;(4)); cout &lt;&lt; "4) 4次方和：" &lt;&lt; result; return 0;&#125; ​ 程序的输出结果如下：1)1 2 3 4 5 6 7 8 9 102)平方和:3853)立方和30254)4次方和:25333 ​ 第44 行，第四个参数是SumSquares函数的名字。函数名字的类型是函数指针，因此本行将accumulate 模板实例化后得到的模板函数定义如下： 123456int accumulate(vector &lt;int&gt;::iterator first, vector &lt;int&gt;::iterator last, int init, int(*op)(int, int))&#123; for (; first != last; ++first) init = op(init, *first); return init;&#125; ​ 形参op是一个函数指针，而op(init, *first)就调用了指针op指向的函数，在第44行的情况下就是函数SumSquares。 ​ 第47行，第四个参数是SumPowers&lt;int&gt;(3)。SumPowers是类模板的名字，SumPowers&lt;int&gt; 就是类的名字。类的名字后面跟着构造函数的参数列表，就代表一个临时对象。因此SumPowers&lt;int&gt;(3)就是一个 SumPowers&lt;int&gt;类的临时对象。 编译器在编译此行时，会将`accumulate`模板实例化成以下函数： 123456int accumulate(vector&lt;int&gt;::iterator first, vector&lt;int&gt;::iterator last, int init, SumPowers&lt;int&gt; op)&#123; for (; first != last; ++first) init = op(init, *first); return init;&#125; ​ 形参op是一个函数对象，而op(init, *first)等价于：1op.operator()(init, *first); ​ 即调用了SumPowers&lt;int&gt;类的operator()成员函数。 ​ 对比SumPowers和SumSquares可以发现，函数对象的operator()成员函数可以根据对象内部的不同状态执行不同操作，而普通函数就无法做到这一点。因此函数对象的功能比普通函数更强大。 函数对象在sort算法中的应用​ STL中的排序模板sort能将区间从小到大排序。sort算法有两个版本。第一个版本的原型如下：12template &lt;class_Randlt&gt; void sort(_Randlt first, _RandIt last); ​ 该模板可以用来将区间[first, last)中的元素从小到大排序，要求first、last是随机访问迭代器。元素比较大小是用&lt;进行的。如果表达式a的值为true，则a排在b前面；如果a的值为false，则b未必排在a前面，还要看b是否成立，成立的话b才排在a前面。要使用这个版本的sort算法，待排序的对象必须能用&lt;运算符进行比较。 ​ sort算法第二个版本的原型如下：12template &lt;class_Randlt, class Pred&gt; void sort(_Randlt first, _RandIt last, Pred op); ​ 这个版本和第一个版本的差别在于，元素a、b比较大小是通过表达式op(a, b)进行的。如果该表达式的值为true，则a比b小；如果该表达式的值为false，也不能认为b比a小，还要看op(b, a)的值。总之，op定义了元素比较大小的规则。下面是一个使用sort算法的例子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;algorithm&gt; //sort算法在此头文件中定义using namespace std;template &lt;class T&gt;void Printlnterva1(T first, T last)&#123; //用以输出 [first, last) 区间中的元素 for (; first != last; ++first) cout &lt;&lt; *first &lt;&lt; " "; cout &lt;&lt; endl;&#125;class A&#123;public: int v; A(int n) : v(n) &#123;&#125;&#125;;bool operator &lt; (const A &amp; a1, const A &amp; a2)&#123; //重载为 A 的 const 成员函数也可以，重载为非 const 成员函数在某些编译器上会出错 return a1.v &lt; a2.v;&#125;bool GreaterA(const A &amp; a1, const A &amp; a2)&#123; //v值大的元素作为较小的数 return a1.v &gt; a2.v;&#125;struct LessA&#123; bool operator() (const A &amp; a1, const A &amp; a2) &#123; //v的个位数小的元素就作为较小的数 return (a1.v % 10) &lt; (a2.v % 10); &#125;&#125;;ostream &amp; operator &lt;&lt; (ostream &amp; o, const A &amp; a)&#123; o &lt;&lt; a.v; return o;&#125;int main()&#123; int a1[4] = &#123; 5, 2, 4, 1 &#125;; A a2[5] = &#123; 13, 12, 9, 8, 16 &#125;; sort(a1, a1 + 4); cout &lt;&lt; "1)"; Printlnterva1(a1, a1 + 4); //输出 1)1 2 4 5 sort(a2, a2 + 5); //按v的值从小到大排序 cout &lt;&lt; "2)"; Printlnterva1(a2, a2 + 5); //输出 2)8 9 12 13 16 sort(a2, a2 + 5, GreaterA); //按v的值从大到小排序 cout &lt;&lt; "3)"; Printlnterva1(a2, a2 + 5); //输出 3)16 13 12 9 8 sort(a2, a2 + 5, LessA()); //按v的个位数从小到大排序 cout &lt;&lt; "4)"; Printlnterva1(a2, a2 + 5); //输出 4)12 13 16 8 9 return 0;&#125; ​ 编译至第57行时，编译器将sort实例化得到的函数原型如下：1void sort(A* first, A* last, bool (*op)(const A &amp;, const A &amp;) ); ​ 该函数在执行过程中，当要比较两个元素a、b的大小时，就是看 op(a, b)和op(b, a)的返回值。本程序中op指向GreaterA，因此就用GreaterA定义的规则来比较大小。 ​ 编译至第61行时，编译器将sort实例化得到的函数原型如下：1void sort( A* first, A* last, LessA op); ​ 该函数在执行过程中，当要比较两个元素a、b的大小时，就是看op(a, b)和 op(b, a)的返回值。本程序中，op(a, b)等价于op.opeartor(a, b)，因此就用LessA定义的规则来比较大小。 ​ STL中定义了一些函数对象类模板，都位于头文件functional 中。例如，greater模板的源代码如下： 1234567template &lt;class T&gt;struct greater&#123; bool operator()(const T&amp; x, const T&amp; y) const&#123; return x &gt; y; &#125;&#125;; ​ 假设有以下数组：1int a[4] = &#123;3, 5, 34, 8&#125;; ​ 要将该数组从大到小排序，则只需写：1sort( a, a+4, greater&lt;int&gt;() ); ​ 要使用greater模板，须确保&gt;运算符本来就有定义，或经过了适当的重载。 ​ list容器的sort成员能将元素从小到大排序。它也有两个版本：一个是没有参数的函数，比较大小用&lt;运算符；另一个是函数模板，原型如下：12template &lt;class Pred&gt; void sort(Pred op); ​ sort函数允许自定义比较大小的规则，即op(x, y)为真就认为x比y小。例如，假设有：1list&lt;int&gt; lst; ​ 如果希望将lst 中的元素按其整数数值从大到小排序，只需写：1lst.sort( greater&lt;int&gt;() ); ​ 在使用关联容器和许多算法时，都可以用函数对象来定义比较大小的规则，以及其他一些规则和操作。 STL中的函数对象类模板STL中有一些函数对象类模板，如表1所示。 函数对象类模板 成员函数T operator ( const T &amp; x, const T &amp; y)的功能 plus &lt;T&gt; return x + y; minus &lt;T&gt; return x - y; multiplies &lt;T&gt; return x * y; divides &lt;T&gt; return x / y; modulus &lt;T&gt; return x % y; 成员函数bool operator( const T &amp; x, const T &amp; y)的功能 equal_to &lt;T&gt; return x == y; not_equal_to &lt;T&gt; return x! = y; greater &lt;T&gt; return x &gt; y; less &lt;T&gt; return x &lt; y; greater_equal &lt;T&gt; return x &gt; = y; less_equal &lt;T&gt; return x &lt;= y; logical_and &lt;T&gt; return x &amp;&amp; y; logical_or &lt;T&gt; `return x \ \ y;` 成员函数T operator( const T &amp; x)的功能 negate &lt;T&gt; return - x; 成员函数bool operator( const T &amp; x)的功能 logical_not &lt;T&gt; return ! x; 例如，如果要求两个double型变量x、y的乘积，可以写：1multiplies&lt;double&gt; () (x, y) ​ less是STL中最常用的函数对象类模板，其定义如下： 123456template &lt;class_Tp&gt;struct less&#123; bool operator() (const_Tp &amp; __x, const_Tp &amp; __y) const &#123; return __x &lt; __y; &#125;&#125;; 要判断两个int变量x、y中x是否比y小，可以写：1if( less&lt;int&gt;()(x, y) ) &#123; ... &#125; 引入函数对象后STL 中的“大”、“小”和“相等”概念​ 前面提到过，默认情况下，STL中的容器和算法比较元素的大小是通过&lt;运算符进行的。sort和list::sort都可以通过一个函数对象或函数自定义比较元素大小的规则。例如以下的 sort 版本：12template &lt;class_RandIt, class Pred&gt; void sort(_RandIt first, _RandIt last, Pred op); ​ 实际调用sort时，和 op对应的实参可以是一个函数对象或者函数的名字。sort在执行过程中用op(x, y) 比较x和y的大小，因此可以将op称为自定义的“比较器”。 ​ 关联容器中的元素是从小到大排序的。使用关联容器时，也可以用自定义的比较器取代&lt;运算符，以规定元素之间的大小关系。STL中还有许多算法都可以自定义比较器。在自定义比较器op的情况下，以下三种说法是等价的： x小于y。 op(x, y)的返回值为true。 y大于x。 同样地，对关联容器的find和count成员函数以及其他一些在有序区间上的STL算法而言，在自定义比较器op的情况下，x和y相等与op(x, y)和op(y, x)`都为假是等价的。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++函数模板]]></title>
    <url>%2F2018%2F08%2F10%2Fc%2B%2B%E6%A8%A1%E6%9D%BF2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[函数模板函数模板的重载​ 当需要对不同的类型使用同一种算法（同一个函数体）时，为了避免定义多个功能重复的函数，可以使用模板。然而，并非所有的类型都使用同一种算法，有些特定的类型需要单独处理，为了满足这种需求，C++允许对函数模板进行重载，程序员可以像重载常规函数那样重载模板定义。 ​ 前面我们定义了Swap()函数用来交换两个变量的值，一种方案是使用指针，另外一种方案是使用引用，请看下面的代码： 12345678910111213//方案①：使用指针template&lt;typename T&gt; void Swap(T *a, T *b)&#123; T temp = *a; *a = *b; *b = temp;&#125;//方案②：使用引用template&lt;class T&gt; void Swap(T &amp;a, T &amp;b)&#123; T temp = a; a = b; b = temp;&#125; ​ 这两种方案都可以交换int、float、char、bool等基本类型变量的值，但是却不能交换两个数组。 对于方案`①`，调用函数时传入的是数组指针，或者说是指向第` 0 `个元素的指针，这样交换的仅仅是数组的第` 0 `个元素，而不是整个数组。数组和指针本来是不等价的，只是当函数的形参为指针时，传递的数组也会隐式地转换为指针。 ​ 对于方案②，假设传入的是一个长度为5的int类型数组（该数组的类型是int [5]），那么T的真实类型为int [5]，T temp会被替换为int [5] temp，这显然是错误的。另外一方面，语句a=b;尝试对数组a赋值，而数组名是常量，它的值不允许被修改，所以也会产生错误。总起来说，方案②会有两处语法错误。 ​ 交换两个数组唯一的办法就是逐个交换所有的数组元素，请看下面的代码： 12345678template&lt;typename T&gt; void Swap(T a[], T b[], int len)&#123; T temp; for(int i=0; i&lt;len; i++)&#123; temp = a[i]; a[i] = b[i]; b[i] = temp; &#125;&#125; ​ 在该函数模板中，最后一个参数的类型为具体类型（int），而不是泛型。并不是所有的模板参数都必须被泛型化。 ​ 下面是一个重载函数模板的完整示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;template&lt;class T&gt; void Swap(T &amp;a, T &amp;b); //模板①：交换基本类型的值template&lt;typename T&gt; void Swap(T a[], T b[], int len); //模板②：交换两个数组void printArray(int arr[], int len); //打印数组元素int main()&#123; //交换基本类型的值 int m = 10, n = 99; Swap(m, n); //匹配模板① cout&lt;&lt;m&lt;&lt;", "&lt;&lt;n&lt;&lt;endl; //交换两个数组 int a[5] = &#123; 1, 2, 3, 4, 5 &#125;; int b[5] = &#123; 10, 20, 30, 40, 50 &#125;; int len = sizeof(a) / sizeof(int); //数组长度 Swap(a, b, len); //匹配模板② printArray(a, len); printArray(b, len); return 0;&#125;template&lt;class T&gt; void Swap(T &amp;a, T &amp;b)&#123; T temp = a; a = b; b = temp;&#125;template&lt;typename T&gt; void Swap(T a[], T b[], int len)&#123; T temp; for(int i=0; i&lt;len; i++)&#123; temp = a[i]; a[i] = b[i]; b[i] = temp; &#125;&#125;void printArray(int arr[], int len)&#123; for(int i=0; i&lt;len; i++)&#123; if(i == len-1)&#123; cout&lt;&lt;arr[i]&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;arr[i]&lt;&lt;", "; &#125; &#125;&#125; 运行结果：99, 1010, 20, 30, 40, 501, 2, 3, 4, 5 函数模板的实参推断​ 在使用类模板创建对象时，程序员需要显式的指明实参（也就是具体的类型）。例如对于下面的Point类： 1template&lt;typename T1, typename T2&gt; class Point; ​ 我们可以在栈上创建对象，也可以在堆上创建对象： 12Point&lt;int, int&gt; p1(10, 20); //在栈上创建对象Point&lt;char*, char*&gt; *p = new Point&lt;char*, char*&gt;("东京180度", "北纬210度"); //在堆上创建对象 ​ 因为已经显式地指明了T1、T2的具体类型，所以编译器就不用再自己推断了，直接拿来使用即可。 ​ 而对于函数模板，调用函数时可以不显式地指明实参（也就是具体的类型）。请看下面的例子： 12345678//函数声明template&lt;typename T&gt; void Swap(T &amp;a, T &amp;b);//函数调用int n1 = 100, n2 = 200;Swap(n1, n2);float f1 = 12.5, f2 = 56.93;Swap(f1, f2); ​ 虽然没有显式地指明T的具体类型，但是编译器会根据n1和n2、f1和f2的类型自动推断出T的类型。这种通过函数实参来确定模板实参（也就是类型参数的具体类型）的过程称为模板实参推断。 ​ 在模板实参推断过程中，编译器使用函数调用中的实参类型来寻找类型参数的具体类型。 模板实参推断过程中的类型转换普通函数​ 对于普通函数（非模板函数），发生函数调用时会对实参的类型进行适当的转换，以适应形参的类型。这些转换包括： 算数转换：例如int转换为float，char转换为int，double转换为int等。 派生类向基类的转换：也就是向上转型。 const转换：也即将非const类型转换为const类型，例如将char *转换为const char *。 数组或函数指针转换：如果函数形参不是引用类型，那么数组名会转换为数组指针，函数名也会转换为函数指针。 用户自定的类型转换。 例如有下面两个函数原型： 12void func1(int n, float f);void func2(int *arr, const char *str); ​ 它们具体的调用形式为： 1234int nums[5];char *url = "http://c.biancheng.net";func1(12.5, 45);func2(nums, url); ​ 对于func1()，12.5会从double转换为int，45 会从int转换为float；对于func2()，nums会从int [5]转换为int *，url会从char *转换为const char *。 函数模板​ 对于函数模板，类型转换则受到了更多的限制，仅能进行「const转换」和「数组或函数指针转换」，其他的都不能应用于函数模板。例如有下面几个函数模板： 12345template&lt;typename T&gt; void func1(T a, T b);template&lt;typename T&gt; void func2(T *buffer);template&lt;typename T&gt; void func3(const T &amp;stu);template&lt;typename T&gt; void func4(T a);template&lt;typename T&gt; void func5(T &amp;a); ​ 它们具体的调用形式为： 12345678int name[20];Student stu1("张华", 20, 96.5); //创建一个Student类型的对象func1(12.5, 30); //Errorfunc2(name); //name的类型从 int [20] 换转换为 int *，所以 T 的真实类型为 intfunc3(stu1); //非const转换为const，T 的真实类型为 Studentfunc4(name); //name的类型从 int [20] 换转换为 int *，所以 T 的真实类型为 int *func5(name); //name的类型依然为 int [20]，不会转换为 int *，所以 T 的真实类型为 int [20] ​ 对于func1(12.5, 30)，12.5的类型为double，30的类型为int，编译器不知道该将T 实例化为 double还是int，也不会尝试将int转换为double，或者将double转换为int，所以调用失败。 请读者注意name，它本来的类型是int [20]： 对于func2(name)和func4(name)，name的类型会从int [20]转换为int *，也即将数组转换为指针，所以 T的类型分别为int * 和int。 对于func5(name)，name的类型依然为int [20]，不会转换为int *，所以T的类型为int [20]。 可以发现，当函数形参是引用类型时，数组不会转换为指针。这个时候读者要注意下面这样的函数模板： 1template&lt;typename T&gt; void func(T &amp;a, T &amp;b); ​ 如果它的具体调用形式为： 123int str1[20];int str2[10];func(str1, str2); ​ 由于str1、str2的类型分别为int [20]和int [10]，在函数调用过程中又不会转换为指针，所以编译器不知道应该将T实例化为int [20]还是int [10]，导致调用失败。 为函数模板显式地指明实参（也就是具体的类型）​ 函数模板的实参推断是指「在函数调用过程中根据实参的类型来寻找类型参数的具体类型」的过程，这在大部分情况下是奏效的，但是当类型参数的个数较多时，就会有个别的类型无法推断出来，这个时候就必须显式地指明实参。 ​ 下面是一个实参推断失败的例子： 12345template&lt;typename T1, typename T2&gt; void func(T1 a)&#123; T2 b;&#125;func(10); //函数调用 ​ func()有两个类型参数，分别是T1和T2，但是编译器只能从函数调用中推断出T1的类型来，不能推断出T2的类型来，所以这种调用是失败的，这个时候就必须显式地指明T1、T2的具体类型。 ​ 「为函数模板显式地指明实参」和「为类模板显式地指明实参」的形式是类似的，就是在函数名后面添加尖括号&lt; &gt;，里面包含具体的类型。例如对于上面的func()，我们要这样来指明实参： 1func&lt;int, int&gt;(10); ​ 显式指明的模板实参会按照从左到右的顺序与对应的模板参数匹配：第一个实参与第一个模板参数匹配，第二个实参与第二个模板参数匹配，以此类推。只有尾部（最右）的类型参数的实参可以省略，而且前提是它们可以从传递给函数的实参中推断出来。 ​ 对于上面的func()，虽然只有T2的类型不能自动推断出来，但是由于它位于类型参数列表的尾部（最右），所以必须同时指明T1和T2的类型。对代码稍微做出修改： 1234567template&lt;typename T1, typename T2&gt; void func(T2 a)&#123; T1 b;&#125;//函数调用func&lt;int&gt;(10); //省略 T2 的类型func&lt;int, int&gt;(20); //指明 T1、T2 的类型 ​ 由于T2的类型能够自动推断出来，并且它位于参数列表的尾部（最右），所以可以省略。 显式地指明实参时可以应用正常的类型转换​ 上面我们提到，函数模板仅能进行「const转换」和「数组或函数指针转换」两种形式的类型转换，但是当我们显式地指明类型参数的实参（具体类型）时，就可以使用正常的类型转换（非模板函数可以使用的类型转换）了。 ​ 例如对于下面的函数模板： 1template&lt;typename T&gt; void func(T a, T b); ​ 它的具体调用形式如下： 12func(10, 23.5); //Errorfunc&lt;float&gt;(20, 93.7); //Correct ​ 在第二种调用形式中，我们已经显式地指明了T的类型为float，编译器不会再为「T的类型到底是int还是double」而纠结了，所以可以从容地使用正常的类型转换了。 函数模板的显式具体化​ 下面的函数模板，它用来获取两个变量中较大的一个： 123template&lt;class T&gt; const T&amp; Max(const T&amp; a, const T&amp; b)&#123; return a &gt; b ? a : b;&#125; ​ 请读者注意a &gt; b这条语句，&gt;能够用来比较 int、float、char等基本类型数据的大小，但是却不能用来比较结构体变量、对象以及数组的大小，因为我们并没有针对结构体、类和数组重载&gt;。另外，该函数模板虽然可以用于指针，但比较的是地址大小，而不是指针指向的数据，所以也没有现实的意义。 ​ 模板是一种泛型技术，它能接受的类型是宽泛的、没有限制的，并且对这些类型使用的算法都是一样的（函数体或类体一样）。但是现在我们希望改变这种“游戏规则”，让模板能够针对某种具体的类型使用不同的算法（函数体或类体不同），这在C++中是可以做到的，这种技术称为模板的显示具体化（Explicit Specialization）。 ​ 函数模板和类模板都可以显示具体化。 在讲解函数模板的显示具体化语法之前，我们先来看一个显示具体化的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;typedef struct&#123; string name; int age; float score;&#125; STU;//函数模板template&lt;class T&gt; const T&amp; Max(const T&amp; a, const T&amp; b);//函数模板的显示具体化（针对STU类型的显示具体化）template&lt;&gt; const STU&amp; Max&lt;STU&gt;(const STU&amp; a, const STU&amp; b);//重载&lt;&lt;ostream &amp; operator&lt;&lt;(ostream &amp;out, const STU &amp;stu);int main()&#123; int a = 10; int b = 20; cout&lt;&lt;Max(a, b)&lt;&lt;endl; STU stu1 = &#123; "王明", 16, 95.5&#125;; STU stu2 = &#123; "徐亮", 17, 90.0&#125;; cout&lt;&lt;Max(stu1, stu2)&lt;&lt;endl; return 0;&#125;template&lt;class T&gt; const T&amp; Max(const T&amp; a, const T&amp; b)&#123; return a &gt; b ? a : b;&#125;template&lt;&gt; const STU&amp; Max&lt;STU&gt;(const STU&amp; a, const STU&amp; b)&#123; return a.score &gt; b.score ? a : b;&#125;ostream &amp; operator&lt;&lt;(ostream &amp;out, const STU &amp;stu)&#123; out&lt;&lt;stu.name&lt;&lt;" , "&lt;&lt;stu.age &lt;&lt;" , "&lt;&lt;stu.score; return out;&#125; 运行结果：20王明 , 16 , 95.5 本例中，STU结构体用来表示一名学生(Student)，它有三个成员，分别是姓名(name)、年龄(age)、成绩(score)；Max()函数用来获取两份数据中较大的一份。 ​ 要想获取两份数据中较大的一份，必然会涉及到对两份数据的比较。对于int、float、char等基本类型的数据，直接比较它们本身的值即可，而对于STU 类型的数据，直接比较它们本身的值不但会有语法错误，而且毫无意义，这就要求我们设计一套不同的比较方案，从语法和逻辑上都能行得通，所以本例中我们比较的是两名学生的成绩（score）。 ​ 不同的比较方案最终导致了算法（函数体）的不同，我们不得不借助模板的显示具体化技术对STU类型进行单独处理。第14行代码就是显示具体化的声明，第34行代码进行了定义。 ​ 请读者注意第34行代码，Max中的STU表明了要将类型参数T具体化为STU类型，原来使用T的位置都应该使用STU替换，包括返回值类型、形参类型、局部变量的类型。 ​ Max只有一个类型参数T，并且已经被具体化为STU了，这样整个模板就不再有类型参数了，类型参数列表也就为空了，所以模板头应该写作template&lt;&gt;。 ​ 另外，Max中的STU是可选的，因为函数的形参已经表明，这是STU类型的一个具体化，编译器能够逆推出T的具体类型。简写后的函数声明为：1template&lt;&gt; const STU&amp; Max(const STU&amp; a, const STU&amp; b); 函数的调用规则​ 回顾一下前面学习到的知识，在C++中，对于给定的函数名，可以有非模板函数、模板函数、显示具体化模板函数以及它们的重载版本，在调用函数时，显示具体化优先于常规模板，而非模板函数优先于显示具体化和常规模板。 函数模板中使用非类型参数​ 模板是一种泛型技术，目的是将数据的类型参数化，以增强C++语言（强类型语言）的灵活性。C++对模板的支持非常自由，模板中除了可以包含类型参数，还可以包含非类型参数，例如： 12template&lt;typename T, int N&gt; class Demo&#123; &#125;;template&lt;class T, int N&gt; void func(T (&amp;arr)[N]); ​ T是一个类型参数，它通过class或typename关键字指定。N是一个非类型参数，用来传递数据的值，而不是类型，它和普通函数的形参一样，都需要指明具体的类型。类型参数和非类型参数都可以用在函数体或者类体中。 ​ 当调用一个函数模板或者通过一个类模板创建对象时，非类型参数会被用户提供的、或者编译器推断出的值所取代。 ​ 之前我们通过Swap()函数来交换两个数组的值，其原型为：1template&lt;typename T&gt; void Swap(T a[], T b[], int len); ​ 形参len用来指明要交换的数组的长度，调用Swap()函数之前必须先通过sizeof求得数组长度再传递给它。 ​ 有读者可能会疑惑，为什么在函数内部不能求得数组长度，一定要通过形参把数组长度传递进去呢？这是因为数组在作为函数参数时会自动转换为数组指针，而sizeof只能通过数组名求得数组长度，不能通过数组指针求得数组长度。 ​ 多出来的形参len给编码带来了不便，我们可以借助模板中的非类型参数将它消除，请看下面的代码： 12345678template&lt;typename T, unsigned N&gt; void Swap(T (&amp;a)[N], T (&amp;b)[N])&#123; T temp; for(int i=0; i&lt;N; i++)&#123; temp = a[i]; a[i] = b[i]; b[i] = temp; &#125;&#125; ​ T (&amp;a)[N]表明a是一个引用，它引用的数据的类型是T [N]，也即一个数组；T (&amp;b)[N]也是类似的道理。分析一个引用和分析一个指针的方法类似，编译器总是从它的名字开始读取，然后按照优先级顺序依次解析。 ​ 调用Swap()函数时，需要将数组名字传递给它： 123int a[5] = &#123; 1, 2, 3, 4, 5 &#125;;int b[5] = &#123; 10, 20, 30, 40, 50 &#125;;Swap(a, b); ​ 编译器会使用数组类型int来代替类型参数T，使用数组长度5来代替非类型参数N。 ​ 下面是一个完整的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;template&lt;class T&gt; void Swap(T &amp;a, T &amp;b); //模板①：交换基本类型的值template&lt;typename T, unsigned N&gt; void Swap(T (&amp;a)[N], T (&amp;b)[N]); //模板②：交换两个数组template&lt;typename T, unsigned N&gt; void printArray(T (&amp;arr)[N]); //打印数组元素int main()&#123; //交换基本类型的值 int m = 10, n = 99; Swap(m, n); //匹配模板① cout&lt;&lt;m&lt;&lt;", "&lt;&lt;n&lt;&lt;endl; //交换两个数组 int a[5] = &#123; 1, 2, 3, 4, 5 &#125;; int b[5] = &#123; 10, 20, 30, 40, 50 &#125;; Swap(a, b); //匹配模板② printArray(a); printArray(b); return 0;&#125;template&lt;class T&gt; void Swap(T &amp;a, T &amp;b)&#123; T temp = a; a = b; b = temp;&#125;template&lt;typename T, unsigned N&gt; void Swap(T (&amp;a)[N], T (&amp;b)[N])&#123; T temp; for(int i=0; i&lt;N; i++)&#123; temp = a[i]; a[i] = b[i]; b[i] = temp; &#125;&#125;template&lt;typename T, unsigned N&gt; void printArray(T (&amp;arr)[N])&#123; for(int i=0; i&lt;N; i++)&#123; if(i == N-1)&#123; cout&lt;&lt;arr[i]&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;arr[i]&lt;&lt;", "; &#125; &#125;&#125; 运行结果：99, 1010, 20, 30, 40, 501, 2, 3, 4, 5 ​ printArray()也使用了非类型参数，这样只传递数组名字就能够打印数组元素了。 非类型参数的限制​ 非类型参数的类型不能随意指定，它受到了严格的限制，只能是一个整数，或者是一个指向对象或函数的指针（也可以是引用）。 ​ 1) 当非类型参数是一个整数时，传递给它的实参，或者由编译器推导出的实参必须是一个常量表达式，例如10、2 * 30、18 + 23 - 4等，但不能是n、n + 10、n + m等（n和m都是变量）。 对于上面的Swap()函数，下面的调用就是错误的： 12345int len;cin&gt;&gt;len;int a[len];int b[len];Swap(a, b); 这种情况，编译器推导出来的实参是len，是一个变量，而不是常量。 2) 当非类型参数是一个指针（引用）时，绑定到该指针的实参必须具有静态的生存期；换句话说，实参必须存储在虚拟地址空间中的静态数据区。局部变量位于栈区，动态创建的对象位于堆区，它们都不能用作实参。 函数模板实例化​ 模板（Templet）并不是真正的函数或类，它仅仅是编译器用来生成函数或类的一张“图纸”。模板不会占用内存，最终生成的函数或者类才会占用内存。由模板生成函数或类的过程叫做模板的实例化（Instantiate），相应地，针对某个类型生成的特定版本的函数或类叫做模板的一个实例（Instantiation）。 ​ 模板也可以看做是编译器的一组指令，它命令编译器生成我们想要的代码。 ​ 模板的实例化是按需进行的，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码。也就是说，编译器会根据传递给类型参数的实参（也可以是编译器自己推演出来的实参）来生成一个特定版本的函数或类，并且相同的类型只生成一次。实例化的过程也很简单，就是将所有的类型参数用实参代替。 ​ 例如，给定下面的函数模板和函数调用： 12345678910111213141516template&lt;typename T&gt; void Swap(T &amp;a, T &amp;b)&#123; T temp = a; a = b; b = temp;&#125;int main()&#123; int n1 = 100, n2 = 200, n3 = 300, n4 = 400; float f1 = 12.5, f2 = 56.93; Swap(n1, n2); //T为int，实例化出 void Swap(int &amp;a, int &amp;b); Swap(f1, f2); //T为float，实例化出 void Swap(float &amp;a, float &amp;b); Swap(n3, n4); //T为int，调用刚才生成的 void Swap(int &amp;a, int &amp;b); return 0;&#125; ​ 编译器会根据不同的实参实例化出不同版本的Swap()函数。对于Swap(n1, n2)调用，编译器会生成并编译一个Swap()版本，其中T被替换为int： 12345void Swap(int &amp;a, int &amp;b)&#123; int temp = a; a = b; b = temp;&#125; ​ 对于Swap(f1, f2)调用，编译器会生成另一个Swap()版本，其中T被替换为float。对于Swap(n3, n4)调用，编译器不会再生成新版本的 Swap()了，因为刚才已经针对int生成了一个版本，直接拿来使用即可。 将函数模板的声明和定义分散到不同的文件​ 总起来说，不管是函数还是类，声明和定义（实现）的分离其实是一回事，都是将函数定义放到其他文件中，最终要解决的问题也只有一个，就是把函数调用和函数定义对应起来（找到函数定义的地址，并填充到函数调用处），而保证完成这项工作的就是链接器。 ​ 基于传统的编程思维，初学者往往也会将模板（函数模板和类模板）的声明和定义分散到不同的文件中，以期达到「模块化编程」的目的。但事实证明这种做法是不对的，程序员惯用的做法是将模板的声明和定义都放到头文件中。 ​ 模板并不是真正的函数或类，它仅仅是用来生成函数或类的一张“图纸”，在这个生成过程中有三点需要明确： 模板的实例化是按需进行的，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码； 模板的实例化是由编译器完成的，而不是由链接器完成的； 在实例化过程中需要知道模板的所有细节，包含声明和定义。 为了更加深入地说明问题，现在有一个反面教材，它将函数模板的声明和实现分别放到了头文件和源文件。 ​ func.cpp源码： 1234567891011121314151617181920//交换两个数的值template&lt;typename T&gt; void Swap(T &amp;a, T &amp;b)&#123; T temp = a; a = b; b = temp;&#125;//冒泡排序算法void bubble_sort(int arr[], int n)&#123; for(int i=0; i&lt;n-1; i++)&#123; bool isSorted = true; for(int j=0; j&lt;n-1-i; j++)&#123; if(arr[j] &gt; arr[j+1])&#123; isSorted = false; Swap(arr[j], arr[j+1]); //调用Swap()函数 &#125; &#125; if(isSorted) break; &#125;&#125; ​ func.h源码： 1234567#ifndef _FUNC_H#define _FUNC_Htemplate&lt;typename T&gt; void Swap(T &amp;a, T &amp;b);void bubble_sort(int arr[], int n);#endif ​ main.cpp源码 12345678910111213#include &lt;iostream&gt;#include "func.h"using namespace std;int main()&#123; int n1 = 10, n2 = 20; Swap(n1, n2); double f1 = 23.8, f2 = 92.6; Swap(f1, f2); return 0;&#125; ​ 该工程包含了两个源文件和一个头文件，func.cpp中定义了两个函数，func.h中对函数进行了声明，main.cpp中对函数进行了调用，这是典型的将函数的声明和实现分离的编程模式。 ​ 运行上面的程序，会产生一个链接错误，意思是无法找到void Swap(double &amp;, double &amp;)这个函数。主函数main()中共调用了两个版本的Swap()函数，它们的原型分别是：12void Swap&lt;double&gt;(int &amp;, int &amp;); void Swap&lt;double&gt;(double &amp;, double &amp;); ​ 为什么针对int的版本能够找到定义，而针对double的版本就找不到呢？ ​ 我们先来说针对double的版本为什么找不到定义。当编译器编译main.cpp时，发现使用到了double版本的Swap()函数，于是尝试生成一个double版本的实例，但是由于只有声明没有定义，所以生成失败。不过这个时候编译器不会报错，而是对该函数的调用做一个记录，希望等到链接程序时在其他目标文件（.obj文件或.o文件）中找到该函数的定义。很明显，本例需要到func.obj中寻找。但是遗憾的是，func.cpp中没有调用double 版本的Swap()函数，编译器不会生成double版本的实例，所以链接器最终也找不到double版本的函数定义，只能抛出一个链接错误，让程序员修改代码。 ​ 那么，针对int的版本为什么能够找到定义呢？请读者注意bubble_sort()函数，该函数用来对数组元素进行排序，在排序过程中需要频繁的交换两个元素的值，所以调用了Swap()函数，这样做的结果是：编译生成的func.obj中会有一个int版本的Swap()函数定义。编译器在编译main.cpp时虽然找不到int版本的实例，但是等到链接程序时，链接器在func.obj中找到了，所以针对int版本的调用就不会出错。 函数模板的显式实例化​ 前面讲到的模板的实例化是在调用函数或者创建对象时由编译器自动完成的，不需要程序员引导，因此称为隐式实例化。相对应的，我们也可以通过代码明确地告诉编译器需要针对哪个类型进行实例化，这称为显式实例化。 ​ 编译器在实例化的过程中需要知道模板的所有细节：对于函数模板，也就是函数定义；对于类模板，需要同时知道类声明和类定义。我们必须将显式实例化的代码放在包含了模板定义的源文件中，而不是仅仅包含了模板声明的头文件中。 ​ 显式实例化的一个好处是，可以将模板的声明和定义（实现）分散到不同的文件中了。 ​ 以上节讲到的compare()函数为例，针对double类型的显式实例化代码为：1template void Swap(double &amp;a, double &amp;b); ​ 这条语言由两部分组成，前边是一个template关键字（后面不带&lt; &gt;），后面是一个普通的函数原型，组合在一起的意思是：将模板实例化成和函数原型对应的一个具体版本。 将该代码放到func.cpp文件的最后，再运行程序就不会出错了。 另外，还可以在包含了函数调用的源文件（main.cpp）中再增加下面的一条语句：1extern template void Swap(double &amp;a, double &amp;b); ​ 该语句在前面增加了extern关键字，它的作用是明确地告诉编译器，该版本的函数实例在其他文件中，请在链接期间查找。不过这条语句是多余的，即使不写，编译器发现当前文件中没有对应的模板定义，也会自动去其他文件中查找。 上节我们展示了一个反面教材，告诉大家不能把函数模板的声明和定义分散到不同的文件中，但是现在有了显式实例化，这一点就可以做到了，下面就对上节的代码进行修复。 func.cpp源码： 12345678910111213141516171819202122//交换两个数的值template&lt;typename T&gt; void Swap(T &amp;a, T &amp;b)&#123; T temp = a; a = b; b = temp;&#125;//冒泡排序算法void bubble_sort(int arr[], int n)&#123; for(int i=0; i&lt;n-1; i++)&#123; bool isSorted = true; for(int j=0; j&lt;n-1-i; j++)&#123; if(arr[j] &gt; arr[j+1])&#123; isSorted = false; Swap(arr[j], arr[j+1]); //调用Swap()函数 &#125; &#125; if(isSorted) break; &#125;&#125;template void Swap(double &amp;a, double &amp;b); //显式实例化定义 func.h源码： 1234567#ifndef _FUNC_H#define _FUNC_Htemplate&lt;typename T&gt; void Swap(T &amp;a, T &amp;b);void bubble_sort(int arr[], int n);#endif main.cpp源码： 1234567891011121314151617#include &lt;iostream&gt;#include "func.h"using namespace std;//显示实例化声明（也可以不写）extern template void Swap(double &amp;a, double &amp;b);extern template void Swap(int &amp;a, int &amp;b);int main()&#123; int n1 = 10, n2 = 20; Swap(n1, n2); double f1 = 23.8, f2 = 92.6; Swap(f1, f2); return 0;&#125; ​ 显式实例化也包括声明和定义，定义要放在模板定义（实现）所在的源文件，声明要放在模板声明所在的头文件（当然也可以不写）。 总结​ 函数模板和类模板的实例化语法是类似的，我们不妨对它们做一下总结：12extern template declaration; //实例化声明template declaration; //实例化定义 ​ 对于函数模板来说，declaration就是一个函数原型；对于类模板来说，declaration就是一个类声明。 显式实例化的缺陷​ C++支持显式实例化的目的是为「模块化编程」提供一种解决方案，这种方案虽然有效，但是也有明显的缺陷：程序员必须要在模板的定义文件（实现文件）中对所有使用到的类型进行实例化。这就意味着，每次更改了模板使用文件（调用函数模板的文件，或者通过类模板创建对象的文件），也要相应地更改模板定义文件，以增加对新类型的实例化，或者删除无用类型的实例化。 ​ 一个模板可能会在多个文件中使用到，要保持这些文件的同步更新是非常困难的。而对于库的开发者来说，他不能提前假设用户会使用哪些类型，所以根本就无法使用显式实例化，只能将模板的声明和定义（实现）全部放到头文件中；C++标准库几乎都是用模板来实现的，这些模板的代码也都位于头文件中。 ​ 总起来说，如果我们开发的模板只有我们自己使用，那也可以勉强使用显式实例化；如果希望让其他人使用（例如库、组件等），那只能将模板的声明和定义都放到头文件中了。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++模板定义]]></title>
    <url>%2F2018%2F08%2F07%2Fc%2B%2B%E6%A8%A1%E6%9D%BF1-%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[为了交换不同类型的变量的值，我们通过函数重载定义了四个名字相同、参数列表不同的函数，如下所示： 123456789101112131415161718192021222324252627//交换 int 变量的值void Swap(int *a, int *b)&#123; int temp = *a; *a = *b; *b = temp;&#125;//交换 float 变量的值void Swap(float *a, float *b)&#123; float temp = *a; *a = *b; *b = temp;&#125;//交换 char 变量的值void Swap(char *a, char *b)&#123; char temp = *a; *a = *b; *b = temp;&#125;//交换 bool 变量的值void Swap(bool *a, bool *b)&#123; char temp = *a; *a = *b; *b = temp;&#125; 这些函数虽然在调用时方便了一些，但从本质上说还是定义了三个功能相同、函数体相同的函数，只是数据的类型不同而已，我们可以借助本节讲的函数模板把它们压缩成一个函数。 ​ 我们知道，数据的值可以通过函数参数传递，在函数定义时数据的值是未知的，只有等到函数调用时接收了实参才能确定其值。这就是值的参数化。 模板的定义​ 在C++中，数据的类型也可以通过参数来传递，在函数定义时可以不指明具体的数据类型，当发生函数调用时，编译器可以根据传入的实参自动推断数据类型。这就是类型的参数化。 ​ 值（Value）和类型（Type）是数据的两个主要特征，它们在C++中都可以被参数化。 函数模板定义​ 所谓函数模板，实际上是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个虚拟的类型来代替（实际上是用一个标识符来占位），等发生函数调用时再根据传入的实参来逆推出真正的类型。这个通用函数就称为函数模板（Function Template）。 ​ 定义模板函数的语法：123template &lt;typename 类型参数1 , typename 类型参数2 , ...&gt; 返回值类型 函数名(形参列表)&#123; //在函数体中可以使用类型参数 &#125; ​ 类型参数可以有多个，它们之间以逗号,分隔。类型参数列表以&lt;&gt;包围，形式参数列表以()包围。typename关键字也可以使用class关键字替代，它们没有任何区别。 ​ 在函数模板中，数据的值和类型都被参数化了，发生函数调用时编译器会根据传入的实参来推演形参的值和类型。换个角度说，函数模板除了支持值的参数化，还支持类型的参数化。 ​ 一但定义了函数模板，就可以将类型参数用于函数定义和函数声明了。说得直白一点，原来使用int、float、char等内置类型的地方，都可以用类型参数来代替。 ​ 下面我们就来实践一下，将上面的四个Swap()函数压缩为一个函数模板： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;template&lt;typename T&gt; void Swap(T *a, T *b)&#123; T temp = *a; *a = *b; *b = temp;&#125;/*template&lt;typename T&gt; void Swap(T &amp;a, T &amp;b)&#123; T temp = a; a = b; b = temp;&#125;*/int main()&#123; //交换 int 变量的值 int n1 = 100, n2 = 200; Swap(&amp;n1, &amp;n2); cout&lt;&lt;n1&lt;&lt;", "&lt;&lt;n2&lt;&lt;endl; //交换 float 变量的值 float f1 = 12.5, f2 = 56.93; Swap(&amp;f1, &amp;f2); cout&lt;&lt;f1&lt;&lt;", "&lt;&lt;f2&lt;&lt;endl; //交换 char 变量的值 char c1 = 'A', c2 = 'B'; Swap(&amp;c1, &amp;c2); cout&lt;&lt;c1&lt;&lt;", "&lt;&lt;c2&lt;&lt;endl; //交换 bool 变量的值 bool b1 = false, b2 = true; Swap(&amp;b1, &amp;b2); cout&lt;&lt;b1&lt;&lt;", "&lt;&lt;b2&lt;&lt;endl; return 0;&#125; 运行结果：200, 10056.93, 12.5B, A1, 0 ​ 请读者重点关注第4行代码。template是定义函数模板的关键字，它后面紧跟尖括号&lt;&gt;，尖括号包围的是类型参数（也可以说是虚拟的类型，或者说是类型占位符）。typename是另外一个关键字，用来声明具体的类型参数，这里的类型参数就是T。从整体上看，template被称为模板头。 类模板定义​ C++除了支持函数模板，还支持类模板（Class Template）。函数模板中定义的类型参数可以用在函数声明和函数定义中，类模板中定义的类型参数可以用在类声明和类实现中。类模板的目的同样是将数据的类型参数化。 ​ 声明类模板的语法为：123template&lt;typename 类型参数1 , typename 类型参数2 , ...&gt; class 类名&#123; //TODO: &#125;; ​ 类模板和函数模板都是以template开头（当然也可以使用class，目前来讲它们没有任何区别），后跟类型参数；类型参数不能为空，多个类型参数用逗号隔开。 ​ 一但声明了类模板，就可以将类型参数用于类的成员函数和成员变量了。换句话说，原来使用int、float、char等内置类型的地方，都可以用类型参数来代替。 ​ 假如我们现在要定义一个类来表示坐标，要求坐标的数据类型可以是整数、小数和字符串，例如： x = 10、y = 10 x = 12.88、y = 129.65 x = &quot;东经180度&quot;、y = &quot;北纬210度&quot; 这个时候就可以使用类模板，请看下面的代码： 12345678910111213template&lt;typename T1, typename T2&gt; //这里不能有分号class Point&#123;public: Point(T1 x, T2 y): m_x(x), m_y(y)&#123; &#125;public: T1 getX() const; //获取x坐标 void setX(T1 x); //设置x坐标 T2 getY() const; //获取y坐标 void setY(T2 y); //设置y坐标private: T1 m_x; //x坐标 T2 m_y; //y坐标&#125;; ​ x坐标和y坐标的数据类型不确定，借助类模板可以将数据类型参数化，这样就不必定义多个类了。 注意：模板头和类头是一个整体，可以换行，但是中间不能有分号。 ​ 上面的代码仅仅是类的声明，我们还需要在类外定义成员函数。在类外定义成员函数时仍然需要带上模板头，格式为：1234template&lt;typename 类型参数1 , typename 类型参数2 , .....&gt; 返回值类型 类名&lt;类型参数1 , 类型参数2, ...&gt;::函数名(形参列表)&#123; //TODO: &#125; ​ 第一行是模板头，第二行是函数头，它们可以合并到一行，不过为了让代码格式更加清晰，一般是将它们分成两行。 ​ 下面就对Point类的成员函数进行定义： 12345678910111213141516171819template&lt;typename T1, typename T2&gt; //模板头T1 Point&lt;T1, T2&gt;::getX() const /*函数头*/ &#123; return m_x;&#125;template&lt;typename T1, typename T2&gt;void Point&lt;T1, T2&gt;::setX(T1 x)&#123; m_x = x;&#125;template&lt;typename T1, typename T2&gt;T2 Point&lt;T1, T2&gt;::getY() const&#123; return m_y;&#125;template&lt;typename T1, typename T2&gt;void Point&lt;T1, T2&gt;::setY(T2 y)&#123; m_y = y;&#125; ​ 仔细观察代码，除了template关键字后面要指明类型参数，类名Point后面也要带上类型参数，只是不加typename关键字了。另外需要注意的是，在类外定义成员函数时，template后面的类型参数要和类声明时的一致。 使用类模板创建对象​ 上面的两段代码完成了类的定义，接下来就可以使用该类创建对象了。使用类模板创建对象时，需要指明具体的数据类型。请看下面的代码： 123Point&lt;int, int&gt; p1(10, 20);Point&lt;int, float&gt; p2(10, 15.5);Point&lt;float, char*&gt; p3(12.4, "东经180度"); ​ 与函数模板不同的是，类模板在实例化时必须显式地指明数据类型，编译器不能根据给定的数据推演出数据类型。 ​ 除了对象变量，我们也可以使用对象指针的方式来实例化： 12Point&lt;float, float&gt; *p1 = new Point&lt;float, float&gt;(10.6, 109.3);Point&lt;char*, char*&gt; *p = new Point&lt;char*, char*&gt;("东经180度", "北纬210度"); ​ 需要注意的是，赋值号两边都要指明具体的数据类型，且要保持一致。下面的写法是错误的： 1234//赋值号两边的数据类型不一致Point&lt;float, float&gt; *p = new Point&lt;float, int&gt;(10.6, 109);//赋值号右边没有指明数据类型Point&lt;float, float&gt; *p = new Point(10.6, 109); 综合示例​ 【实例1】将上面的类定义和类实例化的代码整合起来，构成一个完整的示例，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;template&lt;class T1, class T2&gt; //这里不能有分号class Point&#123;public: Point(T1 x, T2 y): m_x(x), m_y(y)&#123; &#125;public: T1 getX() const; //获取x坐标 void setX(T1 x); //设置x坐标 T2 getY() const; //获取y坐标 void setY(T2 y); //设置y坐标private: T1 m_x; //x坐标 T2 m_y; //y坐标&#125;;template&lt;class T1, class T2&gt; //模板头T1 Point&lt;T1, T2&gt;::getX() const /*函数头*/ &#123; return m_x;&#125;template&lt;class T1, class T2&gt;void Point&lt;T1, T2&gt;::setX(T1 x)&#123; m_x = x;&#125;template&lt;class T1, class T2&gt;T2 Point&lt;T1, T2&gt;::getY() const&#123; return m_y;&#125;template&lt;class T1, class T2&gt;void Point&lt;T1, T2&gt;::setY(T2 y)&#123; m_y = y;&#125;int main()&#123; Point&lt;int, int&gt; p1(10, 20); cout&lt;&lt;"x="&lt;&lt;p1.getX()&lt;&lt;", y="&lt;&lt;p1.getY()&lt;&lt;endl; Point&lt;int, char*&gt; p2(10, "东经180度"); cout&lt;&lt;"x="&lt;&lt;p2.getX()&lt;&lt;", y="&lt;&lt;p2.getY()&lt;&lt;endl; Point&lt;char*, char*&gt; *p3 = new Point&lt;char*, char*&gt;("东经180度", "北纬210度"); cout&lt;&lt;"x="&lt;&lt;p3-&gt;getX()&lt;&lt;", y="&lt;&lt;p3-&gt;getY()&lt;&lt;endl; return 0;&#125; 运行结果：x=10, y=20x=10, y=东经180度x=东经180度, y=北纬210度 ​ 在定义类型参数时我们使用了class，而不是typename，这样做的目的是让读者对两种写法都熟悉。 【实例2】用类模板实现可变长数组。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;template &lt;class T&gt;class CArray&#123; int size; //数组元素的个数 T *ptr; //指向动态分配的数组public: CArray(int s = 0); //s代表数组元素的个数 CArray(CArray &amp; a); ~CArray(); void push_back(const T &amp; v); //用于在数组尾部添加一个元素v CArray &amp; operator=(const CArray &amp; a); //用于数组对象间的赋值 T length() &#123; return size; &#125; T &amp; operator[](int i) &#123;//用以支持根据下标访问数组元素，如a[i] = 4;和n = a[i]这样的语句 return ptr[i]; &#125;&#125;;template&lt;class T&gt;CArray&lt;T&gt;::CArray(int s):size(s)&#123; if(s == 0) ptr = NULL; else ptr = new T[s];&#125;template&lt;class T&gt;CArray&lt;T&gt;::CArray(CArray &amp; a)&#123; if(!a.ptr) &#123; ptr = NULL; size = 0; return; &#125; ptr = new T[a.size]; memcpy(ptr, a.ptr, sizeof(T ) * a.size); size = a.size;&#125;template &lt;class T&gt;CArray&lt;T&gt;::~CArray()&#123; if(ptr) delete [] ptr;&#125;template &lt;class T&gt;CArray&lt;T&gt; &amp; CArray&lt;T&gt;::operator=(const CArray &amp; a)&#123; //赋值号的作用是使"="左边对象里存放的数组，大小和内容都和右边的对象一样 if(this == &amp; a) //防止a=a这样的赋值导致出错 return * this; if(a.ptr == NULL) &#123; //如果a里面的数组是空的 if( ptr ) delete [] ptr; ptr = NULL; size = 0; return * this; &#125; if(size &lt; a.size) &#123; //如果原有空间够大，就不用分配新的空间 if(ptr) delete [] ptr; ptr = new T[a.size]; &#125; memcpy(ptr,a.ptr,sizeof(T)*a.size); size = a.size; return *this;&#125;template &lt;class T&gt;void CArray&lt;T&gt;::push_back(const T &amp; v)&#123; //在数组尾部添加一个元素 if(ptr) &#123; T *tmpPtr = new T[size+1]; //重新分配空间 memcpy(tmpPtr,ptr,sizeof(T)*size); //拷贝原数组内容 delete []ptr; ptr = tmpPtr;&#125; else //数组本来是空的 ptr = new T[1]; ptr[size++] = v; //加入新的数组元素&#125;int main()&#123; CArray&lt;int&gt; a; for(int i = 0;i &lt; 5;++i) a.push_back(i); for(int i = 0; i &lt; a.length(); ++i) cout &lt;&lt; a[i] &lt;&lt; " "; return 0;&#125; 模板编程来源​ 计算机编程语言种类繁多，这些编程语言根据不同的标准可以分为不同的种类，根据“在定义变量时是否需要显式地指明数据类型”可以分为强类型语言和弱类型语言。 强类型语言​ 强类型语言在定义变量时需要显式地指明数据类型，并且一旦为变量指明了某种数据类型，该变量以后就不能赋予其他类型的数据了，除非经过强制类型转换或隐式类型转换。典型的强类型语言有C/C++、Java、C#等。 ​ 下面的代码演示了如何在C/C++中使用变量： 123int a = 100; //不转换a = 12.34; //隐式转换（直接舍去小数部分，得到12）a = (int)"http://c.biancheng.net"; //强制转换（得到字符串的地址） ​ 下面的代码演示了如何在Java中使用变量： 12int a = 100; //不转换a = (int)12.34; //强制转换（直接舍去小数部分，得到12） ​ Java对类型转换的要求比C/C++更为严格，隐式转换只允许由低向高转，由高向低转必须强制转换。 弱类型语言​ 弱类型语言在定义变量时不需要显式地指明数据类型，编译器（解释器）会根据赋给变量的数据自动推导出类型，并且可以赋给变量不同类型的数据。典型的弱类型语言有JavaScript、Python、PHP、Ruby、Shell、Perl等。 ​ 下面的代码演示了如何在 JavaScript中使用变量： 1234var a = 100; //赋给整数a = 12.34; //赋给小数a = "http://c.biancheng.net"; //赋给字符串a = new Array("JavaScript","React","JSON"); //赋给数组 ​ var是JavaScript中的一个关键字，表示定义一个新的变量，而不是数据类型。 ​ 下面的代码演示了如何在PHP中使用变量： 1234$a = 100; //赋给整数$a = 12.34; //赋给小数$a = "http://c.biancheng.net"; //赋给字符串$a = array("JavaScript","React","JSON"); //赋给数组 ​ $是一个特殊符号，所有的变量名都要以$开头。PHP中的变量不用特别地定义，变量名首次出现即视为定义。 这里的强类型和弱类型是站在变量定义和类型转换的角度讲的，并把C/C++归为强类型语言。另外还有一种说法是站在编译和运行的角度，并把C/C++归为弱类型语言。本节我们只关注第一种说法。 ​ 类型对于编程语言来说非常重要，不同的类型支持不同的操作，例如class Student类型的变量可以调用 display()方法，int类型的变量就不行。不管是强类型语言还是弱类型语言，在编译器（解释器）内部都有一个类型系统来维护变量的各种信息。 ​ 对于强类型的语言，变量的类型从始至终都是确定的、不变的，编译器在编译期间就能检测某个变量的操作是否正确，这样最终生成的程序中就不用再维护一套类型信息了，从而减少了内存的使用，加快了程序的运行。 ​ 不过这种说法也不是绝对的，有些特殊情况还是要等到运行阶段才能确定变量的类型信息。比如C++中的多态，编译器在编译阶段会在对象内存模型中增加虚函数表、type_info对象等辅助信息，以维护一个完整的继承链，等到程序运行后再执行一段代码才能确定调用哪个函数。 ​ 对于弱类型的语言，变量的类型可以随时改变，赋予它什么类型的数据它就是什么类型，编译器在编译期间不好确定变量的类型，只有等到程序运行后、真的赋给变量一个值了，才能确定变量当前是什么类型，所以传统的编译对弱类型语言意义不大，因为即使编译了也有很多东西确定不下来。 ​ 弱类型语言往往是一边执行一边编译，这样可以根据上下文（可以理解为当前的执行环境）推导出很多有用信息，让编译更加高效。 ​ 我们将这种一边执行一边编译的语言称为解释型语言，而将传统的先编译后执行的语言称为编译型语言。 ​ 强类型语言较为严谨，在编译时就能发现很多错误，适合开发大型的、系统级的、工业级的项目；而弱类型语言较为灵活，编码效率高，部署容易，学习成本低，在Web开发中大显身手。另外，强类型语言的IDE一般都比较强大，代码感知能力好，提示信息丰富；而弱类型语言一般都是在编辑器中直接书写代码。 ​ 为了展示弱类型语言的灵活，我们以PHP为例来实现上节中的Point类，让它可以处理整数、小数以及字符串： 12345678910111213141516171819202122232425262728293031323334class Point&#123; public function Point($x, $y)&#123; //构造函数 $this -&gt; m_x = $x; $this -&gt; m_y = $y; &#125; public function getX()&#123; return $this -&gt; m_x; &#125; public function getY()&#123; return $this -&gt; m_y; &#125; public function setX($x)&#123; $this -&gt; m_x = $x; &#125; public function setY($y)&#123; $this -&gt; m_y = $y; &#125; private $m_x; private $m_y;&#125;$p = new Point(10, 20); //处理整数echo $p-&gt;getX() . ", " . $p-&gt;getY() . "&lt;br /&gt;";$p = new Point(24.56, "东京180度"); //处理小数和字符串echo $p-&gt;getX() . ", " . $p-&gt;getY() . "&lt;br /&gt;";$p = new Point("东京180度", "北纬210度"); //处理字符串echo $p-&gt;getX() . ", " . $p-&gt;getY() . "&lt;br /&gt;"; 运行结果：10, 2024.56, 东京180度东京180度, 北纬210度 ​ PHP不需要使用模板就可以处理多种类型的数据，它天生对类型就不敏感。C++就不一样了，它是强类型的，比较“死板”，所以后来C++开始支持模板了，主要就是为了弥补强类型语言“不够灵活”的缺点。 ​ 模板所支持的类型是宽泛的，没有限制的，我们可以使用任意类型来替换，这种编程方式称为泛型编程（Generic Programming）。相应地，可以将参数T看做是一个泛型，而将int、float、string等看做是一种具体的类型。除了C++，Java、C#、Pascal（Delphi）也都支持泛型编程。 ​ C++模板也是被迫推出的，最直接的动力来源于对数据结构的封装。数据结构关注的是数据的存储，以及存储后如何进行增加、删除、修改和查询操作，它是一门基础性的学科，在实际开发中有着非常广泛的应用。C++开发者们希望为线性表、链表、图、树等常见的数据结构都定义一个类，并把它们加入到标准库中，这样以后程序员就不用重复造轮子了，直接拿来使用即可。 ​ 但是这个时候遇到了一个无法解决的问题，就是数据结构中每份数据的类型无法提前预测。以链表为例，它的每个节点可以用来存储小数、整数、字符串等，也可以用来存储一名学生、教师、司机等，还可以直接存储二进制数据，这些都是可以的，没有任何限制。而C++又是强类型的，数据的种类受到了严格的限制，这种矛盾是无法调和的。 ​ 要想解决这个问题，C++必须推陈出新，跳出现有规则的限制，开发新的技术，于是模板就诞生了。模板虽然不是C++的首创，但是却在C++中大放异彩，后来也被Java、C#等其他强类型语言采用。 ​ C++模板有着复杂的语法，也非常重要，整个标准库几乎都是使用模板来开发的，STL更是经典之作。 STL（Standard Template Library，标准模板库）就是C++对数据结构进行封装后的称呼。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++运行时类型识别(RTTI)]]></title>
    <url>%2F2018%2F08%2F03%2Fc%2B%2B%E5%A4%9A%E6%80%813-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB(RTTI)%2F</url>
    <content type="text"><![CDATA[运行时类型识别(RTTI)机制精讲​ 一般情况下，在编译期间就能确定一个表达式的类型，但是当存在多态时，有些表达式的类型在编译期间就无法确定了，必须等到程序运行后根据实际的环境来确定。下面的例子演示了这种情况： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;//基类class Base&#123;public: virtual void func();protected: int m_a; int m_b;&#125;;void Base::func()&#123; cout&lt;&lt;"Base"&lt;&lt;endl; &#125;//派生类class Derived: public Base&#123;public: void func();private: int m_c;&#125;;void Derived::func()&#123; cout&lt;&lt;"Derived"&lt;&lt;endl; &#125;int main()&#123; Base *p; int n; cin&gt;&gt;n; if(n &lt;= 100)&#123; p = new Base(); &#125;else&#123; p = new Derived(); &#125; cout&lt;&lt;typeid(*p).name()&lt;&lt;endl; return 0;&#125; 输入45，运行结果为： 45↙class Base 输入130，运行结果为： 130↙class Derived ​ 基类Base包含了一个虚函数，派生类Derived又定义了一个原型相同的函数遮蔽了它，这就构成了多态。p是基类的指针，可以指向基类对象，也可以指向派生类对象；*p表示 p 指向的对象。 ​ 从代码中可以看出，用户输入的数字不同，*p表示的对象就不同，typeid获取到的类型也就不同，编译器在编译期间无法预估用户的输入，所以无法确定*p的类型，必须等到程序真的运行了、用户输入完毕了才能确定*p的类型。 根据前面讲过的知识，C++的对象内存模型主要包含了以下几个方面的内容： 如果没有虚函数也没有虚继承，那么对象内存模型中只有成员变量。 如果类包含了虚函数，那么会额外添加一个虚函数表，并在对象内存中插入一个指针，指向这个虚函数表。 如果类包含了虚继承，那么会额外添加一个虚基类表，并在对象内存中插入一个指针，指向这个虚基类表。 现在我们要补充的一点是，如果类包含了虚函数，那么该类的对象内存中还会额外增加类型信息，也即 type_info对象。以上面的代码为例，Base和Derived的对象内存模型如下图所示： ​ 编译器会在虚函数表vftable的开头插入一个指针，指向当前类对应的type_info对象。当程序在运行阶段获取类型信息时，可以通过对象指针p找到虚函数表指针vfptr，再通过vfptr找到type_info对象的指针，进而取得类型信息。下面的代码演示了这种转换过程： **(p-&gt;vfptr - 1) ​ 程序运行后，不管p指向Base类对象还是指向Derived类对象，只要执行这条语句就可以取得 type_info对象。 ​ 编译器在编译阶段无法确定p指向哪个对象，也就无法获取*p的类型信息，但是编译器可以在编译阶段做好各种准备，这样程序在运行后可以借助这些准备好的数据来获取类型信息。这些准备包括： 创建type_info对象，并在vftable的开头插入一个指针，指向type_info对象。 将获取类型信息的操作转换成类似**(p-&gt;vfptr - 1)这样的语句。 这样做虽然会占用更多的内存，效率也降低了，但这是没办法的事情，编译器实在是无能为力了。 ​ 这种在程序运行后确定对象的类型信息的机制称为运行时类型识别（Run-Time Type Identification，RTTI）。在C++中，只有类中包含了虚函数时才会启用RTTI机制，其他所有情况都可以在编译阶段确定类型信息。 ​ 下面是RTTI机制的一个具体应用，可以让代码根据不同的类型进行不同的操作： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;//基类class People&#123;public: virtual void func()&#123; &#125;&#125;;//派生类class Student: public People&#123; &#125;;int main()&#123; People *p; int n; cin&gt;&gt;n; if(n &lt;= 100)&#123; p = new People(); &#125;else&#123; p = new Student(); &#125; //根据不同的类型进行不同的操作 if(typeid(*p) == typeid(People))&#123; cout&lt;&lt;"I am human."&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;"I am a student."&lt;&lt;endl; &#125; return 0;&#125; 可能的运行结果：83↙I am human. ​ 多态（Polymorphism）是面向对象编程的一个重要特征，它极大地增加了程序的灵活性，C++、C#、Java等“正统的”面向对象编程语言都支持多态。但是支持多态的代价也是很大的，有些信息在编译阶段无法确定下来，必须提前做好充足的准备，让程序运行后再执行一段代码获取，这会消耗更多的内存和CPU资源。 静态绑定和动态绑定​ C/C++用变量来存储数据，用函数来定义一段可以重复使用的代码，它们最终都要放到内存中才能供 CPU使用。CPU通过地址来取得内存中的代码和数据，程序在执行过程中会告知CPU要执行的代码以及要读写的数据的地址。 ​ CPU访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。编译和链接过程的一项重要任务就是找到这些名称所对应的地址。 ​ 假设变量a、b、c在内存中的地址分别是0X1000、0X2000、0X3000，那么加法运算c = a + b;将会被转换成类似下面的形式： 0X3000 = (0X1000) + (0X2000); ​ ( )表示取值操作，整个表达式的意思是，取出地址0X1000和 0X2000上的值，将它们相加，把相加的结果赋值给地址为0X3000的内存。 ​ 变量名和函数名为我们提供了方便，让我们在编写代码的过程中可以使用易于阅读和理解的英文字符串，不用直接面对二进制地址，那场景简直让人崩溃。 ​ 我们不妨将变量名和函数名统称为符号（Symbol），找到符号对应的地址的过程叫做符号绑定。本节只讨论函数名和地址的绑定，变量名也是类似的道理。 函数绑定​ 我们知道，函数调用实际上是执行函数体中的代码。函数体是内存中的一个代码段，函数名就表示该代码段的首地址，函数执行时就从这里开始。说得简单一点，就是必须要知道函数的入口地址，才能成功调用函数。 ​ 找到函数名对应的地址，然后将函数调用处用该地址替换，这称为函数绑定。 ​ 一般情况下，在编译期间（包括链接期间）就能找到函数名对应的地址，完成函数的绑定，程序运行后直接使用这个地址即可。这称为静态绑定（Static binding）。 ​ 但是有时候在编译期间想尽所有办法都不能确定使用哪个函数，必须要等到程序运行后根据具体的环境或者用户操作才能决定。这称为动态绑定（dynamic binding）。 ​ C++ 是一门静态性的语言，会尽力在编译期间找到函数的地址，以提高程序的运行效率，但是有时候实在没办法，只能等到程序运行后再执行一段代码（很少的代码）才能找到函数的地址。 ​ 上节我们讲到，通过p -&gt; display();语句调用display()函数时会转换为下面的表达式： ( *( *(p+0) + 0 ) )(p); ​ 这里的p 有可能指向People类的对象，也可能指向Student或Senior类的对象，编译器不能提前假设 p指向哪个对象，也就不能确定调用哪个函数，所以编译器干脆不管了，p爱指向哪个对象就指向哪个对象，等到程序运行后执行一下这个表达式自然就知道了。 有读者可能会问，对于下面的语句： 12p = new Senior(&quot;李智&quot;, 22, 92.0, true);p -&gt; display(); ​ p不是已经确定了指向Senior类的对象吗，难道编译器不知道吗？对，编译器编译到第二条语句的时候如果向前逆推一下，确实能够知道p指向Senior类的对象。但是，如果是下面的情况呢？ 12345678int n;cin&gt;&gt;n;if(n &gt; 100)&#123; p = new Student("王刚", 16, 84.5);&#125;else&#123; p = new Senior("李智", 22, 92.0, true);&#125;p -&gt; display(); ​ 如果用户输入的数字大于100，那么p指向Student类的对象，否则就指向Senior类的对象，这种情况编译器如何逆推呢？鬼知道用户输入什么数字！所以编译器干脆不会向前逆推，因为编译器不知道前方是什么情况，可能会很复杂，它也无能为力。 ​ 这就是动态绑定的本质：编译器在编译期间不能确定指针指向哪个对象，只能等到程序运行后根据具体的情况再决定。 RTTI机制下的对象内存模型​ 上节所示的Base和Derived的对象内存模型非常简单，读者也很容易理解，它满足了typeid运算符在程序运行期间动态地获取表达式的类型信息的需求。在C++中，除了typeid运算符，dynamic_cast运算符和异常处理也依赖于RTTI机制，并且要能够通过派生类获取基类的信息，或者说要能够判断一个类是否是另一个类的基类，这样上节讲到的内存模型就不够用了，我们必须要在基类和派生类之间再增加一条绳索，把它们连接起来，形成一条通路，让程序在各个对象之间游走。在面向对象的编程语言中，我们称此为继承链（Inheritance Chain）。 ​ 将基类和派生类连接起来很容易，只需要在基类对象中增加一个指向派生类对象的指针，然而考虑到多继承、降低内存使用等诸多方面的因素，真正的对象内存模型比上节讲到的要复杂很多，并且不同的编译器有不同的实现（C++标准并没有对对象内存模型的细节做出规定）。 ​ 我们以下面的代码为例来展示Visual C++下真正的对象内存模型： 1234567891011121314151617181920212223242526class A&#123;protected: int a1;public: virtual int A_virt1(); virtual int A_virt2(); static void A_static1(); void A_simple1();&#125;;class B&#123;protected: int b1; int b2;public: virtual int B_virt1(); virtual int B_virt2();&#125;;class C: public A, public B&#123;protected: int c1;public: virtual int A_virt2(); virtual int B_virt2();&#125;; 最终的内存模型如下所示（猛击图片可查看大图）： 图片来源于http://www.openrce.org/articles/full_view/23，红色是我加的说明。 ​ 从图中可以看出，对于有虚函数的类，内存模型中除了有虚函数表，还会额外增加好几个表，以维护当前类和基类的信息，空间上的开销不小。typeid(type).name()方法返回的类名就来自“当前类的信息表”。 ​ 如果你希望深入了解上图的结构，请查看下面几篇文章： VC++逆向：类、方法和 RTTI(http://www.openrce.org/articles/full_view/23) RTTI结构详细分析(VC++)(http://bbs.pediy.com/showthread.php?t=196996) C++中RTTI机制剖析(http://blog.csdn.net/pi9nc/article/details/21742355) C++ dynamic_cast实现原理(http://blog.csdn.net/passion_wu128/article/details/38511957) dynamic_cast, RTTI， 整理(http://www.cnblogs.com/dirichlet/p/3221066.html) typeid经过固定次数的间接转换返回type_info对象，间接次数不会随着继承层次的增加而增加，对效率的影响很小，读者可以放心使用。而dynamic_cast运算符和异常处理不仅要经过数次间接转换，还要遍历继承链，如果继承层次较深，那么它们的性能堪忧，读者应当谨慎使用！ ​ 类型是表达式的一个属性，不同的类型支持不同的操作，例如class Student类型的表达式可以调用 display()方法，int类型的表达式就不行。类型对于编程语言来说非常重要，编译器内部有一个类型系统来维护表达式的各种信息。 ​ 在C/C++中，变量、函数参数、函数返回值等在定义时都必须显式地指明类型，并且一旦指明类型后就不能再更改了，所以大部分表达式的类型都能够精确的推测出来，编译器在编译期间就能够搞定这些事情，这样的编程语言称为静态语言（Static Language）。 ​ 静态语言在定义变量时通常需要显式地指明类型，并且在编译期间会拼尽全力来确定表达式的类型信息，只有在万不得已时才让程序等到运行后动态地获取类型信息（例如多态），这样做可以提高程序运行效率，降低内存消耗。 ​ 与静态语言（Static Language）相对的是动态语言（Dynamic Language）。动态语言在定义变量时往往不需要指明类型，并且变量的类型可以随时改变（赋给它不同类型的数据），编译器在编译期间也不容易确定表达式的类型信息，只能等到程序运行后再动态地获取。典型的动态语言有JavaScript、Python、PHP、Perl、Ruby 等。 ​ 动态语言为了能够使用灵活，部署简单，往往是一边编译一边执行，模糊了传统的编译和运行的过程。例如JavaScript主要用来给网页添加各种特效（这是一种简单的理解），浏览器访问一个页面时会从服务器上下载JavaScript源文件，并负责编译和运行它。如果我们提前将 JavaScript 源码编译成可执行文件，那么这个文件就会比较大，下载就会更加耗时，结果就是网页打开速度非常慢，这在网络不发达的早期是不能忍受的。 总起来说，静态语言由于类型的限制会降低编码的速度，但是它的执行效率高，适合开发大型的、系统级的程序；动态语言则比较灵活，编码简单，部署容易，在Web开发中大显身手。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++typpeid运算符：获取类型信息]]></title>
    <url>%2F2018%2F07%2F28%2Fc%2B%2B%E5%A4%9A%E6%80%812-typeid%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[typeid运算符：获取类型信息​ typeid运算符用来获取一个表达式的类型信息。类型信息对于编程语言非常重要，它描述了数据的各种属性： 对于基本类型（int、float 等C++内置类型）的数据，类型信息所包含的内容比较简单，主要是指数据的类型。 对于类类型的数据（也就是对象），类型信息是指对象所属的类、所包含的成员、所在的继承关系等。 类型信息是创建数据的模板，数据占用多大内存、能进行什么样的操作、该如何操作等，这些都由它的类型信息决定。 ​ typeid的操作对象既可以是表达式，也可以是数据类型，下面是它的两种使用方法： 12typeid( dataType )typeid( expression ) ​ dataType是数据类型，expression是表达式，这和sizeof运算符非常类似，只不过sizeof 有时候可以省略括号( )，而typeid必须带上括号。 ​ typeid会把获取到的类型信息保存到一个type_info类型的对象里面，并返回该对象的常引用；当需要具体的类型信息时，可以通过成员函数来提取。typeid的使用非常灵活，请看下面的例子（只能在VC/VS下运行）： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;class Base&#123; &#125;;struct STU&#123; &#125;;int main()&#123; //获取一个普通变量的类型信息 int n = 100; const type_info &amp;nInfo = typeid(n); cout&lt;&lt;nInfo.name()&lt;&lt;" | "&lt;&lt;nInfo.raw_name()&lt;&lt;" | "&lt;&lt;nInfo.hash_code()&lt;&lt;endl; //获取一个字面量的类型信息 const type_info &amp;dInfo = typeid(25.65); cout&lt;&lt;dInfo.name()&lt;&lt;" | "&lt;&lt;dInfo.raw_name()&lt;&lt;" | "&lt;&lt;dInfo.hash_code()&lt;&lt;endl; //获取一个对象的类型信息 Base obj; const type_info &amp;objInfo = typeid(obj); cout&lt;&lt;objInfo.name()&lt;&lt;" | "&lt;&lt;objInfo.raw_name()&lt;&lt;" | "&lt;&lt;objInfo.hash_code()&lt;&lt;endl; //获取一个类的类型信息 const type_info &amp;baseInfo = typeid(Base); cout&lt;&lt;baseInfo.name()&lt;&lt;" | "&lt;&lt;baseInfo.raw_name()&lt;&lt;" | "&lt;&lt;baseInfo.hash_code()&lt;&lt;endl; //获取一个结构体的类型信息 const type_info &amp;stuInfo = typeid(struct STU); cout&lt;&lt;stuInfo.name()&lt;&lt;" | "&lt;&lt;stuInfo.raw_name()&lt;&lt;" | "&lt;&lt;stuInfo.hash_code()&lt;&lt;endl; //获取一个普通类型的类型信息 const type_info &amp;charInfo = typeid(char); cout&lt;&lt;charInfo.name()&lt;&lt;" | "&lt;&lt;charInfo.raw_name()&lt;&lt;" | "&lt;&lt;charInfo.hash_code()&lt;&lt;endl; //获取一个表达式的类型信息 const type_info &amp;expInfo = typeid(20 * 45 / 4.5); cout&lt;&lt;expInfo.name()&lt;&lt;" | "&lt;&lt;expInfo.raw_name()&lt;&lt;" | "&lt;&lt;expInfo.hash_code()&lt;&lt;endl; return 0;&#125; 运行结果：int | .H | 529034928double | .N | 667332678class Base | .?AVBase@@ | 1035034353class Base | .?AVBase@@ | 1035034353struct STU | .?AUSTU@@ | 734635517char | .D | 4140304029double | .N | 667332678 ​ 从本例可以看出，typeid的使用非常灵活，它的操作数可以是普通变量、对象、内置类型（int、float等）、自定义类型（结构体和类），还可以是一个表达式。 本例中还用到了type_info类的几个成员函数，下面是对它们的介绍： name()用来返回类型的名称。 raw_name()用来返回名字编码（Name Mangling）算法产生的新名称。 hash_code()用来返回当前类型对应的hash 值。hash值是一个可以用来标志当前类型的整数，有点类似学生的学号、公民的身份证号、银行卡号等。不过hash值有赖于编译器的实现，在不同的编译器下可能会有不同的整数，但它们都能唯一地标识某个类型。 遗憾的是，C++标准只对type_info类做了很有限的规定，不仅成员函数少，功能弱，而且各个平台的实现不一致。例如上面代码中的name()函数，nInfo.name()、objInfo.name()在VC/VS下的输出结果分别是int和class Base，而在GCC下的输出结果分别是i和4Base。 ​ C++标准规定，type_info类至少要有如下所示的4个 public 属性的成员函数，其他的扩展函数编译器开发者可以自由发挥，不做限制。 1) 原型：const char* name() const;​ 返回一个能表示类型名称的字符串。但是C++标准并没有规定这个字符串是什么形式的，例如对于上面的objInfo.name()语句，VC/VS下返回“class Base”，但GCC下返回“4Base”。 2) 原型：bool before (const type_info&amp; rhs) const;​ 判断一个类型是否位于另一个类型的前面，rhs参数是一个type_info 对象的引用。但是C++标准并没有规定类型的排列顺序，不同的编译器有不同的排列规则，程序员也可以自定义。要特别注意的是，这个排列顺序和继承顺序没有关系，基类并不一定位于派生类的前面。 3) 原型：bool operator== (const type_info&amp; rhs) const;​ 重载运算符“==”，判断两个类型是否相同，rhs参数是一个type_info对象的引用。 4) 原型：bool operator!= (const type_info&amp; rhs) const;​ 重载运算符“!=”，判断两个类型是否不同，rhs参数是一个type_info对象的引用。 raw_name()是VC/VS独有的一个成员函数，hash_code()在VC/VS和较新的GCC下有效。 可以发现，C++能获取到的类型信息非常有限，也没有统一的标准，如同“鸡肋”一般，大部分情况下我们只是使用重载过的“==”运算符来判断两个类型是否相同。 判断类型是否相等​ typeid运算符经常被用来判断两个类型是否相等。 1) 内置类型的比较例如有下面的定义： 1234char *str;int a = 2;int b = 10;float f; 类型判断结果为： 类型比较 结果 类型比较 结果 typeid(int) == typeid(int) true typeid(int) == typeid(char) false typeid(char*) == typeid(char) false typeid(str) == typeid(char*) true typeid(a) == typeid(int) true typeid(b) == typeid(int) true typeid(a) == typeid(a) true typeid(a) == typeid(b) true typeid(a) == typeid(f) false typeid(a/b) == typeid(int) true ​ typeid返回type_info对象的引用，而表达式typeid(a) == typeid(b)的结果为true，可以说明，一个类型不管使用了多少次，编译器都只为它创建一个对象，所有typeid都返回这个对象的引用。 ​ 需要提醒的是，为了减小编译后文件的体积，编译器不会为所有的类型创建type_info对象，只会为使用了typeid运算符的类型创建。不过有一种特殊情况，就是带虚函数的类（包括继承来的），不管有没有使用typeid运算符，编译器都会为带虚函数的类创建type_info对象。 2) 类的比较​ 例如有下面的定义： 12345678class Base&#123;&#125;;class Derived: public Base&#123;&#125;;Base obj1;Base *p1;Derived obj2;Derived *p2 = new Derived;p1 = p2; 类型判断结果为： 类型比较 结果 类型比较 结果 typeid(obj1) == typeid(p1) false typeid(obj1) == typeid(*p1) true typeid(&amp;obj1) == typeid(p1) true typeid(obj1) == typeid(obj2) false typeid(obj1) == typeid(Base) true typeid(*p1) == typeid(Base) true typeid(p1) == typeid(Base*) true typeid(p1) == typeid(Derived*) false ​ 表达式typeid(*p1) == typeid(Base)和typeid(p1) == typeid(Base*)的结果为true可以说明：即使将派生类指针p2赋值给基类指针p1，p1的类型仍然为Base*。 type_info类的声明​ 最后我们再来看一下type_info类的声明，以进一步了解它所包含的成员函数以及这些函数的访问权限。type_info类位于typeinfo头文件，声明形式类似于： 1234567891011121314class type_info &#123;public: virtual ~type_info(); int operator==(const type_info&amp; rhs) const; int operator!=(const type_info&amp; rhs) const; int before(const type_info&amp; rhs) const; const char* name() const; const char* raw_name() const;private: void *_m_data; char _m_d_name[1]; type_info(const type_info&amp; rhs); type_info&amp; operator=(const type_info&amp; rhs);&#125;; ​ 它的构造函数是private属性的，所以不能在代码中直接实例化，只能由编译器在内部实例化（借助友元）。而且还重载了“=”运算符，也是private属性的，所以也不能赋值。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++虚函数和纯虚函数]]></title>
    <url>%2F2018%2F07%2F25%2Fc%2B%2B%E5%A4%9A%E6%80%811-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）。 虚函数指针实现多态​ 基类的指针也可以指向派生类对象，请看下面的例子： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;//基类Peopleclass People&#123;public: People(char *name, int age); void display();protected: char *m_name; int m_age;&#125;;People::People(char *name, int age): m_name(name), m_age(age)&#123;&#125;void People::display()&#123; cout&lt;&lt;m_name&lt;&lt;"今年"&lt;&lt;m_age&lt;&lt;"岁了，是个无业游民。"&lt;&lt;endl;&#125;//派生类Teacherclass Teacher: public People&#123;public: Teacher(char *name, int age, int salary); void display();private: int m_salary;&#125;;Teacher::Teacher(char *name, int age, int salary): People(name, age), m_salary(salary)&#123;&#125;void Teacher::display()&#123; cout&lt;&lt;m_name&lt;&lt;"今年"&lt;&lt;m_age&lt;&lt;"岁了，是一名教师，每月有"&lt;&lt;m_salary&lt;&lt;"元的收入。"&lt;&lt;endl;&#125;int main()&#123; People *p = new People("王志刚", 23); p -&gt; display(); p = new Teacher("赵宏佳", 45, 8200); p -&gt; display(); return 0;&#125; 运行结果：12王志刚今年23岁了，是个无业游民。赵宏佳今年45岁了，是个无业游民。 ​ 我们直观上认为，如果指针指向了派生类对象，那么就应该使用派生类的成员变量和成员函数，这符合人们的思维习惯。但是本例的运行结果却告诉我们，当基类指针p指向派生类Teacher的对象时，虽然使用了Teacher 的成员变量，但是却没有使用它的成员函数，导致输出结果不伦不类（赵宏佳本来是一名老师，输出结果却显示人家是个无业游民），不符合我们的预期。 ​ 换句话说，通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。 ​ 为了消除这种尴尬，让基类指针能够访问派生类的成员函数，C++增加了虚函数（Virtual Function）。使用虚函数非常简单，只需要在函数声明前面增加virtual关键字。 ​ 更改上面的代码，将display()声明为虚函数： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;//基类Peopleclass People&#123;public: People(char *name, int age); virtual void display(); //声明为虚函数protected: char *m_name; int m_age;&#125;;People::People(char *name, int age): m_name(name), m_age(age)&#123;&#125;void People::display()&#123; cout&lt;&lt;m_name&lt;&lt;"今年"&lt;&lt;m_age&lt;&lt;"岁了，是个无业游民。"&lt;&lt;endl;&#125;//派生类Teacherclass Teacher: public People&#123;public: Teacher(char *name, int age, int salary); virtual void display(); //声明为虚函数private: int m_salary;&#125;;Teacher::Teacher(char *name, int age, int salary): People(name, age), m_salary(salary)&#123;&#125;void Teacher::display()&#123; cout&lt;&lt;m_name&lt;&lt;"今年"&lt;&lt;m_age&lt;&lt;"岁了，是一名教师，每月有"&lt;&lt;m_salary&lt;&lt;"元的收入。"&lt;&lt;endl;&#125;int main()&#123; People *p = new People("王志刚", 23); p -&gt; display(); p = new Teacher("赵宏佳", 45, 8200); p -&gt; display(); return 0;&#125; 运行结果： 12王志刚今年23岁了，是个无业游民。赵宏佳今年45岁了，是一名教师，每月有8200元的收入。 ​ 和前面的例子相比，本例仅仅是在display()函数声明前加了一个virtual关键字，将成员函数声明为了虚函数（Virtual Function），这样就可以通过p指针调用Teacher类的成员函数了，运行结果也证明了这一点（赵宏佳已经是一名老师了，不再是无业游民了）。 ​ 有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）。 ​ 上面的代码中，同样是p-&gt;display();这条语句，当p指向不同的对象时，它执行的操作是不一样的。同一条语句可以执行不同的操作，看起来有不同表现方式，这就是多态。 多态是面向对象编程的主要特征之一，`C++`中虚函数的唯一用处就是构成多态。 ​ C++提供多态的目的是：可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问，尤其是成员函数。如果没有多态，我们只能访问成员变量。 ​ 前面我们说过，通过指针调用普通的成员函数时会根据指针的类型（通过哪个类定义的指针）来判断调用哪个类的成员函数，但是通过本节的分析可以发现，这种说法并不适用于虚函数，虚函数是根据指针的指向来调用的，指针指向哪个类的对象就调用哪个类的虚函数。 引用实现多态​ 引用在本质上是通过指针的方式实现的，既然借助指针可以实现多态，那么我们就有理由推断：借助引用也可以实现多态。 ​ 修改上例中main()函数内部的代码，用引用取代指针： 123456789101112int main()&#123; People p("王志刚", 23); Teacher t("赵宏佳", 45, 8200); People &amp;rp = p; People &amp;rt = t; rp.display(); rt.display(); return 0;&#125; 运行结果：12王志刚今年23岁了，是个无业游民。赵宏佳今年45岁了，是一名教师，每月有8200元的收入。 ​ 由于引用类似于常量，只能在定义的同时初始化，并且以后也要从一而终，不能再引用其他数据，所以本例中必须要定义两个引用变量，一个用来引用基类对象，一个用来引用派生类对象。从运行结果可以看出，当基类的引用指代基类对象时，调用的是基类的成员，而指代派生类对象时，调用的是派生类的成员。 ​ 不过引用不像指针灵活，指针可以随时改变指向，而引用只能指代固定的对象，在多态性方面缺乏表现力，所以以后我们再谈及多态时一般是说指针。 ​ 本例的主要目的是让读者知道，除了指针，引用也可以实现多态。 多态的用途​ 通过上面的例子读者可能还未发现多态的用途，不过确实也是，多态在小项目中鲜有有用武之地。 ​ 接下来的例子中，我们假设你正在玩一款军事游戏，敌人突然发动了地面战争，于是你命令陆军、空军及其所有现役装备进入作战状态。具体的代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;//军队class Troops&#123;public: virtual void fight()&#123; cout&lt;&lt;"Strike back!"&lt;&lt;endl; &#125;&#125;;//陆军class Army: public Troops&#123;public: void fight()&#123; cout&lt;&lt;"--Army is fighting!"&lt;&lt;endl; &#125;&#125;;//99A主战坦克class _99A: public Army&#123;public: void fight()&#123; cout&lt;&lt;"----99A(Tank) is fighting!"&lt;&lt;endl; &#125;&#125;;//武直10武装直升机class WZ_10: public Army&#123;public: void fight()&#123; cout&lt;&lt;"----WZ-10(Helicopter) is fighting!"&lt;&lt;endl; &#125;&#125;;//长剑10巡航导弹class CJ_10: public Army&#123;public: void fight()&#123; cout&lt;&lt;"----CJ-10(Missile) is fighting!"&lt;&lt;endl; &#125;&#125;;//空军class AirForce: public Troops&#123;public: void fight()&#123; cout&lt;&lt;"--AirForce is fighting!"&lt;&lt;endl; &#125;&#125;;//J-20隐形歼击机class J_20: public AirForce&#123;public: void fight()&#123; cout&lt;&lt;"----J-20(Fighter Plane) is fighting!"&lt;&lt;endl; &#125;&#125;;//CH5无人机class CH_5: public AirForce&#123;public: void fight()&#123; cout&lt;&lt;"----CH-5(UAV) is fighting!"&lt;&lt;endl; &#125;&#125;;//轰6K轰炸机class H_6K: public AirForce&#123;public: void fight()&#123; cout&lt;&lt;"----H-6K(Bomber) is fighting!"&lt;&lt;endl; &#125;&#125;;int main()&#123; Troops *p = new Troops; p -&gt;fight(); //陆军 p = new Army; p -&gt;fight(); p = new _99A; p -&gt; fight(); p = new WZ_10; p -&gt; fight(); p = new CJ_10; p -&gt; fight(); //空军 p = new AirForce; p -&gt; fight(); p = new J_20; p -&gt; fight(); p = new CH_5; p -&gt; fight(); p = new H_6K; p -&gt; fight(); return 0;&#125; 运行结果：123456789Strike back!--Army is fighting!----99A(Tank) is fighting!----WZ-10(Helicopter) is fighting!----CJ-10(Missile) is fighting!--AirForce is fighting!----J-20(Fighter Plane) is fighting!----CH-5(UAV) is fighting!----H-6K(Bomber) is fighting! ​ 这个例子中的派生类比较多，如果不使用多态，那么就需要定义多个指针变量，很容易造成混乱；而有了多态，只需要一个指针变量p就可以调用所有派生类的虚函数。 ​ 从这个例子中也可以发现，对于具有复杂继承关系的大中型程序，多态可以增加其灵活性，让代码更具有表现力。 虚函数注意事项​ 虚函数对于多态具有决定性的作用，有虚函数才能构成多态，这节我们来重点说一下虚函数的注意事项。 1) 只需要在虚函数的声明处加上 virtual 关键字，函数定义处可以加也可以不加。 2) 为了方便，你可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽（覆盖）关系的同名函数都将自动成为虚函数。 3) 当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。 4) 只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）。例如基类虚函数的原型为virtual void func();，派生类虚函数的原型为virtual void func(int);，那么当基类指针p指向派生类对象时，语句p -&gt; func(100);将会出错，而语句p -&gt; func();将调用基类的函数。 5) 构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。 6) 析构函数可以声明为虚函数，而且有时候必须要声明为虚函数。 构成多态的条件​ 站在“学院派”的角度讲，封装、继承和多态是面向对象的三大特征，多态是指通过基类的指针既可以访问基类的成员，也可以访问派生类的成员。 下面是构成多态的条件： 必须存在继承关系； 继承关系中必须有同名的虚函数，并且它们是遮蔽（覆盖）关系。 存在基类的指针，通过该指针调用虚函数。 下面的例子对各种混乱情形进行了演示： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;//基类Baseclass Base&#123;public: virtual void func(); virtual void func(int);&#125;;void Base::func()&#123; cout&lt;&lt;"void Base::func()"&lt;&lt;endl;&#125;void Base::func(int n)&#123; cout&lt;&lt;"void Base::func(int)"&lt;&lt;endl;&#125;//派生类Derivedclass Derived: public Base&#123;public: void func(); void func(char *);&#125;;void Derived::func()&#123; cout&lt;&lt;"void Derived::func()"&lt;&lt;endl;&#125;void Derived::func(char *str)&#123; cout&lt;&lt;"void Derived::func(char *)"&lt;&lt;endl;&#125;int main()&#123; Base *p = new Derived(); p -&gt; func(); //输出void Derived::func() p -&gt; func(10); //输出void Base::func(int) p -&gt; func("http://c.biancheng.net"); //compile error return 0;&#125; ​ 在基类Base中我们将void func()声明为虚函数，这样派生类Derived中的void func()就会自动成为虚函数。p是基类Base的指针，但是指向了派生类Derived的对象。语句p-&gt;func();调用的是派生类的虚函数，构成了多态。语句p -&gt; func(10);调用的是基类的虚函数，因为派生类中没有函数遮蔽它。语句p -&gt; func(&quot;http://c.biancheng.net&quot;);出现编译错误，因为通过基类的指针只能访问从基类继承过去的成员，不能访问派生类新增的成员。 什么时候声明虚函数​ 首先看成员函数所在的类是否会作为基类。然后看成员函数在类的继承后有无可能被更改功能，如果希望更改其功能的，一般应该将它声明为虚函数。如果成员函数在类被继承后功能不需修改，或派生类用不到该函数，则不要把它声明为虚函数。 虚析构函数​ 上节我们讲到，构造函数不能是虚函数，因为派生类不能继承基类的构造函数，将构造函数声明为虚函数没有意义。 ​ 这是原因之一，另外还有一个原因：C++中的构造函数用于在创建对象时进行初始化工作，在执行构造函数之前对象尚未创建完成，虚函数表尚不存在，也没有指向虚函数表的指针，所以此时无法查询虚函数表，也就不知道要调用哪一个构造函数。 ​ 析构函数用于在销毁对象时进行清理工作，可以声明为虚函数，而且有时候必须要声明为虚函数。 ​ 为了说明虚析构函数的必要性，请大家先看下面一个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;//基类class Base&#123;public: Base(); ~Base();protected: char *str;&#125;;Base::Base()&#123; str = new char[100]; cout&lt;&lt;"Base constructor"&lt;&lt;endl;&#125;Base::~Base()&#123; delete[] str; cout&lt;&lt;"Base destructor"&lt;&lt;endl;&#125;//派生类class Derived: public Base&#123;public: Derived(); ~Derived();private: char *name;&#125;;Derived::Derived()&#123; name = new char[100]; cout&lt;&lt;"Derived constructor"&lt;&lt;endl;&#125;Derived::~Derived()&#123; delete[] name; cout&lt;&lt;"Derived destructor"&lt;&lt;endl;&#125;int main()&#123; Base *pb = new Derived(); delete pb; cout&lt;&lt;"-------------------"&lt;&lt;endl; Derived *pd = new Derived(); delete pd; return 0;&#125; 运行结果：12345678Base constructorDerived constructorBase destructor-------------------Base constructorDerived constructorDerived destructorBase destructor ​ 本例中定义了两个类，基类Base和派生类Derived，它们都有自己的构造函数和析构函数。在构造函数中，会分配100个char类型的内存空间；在析构函数中，会把这些内存释放掉。 ​ pb、pd分别是基类指针和派生类指针，它们都指向派生类对象，最后使用delete 销毁 pb、pd 所指向的对象。 ​ 从运行结果可以看出，语句delete pb;只调用了基类的析构函数，没有调用派生类的析构函数；而语句delete pd;同时调用了派生类和基类的析构函数。 ​ 在本例中，不调用派生类的析构函数会导致name指向的100个char类型的内存空间得不到释放；除非程序运行结束由操作系统回收，否则就再也没有机会释放这些内存。这是典型的内存泄露。 1) 为什么delete pb;不会调用派生类的析构函数呢？ ​ 因为这里的析构函数是非虚函数，通过指针访问非虚函数时，编译器会根据指针的类型来确定要调用的函数；也就是说，指针是哪个类就调用哪个类的函数，这在前面的章节中已经多次强调过。pb 是基类的指针，所以不管它指向基类的对象还是派生类的对象，始终都是调用基类的析构函数。 2) 为什么delete pd;会同时调用派生类和基类的析构函数呢？ ​ pd是派生类的指针，编译器会根据它的类型匹配到派生类的析构函数，在执行派生类的析构函数的过程中，又会调用基类的析构函数。派生类析构函数始终会调用基类的析构函数，并且这个过程是隐式完成的， ​ 更改上面的代码，将基类的析构函数声明为虚函数： 1234567class Base&#123;public: Base(); virtual ~Base();protected: char *str;&#125;; 运行结果：123456789Base constructorDerived constructorDerived destructorBase destructor-------------------Base constructorDerived constructorDerived destructorBase destructor ​ 将基类的析构函数声明为虚函数后，派生类的析构函数也会自动成为虚函数。这个时候编译器会忽略指针的类型，而根据指针的指向来选择函数；也就是说，指针指向哪个类的对象就调用哪个类的函数。pb、pd 都指向了派生类的对象，所以会调用派生类的析构函数，继而再调用基类的析构函数。如此一来也就解决了内存泄露的问题。 ​ 在实际开发中，一旦我们自己定义了析构函数，就是希望在对象销毁时用它来进行清理工作，比如释放内存、关闭文件等，如果这个类又是一个基类，那么我们就必须将该析构函数声明为虚函数，否则就有内存泄露的风险。 ​ 也就是说，大部分情况下都应该将基类的析构函数声明为虚函数。 ​ 注意，这里强调的是基类，如果一个类是最终的类，那就没必要再声明为虚函数了。 纯虚函数​ 在C++中，可以将虚函数声明为纯虚函数，语法格式为： virtual 返回值类型 函数名 (函数参数) = 0; ​ 纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上=0，表明此函数为纯虚函数。 最后的=0并不表示函数返回值为0，它只起形式上的作用，告诉编译系统“这是纯虚函数”。 ​ 包含纯虚函数的类称为抽象类（Abstract Class）。之所以说它抽象，是因为它无法实例化，也就是无法创建对象。原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。 ​ 抽象类通常是作为基类，让派生类去实现纯虚函数。派生类必须实现纯虚函数才能被实例化。 纯虚函数使用举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;using namespace std;//线class Line&#123;public: Line(float len); virtual float area() = 0; virtual float volume() = 0;protected: float m_len;&#125;;Line::Line(float len): m_len(len)&#123; &#125;//矩形class Rec: public Line&#123;public: Rec(float len, float width); float area();protected: float m_width;&#125;;Rec::Rec(float len, float width): Line(len), m_width(width)&#123; &#125;float Rec::area()&#123; return m_len * m_width; &#125;//长方体class Cuboid: public Rec&#123;public: Cuboid(float len, float width, float height); float area(); float volume();protected: float m_height;&#125;;Cuboid::Cuboid(float len, float width, float height): Rec(len, width), m_height(height)&#123; &#125;float Cuboid::area()&#123; return 2 * ( m_len*m_width + m_len*m_height + m_width*m_height); &#125;float Cuboid::volume()&#123; return m_len * m_width * m_height; &#125;//正方体class Cube: public Cuboid&#123;public: Cube(float len); float area(); float volume();&#125;;Cube::Cube(float len): Cuboid(len, len, len)&#123; &#125;float Cube::area()&#123; return 6 * m_len * m_len; &#125;float Cube::volume()&#123; return m_len * m_len * m_len; &#125;int main()&#123; Line *p = new Cuboid(10, 20, 30); cout&lt;&lt;"The area of Cuboid is "&lt;&lt;p-&gt;area()&lt;&lt;endl; cout&lt;&lt;"The volume of Cuboid is "&lt;&lt;p-&gt;volume()&lt;&lt;endl; p = new Cube(15); cout&lt;&lt;"The area of Cube is "&lt;&lt;p-&gt;area()&lt;&lt;endl; cout&lt;&lt;"The volume of Cube is "&lt;&lt;p-&gt;volume()&lt;&lt;endl; return 0;&#125; 运行结果：1234The area of Cuboid is 2200The volume of Cuboid is 6000The area of Cube is 1350The volume of Cube is 3375 ​ 本例中定义了四个类，它们的继承关系为：Line --&gt; Rec --&gt; Cuboid --&gt; Cube。 ​ Line 是一个抽象类，也是最顶层的基类，在Line类中定义了两个纯虚函数 area() 和 volume()。 ​ 在Rec类中，实现了area()函数；所谓实现，就是定义了纯虚函数的函数体。但这时Rec仍不能被实例化，因为它没有实现继承来的volume()函数，volume()仍然是纯虚函数，所以Rec也仍然是抽象类。 ​ 直到Cuboid类，才实现了volume()函数，才是一个完整的类，才可以被实例化。 ​ 可以发现，Line类表示“线”，没有面积和体积，但它仍然定义了area()和volume()两个纯虚函数。这样的用意很明显：Line类不需要被实例化，但是它为派生类提供了“约束条件”，派生类必须要实现这两个函数，完成计算面积和体积的功能，否则就不能实例化。 ​ 在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现（谁派生谁实现）。这部分未完成的功能，往往是基类不需要的，或者在基类中无法实现的。虽然抽象基类没有完成，但是却强制要求派生类完成，这就是抽象基类的“霸王条款”。 ​ 抽象基类除了约束派生类的功能，还可以实现多态。请注意第51行代码，指针p的类型是Line，但是它却可以访问派生类中的area()和volume() 函数，正是由于在Line类中将这两个函数定义为纯虚函数；如果不这样做，51行后面的代码都是错误的。我想，这或许才是C++提供纯虚函数的主要目的。 纯虚函数的说明​ 1) 一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。 2) 只有类中的虚函数才能被声明为**纯虚函数**，普通成员函数和顶层函数均不能声明为纯虚函数。如下例所示： 12345678//顶层函数不能被声明为纯虚函数void fun() = 0; //compile errorclass base&#123;public : //普通成员函数不能被声明为纯虚函数 void display() = 0; //compile error&#125;; 前面我们一再强调，当通过指针访问类的成员函数时： 如果该函数是非虚函数，那么编译器会根据指针的类型找到该函数；也就是说，指针是哪个类的类型就调用哪个类的函数。 如果该函数是虚函数，并且派生类有同名的函数遮蔽它，那么编译器会根据指针的指向找到该函数；也就是说，指针指向的对象属于哪个类就调用哪个类的函数。这就是多态。 ​ 虚函数表​ 编译器之所以能通过指针指向的对象找到虚函数，是因为在创建对象时额外地增加了虚函数表。 ​ 如果一个类包含了虚函数，那么在创建该类的对象时就会额外地增加一个数组，数组中的每一个元素都是虚函数的入口地址。不过数组和对象是分开存储的，为了将对象和数组关联起来，编译器还要在对象中安插一个指针，指向数组的起始位置。 ​ 这里的数组就是虚函数表（Virtual function table），简写为vtable。 ​ 我们以下面的继承关系为例进行讲解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//People类class People&#123;public: People(string name, int age);public: virtual void display(); virtual void eating();protected: string m_name; int m_age;&#125;;People::People(string name, int age): m_name(name), m_age(age)&#123; &#125;void People::display()&#123; cout&lt;&lt;"Class People："&lt;&lt;m_name&lt;&lt;"今年"&lt;&lt;m_age&lt;&lt;"岁了。"&lt;&lt;endl;&#125;void People::eating()&#123; cout&lt;&lt;"Class People：我正在吃饭，请不要跟我说话..."&lt;&lt;endl;&#125;//Student类class Student: public People&#123;public: Student(string name, int age, float score);public: virtual void display(); virtual void examing();protected: float m_score;&#125;;Student::Student(string name, int age, float score): People(name, age), m_score(score)&#123; &#125;void Student::display()&#123; cout&lt;&lt;"Class Student："&lt;&lt;m_name&lt;&lt;"今年"&lt;&lt;m_age&lt;&lt;"岁了，考了"&lt;&lt;m_score&lt;&lt;"分。"&lt;&lt;endl;&#125;void Student::examing()&#123; cout&lt;&lt;"Class Student："&lt;&lt;m_name&lt;&lt;"正在考试，请不要打扰T啊！"&lt;&lt;endl;&#125;//Senior类class Senior: public Student&#123;public: Senior(string name, int age, float score, bool hasJob);public: virtual void display(); virtual void partying();private: bool m_hasJob;&#125;;Senior::Senior(string name, int age, float score, bool hasJob): Student(name, age, score), m_hasJob(hasJob)&#123; &#125;void Senior::display()&#123; if(m_hasJob)&#123; cout&lt;&lt;"Class Senior："&lt;&lt;m_name&lt;&lt;"以"&lt;&lt;m_score&lt;&lt;"的成绩从大学毕业了，并且顺利找到了工作，Ta今年"&lt;&lt;m_age&lt;&lt;"岁。"&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;"Class Senior："&lt;&lt;m_name&lt;&lt;"以"&lt;&lt;m_score&lt;&lt;"的成绩从大学毕业了，不过找工作不顺利，Ta今年"&lt;&lt;m_age&lt;&lt;"岁。"&lt;&lt;endl; &#125;&#125;void Senior::partying()&#123; cout&lt;&lt;"Class Senior：快毕业了，大家都在吃散伙饭..."&lt;&lt;endl;&#125;int main()&#123; People *p = new People("赵红", 29); p -&gt; display(); p = new Student("王刚", 16, 84.5); p -&gt; display(); p = new Senior("李智", 22, 92.0, true); p -&gt; display(); return 0;&#125; 运行结果：123Class People：赵红今年29岁了。Class Student：王刚今年16岁了，考了84.5分。Class Senior：李智以92的成绩从大学毕业了，并且顺利找到了工作，Ta今年22岁。 各个类的对象内存模型如下所示： ​ 图中左半部分是对象占用的内存，右半部分是虚函数表 vtable。在对象的开头位置有一个指针 vfptr，指向虚函数表，并且这个指针始终位于对象的开头位置。 ​ 仔细观察虚函数表，可以发现基类的虚函数在 vtable 中的索引（下标）是固定的，不会随着继承层次的增加而改变，派生类新增的虚函数放在 vtable 的最后。如果派生类有同名的虚函数遮蔽（覆盖）了基类的虚函数，那么将使用派生类的虚函数替换基类的虚函数，这样具有遮蔽关系的虚函数在 vtable 中只会出现一次。 ​ 当通过指针调用虚函数时，先根据指针找到 vfptr，再根据 vfptr 找到虚函数的入口地址。以虚函数display()为例，它在 vtable 中的索引为0，通过p 调用时：1p -&gt; display(); 编译器内部会发生类似下面的转换： 1( *( *(p+0) + 0 ) )(p); 下面我们一步一步来分析这个表达式： 0是 vfptr 在对象中的偏移，p+0是 vfptr 的地址； *(p+0)是 vfptr 的值，而 vfptr 是指向 vtable 的指针，所以*(p+0)也就是 vtable 的地址； display()在 vtable 中的索引（下标）是0，所以( *(p+0) + 0 )也就是 display() 的地址； 知道了 display() 的地址，( *( *(p+0) + 0 ) )(p)也就是对 display() 的调用了，这里的 p就是传递的实参，它会赋值给this指针。 ​ 可以看到，转换后的表达式是固定的，只要调用display()函数，不管它是哪个类的，都会使用这个表达式。换句话说，编译器不管p指向哪里，一律转换为相同的表达式。 ​ 转换后的表达式没有用到与 p的类型有关的信息，只要知道p的指向就可以调用函数，这跟名字编码（Name Mangling）算法有着本质上的区别。 ​ 再来看一下eating()函数，它在 vtable 中的索引为1，通过p调用时：1p -&gt; eating(); 编译器内部会发生类似下面的转换： 1( *( *(p+0) + 1 ) )(p); ​ 对于不同的虚函数，仅仅改变索引（下标）即可。 ​ 以上是针对单继承进行的讲解。当存在多继承时，虚函数表的结构就会变得复杂，尤其是有虚继承时，还会增加虚基类表，更加让人抓狂，这里我们就不分析了，有兴趣的读者可以自行研究。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++拷贝控制操作]]></title>
    <url>%2F2018%2F07%2F23%2Fc%2B%2B%E5%B0%81%E8%A3%857-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[当定义一个类时，我们显式地或隐式地指定了此类型的对象在拷贝、赋值和销毁时做什么。一个类通过定义三种特殊的成员函数来控制这些操作，分别是拷贝构造函数、赋值运算符和析构函数。 拷贝构造函数定义了当用同类型的另一个对象初始化新对象时做什么，赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么，析构函数定义了此类型的对象销毁时做什么。我们将这些操作称为拷贝控制操作。 拷贝控制操作 ​ 由于拷贝控制操作是由三个特殊的成员函数来完成的，所以我们称此为“C++三法则”。在较新的C++11 标准中，为了支持移动语义，又增加了移动构造函数和移动赋值运算符，这样共有五个特殊的成员函数，所以又称为“C++五法则”。也就是说，“三法则”是针对较旧的C++89标准说的，“五法则”是针对较新的 C++11标准说的。为了统一称呼，后来人们干把它叫做“C++ 三/五法则”。 ​ 如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义默认的操作，因此很多类会忽略这些拷贝控制操作。但是，对于一些持有其他资源（例如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等）的类来说，依赖这些默认的操作会导致灾难，我们必须显式的定义这些操作。 ​ C++并不要求我们定义所有的这些操作，你可以只定义其中的一个或两个。但是，这些操作通常应该被看做一个整体，只需要定义其中一个操作，而不需要定义其他操作的情况很少见。 需要析构函数的类也需要拷贝和赋值操作​ 当我们决定是否要为一个类显式地定义拷贝构造函数和赋值运算符时，一个基本原则是首先确定这个类是否需要一个析构函数。通常，对析构函数的需求要比拷贝构造函数和赋值运算符的需求更加明显。如果一个类需要定义析构函数，那么几乎可以肯定这个类也需要一个拷贝构造函数和一个赋值运算符。 ​ 我们在前面几节中使用过的Array类就是一个典型的例子。这个类在构造函数中动态地分配了一块内存，并用一个成员变量（指针变量）指向它，默认的析构函数不会释放这块内存，所以我们需要显式地定义一个析构函数来释放内存。 ​ 「应该怎么做」可能还是有点不清晰，但基本原则告诉我们，Array类也需要一个拷贝构造函数和一个赋值运算符。 ​ 如果我们为Array定义了一个析构函数，但却使用默认的拷贝构造函数和赋值运算符，那么将导致不同对象之间相互干扰，修改一个对象的数据会影响另外的对象。此外还可能会导致内存操作错误，请看下面的代码： 1234Array func(Array arr)&#123; //按值传递，将发生拷贝 Array ret = arr; //发生拷贝 return ret; //ret和arr将被销毁&#125; ​ 当 func()返回时，arr 和 ret都会被销毁，在两个对象上都会调用析构函数，此析构函数会 free()掉 m_p 成员所指向的动态内存。但是，这两个对象的m_p成员指向的是同一块内存，所以该内存会被 free() 两次，这显然是一个错误，将要发生什么是未知的。 ​ 此外，func()的调用者还会继续使用传递给func()的对象： 123Array arr1(10);func(arr1); //当 func() 调用结束时，arr1.m_p 指向的内存被释放Array arr2 = arr1; //现在 arr2 和 arr1 都指向无效内存 ​ arr2（以及 arr1）指向的内存不再有效，在arr（以及 ret）被销毁时系统已经归还给操作系统了。 ​ 总之，如果一个类需要定义析构函数，那么几乎可以肯定它也需要定义拷贝构造函数和赋值运算符。 需要拷贝操作的类也需要赋值操作，反之亦然​ 虽然很多类需要定义所有（或是不需要定义任何）拷贝控制成员，但某些类所要完成的工作，只需要拷贝或者赋值操作，不需要析构操作。 ​ 作为一个例子，考虑一个类为每个对象分配一个独有的、唯一的编号。这个类除了需要一个拷贝构造函数为每个新创建的对象生成一个新的编号，还需要一个赋值运算符来避免将一个对象的编号赋值给另外一个对象。但是，这个类并不需要析构函数。 ​ 这个例子引出了第二个基本原则：如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个赋值运算符；反之亦然。然而，无论需要拷贝构造函数还是需要复制运算符，都不必然意味着也需要析构函数。 自定义类型转换​ 在C/C++中，不同的数据类型之间可以相互转换。无需用户指明如何转换的称为自动类型转换（隐式类型转换），需要用户显式地指明如何转换的称为强制类型转换。 自动类型转换示例： 12int a = 6;a = 7.5 + a; ​ 编译器对7.5是作为double类型处理的，在求解表达式时，先将 a转换为double类型，然后与7.5相加，得到和为13.5。在向整型变量a赋值时，将13.5转换为整数13，然后赋给a。整个过程中，我们并没有告诉编译器如何去做，编译器使用内置的规则完成数据类型的转换。 ​ 强制类型转换示例： 123int n = 100;int *p1 = &amp;n;float *p2 = (float*)p1; ​ p1 是int *类型，它指向的内存里面保存的是整数，p2 是float *类型，将 p1 赋值给 p2后，p2 也指向了这块内存，并把这块内存中的数据作为小数处理。我们知道，整数和小数的存储格式大相径庭，将整数作为小数处理非常荒诞，可能会引发莫名其妙的错误，所以编译器默认不允许将 p1赋值给p2。但是，使用强制类型转换后，编译器就认为我们知道这种风险的存在，并进行了适当的权衡，所以最终还是允许了这种行为。 ​ 不管是自动类型转换还是强制类型转换，前提必须是编译器知道如何转换，例如，将小数转换为整数会抹掉小数点后面的数字，将int *转换为float *只是简单地复制指针的值，这些规则都是编译器内置的，我们并没有告诉编译器。 ​ 换句话说，如果编译器不知道转换规则就不能转换，使用强制类型也无用，请看下面的例子： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;//复数类class Complex&#123;public: Complex(): m_real(0.0), m_imag(0.0)&#123; &#125; Complex(double real, double imag): m_real(real), m_imag(imag)&#123; &#125;public: friend ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c); //友元函数private: double m_real; //实部 double m_imag; //虚部&#125;;//重载&gt;&gt;运算符ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123; out &lt;&lt; c.m_real &lt;&lt;" + "&lt;&lt; c.m_imag &lt;&lt;"i";; return out;&#125;int main()&#123; Complex a(10.0, 20.0); a = (Complex)25.5; //错误，转换失败 return 0;&#125; ​ 25.5是实数，a是复数，将25.5 赋值给a后，我们期望a的实部变为25.5，而虚部为0。但是，编译器并不知道这个转换规则，这超出了编译器的处理能力，所以转换失败，即使加上强制类型转换也无用。 ​ 幸运的是，C++允许我们自定义类型转换规则，用户可以将其它类型转换为当前类类型，也可以将当前类类型转换为其它类型。这种自定义的类型转换规则只能以类的成员函数的形式出现，换句话说，这种转换规则只适用于类。 ​ 本节我们先讲解如何将其它类型转换为当前类类型，下节再讲解如何将当前类类型转换为其它类型。 转换构造函数​ 将其它类型转换为当前类类型需要借助转换构造函数（Conversion constructor）。 ​ 转换构造函数也是一种构造函数，它遵循构造函数的一般规则。转换构造函数只有一个参数。 ​ 仍然以Complex类为例，我们为它添加转换构造函数： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;//复数类class Complex&#123;public: Complex(): m_real(0.0), m_imag(0.0)&#123; &#125; Complex(double real, double imag): m_real(real), m_imag(imag)&#123; &#125; Complex(double real): m_real(real), m_imag(0.0)&#123; &#125; //转换构造函数public: friend ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c); //友元函数private: double m_real; //实部 double m_imag; //虚部&#125;;//重载&gt;&gt;运算符ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123; out &lt;&lt; c.m_real &lt;&lt;" + "&lt;&lt; c.m_imag &lt;&lt;"i";; return out;&#125;int main()&#123; Complex a(10.0, 20.0); cout&lt;&lt;a&lt;&lt;endl; a = 25.5; //调用转换构造函数 cout&lt;&lt;a&lt;&lt;endl; return 0;&#125; 运行结果： 12310 + 20i25.5 + 0i ​ Complex(double real);就是转换构造函数，它的作用是将double类型的参数real转换成Complex类的对象，并将real作为复数的实部，将0作为复数的虚部。这样一来，a = 25.5;整体上的效果相当于：1a.Complex(25.5); ​ 将赋值的过程转换成了函数调用的过程。 ​ 在进行数学运算、赋值、拷贝等操作时，如果遇到类型不兼容、需要将double类型转换为Complex类型时，编译器会检索当前的类是否定义了转换构造函数，如果没有定义的话就转换失败，如果定义了的话就调用转换构造函数。 ​ 转换构造函数也是构造函数的一种，它除了可以用来将其它类型转换为当前类类型，还可以用来初始化对象，这是构造函数本来的意义。下面创建对象的方式是正确的： 1234Complex c1(26.4); //创建具名对象Complex c2 = 240.3; //以拷贝的方式初始化对象Complex(15.9); //创建匿名对象c1 = Complex(46.9); //创建一个匿名对象并将它赋值给 c1 ​ 在以拷贝的方式初始化对象时，编译器先调用转换构造函数，将240.3转换为Complex类型（创建一个 Complex类的匿名对象），然后再拷贝给 c2。 ​ 如果已经对+运算符进行了重载，使之能进行两个Complex类对象的相加，那么下面的语句也是正确的： 1234Complex c1(15.6, 89.9);Complex c2;c2 = c1 + 29.6;cout&lt;&lt;c2&lt;&lt;endl; ​ 在进行加法运算符时，编译器先将29.6转换为Complex类型（创建一个Complex类的匿名对象）再相加。 ​ 需要注意的是，为了获得目标类型，编译器会“不择手段”，会综合使用内置的转换规则和用户自定义的转换规则，并且会进行多级类型转换，例如： 编译器会根据内置规则先将int转换为double，再根据用户自定义规则将double转换为 Complex（int --&gt; double --&gt; Complex）； 编译器会根据内置规则先将char 转换为int，再将int转换为double，最后根据用户自定义规则将double转换为 Complex（char --&gt; int --&gt; double --&gt; Complex）。 ​ 从本例看，只要一个类型能转换为double类型，就能转换为Complex类型。请看下面的例子： 1234567891011121314151617int main()&#123; Complex c1 = 100; //int --&gt; double --&gt; Complex cout&lt;&lt;c1&lt;&lt;endl; c1 = 'A'; //char --&gt; int --&gt; double --&gt; Complex cout&lt;&lt;c1&lt;&lt;endl; c1 = true; //bool --&gt; int --&gt; double --&gt; Complex cout&lt;&lt;c1&lt;&lt;endl; Complex c2(25.8, 0.7); //假设已经重载了+运算符 c1 = c2 + 'H' + true + 15; //将char、bool、int都转换为Complex类型再运算 cout&lt;&lt;c1&lt;&lt;endl; return 0;&#125; ​ 运行结果：1234100 + 0i65 + 0i1 + 0i113.8 + 0.7i 再谈构造函数​ 构造函数的本意是在创建对象的时候初始化对象，编译器会根据传递的实参来匹配不同的（重载的）构造函数。回顾一下以前的章节，到目前为止我们已经学习了以下几种构造函数。 ​ 1) 默认构造函数。就是编译器自动生成的构造函数。以Complex类为例，它的原型为：1Complex(); //没有参数 ​ 2) 普通构造函数。就是用户自定义的构造函数。以Complex类为例，它的原型为：1Complex(double real, double imag); //两个参数 ​ 3) 拷贝构造函数。在以拷贝的方式初始化对象时调用。以Complex类为例，它的原型为：1Complex(const Complex &amp;c); ​ 4) 转换构造函数。将其它类型转换为当前类类型时调用。以Complex为例，它的原型为：1Complex(double real); ​ 不管哪一种构造函数，都能够用来初始化对象，这是构造函数的本意。假设Complex类定义了以上所有的构造函数，那么下面创建对象的方式都是正确的： 1234Complex c1(); //调用Complex()Complex c2(10, 20); //调用Complex(double real, double imag)Complex c3(c2); //调用Complex(const Complex &amp;c)Complex c4(25.7); //调用Complex(double real) ​ 这些代码都体现了构造函数的本意——在创建对象时初始化对象。 ​ 除了在创建对象时初始化对象，其他情况下也会调用构造函数，例如，以拷贝的的方式初始化对象时会调用拷贝构造函数，将其它类型转换为当前类类型时会调用转换构造函数。这些在其他情况下调用的构造函数，就成了特殊的构造函数了。特殊的构造函数并不一定能体现出构造函数的本意。 对Complex类的进一步精简​ 上面的Complex类中我们定义了三个构造函数，其中包括两个普通的构造函数和一个转换构造函数。其实，借助函数的默认参数，我们可以将这三个构造函数简化为一个，请看下面的代码： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;//复数类class Complex&#123;public: Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag)&#123; &#125;public: friend ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c); //友元函数private: double m_real; //实部 double m_imag; //虚部&#125;;//重载&gt;&gt;运算符ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123; out &lt;&lt; c.m_real &lt;&lt;" + "&lt;&lt; c.m_imag &lt;&lt;"i";; return out;&#125;int main()&#123; Complex a(10.0, 20.0); //向构造函数传递 2 个实参，不使用默认参数 Complex b(89.5); //向构造函数传递 1 个实参，使用 1 个默认参数 Complex c; //不向构造函数传递实参，使用全部默认参数 a = 25.5; //调用转换构造函数（向构造函数传递 1 个实参，使用 1 个默认参数） return 0;&#125; ​ 精简后的构造函数包含了两个默认参数，在调用它时可以省略部分或者全部实参，也就是可以向它传递0个、1个、2个实参。转换构造函数就是包含了一个参数的构造函数，恰好能够和其他两个普通的构造函数“融合”在一起。 类型转换函数​ 转换构造函数能够将其它类型转换为当前类类型（例如将double类型转换为Complex类型），但是不能反过来将当前类类型转换为其它类型（例如将Complex类型转换为double类型）。 ​ C++提供了类型转换函数（Type conversion function）来解决这个问题。类型转换函数的作用就是将当前类类型转换为其它类型，它只能以成员函数的形式出现，也就是只能出现在类中。 ​ 类型转换函数的语法格式为：1234operator type()&#123; //TODO: return data;&#125; ​ operator是C++关键字，type是要转换的目标类型，data是要返回的type类型的数据。 ​ 因为要转换的目标类型是type，所以返回值data也必须是type类型。既然已经知道了要返回type类型的数据，所以没有必要再像普通函数一样明确地给出返回值类型。这样做导致的结果是：类型转换函数看起来没有返回值类型，其实是隐式地指明了返回值类型。 ​ 类型转换函数也没有参数，因为要将当前类的对象转换为其它类型，所以参数不言而喻。实际上编译器会把当前对象的地址赋值给this指针，这样在函数体内就可以操作当前对象了。 ​ 【示例】为Complex 类添加类型转换函数，使得Complex类型能够转换为double类型。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;//复数类class Complex&#123;public: Complex(): m_real(0.0), m_imag(0.0)&#123; &#125; Complex(double real, double imag): m_real(real), m_imag(imag)&#123; &#125;public: friend ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c); friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2); operator double() const &#123; return m_real; &#125; //类型转换函数private: double m_real; //实部 double m_imag; //虚部&#125;;//重载&gt;&gt;运算符ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123; out &lt;&lt; c.m_real &lt;&lt;" + "&lt;&lt; c.m_imag &lt;&lt;"i";; return out;&#125;//重载+运算符Complex operator+(const Complex &amp;c1, const Complex &amp;c2)&#123; Complex c; c.m_real = c1.m_real + c2.m_real; c.m_imag = c1.m_imag + c2.m_imag; return c;&#125;int main()&#123; Complex c1(24.6, 100); double f = c1; //相当于 double f = Complex::operator double(&amp;c1); cout&lt;&lt;"f = "&lt;&lt;f&lt;&lt;endl; f = 12.5 + c1 + 6; //相当于 f = 12.5 + Complex::operator double(&amp;c1) + 6; cout&lt;&lt;"f = "&lt;&lt;f&lt;&lt;endl; int n = Complex(43.2, 9.3); //先转换为 double，再转换为 int cout&lt;&lt;"n = "&lt;&lt;n&lt;&lt;endl; return 0;&#125; ​ 运行结果：123f = 24.6f = 43.1n = 43 ​ 本例中，类型转换函数非常简单，就是返回成员变量m_real的值，所以建议写成inline的形式。 ​ 类型转换函数和运算符的重载非常相似，都使用operator关键字，因此也把类型转换函数称为类型转换运算符。 关于类型转换函数的说明​ 1) type可以是内置类型、类类型以及由typedef定义的类型别名，任何可作为函数返回类型的类型（void除外）都能够被支持。一般而言，不允许转换为数组或函数类型，转换为指针类型或引用类型是可以的。 ​ 2) 类型转换函数一般不会更改被转换的对象，所以通常被定义为 const 成员。 ​ 3) 类型转换函数可以被继承，可以是虚函数。 ​ 4) 一个类虽然可以有多个类型转换函数（类似于函数重载），但是如果多个类型转换函数要转换的目标类型本身又可以相互转换（类型相近），那么有时候就会产生二义性。以Complex类为例，假设它有两个类型转换函数：12operator double() const &#123; return m_real; &#125; //转换为double类型operator int() const &#123; return (int)m_real; &#125; //转换为int类型 ​ 那么下面的写法就会引发二义性：12Complex c1(24.6, 100);float f = 12.5 + c1; ​ 编译器可以调用operator double()将 c1转换为double类型，也可以调用operator int()将c1转换为int类型，这两种类型都可以跟12.5进行加法运算，并且从Complex转换为double与从Complex转化为int是平级的，没有谁的优先级更高，所以这个时候编译器就不知道该调用哪个函数了，干脆抛出一个二义性错误，让用户解决。 转换构造函数和类型转换函数异同​ 转换构造函数和类型转换函数的作用是相反的：转换构造函数会将其它类型转换为当前类类型，类型转换函数会将当前类类型转换为其它类型。如果没有这两个函数，Complex 类和 int、double、bool等基本类型的四则运算、逻辑运算都将变得非常复杂，要编写大量的运算符重载函数。 ​ 但是，如果一个类同时存在这两个函数，就有可能产生二义性。下面以Complex类为例来演示：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;//复数类class Complex&#123;public: Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag)&#123; &#125; //包含了转换构造函数public: friend ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c); friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2); operator double() const &#123; return m_real; &#125; //类型转换函数private: double m_real; //实部 double m_imag; //虚部&#125;;//重载&gt;&gt;运算符ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123; out &lt;&lt; c.m_real &lt;&lt;" + "&lt;&lt; c.m_imag &lt;&lt;"i";; return out;&#125;//重载+运算符Complex operator+(const Complex &amp;c1, const Complex &amp;c2)&#123; Complex c; c.m_real = c1.m_real + c2.m_real; c.m_imag = c1.m_imag + c2.m_imag; return c;&#125;int main()&#123; Complex c1(24.6, 100); double f = c1; //①正确，调用类型转换函数 c1 = 78.4; //②正确，调用转换构造函数 f = 12.5 + c1; //③错误，产生二义性 Complex c2 = c1 + 46.7; //④错误，产生二义性 return 0;&#125; ​ ①和②是正确的，相信大家很容易理解。 ​ 对于③，进行加法运算时，有两种转换方案： 第一种方案是先将12.5转换为Complex类型再运算，这样得到的结果也是Complex类型，再调用类型转换函数就可以赋值给f了。 第二种方案是先将c1转换为double类型再运算，这样得到的结果也是double类型，可以直接赋值给f。 ​ 很多人会认为，既然=左边是double类型，很显然应该选择第二种方案，这样才符合“常理”。其实不然，编译器不会根据=左边的数据类型来选择转换方案，编译器只关注12.5 + c1这个表达式本身，站在这个角度考虑，上面的两种转换方案都可以，编译器不知道选择哪一种，所以会抛出二义性错误，让用户自己去解决。 ​ 当然，你也可以认为编译器不够智能，没有足够强大的上下文（周边环境）推导能力。反过来说，即使我们假设编译器会根据=左边的数据类型来选择解决方案，那仍然会存在二义性问题，下面就是一个例子：12Complex c1(24.6, 100);cout&lt;&lt;c1 + 46.7&lt;&lt;endl; ​ 该语句没有将c1 + 46.7的结果赋值给其他变量，而是直接输出，这种情况应该将c1 转换成double类型呢，还是应该将46.7转换成 Complex 类型呢？很明显都可以，因为转换构造函数和类型转换函数是平级的，没有谁的优先级更高，所以该语句也会产生二义性错误。 ​ 解决二义性问题的办法也很简单粗暴，要么只使用转换构造函数，要么只使用类型转换函数。实践证明，用户对转换构造函数的需求往往更加强烈，这样能增加编码的灵活性，例如，可以将一个字符串字面量或者一个字符数组直接赋值给string类的对象，可以将一个int、double、bool 等基本类型的数据直接赋值给 Complex类的对象。 ​ 那么，如果我们想把当前类类型转换为其它类型怎么办呢？很简单，增加一个普通的成员函数即可，例如，string类使用c_str()函数转换为C风格的字符串，complex类使用real()和imag()函数来获取复数的实部和虚部。 ​ complex是C++标准库中的复数类，c是小写的，使用时需要引入complex头文件。Complex是我们为了教学而自定义的复数类，C是大写的，Complex类尽量模拟complex类。 ​ 下面是重新编写的Complex类，该类只使用了转换构造函数，没有使用类型转换函数，取而代之的是 real() 和imag()两个普通成员函数。一个实用的 Complex 类能够进行四则运算和关系运算，需要重载 +、-、*、/、+=、-=、*=、/=、==、!=这些运算符，不过作为教学演示，这里仅仅重载了 +、+=、==、!=运算符，其它运算符的重载与此类似。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;using namespace std;//复数类class Complex&#123;public: //构造函数 Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag)&#123; &#125; //包含了转换构造函数public: //运算符重载 //以全局函数的形式重载 friend ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c); friend istream &amp; operator&gt;&gt;(istream &amp;in, Complex &amp;c); friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2); friend bool operator==(const Complex &amp;c1, const Complex &amp;c2); friend bool operator!=(const Complex &amp;c1, const Complex &amp;c2); //以成员函数的形式重载 Complex &amp; operator+=(const Complex &amp;c);public: //成员函数 double real() const&#123; return m_real; &#125; double imag() const&#123; return m_imag; &#125;private: double m_real; //实部 double m_imag; //虚部&#125;;//重载&gt;&gt;运算符ostream &amp; operator&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123; out &lt;&lt; c.m_real &lt;&lt;" + "&lt;&lt; c.m_imag &lt;&lt;"i";; return out;&#125;//重载&lt;&lt;运算符istream &amp; operator&gt;&gt;(istream &amp;in, Complex &amp;c)&#123; in &gt;&gt; c.m_real &gt;&gt; c.m_imag; return in;&#125;//重载+运算符Complex operator+(const Complex &amp;c1, const Complex &amp;c2)&#123; Complex c; c.m_real = c1.m_real + c2.m_real; c.m_imag = c1.m_imag + c2.m_imag; return c;&#125;//重载+=运算符Complex &amp; Complex::operator+=(const Complex &amp;c)&#123; this-&gt;m_real += c.m_real; this-&gt;m_imag += c.m_imag; return *this;&#125;//重载==运算符bool operator==(const Complex &amp;c1, const Complex &amp;c2)&#123; if( c1.m_real == c2.m_real &amp;&amp; c1.m_imag == c2.m_imag )&#123; return true; &#125;else&#123; return false; &#125;&#125;//重载!=运算符bool operator!=(const Complex &amp;c1, const Complex &amp;c2)&#123; if( c1.m_real != c2.m_real || c1.m_imag != c2.m_imag )&#123; return true; &#125;else&#123; return false; &#125;&#125;int main()&#123; Complex c1(12, 60); cout&lt;&lt;"c1 = "&lt;&lt;c1&lt;&lt;endl; //先调用转换构造函数将 22.8 转换为 Complex 类型，再调用重载过的 + 运算符 Complex c2 = c1 + 22.8; cout&lt;&lt;"c2 = "&lt;&lt;c2&lt;&lt;endl; //同上 Complex c3 = 8.3 + c1; cout&lt;&lt;"c3 = "&lt;&lt;c3&lt;&lt;endl; //先调用转换构造函数将 73 转换为 Complex 类型，再调用重载过的 += 运算符 Complex c4(4, 19); c4 += 73; cout&lt;&lt;"c4 = "&lt;&lt;c4&lt;&lt;endl; //调用重载过的 += 运算符 Complex c5(14.6, 26.2); c5 += c1; cout&lt;&lt;"c5 = "&lt;&lt;c5&lt;&lt;endl; //调用重载过的 == 运算符 if(c1 == c2)&#123; cout&lt;&lt;"c1 == c2"&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;"c1 != c2"&lt;&lt;endl; &#125; //先调用转换构造函数将 77 转换为 Complex 类型，再调用重载过的 != 运算符 if(c4 != 77)&#123; cout&lt;&lt;"c4 != 77"&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;"c4 == 77"&lt;&lt;endl; &#125; //将 Complex 转换为 double，没有调用类型转换函数，而是调用了 real() 这个普通的成员函数 double f = c5.real(); cout&lt;&lt;"f = "&lt;&lt;f&lt;&lt;endl; return 0;&#125; ​ 运行结果： 12345678c1 = 12 + 60ic2 = 34.8 + 60ic3 = 20.3 + 60ic4 = 77 + 19ic5 = 26.6 + 86.2ic1 != c2c4 != 77f = 26.6 类型转换的本质​ 在C/C++中，不同的数据类型之间可以相互转换：无需用户指明如何转换的称为自动类型转换（隐式类型转换），需要用户显式地指明如何转换的称为强制类型转换（显式类型转换）。 ​ 隐式类型转换利用的是编译器内置的转换规则，或者用户自定义的转换构造函数以及类型转换函数（这些都可以认为是已知的转换规则），例如从int到 double、从派生类到基类、从type *到void *、从double到 Complex等。 ​ type *是一个具体类型的指针，例如int *、double *、Student *等，它们都可以直接赋值给void *指针。而反过来是不行的，必须使用强制类型转换才能将void *转换为type *，例如，malloc() 分配内存后返回的就是一个void *指针，我们必须进行强制类型转换后才能赋值给指针变量。 ​ 当隐式转换不能完成类型转换工作时，我们就必须使用强制类型转换了。强制类型转换的语法也很简单，只需要在表达式的前面增加新类型的名称，格式为：1(new_type) expression 本质​ 我们知道，数据是放在内存中的，变量（以及指针、引用）是给这块内存起的名字，有了变量就可以找到并使用这份数据。但问题是，该如何使用呢？ ​ 诸如数字、文字、符号、图形、音频、视频等数据都是以二进制形式存储在内存中的，它们并没有本质上的区别，那么，00010000该理解为数字16呢，还是图像中某个像素的颜色呢，还是要发出某个声音呢？如果没有特别指明，我们并不知道。也就是说，内存中的数据有多种解释方式，使用之前必须要确定。这种「确定数据的解释方式」的工作就是由数据类型（Data Type）来完成的。例如int a;表明，a这份数据是整数，不能理解为像素、声音、视频等。 ​ 顾名思义，数据类型用来说明数据的类型，确定了数据的解释方式，让计算机和程序员不会产生歧义。C/C++支持多种数据类型，包括内置类型（例如int、double、bool等）和自定义类型（结构体类型和类类型）。 ​ 所谓数据类型转换，就是对数据所占用的二进制位做出重新解释。如果有必要，在重新解释的同时还会修改数据，改变它的二进制位。对于隐式类型转换，编译器可以根据已知的转换规则来决定是否需要修改数据的二进制位；而对于强制类型转换，由于没有对应的转换规则，所以能做的事情仅仅是重新解释数据的二进制位，但无法对数据的二进制位做出修正。这就是隐式类型转换和强制类型转换最根本的区别。 ​ 这里说的修改数据并不是修改原有的数据，而是修改它的副本（先将原有数据拷贝到另外一个地方再修改）。 ​ 修改数据的二进制位非常重要，它能把转换后的数据调整到正确的值，所以这种修改时常会发生，例如： ​ 1) 整数和浮点数在内存中的存储形式大相径庭，将浮点数f赋值给整数i时，不能原样拷贝f的二进制位，也不能截取部分二进制位，必须先将f的二进制位读取出来，以浮点数的形式呈现，然后直接截掉小数部分，把剩下的整数部分再转换成二进制形式，拷贝到i所在的内存中。 ​ 2) short一般占用两个字节，int一般占用四个字节，将short类型的s赋值给int类型的i时，如果仅仅是将s的二进制位拷贝给i，那么i最后的两个字节会原样保留，这样会导致赋值结束后i的值并不等于s的值，所以这样做是错误的。正确的做法是，先给s添加16个二进制位（两个字节）并全部置为0，然后再拷贝给i所在的内存。 ​ 3) 当存在多重继承时，如果把派生类指针pd赋值给基类指针pb，就必须考虑基类子对象在派生类对象中的偏移，偏移不为0时就要调整pd的值，让它加上或减去偏移量，这样赋值后才能让pb恰好指向基类子对象。 ​ 4) Complex类型占用16个字节，double类型占用8个字节，将double类型的数据赋值给Complex类型的变量（对象）时，必须调用转换构造函数，否则剩下的8个字节就不知道如何填充了。 ​ 以上这些都是隐式类型转换，它对数据的调整都是有益的，能够让程序更加安全稳健地运行。 ​ 隐式类型转换必须使用已知的转换规则，虽然灵活性受到了限制，但是由于能够对数据进行恰当地调整，所以更加安全（几乎没有风险）。强制类型转换能够在更大范围的数据类型之间进行转换，例如不同类型指针（引用）之间的转换、从 const到非const的转换、从int到指针的转换（有些编译器也允许反过来）等，这虽然增加了灵活性，但是由于不能恰当地调整数据，所以也充满了风险，程序员要小心使用。 ​ 下面的代码演示了不同类型指针之间的转换所带来的风险：1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;class Base&#123;public: Base(int a = 0, int b = 0): m_a(a), m_b(b)&#123; &#125;private: int m_a; int m_b;&#125;;int main()&#123; //风险①：破坏类的封装性 Base *pb = new Base(10, 20); int n = *((int*)pb + 1); cout&lt;&lt;n&lt;&lt;endl; //风险②：进行无意义的操作 float f = 56.2; int *pi = (int*)&amp;f; *pi = -23; cout&lt;&lt;f&lt;&lt;endl; return 0;&#125; ​ 运行结果：1220NaN NaN是“not a number”的缩写，意思是“不是一个数字”。 ​ Base类有两个private属性的成员变量，原则上讲它们不能在类的外部访问，但是当把对象指针进行强制类型转换后，就突破了这种限制，破坏了类的封装性。 ​ f是float类型的变量，用来存储浮点数，但是我们通过指针将一个整数直接放到了f所在的内存，由于整数和浮点数的存储格式不一样，所以直接放入一个整数毫无意义。 为什么会有隐式类型转换和强制类型转换之分？​ 隐式类型转换和显式类型转换最根本的区别是：隐式类型转换除了会重新解释数据的二进制位，还会利用已知的转换规则对数据进行恰当地调整；而显式类型转换只能简单粗暴地重新解释二进制位，不能对数据进行任何调整。 ​ 其实，能不能对数据进行调整是显而易见地事情，有转换规则就可以调整，没有转换规则就不能调整，当进行数据类型转换时，编译器明摆着是知道有没有转换规则的。站在这个角度考虑，强制类型转换的语法就是多此一举，编译器完全可以自行判断是否需要调整数据。例如从int *转换到float *，加不加强制类型转换的语法都不能对数据进行调整。 ​ C/C++之所以增加强制类型转换的语法，是为了提醒程序员这样做存在风险，一定要谨慎小心。说得通俗一点，你现在的类型转换存在风险，你自己一定要知道。 强制类型转换也不是万能的​ 类型转换只能发生在相关类型或者相近类型之间，两个毫不相干的类型不能相互转换，即使使用强制类型转换也不行。例如，两个没有继承关系的类不能相互转换，基类不能向派生类转换（向下转型），类类型不能向基本类型转换，指针和类类型之间不能相互转换。 ​ 下面的代码演示了不相干类型之间的转换：123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;class A&#123;&#125;;class B&#123;&#125;;class Base&#123; &#125;;class Derived: public Base&#123; &#125;;int main()&#123; A a; B b; Base obj1; Derived obj2; a = (A)b; //Error: 两个没有继承关系的类不能相互转换 int n = (int)a; //Error: 类类型不能向基本类型转换 int *p = (int*)b; //Error: 指针和类类型之间不能相互转换 obj2 = (Derived)obj1; //Error: 向下转型 obj1 = obj2; //Correct: 向上转型 return 0;&#125;]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++重载]]></title>
    <url>%2F2018%2F07%2F20%2Fc%2B%2B%E5%B0%81%E8%A3%856-%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[所谓重载，就是赋予新的含义。函数重载（Function Overloading）可以让一个函数名有多种功能，在不同情况下进行不同的操作。运算符重载（Operator Overloading）也是一个道理，同一个运算符可以有不同的功能。函数重载的目的就是为了方便的使用函数名。 函数重载实现函数重载的条件 同一个作用域 参数个数不同 参数类型不同 参数顺序不同 1234567891011121314//1. 函数重载条件namespace A&#123; void MyFunc()&#123; cout &lt;&lt; "无参数!" &lt;&lt; endl; &#125; void MyFunc(int a)&#123; cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; endl; &#125; void MyFunc(string b)&#123; cout &lt;&lt; "b: " &lt;&lt; b &lt;&lt; endl; &#125; void MyFunc(int a, string b)&#123; cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; " b:" &lt;&lt; b &lt;&lt; endl;&#125; void MyFunc(string b, int a)&#123;cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; " b:" &lt;&lt; b &lt;&lt; endl;&#125;&#125;//2.返回值不作为函数重载依据namespace B&#123; void MyFunc(string b, int a)&#123;&#125; //int MyFunc(string b, int a)&#123;&#125; //无法重载仅按返回值区分的函数&#125; ​ 注意: 函数重载和默认参数一起使用，需要额外注意二义性问题的产生。 12345678910111213void MyFunc(string b)&#123; cout &lt;&lt; "b: " &lt;&lt; b &lt;&lt; endl;&#125;//函数重载碰上默认参数void MyFunc(string b, int a = 10)&#123; cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; " b:" &lt;&lt; b &lt;&lt; endl;&#125;int main()&#123; MyFunc("hello"); //这时，两个函数都能匹配调用，产生二义性 return 0;&#125; ​ 思考：为什么函数返回值不作为重载条件呢？ 12345678910111213141516void func(int a, double b)&#123; cout &lt;&lt; "无返回值的func(int a ,double b)" &lt;&lt; endl;&#125;//返回值可以作为函数重载的条件吗？？？ 不可以int func(int a, double b)&#123; cout &lt;&lt; "有返回值的func(int a ,double b)" &lt;&lt; endl; return 1;&#125;int main()&#123; func(1, 3.14); return 0;&#125; ​ 当编译器能从上下文中确定唯一的函数的时，如int ret = func(),这个当然是没有问题的。然而，我们在编写程序过程中可以忽略他的返回值。那么这个时候,一个函数void func(int x);另一个为int func(int x); 当我们直接调用func(10),这个时候编译器就不确定调用那个函数。所以在c++中禁止使用返回值作为重载的条件。 ​ 注意: 引用const也是可以作为重载的条件。 12345678910111213141516//引用的重载版本void func3(int &amp;a) //引用必须要引合法的内存空间&#123; cout &lt;&lt; " int &amp;a" &lt;&lt; endl;&#125;void func3(const int &amp;a) //const也是可以作为重载的条件 int tmp = 10; const int &amp;a = tmp;&#123; cout &lt;&lt; "const int &amp;a" &lt;&lt; endl;&#125;int main()&#123; func3(10); return 0;&#125; 函数重载实现原理​ 编译器为了实现函数重载，也是默认为我们做了一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，比如void func(); 编译器可能会将函数名修饰成_func；当编译器碰到void func(int x),编译器可能将函数名修饰为_func_int；当编译器碰到void func(int x,char c),编译器可能会将函数名修饰为_func_int_char。 ​ 我这里使用”可能”这个字眼是因为编译器如何修饰重载的函数名称并没有一个统一的标准，所以不同的编译器可能会产生不同的内部名。 123456789void func()&#123;&#125;void func(int x)&#123;&#125;void func(int x,char y)&#123;&#125;//以上三个函数在linux下生成的编译之后的函数名为: _Z4funcv //v 代表void,无参数_Z4funci //i 代表参数为int类型_Z4funcic //i 代表第一个参数为int类型，第二个参数为char类型 运算符重载成员函数重载运算符​ 实际上，我们已经在不知不觉中使用了运算符重载。例如，+号可以对不同类型（int、float等）的数据进行加法操作；&lt;&lt;既是位移运算符，又可以配合 cout 向控制台输出数据。C++本身已经对这些运算符进行了重载。 C++也允许程序员自己重载运算符，这给我们带来了很大的便利。 ​ 下面的代码定义了一个复数类，通过运算符重载，可以用+号实现复数的加法运算： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;class complex&#123;public: complex(); complex(double real, double imag);public: //声明运算符重载 complex operator+(const complex &amp;A) const; void display() const;private: double m_real; //实部 double m_imag; //虚部&#125;;complex::complex(): m_real(0.0), m_imag(0.0)&#123; &#125;complex::complex(double real, double imag): m_real(real), m_imag(imag)&#123; &#125;//实现运算符重载complex complex::operator+(const complex &amp;A) const&#123; complex B; B.m_real = this-&gt;m_real + A.m_real; B.m_imag = this-&gt;m_imag + A.m_imag; return B;&#125;void complex::display() const&#123; cout&lt;&lt;m_real&lt;&lt;" + "&lt;&lt;m_imag&lt;&lt;"i"&lt;&lt;endl;&#125;int main()&#123; complex c1(4.3, 5.8); complex c2(2.4, 3.7); complex c3; c3 = c1 + c2; c3.display(); return 0;&#125; 运行结果：16.7 + 9.5i ​ 本例中义了一个复数类complex，m_real 表示实部，m_imag 表示虚部，第10行声明了运算符重载，第21行进行了实现（定义）。认真观察这两行代码，可以发现运算符重载的形式与函数非常类似。 ​ 运算符重载其实就是定义一个函数，在函数体内实现想要的功能，当用到该运算符时，编译器会自动调用这个函数。也就是说，运算符重载是通过函数实现的，它本质上是函数重载。 ​ 运算符重载的格式为：123返回值类型 operator 运算符名称 (形参表列)&#123; //TODO:&#125; ​ operator是关键字，专门用于定义重载运算符的函数。我们可以将operator 运算符名称这一部分看做函数名，对于上面的代码，函数名就是operator+。运算符重载函数除了函数名有特定的格式，其它地方和普通函数并没有区别。 ​ 上面的例子中，我们在complex类中重载了运算符+，该重载只对complex对象有效。当执行c3 = c1 + c2;语句时，编译器检测到+号左边（+号具有左结合性，所以先检测左边）是一个complex对象，就会调用成员函数operator+()，也就是转换为下面的形式：1c3 = c1.operator+(c2); c1 是要调用函数的对象，c2 是函数的实参。 ​ 上面的运算符重载还可以有更加简练的定义形式： 123complex complex::operator+(const complex &amp;A)const&#123; return complex(this-&gt;m_real + A.m_real, this-&gt;m_imag + A.m_imag);&#125; ​ return语句中的 1complex(this-&gt;m_real + A.m_real, this-&gt;m_imag + A.m_imag) ​ 会创建一个临时对象，这个对象没有名称，是一个匿名对象。在创建临时对象过程中调用构造函数，return语句将该临时对象作为函数返回值。 全局范围内重载运算符​ 运算符重载函数不仅可以作为类的成员函数，还可以作为全局函数。 ​ 更改上面的代码，在全局范围内重载+，实现复数的加法运算： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;class complex&#123;public: complex(); complex(double real, double imag);public: void display() const; //声明为友元函数 friend complex operator+(const complex &amp;A, const complex &amp;B);private: double m_real; double m_imag;&#125;;complex operator+(const complex &amp;A, const complex &amp;B);complex::complex(): m_real(0.0), m_imag(0.0)&#123; &#125;complex::complex(double real, double imag): m_real(real), m_imag(imag)&#123; &#125;void complex::display() const&#123; cout&lt;&lt;m_real&lt;&lt;" + "&lt;&lt;m_imag&lt;&lt;"i"&lt;&lt;endl;&#125;//在全局范围内重载+complex operator+(const complex &amp;A, const complex &amp;B)&#123; complex C; C.m_real = A.m_real + B.m_real; C.m_imag = A.m_imag + B.m_imag; return C;&#125;int main()&#123; complex c1(4.3, 5.8); complex c2(2.4, 3.7); complex c3; c3 = c1 + c2; c3.display(); return 0;&#125; ​ 运算符重载函数不是 complex类的成员函数，但是却用到了complex类的private成员变量，所以必须在complex类中将该函数声明为友元函数。 ​ 当执行c3 = c1 + c2;语句时，编译器检测到+号两边都是complex对象，就会转换为类似下面的函数调用：1c3 = operator+(c1, c2); 运算符重载注意事项​ 运算符重载是通过函数重载实现的，概念上大家都很容易理解，这节我们来说一下运算符重载的注意事项。 **(1) 并不是所有的运算符都可以重载。**能够重载的运算符包括： ​ \+ - * / % ^ &amp; | ~ ! = &lt; &gt; += -= *= /= %= ^= &amp;= |= &lt;&lt; &gt;&gt; &lt;&lt;= &gt;&gt;= == != &lt;= &gt;= &amp;&amp; || ++ -- , -&gt;* -&gt; () [] new new[] delete delete[] ​ 上述运算符中，[]是下标运算符，()是函数调用运算符。自增自减运算符的前置和后置形式都可以重载。长度运算符sizeof、条件运算符: ?、成员选择符.和域解析运算符::不能被重载。 **(2) 重载不能改变运算符的优先级和结合性。**假设上一节的` complex `类中重载了`+`号和`*`·号，并且 `c1`、`c2`、`c3`、`c4` 都是` complex `类的对象，那么下面的语句： 1c4 = c1 + c2 * c3; ​ 等价于：1c4 = c1 + ( c2 * c3 ); ​ 乘法的优先级仍然高于加法，并且它们仍然是二元运算符。 **(3) 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变。**例如`~`号右边只有一个操作数，`+`号总是出现在两个操作数之间，重载后也必须如此。 **(4) 运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的。** ​ (5) 运算符重载函数既可以作为类的成员函数，也可以作为全局函数。将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的。 ​ 例如，上节的 complex 类中重载了加法运算符：1complex operator+(const complex &amp; A) const; ​ 当执行：1c3 = c1 + c2; ​ 会被转换为：1c3 = c1.operator+(c2); ​ 通过this指针隐式的访问 c1 的成员变量。 ​ 将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要一个参数，而且其中必须有一个参数是对象，好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质。 例如，下面这样是不对的： 123int operator + (int a,int b)&#123; return (a-b);&#125; ​ +号原来是对两个数相加，现在企图通过重载使它的作用改为两个数相减， 如果允许这样重载的话，那么表达式4+3的结果是7还是1呢？显然，这是绝对禁止的。 ​ 如果有两个参数，这两个参数可以都是对象，也可以一个是对象，一个是C ++内置类型的数据，例如： 123complex operator+(int a, complex &amp;c)&#123; return complex(a+c.real, c.imag);&#125; ​ 它的作用是使一个整数和一个复数相加。另外，将运算符重载函数作为全局函数时，一般都需要在类中将该函数声明为友元函数。原因很简单，该函数大部分情况下都需要使用类的private成员。 ​ 上节的最后一个例子中，我们在全局范围内重载了+号，并在complex类中将运算符重载函数声明为友元函数，因为该函数使用到了complex类的 m_real 和 m_imag 两个成员变量，它们都是private属性的，默认不能在类的外部访问。 ​ (6) 箭头运算符-&gt;、下标运算符[ ]、函数调用运算符( )、赋值运算符=只能以成员函数的形式重载。 重载数学运算符​ 四则运算符（+、-、*、/、+=、-=、*=、/=）和关系运算符（&gt;、&lt;、&lt;=、&gt;=、==、!=）都是数学运算符，它们在实际开发中非常常见，被重载的几率也很高，并且有着相似的重载格式。本节以复数类Complex为例对它们进行重载，重在演示运算符重载的语法以及规范。 ​ 复数能够进行完整的四则运算，但不能进行完整的关系运算：我们只能判断两个复数是否相等，但不能比较它们的大小，所以不能对&gt;、&lt;、&lt;=、&gt;=进行重载。下面是具体的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;//复数类class Complex&#123;public: //构造函数 Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag)&#123; &#125;public: //运算符重载 //以全局函数的形式重载 friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2); friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2); friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2); friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2); friend bool operator==(const Complex &amp;c1, const Complex &amp;c2); friend bool operator!=(const Complex &amp;c1, const Complex &amp;c2); //以成员函数的形式重载 Complex &amp; operator+=(const Complex &amp;c); Complex &amp; operator-=(const Complex &amp;c); Complex &amp; operator*=(const Complex &amp;c); Complex &amp; operator/=(const Complex &amp;c);public: //成员函数 double real() const&#123; return m_real; &#125; double imag() const&#123; return m_imag; &#125;private: double m_real; //实部 double m_imag; //虚部&#125;;//重载+运算符Complex operator+(const Complex &amp;c1, const Complex &amp;c2)&#123; Complex c; c.m_real = c1.m_real + c2.m_real; c.m_imag = c1.m_imag + c2.m_imag; return c;&#125;//重载-运算符Complex operator-(const Complex &amp;c1, const Complex &amp;c2)&#123; Complex c; c.m_real = c1.m_real - c2.m_real; c.m_imag = c1.m_imag - c2.m_imag; return c;&#125;//重载*运算符 (a+bi) * (c+di) = (ac-bd) + (bc+ad)iComplex operator*(const Complex &amp;c1, const Complex &amp;c2)&#123; Complex c; c.m_real = c1.m_real * c2.m_real - c1.m_imag * c2.m_imag; c.m_imag = c1.m_imag * c2.m_real + c1.m_real * c2.m_imag; return c;&#125;//重载/运算符 (a+bi) / (c+di) = [(ac+bd) / (c²+d²)] + [(bc-ad) / (c²+d²)]iComplex operator/(const Complex &amp;c1, const Complex &amp;c2)&#123; Complex c; c.m_real = (c1.m_real*c2.m_real + c1.m_imag*c2.m_imag) / (pow(c2.m_real, 2) + pow(c2.m_imag, 2)); c.m_imag = (c1.m_imag*c2.m_real - c1.m_real*c2.m_imag) / (pow(c2.m_real, 2) + pow(c2.m_imag, 2)); return c;&#125;//重载==运算符bool operator==(const Complex &amp;c1, const Complex &amp;c2)&#123; if( c1.m_real == c2.m_real &amp;&amp; c1.m_imag == c2.m_imag )&#123; return true; &#125;else&#123; return false; &#125;&#125;//重载!=运算符bool operator!=(const Complex &amp;c1, const Complex &amp;c2)&#123; if( c1.m_real != c2.m_real || c1.m_imag != c2.m_imag )&#123; return true; &#125;else&#123; return false; &#125;&#125;//重载+=运算符Complex &amp; Complex::operator+=(const Complex &amp;c)&#123; this-&gt;m_real += c.m_real; this-&gt;m_imag += c.m_imag; return *this;&#125;//重载-=运算符Complex &amp; Complex::operator-=(const Complex &amp;c)&#123; this-&gt;m_real -= c.m_real; this-&gt;m_imag -= c.m_imag; return *this;&#125;//重载*=运算符Complex &amp; Complex::operator*=(const Complex &amp;c)&#123; this-&gt;m_real = this-&gt;m_real * c.m_real - this-&gt;m_imag * c.m_imag; this-&gt;m_imag = this-&gt;m_imag * c.m_real + this-&gt;m_real * c.m_imag; return *this;&#125;//重载/=运算符Complex &amp; Complex::operator/=(const Complex &amp;c)&#123; this-&gt;m_real = (this-&gt;m_real*c.m_real + this-&gt;m_imag*c.m_imag) / (pow(c.m_real, 2) + pow(c.m_imag, 2)); this-&gt;m_imag = (this-&gt;m_imag*c.m_real - this-&gt;m_real*c.m_imag) / (pow(c.m_real, 2) + pow(c.m_imag, 2)); return *this;&#125;int main()&#123; Complex c1(25, 35); Complex c2(10, 20); Complex c3(1, 2); Complex c4(4, 9); Complex c5(34, 6); Complex c6(80, 90); Complex c7 = c1 + c2; Complex c8 = c1 - c2; Complex c9 = c1 * c2; Complex c10 = c1 / c2; cout&lt;&lt;"c7 = "&lt;&lt;c7.real()&lt;&lt;" + "&lt;&lt;c7.imag()&lt;&lt;"i"&lt;&lt;endl; cout&lt;&lt;"c8 = "&lt;&lt;c8.real()&lt;&lt;" + "&lt;&lt;c8.imag()&lt;&lt;"i"&lt;&lt;endl; cout&lt;&lt;"c9 = "&lt;&lt;c9.real()&lt;&lt;" + "&lt;&lt;c9.imag()&lt;&lt;"i"&lt;&lt;endl; cout&lt;&lt;"c10 = "&lt;&lt;c10.real()&lt;&lt;" + "&lt;&lt;c10.imag()&lt;&lt;"i"&lt;&lt;endl; c3 += c1; c4 -= c2; c5 *= c2; c6 /= c2; cout&lt;&lt;"c3 = "&lt;&lt;c3.real()&lt;&lt;" + "&lt;&lt;c3.imag()&lt;&lt;"i"&lt;&lt;endl; cout&lt;&lt;"c4 = "&lt;&lt;c4.real()&lt;&lt;" + "&lt;&lt;c4.imag()&lt;&lt;"i"&lt;&lt;endl; cout&lt;&lt;"c5 = "&lt;&lt;c5.real()&lt;&lt;" + "&lt;&lt;c5.imag()&lt;&lt;"i"&lt;&lt;endl; cout&lt;&lt;"c6 = "&lt;&lt;c6.real()&lt;&lt;" + "&lt;&lt;c6.imag()&lt;&lt;"i"&lt;&lt;endl; if(c1 == c2)&#123; cout&lt;&lt;"c1 == c2"&lt;&lt;endl; &#125; if(c1 != c2)&#123; cout&lt;&lt;"c1 != c2"&lt;&lt;endl; &#125; return 0;&#125; 运行结果：123456789c7 = 35 + 55ic8 = 15 + 15ic9 = -450 + 850ic10 = 1.9 + -0.3ic3 = 26 + 37ic4 = -6 + -11ic5 = 220 + 4460ic6 = 5.2 + 1.592ic1 != c2 ​ 需要注意的是，我们以全局函数的形式重载了+、-、*、/、==、!=，以成员函数的形式重载了 +=、-=、*=、/=，而且应该坚持这样做，不能一股脑都写作成员函数或者全局函数，具体原因我们将在下节讲解。 简单地了解转换构造函数​ 在上节的例子中，我们以全局函数的形式重载了+、-、*、/、==、!=，以成员函数的形式重载了 +=、-=、*=、/=，而没有一股脑都写成全局函数或者成员函数，这样做是有原因的，这节我们就来分析一下。 ​ 在分析以前，我们先来了解一个概念，叫做「转换构造函数」。 请大家先看下面的例子： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;//复数类class Complex&#123;public: Complex(): m_real(0.0), m_imag(0.0)&#123; &#125; Complex(double real, double imag): m_real(real), m_imag(imag)&#123; &#125; Complex(double real): m_real(real), m_imag(0.0)&#123; &#125; //转换构造函数public: friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2);public: double real() const&#123; return m_real; &#125; double imag() const&#123; return m_imag; &#125;private: double m_real; //实部 double m_imag; //虚部&#125;;//重载+运算符Complex operator+(const Complex &amp;c1, const Complex &amp;c2)&#123; Complex c; c.m_real = c1.m_real + c2.m_real; c.m_imag = c1.m_imag + c2.m_imag; return c;&#125;int main()&#123; Complex c1(25, 35); Complex c2 = c1 + 15.6; Complex c3 = 28.23 + c1; cout&lt;&lt;c2.real()&lt;&lt;" + "&lt;&lt;c2.imag()&lt;&lt;"i"&lt;&lt;endl; cout&lt;&lt;c3.real()&lt;&lt;" + "&lt;&lt;c3.imag()&lt;&lt;"i"&lt;&lt;endl; return 0;&#125; 运行结果： 1240.6 + 35i53.23 + 35i ​ 请读者留意第30、31行代码，它说明Complex类型可以和 double类型相加，这很奇怪，因为我们并没有对针对这两个类型重载+，这究竟是怎么做到的呢？ ​ 其实，编译器在检测到Complex和double（小数默认为double类型）相加时，会先尝试将double转换为Complex，或者反过来将Complex转换为double（只有类型相同的数据才能进行+运算），如果都转换失败，或者都转换成功（产生了二义性），才报错。本例中，编译器会先通过构造函数Complex(double real);将double转换为Complex，再调用重载过的+进行计算，整个过程类似于下面的形式： ​ 也就是说，小数被转换成了匿名的Complex对象。在这个转换过程中，构造函数Complex(double real);起到了至关重要的作用，如果没有它，转换就会失败，Complex也不能和double相加。 ​ Complex(double real);在作为普通构造函数的同时，还能将 double 类型转换为 Complex 类型，集合了“构造函数”和“类型转换”的功能，所以被称为「转换构造函数」。换句话说，转换构造函数用来将其它类型（可以是 bool、int、double 等基本类型，也可以是数组、指针、结构体、类等构造类型）转换为当前类类型。 为什么要以全局函数的形式重载 +​ 上面的例子中，我们定义的operator+是一个全局函数（一个友元函数），而不是成员函数，这样做是为了保证+运算符的操作数能够被对称的处理；换句话说，小数（double类型）在+左边和右边都是正确的。第30行代码中，15.6在+的右边，第31行代码中，28.23在+的左边，它们都能够被顺利地转换为 Complex类型，所以不会出错。 ​ 如果将operator+定义为成员函数，根据“+ 运算符具有左结合性”这条原则，Complex c2 = c1 + 15.6;会被转换为下面的形式：1Complex c2 = c1.operator+(Complex(15.6)); ​ 这就是通过对象调用成员函数，是正确的。而对于Complex c3 = 28.23 + c1;，编译器会尝试转换为不同的形式：1Complex c3 = (28.23).operator+(c1); ​ 很显然这是错误的，因为double类型并没有以成员函数的形式重载 +。也就是说，以成员函数的形式重载+，只能计算c1 + 15.6，不能计算28.23 + c1，这是不对称的 ​ 有读者可能会问，编译器明明可以把28.23先转换成Complex类型再相加呀，也就是下面的形式：1Complex c3 = Complex(28.23).operator+(c1); ​ 为什么就是不转换呢？没错，编译器不会转换，原因在于，C++只会对成员函数的参数进行类型转换，而不会对调用成员函数的对象进行类型转换。以下面的语句为例：1obj.func(params); ​ 编译器不会尝试对obj进行任何类型转换，它有 func() 成员函数就调用，没有就报错。而对于实参 params，编译器会“拼命地”将它转换为形参的类型。 为什么要以成员函数的形式重载+=​ 我们首先要明白，运算符重载的初衷是给类添加新的功能，方便类的运算，它作为类的成员函数是理所应当的，是首选的。 ​ 不过，类的成员函数不能对称地处理数据，程序员必须在（参与运算的）所有类型的内部都重载当前的运算符。以上面的情况为例，我们必须在Complex和double内部都重载+运算符，这样做不但会增加运算符重载的数目，还要在许多地方修改代码，这显然不是我们所希望的，所以C++ 进行了折中，允许以全局函数（友元函数）的形式重载运算符。 ​ C++创始人 Bjarne Stroustrup 也曾考虑过为内部类型（bool、int、double 等）定义额外运算符的问题，但后来还是放弃了这种想法，因为 Bjarne Stroustrup 不希望改变现有规则：任何类型（无论是内部类型还是用户自定义类型）都不能在其定义完成以后再增加额外的操作。这里还有另外的一个原因，C内部类型之间的转换已经够肮脏了，决不能再向里面添乱。而通过成员函数为已存在的类型提供混合运算的方式，从本质上看，比我们所采用的全局函数（友元函数）加转换构造函数的方式还要肮脏许多。 ​ 采用全局函数能使我们定义这样的运算符，它们的参数具有逻辑的对称性。与此相对应的，把运算符定义为成员函数能够保证在调用时对第一个（最左的）运算对象不出现类型转换，也就是上面提到的「C++不会对调用成员函数的对象进行类型转换」。 ​ 总起来说，有一部分运算符重载既可以是成员函数也可以是全局函数，虽然没有一个必然的、不可抗拒的理由选择成员函数，但我们应该优先考虑成员函数，这样更符合运算符重载的初衷；另外有一部分运算符重载必须是全局函数，这样能保证参数的对称性；除了C++规定的几个特定的运算符外，暂时还没有发现必须以成员函数的形式重载的运算符。 C++规定，箭头运算符-&gt;、下标运算符[ ]、函数调用运算符( )、赋值运算符=只能以成员函数的形式重载。 自增自减(++/--)运算符重载​ 重载的++和--运算符有点让人不知所措，因为我们总是希望能根据它们出现在所作用对象的前面还是后面来调用不同的函数。解决办法很简单，例如当编译器看到++a(前置++)，它就调用operator++(a),当编译器看到a++（后置++），它就会去调用operator++(a,int). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Complex&#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; os,Complex&amp; complex)&#123; os &lt;&lt; "A:" &lt;&lt; complex.mA &lt;&lt; " B:" &lt;&lt; complex.mB &lt;&lt; endl; return os; &#125;public: Complex()&#123; mA = 0; mB = 0; &#125; //重载前置++ Complex&amp; operator++()&#123; mA++; mB++; return *this; &#125; //重载后置++ Complex operator++(int)&#123; Complex temp; temp.mA = this-&gt;mA; temp.mB = this-&gt;mB; mA++; mB++; return temp; &#125; //前置-- Complex&amp; operator--()&#123; mA--; mB--; return *this; &#125; //后置-- Complex operator--(int)&#123; Complex temp; temp.mA = mA; temp.mB = mB; mA--; mB--; return temp; &#125; void ShowComplex()&#123; cout &lt;&lt; "A:" &lt;&lt; mA &lt;&lt; " B:" &lt;&lt; mB &lt;&lt; endl; &#125;private: int mA; int mB;&#125;;void test()&#123; Complex complex; complex++; cout &lt;&lt; complex; ++complex; cout &lt;&lt; complex; Complex ret = complex++; cout &lt;&lt; ret; cout &lt;&lt; complex; cout &lt;&lt; "------" &lt;&lt; endl; ret--; --ret; cout &lt;&lt; "ret:" &lt;&lt; ret; complex--; --complex; cout &lt;&lt; "complex:" &lt;&lt; complex;&#125; ​ 优先使用++和--的标准形式，优先调用前置++。 ​ 如果定义了++c，也要定义c++，递增操作符比较麻烦，因为他们都有前缀和后缀形式，而两种语义略有不同。重载operator++和operator--时应该模仿他们对应的内置操作符。 ​ 对于++和--而言，后置形式是先返回，然后对象++或者--，返回的是对象的原值。前置形式，对象先++或--，返回当前对象，返回的是新对象。其标准形式为: ​ 调用代码时候，要优先使用前缀形式，除非确实需要后缀形式返回的原值，前缀和后缀形式语义上是等价的，输入工作量也相当，只是效率经常会略高一些，由于前缀形式少创建了一个临时对象。 指针运算符(*、-&gt;)重载1234567891011121314151617181920212223242526272829303132333435363738394041class Person&#123;public: Person(int param)&#123; this-&gt;mParam = param; &#125; void PrintPerson()&#123; cout &lt;&lt; "Param:" &lt;&lt; mParam &lt;&lt; endl; &#125;private: int mParam;&#125;;class SmartPointer&#123;public: SmartPointer(Person* person)&#123; this-&gt;pPerson = person; &#125; //重载指针的-&gt;、*操作符 Person* operator-&gt;()&#123; return pPerson; &#125; Person&amp; operator*()&#123; return *pPerson; &#125; ~SmartPointer()&#123; if (pPerson != NULL)&#123; delete pPerson; &#125; &#125;public: Person* pPerson;&#125;;void test01()&#123; //Person* person = new Person(100); //如果忘记释放，那么就会造成内存泄漏 SmartPointer pointer(new Person(100)); pointer-&gt;PrintPerson();&#125; 赋值(=)运算符重载​ 赋值符常常初学者的混淆。这是毫无疑问的，因为’=’在编程中是最基本的运算符，可以进行赋值操作，也能引起拷贝构造函数的调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293class Person&#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; os,const Person&amp; person)&#123; os &lt;&lt; "ID:" &lt;&lt; person.mID &lt;&lt; " Age:" &lt;&lt; person.mAge &lt;&lt; endl; return os; &#125;public: Person(int id,int age)&#123; this-&gt;mID = id; this-&gt;mAge = age; &#125; //重载赋值运算符 Person&amp; operator=(const Person&amp; person)&#123; this-&gt;mID = person.mID; this-&gt;mAge = person.mAge; return *this; &#125;private: int mID; int mAge;&#125;;//1. =号混淆的地方void test01()&#123; Person person1(10, 20); Person person2 = person1; //调用拷贝构造 //如果一个对象还没有被创建，则必须初始化，也就是调用构造函数 //上述例子由于person2还没有初始化，所以会调用构造函数 //由于person2是从已有的person1来创建的，所以只有一个选择 //就是调用拷贝构造函数 person2 = person1; //调用operator=函数 //由于person2已经创建，不需要再调用构造函数，这时候调用的是重载的赋值运算符&#125;//2. 赋值重载案例void test02()&#123; Person person1(20, 20); Person person2(30, 30); cout &lt;&lt; "person1:" &lt;&lt; person1; cout &lt;&lt; "person2:" &lt;&lt; person2; person2 = person1; cout &lt;&lt; "person2:" &lt;&lt; person2;&#125;//常见错误，当准备给两个相同对象赋值时，应该首先检查一下这个对象是否对自身赋值了//对于本例来讲，无论如何执行这些赋值运算都是无害的，但如果对类的实现进行修改，那么将会出现差异；//3. 类中指针class Person2&#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Person2&amp; person)&#123; os &lt;&lt; "Name:" &lt;&lt; person.pName &lt;&lt; " ID:" &lt;&lt; person.mID &lt;&lt; " Age:" &lt;&lt; person.mAge &lt;&lt; endl; return os; &#125;public: Person2(char* name,int id, int age)&#123; this-&gt;pName = new char[strlen(name) + 1]; strcpy(this-&gt;pName, name); this-&gt;mID = id; this-&gt;mAge = age; &#125;#if 1 //重载赋值运算符 Person2&amp; operator=(const Person2&amp; person)&#123; //注意:由于当前对象已经创建完毕，那么就有可能pName指向堆内存 //这个时候如果直接赋值，会导致内存没有及时释放 if (this-&gt;pName != NULL)&#123; delete[] this-&gt;pName; &#125; this-&gt;pName = new char[strlen(person.pName) + 1]; strcpy(this-&gt;pName,person.pName); this-&gt;mID = person.mID; this-&gt;mAge = person.mAge; return *this; &#125;#endif //析构函数 ~Person2()&#123; if (this-&gt;pName != NULL)&#123; delete[] this-&gt;pName; &#125; &#125;private: char* pName; int mID; int mAge;&#125;;void test03()&#123; Person2 person1("John",20, 20); Person2 person2("Edward",30, 30); cout &lt;&lt; "person1:" &lt;&lt; person1; cout &lt;&lt; "person2:" &lt;&lt; person2; person2 = person1; cout &lt;&lt; "person2:" &lt;&lt; person2;&#125; ​ 如果没有重载赋值运算符，编译器会自动创建默认的赋值运算符重载函数。行为类似默认拷贝构造，进行简单值拷贝。 等于和不等于(==、!=)运算符重载123456789101112131415161718192021222324252627282930313233343536373839404142class Complex&#123;public: Complex(char* name,int id,int age)&#123; this-&gt;pName = new char[strlen(name) + 1]; strcpy(this-&gt;pName, name); this-&gt;mID = id; this-&gt;mAge = age; &#125; //重载==号操作符 bool operator==(const Complex&amp; complex)&#123; if (strcmp(this-&gt;pName,complex.pName) == 0 &amp;&amp; this-&gt;mID == complex.mID &amp;&amp; this-&gt;mAge == complex.mAge)&#123; return true; &#125; return false; &#125; //重载!=操作符 bool operator!=(const Complex&amp; complex)&#123; if (strcmp(this-&gt;pName, complex.pName) != 0 || this-&gt;mID != complex.mID || this-&gt;mAge != complex.mAge)&#123; return true; &#125; return false; &#125; ~Complex()&#123; if (this-&gt;pName != NULL)&#123; delete[] this-&gt;pName; &#125; &#125;private: char* pName; int mID; int mAge;&#125;;void test()&#123; Complex complex1("aaa", 10, 20); Complex complex2("bbb", 10, 20); if (complex1 == complex2)&#123; cout &lt;&lt; "相等!" &lt;&lt; endl; &#125; if (complex1 != complex2)&#123; cout &lt;&lt; "不相等!" &lt;&lt; endl; &#125;&#125; 符号重载总结 =, [], () 和 -&gt; 操作符只能通过成员函数进行重载 &lt;&lt; 和 &gt;&gt;只能通过全局函数配合友元函数进行重载 不要重载 &amp;&amp; 和 || 操作符，因为无法实现短路规则 常规建议]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++构造和析构]]></title>
    <url>%2F2018%2F07%2F15%2Fc%2B%2B%E5%B0%81%E8%A3%855-%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%2F</url>
    <content type="text"><![CDATA[对象的初始化和清理也是两个非常重要的安全问题，一个对象或者变量没有初始时，对其使用后果是未知，同样的使用完一个变量，没有及时清理，也会造成一定的安全问题。c++为了给我们提供这种问题的解决方案，构造函数和析构函数，这两个函数将会被编译器自动调用，完成对象初始化和对象清理工作。 ​ 无论你是否喜欢，对象的初始化和清理工作是编译器强制我们要做的事情，即使你不提供初始化操作和清理操作，编译器也会给你增加默认的操作，只是这个默认初始化操作不会做任何事，所以编写类就应该顺便提供初始化函数。 对象的构造和析构构造函数和析构函数的定义​ 构造函数主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 ​ 析构函数主要用于对象销毁前系统自动调用，执行一些清理工作 构造函数语法： 构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数。 ClassName(){} 析构函数语法： 析构函数函数名是在类名前面加”~”组成,没有返回值，不能有void,不能有参数，不能重载。 ~ClassName(){} 1234567891011121314151617181920212223242526class Person&#123;public: Person()&#123; cout &lt;&lt; "构造函数调用!" &lt;&lt; endl; pName = (char*)malloc(sizeof("John")); strcpy(pName, "John"); mTall = 150; mMoney = 100; &#125; ~Person()&#123; cout &lt;&lt; "析构函数调用!" &lt;&lt; endl; if (pName != NULL)&#123; free(pName); pName = NULL; &#125; &#125;public: char* pName; int mTall; int mMoney;&#125;;void test()&#123; Person person; cout &lt;&lt; person.pName &lt;&lt; person.mTall &lt;&lt; person.mMoney &lt;&lt; endl;&#125; 构造函数的分类及调用 按参数类型：分为无参构造函数和有参构造函数 按类型分类：普通构造函数和拷贝构造函数(复制构造函数) 普通构造函数123456789101112131415161718192021222324252627282930313233343536373839class Person&#123;public: //无参构造函数 Person()&#123; cout &lt;&lt; "no param constructor!" &lt;&lt; endl; mAge = 0; &#125; //有参构造函数 Person(int age)&#123; cout &lt;&lt; "1 param constructor!" &lt;&lt; endl; mAge = age; &#125; //打印年龄 void PrintPerson()&#123; cout &lt;&lt; "Age:" &lt;&lt; mAge &lt;&lt; endl; &#125;private: int mAge;&#125;;//1. 无参构造调用方式void test01()&#123; //调用无参构造函数 Person person1; person1.PrintPerson(); //调用无参构造函数 Person *person2 = new Person(); person2-&gt;PrintPerson(); //调用有参构造函数 Person person3(10); person3.PrintPerson(); //无参构造函数错误调用方式 //Person person2(); //person2.PrintPerson();&#125; 拷贝构造函数拷贝构造函数定义​ 例如，将Word文档拷贝到U盘去复印店打印，将D盘的图片拷贝到桌面以方便浏览，将重要的文件上传到百度网盘以防止丢失等，都是「创建一份新数据」的意思。 ​ 在C++中，拷贝并没有脱离它本来的含义，只是将这个含义进行了“特化”，是指用已经存在的对象创建出一个新的对象。从本质上讲，对象也是一份数据，因为它会占用内存。 ​ 严格来说，对象的创建包括两个阶段，首先要分配内存空间，然后再进行初始化： 分配内存很好理解，就是在堆区、栈区或者全局数据区留出足够多的字节。这个时候的内存还比较“原始”，没有被“教化”，它所包含的数据一般是零值或者随机值，没有实际的意义。 初始化就是首次对内存赋值，让它的数据有意义。注意是首次赋值，再次赋值不叫初始化。初始化的时候还可以为对象分配其他的资源（打开文件、连接网络、动态分配内存等），或者提前进行一些计算（根据价格和数量计算出总价、根据长度和宽度计算出矩形的面积等）等。说白了，初始化就是调用构造函数。 ​ 很明显，这里所说的拷贝是在初始化阶段进行的，也就是用其它对象的数据来初始化新对象的内存。 ​ 那么，如何用拷贝的方式来初始化一个对象呢？其实这样的例子比比皆是，string类就是一个典型的例子。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void func(string str)&#123; cout&lt;&lt;str&lt;&lt;endl;&#125;int main()&#123; string s1 = "http://c.biancheng.net"; string s2(s1); string s3 = s1; string s4 = s1 + " " + s2; func(s1); cout&lt;&lt;s1&lt;&lt;endl&lt;&lt;s2&lt;&lt;endl&lt;&lt;s3&lt;&lt;endl&lt;&lt;s4&lt;&lt;endl; return 0;&#125; 运行结果：12345http://c.biancheng.nethttp://c.biancheng.nethttp://c.biancheng.nethttp://c.biancheng.nethttp://c.biancheng.net http://c.biancheng.net ​ s1、s2、s3、s4 以及 func() 的形参str，都是使用拷贝的方式来初始化的。 对于s1，表面上看起来是将一个字符串直接赋值给了s1，实际上在内部进行了类型转换，将const char *类型转换为string类型后才赋值的，s4也是类似的道理。 ​ 对于s1、s2、s3、s4，都是将其它对象的数据拷贝给当前对象，以完成当前对象的初始化。 ​ 对于func() 的形参 str，其实在定义时就为它分配了内存，但是此时并没有初始化，只有等到调用func() 时，才会将其它对象的数据拷贝给 str以完成初始化。 ​ 当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是拷贝构造函数（Copy Constructor）。 ​ 下面的例子演示了拷贝构造函数的定义和使用： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Student&#123;public: Student(string name = "", int age = 0, float score = 0.0f); //普通构造函数 Student(const Student &amp;stu); //拷贝构造函数（声明）public: void display();private: string m_name; int m_age; float m_score;&#125;;Student::Student(string name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;//拷贝构造函数（定义）Student::Student(const Student &amp;stu)&#123; this-&gt;m_name = stu.m_name; this-&gt;m_age = stu.m_age; this-&gt;m_score = stu.m_score; cout&lt;&lt;"Copy constructor was called."&lt;&lt;endl;&#125;void Student::display()&#123; cout&lt;&lt;m_name&lt;&lt;"的年龄是"&lt;&lt;m_age&lt;&lt;"，成绩是"&lt;&lt;m_score&lt;&lt;endl;&#125;int main()&#123; Student stu1("小明", 16, 90.5); Student stu2 = stu1; //调用拷贝构造函数 Student stu3(stu1); //调用拷贝构造函数 stu1.display(); stu2.display(); stu3.display(); return 0;&#125; ​ 运行结果：12345Copy constructor was called.Copy constructor was called.小明的年龄是16，成绩是90.5小明的年龄是16，成绩是90.5小明的年龄是16，成绩是90.5 ​ 第8行是拷贝构造函数的声明，第20行是拷贝构造函数的定义。拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 const引用。 1) 为什么必须是当前类的引用呢？​ 如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。 ​ 只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是C++语法的要求。 2) 为什么是const引用呢？​ 拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。 ​ 另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为const类型不能转换为非 const类型，这就意味着，不能使用 const对象来初始化当前对象了。 ​ 以上面的 Student 类为例，将const 去掉后，拷贝构造函数的原型变为：1Student::Student(Student &amp;stu); ​ 此时，下面的代码就会发生错误： 123const Student stu1("小明", 16, 90.5);Student stu2 = stu1;Student stu3(stu1); ​ stu1 是 const 类型，在初始化 stu2、stu3 时，编译器希望调用Student::Student(const Student &amp;stu)，但是这个函数却不存在，又不能将 const Student 类型转换为 Student 类型去调用Student::Student(Student &amp;stu)，所以最终调用失败了。 ​ 当然，你也可以再添加一个参数为 const 引用的拷贝构造函数，这样就不会出错了。换句话说，一个类可以同时存在两个拷贝构造函数，一个函数的参数为 const引用，另一个函数的参数为非 const 引用。 默认拷贝构造函数​ 在前面的教程中，我们还没有讲解拷贝构造函数，但是却已经在使用拷贝的方式创建对象了，并且也没有引发什么错误。这是因为，如果程序员没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数。这个默认的拷贝构造函数很简单，就是使用“老对象”的成员变量对“新对象”的成员变量进行一一赋值，和上面 Student类的拷贝构造函数非常类似。 ​ 对于简单的类，默认拷贝构造函数一般是够用的，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认拷贝构造函数就不能拷贝这些资源，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据 拷贝构造函数的调用时机​ 当以拷贝的方式初始化对象时会调用拷贝构造函数。这里有两个关键点，分别是「以拷贝的方式」和「初始化对象」。 初始化对象​ 初始化对象是指，为对象分配内存后第一次向内存中填充数据，这个过程会调用构造函数。对象被创建后必须立即被初始化，换句话说，只要创建对象，就会调用构造函数。 初始化和赋值的区别​ 初始化和赋值都是将数据写入内存中，并且从表面上看起来，初始化在很多时候都是以赋值的方式来实现的，所以很容易混淆。请看下面的例子： 123456int a = 100; //以赋值的方式初始化a = 200; //赋值a = 300; //赋值int b; //默认初始化b = 29; //赋值b = 39; //赋值 ​ 在定义的同时进行赋值叫做初始化（Initialization），定义完成以后再赋值（不管在定义的时候有没有赋值）就叫做赋值（Assignment）。初始化只能有一次，赋值可以有多次。 ​ 对于基本类型的数据，我们很少会区分「初始化」和「赋值」这两个概念，即使将它们混淆，也不会出现什么错误。但是对于类，它们的区别就非常重要了，因为初始化对象时会调用构造函数（以拷贝的方式初始化时会调用拷贝构造函数），而赋值时会调用重载过的赋值运算符。请看下面的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Student&#123;public: Student(string name = "", int age = 0, float score = 0.0f); //普通构造函数 Student(const Student &amp;stu); //拷贝构造函数public: Student &amp; operator=(const Student &amp;stu); //重载=运算符 void display();private: string m_name; int m_age; float m_score;&#125;;Student::Student(string name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;//拷贝构造函数Student::Student(const Student &amp;stu)&#123; this-&gt;m_name = stu.m_name; this-&gt;m_age = stu.m_age; this-&gt;m_score = stu.m_score; cout&lt;&lt;"Copy constructor was called."&lt;&lt;endl;&#125;//重载=运算符Student &amp; Student::operator=(const Student &amp;stu)&#123; this-&gt;m_name = stu.m_name; this-&gt;m_age = stu.m_age; this-&gt;m_score = stu.m_score; cout&lt;&lt;"operator=() was called."&lt;&lt;endl; return *this;&#125;void Student::display()&#123; cout&lt;&lt;m_name&lt;&lt;"的年龄是"&lt;&lt;m_age&lt;&lt;"，成绩是"&lt;&lt;m_score&lt;&lt;endl;&#125;int main()&#123; //stu1、stu2、stu3都会调用普通构造函数Student(string name, int age, float score) Student stu1("小明", 16, 90.5); Student stu2("王城", 17, 89.0); Student stu3("陈晗", 18, 98.0); Student stu4 = stu1; //调用拷贝构造函数Student(const Student &amp;stu) stu4 = stu2; //调用operator=() stu4 = stu3; //调用operator=() Student stu5; //调用普通构造函数Student() stu5 = stu1; //调用operator=() stu5 = stu2; //调用operator=() return 0;&#125; 运行结果： 12345Copy constructor was called.operator=() was called.operator=() was called.operator=() was called.operator=() was called. 以拷贝的方式初始化对象​ 初始化对象时会调用构造函数，不同的初始化方式会调用不同的构造函数： 如果用传递进来的实参初始化对象，那么会调用普通的构造函数，我们不妨将此称为普通初始化； 如果用其它对象（现有对象）的数据来初始化对象，那么会调用拷贝构造函数，这就是以拷贝的方式初始化。 在实际编程中，具体有哪些情况是以拷贝的方式来初始化对象呢？ (1) 将其它对象作为实参​ 以上面的Student类为例，我们可以这样来创建一个新的对象： 12Student stu1("小明", 16, 90.5); //普通初始化Student stu2(stu1); //以拷贝的方式初始化 ​ 即使我们不在类中显式地定义拷贝构造函数，这种初始化方式也是有效的，因为编译器会生成默认的拷贝构造函数。 (2) 在创建对象的同时赋值​ 接着使用 Student 类，请看下面的例子： 12Student stu1("小明", 16, 90.5); //普通初始化Student stu2 = stu1; //以拷贝的方式初始化 ​ 这是最常见的一种以拷贝的方式初始化对象的情况，非常容易理解，我们也已经多次使用。 (3) 函数的形参为类类型​ 如果函数的形参为类类型（也就是一个对象），那么调用函数时要将另外一个对象作为实参传递进来赋值给形参，这也是以拷贝的方式初始化形参对象。请看下面的代码： 123456void func(Student s)&#123; //TODO:&#125;Student stu("小明", 16, 90.5); //普通初始化func(stu); //以拷贝的方式初始化 `func() `函数有一个` Student `类型的形参` s`，将实参 `stu `传递给形参` s `就是以拷贝的方式初始化的过程。 ​ 函数是一段可以重复使用的代码，只有等到真正调用函数时才会为局部数据（形参和局部变量）在栈上分配内存。对于上面的func()，虽然它的形参s是一个对象，但在定义函数时s对象并没有被创建，只有等到调用函数时才会真正地创建s对象，并在栈上为它分配内存。而创建s对象，就是以拷贝的方式进行的，它等价于下面的代码：1Student s = stu; (4) 函数返回值为类类型​ 当函数的返回值为类类型时，return语句会返回一个对象，不过为了防止局部对象被销毁，也为了防止通过返回值修改原来的局部对象，编译器并不会直接返回这个对象，而是根据这个对象先创建出一个临时对象（匿名对象），再将这个临时对象返回。而创建临时对象的过程，就是以拷贝的方式进行的，会调用拷贝构造函数。 ​ 下面的代码演示了返回一个对象的情形： 123456Student func()&#123; Student s("小明", 16, 90.5); return s;&#125;Student stu = func(); ​ 理论上讲，运行代码后会调用两次拷贝构造函数，一次是返回s对象时，另外一次是创建stu对象时。 深拷贝和浅拷贝​ 对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存。例如： 123456789101112131415161718class Base&#123;public: Base(): m_a(0), m_b(0)&#123; &#125; Base(int a, int b): m_a(a), m_b(b)&#123; &#125;private: int m_a; int m_b;&#125;;int main()&#123; int a = 10; int b = a; //拷贝 Base obj1(10, 20); Base obj2 = obj1; //拷贝 return 0;&#125; ​ b和 obj2都是以拷贝的方式初始化的，具体来说，就是将a和 obj1所在内存中的数据按照二进制位（Bit）复制到b和 obj2 所在的内存，这种默认的拷贝行为就是浅拷贝，这和调用 memcpy()函数的效果非常类似。 ​ 对于简单的类，默认的拷贝构造函数一般就够用了，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，例如动态分配的内存、指向其他数据的指针等，默认的拷贝构造函数就不能拷贝这些资源了，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。 ​ 下面我们通过一个具体的例子来说明显式定义拷贝构造函数的必要性。我们知道，有些较老的编译器不支持变长数组，例如 VC6.0、VS2010 等，这有时候会给编程带来不便，下面我们通过自定义的 Array 类来实现变长数组。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;//变长数组类class Array&#123;public: Array(int len); Array(const Array &amp;arr); //拷贝构造函数 ~Array();public: int operator[](int i) const &#123; return m_p[i]; &#125; //获取元素（读取） int &amp;operator[](int i)&#123; return m_p[i]; &#125; //获取元素（写入） int length() const &#123; return m_len; &#125;private: int m_len; int *m_p;&#125;;Array::Array(int len): m_len(len)&#123; m_p = (int*)calloc( len, sizeof(int) );&#125;Array::Array(const Array &amp;arr)&#123; //拷贝构造函数 this-&gt;m_len = arr.m_len; this-&gt;m_p = (int*)calloc( this-&gt;m_len, sizeof(int) ); memcpy( this-&gt;m_p, arr.m_p, m_len * sizeof(int) );&#125;Array::~Array()&#123; free(m_p); &#125;//打印数组元素void printArray(const Array &amp;arr)&#123; int len = arr.length(); for(int i=0; i&lt;len; i++)&#123; if(i == len-1)&#123; cout&lt;&lt;arr[i]&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;arr[i]&lt;&lt;", "; &#125; &#125;&#125;int main()&#123; Array arr1(10); for(int i=0; i&lt;10; i++)&#123; arr1[i] = i; &#125; Array arr2 = arr1; arr2[5] = 100; arr2[3] = 29; printArray(arr1); printArray(arr2); return 0;&#125; 运行结果：120, 1, 2, 3, 4, 5, 6, 7, 8, 90, 1, 2, 29, 4, 100, 6, 7, 8, 9 ​ 本例中我们显式地定义了拷贝构造函数，它除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来。这样做的结果是，原有对象和新对象所持有的动态内存是相互独立的，更改一个对象的数据不会影响另外一个对象，本例中我们更改了 arr2的数据，就没有影响 arr1。 ​ 这种将对象所持有的其它资源一并拷贝的行为叫做深拷贝，我们必须显式地定义拷贝构造函数才能达到深拷贝的目的。 ​ 深拷贝的例子比比皆是，除了上面的变长数组类，标准模板库（STL）中的string、vector、stack、set、map等也都必须使用深拷贝。 ​ 读者如果希望亲眼目睹不使用深拷贝的后果，可以将上例中的拷贝构造函数删除，那么运行结果将变为：120, 1, 2, 29, 4, 100, 6, 7, 8, 90, 1, 2, 29, 4, 100, 6, 7, 8, 9 ​ 可以发现，更改arr2 的数据也影响到了 arr1。这是因为，在创建 arr2 对象时，默认拷贝构造函数将 arr1.m_p 直接赋值给了 arr2.m_p，导致 arr2.m_p和 arr1.m_p 指向了同一块内存，所以会相互影响。 ​ 另外需要注意的是，printArray()函数的形参为引用类型，这样做能够避免在传参时调用拷贝构造函数；又因为 printArray() 函数不会修改任何数组元素，所以我们添加了const 限制，以使得语义更加明确。 到底是浅拷贝还是深拷贝​ 如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深拷贝，因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。如果类的成员变量没有指针，一般浅拷贝足以。 ​ 另外一种需要深拷贝的情况就是在创建对象时进行一些预处理工作，比如统计创建过的对象的数目、记录对象创建的时间等，请看下面的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;ctime&gt;#include &lt;windows.h&gt; //在Linux和Mac下要换成 unistd.h 头文件using namespace std;class Base&#123;public: Base(int a = 0, int b = 0); Base(const Base &amp;obj); //拷贝构造函数public: int getCount() const &#123; return m_count; &#125; time_t getTime() const &#123; return m_time; &#125;private: int m_a; int m_b; time_t m_time; //对象创建时间 static int m_count; //创建过的对象的数目&#125;;int Base::m_count = 0;Base::Base(int a, int b): m_a(a), m_b(b)&#123; m_count++; m_time = time((time_t*)NULL);&#125;Base::Base(const Base &amp;obj)&#123; //拷贝构造函数 this-&gt;m_a = obj.m_a; this-&gt;m_b = obj.m_b; this-&gt;m_count++; this-&gt;m_time = time((time_t*)NULL);&#125;int main()&#123; Base obj1(10, 20); cout&lt;&lt;"obj1: count = "&lt;&lt;obj1.getCount()&lt;&lt;", time = "&lt;&lt;obj1.getTime()&lt;&lt;endl; Sleep(3000); //在Linux和Mac下要写作 sleep(3); Base obj2 = obj1; cout&lt;&lt;"obj2: count = "&lt;&lt;obj2.getCount()&lt;&lt;", time = "&lt;&lt;obj2.getTime()&lt;&lt;endl; return 0;&#125; 运行结果：123obj1: count = 1, time = 1488344372obj2: count = 2, time = 1488344375 ​ 运行程序，先输出第一行结果，等待 3 秒后再输出第二行结果。Base 类中的 m_time 和 m_count 分别记录了对象的创建时间和创建数目，它们在不同的对象中有不同的值，所以需要在初始化对象的时候提前处理一下，这样浅拷贝就不能胜任了，就必须使用深拷贝了。 重载赋值运算符​ 我们讲解了初始化和赋值的区别：在定义的同时进行赋值叫做初始化（Initialization），定义完成以后再赋值（不管在定义的时候有没有赋值）就叫做赋值（Assignment）。初始化只能有一次，赋值可以有多次。 ​ 当以拷贝的方式初始化一个对象时，会调用拷贝构造函数；当给一个对象赋值时，会调用重载过的赋值运算符。 ​ 即使我们没有显式的重载赋值运算符，编译器也会以默认地方式重载它。默认重载的赋值运算符功能很简单，就是将原有对象的所有成员变量一一赋值给新对象，这和默认拷贝构造函数的功能类似。 ​ 对于简单的类，默认的赋值运算符一般就够用了，我们也没有必要再显式地重载它。但是当类持有其它资源时，例如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认的赋值运算符就不能处理了，我们必须显式地重载它，这样才能将原有对象的所有数据都赋值给新对象。 ​ 仍然以上节的Array类为例，该类拥有一个指针成员，指向动态分配的内存。为了让Array类的对象之间能够正确地赋值，我们必须重载赋值运算符。请看下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;//变长数组类class Array&#123;public: Array(int len); Array(const Array &amp;arr); //拷贝构造函数 ~Array();public: int operator[](int i) const &#123; return m_p[i]; &#125; //获取元素（读取） int &amp;operator[](int i)&#123; return m_p[i]; &#125; //获取元素（写入） Array &amp; operator=(const Array &amp;arr); //重载赋值运算符 int length() const &#123; return m_len; &#125;private: int m_len; int *m_p;&#125;;Array::Array(int len): m_len(len)&#123; m_p = (int*)calloc( len, sizeof(int) );&#125;Array::Array(const Array &amp;arr)&#123; //拷贝构造函数 this-&gt;m_len = arr.m_len; this-&gt;m_p = (int*)calloc( this-&gt;m_len, sizeof(int) ); memcpy( this-&gt;m_p, arr.m_p, m_len * sizeof(int) );&#125;Array::~Array()&#123; free(m_p); &#125;Array &amp;Array::operator=(const Array &amp;arr)&#123; //重载赋值运算符 if( this != &amp;arr)&#123; //判断是否是给自己赋值 this-&gt;m_len = arr.m_len; free(this-&gt;m_p); //释放原来的内存 this-&gt;m_p = (int*)calloc( this-&gt;m_len, sizeof(int) ); memcpy( this-&gt;m_p, arr.m_p, m_len * sizeof(int) ); &#125; return *this;&#125;//打印数组元素void printArray(const Array &amp;arr)&#123; int len = arr.length(); for(int i=0; i&lt;len; i++)&#123; if(i == len-1)&#123; cout&lt;&lt;arr[i]&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;arr[i]&lt;&lt;", "; &#125; &#125;&#125;int main()&#123; Array arr1(10); for(int i=0; i&lt;10; i++)&#123; arr1[i] = i; &#125; printArray(arr1); Array arr2(5); for(int i=0; i&lt;5; i++)&#123; arr2[i] = i; &#125; printArray(arr2); arr2 = arr1; //调用operator=() printArray(arr2); arr2[3] = 234; //修改arr1的数据不会影响arr2 arr2[7] = 920; printArray(arr1); return 0;&#125; 运行结果：12340, 1, 2, 3, 4, 5, 6, 7, 8, 90, 1, 2, 3, 40, 1, 2, 3, 4, 5, 6, 7, 8, 90, 1, 2, 3, 4, 5, 6, 7, 8, 9 ​ 将 arr1 赋值给 arr2后，修改 arr2 的数据不会影响 arr1。如果把operator=()注释掉，那么运行结果将变为：12340, 1, 2, 3, 4, 5, 6, 7, 8, 90, 1, 2, 3, 40, 1, 2, 3, 4, 5, 6, 7, 8, 90, 1, 2, 234, 4, 5, 6, 920, 8, 9 去掉operator=()后，由于m_p指向的堆内存会被free()两次，所以还会导致内存错误。 下面我们就来分析一下重载过的赋值运算符。 operator=()的返回值类型为Array &amp;，这样不但能够避免在返回数据时调用拷贝构造函数，还能够达到连续赋值的目的。下面的语句就是连续赋值： 1arr4 = arr3 = arr2 = arr1; if( this != &amp;arr)语句的作用是「判断是否是给同一个对象赋值」：如果是，那就什么也不做；如果不是，那就将原有对象的所有成员变量一一赋值给新对象，并为新对象重新分配内存。下面的语句就是给同一个对象赋值： 12arr1 = arr1;arr2 = arr2; return *this表示返回当前对象（新对象）。 operator=() 的形参类型为const Array &amp;，这样不但能够避免在传参时调用拷贝构造函数，还能够同时接收const 类型和非 const 类型的实参。 赋值运算符重载函数除了能有对象引用这样的参数之外，也能有其它参数。但是其它参数必须给出默认值，例如： 1Array &amp; operator=(const Array &amp;arr, int a = 100); 多个对象构造和析构初始化列表​ 构造函数和其他函数不同，除了有名字，参数列表，函数体之外还有初始化列表。 ​ 初始化列表简单使用: 12345678910111213141516171819202122class Person&#123;public:#if 0 //传统方式初始化 Person(int a,int b,int c)&#123; mA = a; mB = b; mC = c; &#125;#endif //初始化列表方式初始化 Person(int a, int b, int c):mA(a),mB(b),mC(c)&#123;&#125; void PrintPerson()&#123; cout &lt;&lt; "mA:" &lt;&lt; mA &lt;&lt; endl; cout &lt;&lt; "mB:" &lt;&lt; mB &lt;&lt; endl; cout &lt;&lt; "mC:" &lt;&lt; mC &lt;&lt; endl; &#125;private: int mA; int mB; int mC;&#125;; ​ 注意：初始化成员列表(参数列表)只能在构造函数使用。 类对象作为成员类对象作为成员​ 在类中定义的数据成员一般都是基本的数据类型。但是类中的成员也可以是对象，叫做对象成员。 ​ C++中对对象的初始化是非常重要的操作，当创建一个对象的时候，c++编译器必须确保调用了所有子对象的构造函数。如果所有的子对象有默认构造函数，编译器可以自动调用他们。但是如果子对象没有默认的构造函数，或者想指定调用某个构造函数怎么办？ ​ 那么是否可以在类的构造函数直接调用子类的属性完成初始化呢？但是如果子类的成员属性是私有的，我们是没有办法访问并完成初始化的。 ​ 解决办法非常简单：对于子类调用构造函数，c++为此提供了专门的语法，即构造函数初始化列表。 ​ 当调用构造函数时，首先会先按各对象成员在类定义中的顺序（和参数列表的顺序无关）依次调用它们的构造函数，再调用自己的构造函数，对这些对象初始化。析构函数和构造函数调用顺序相反。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;string&gt;using namespace std;class Phone&#123;public: Phone() &#123; cout &lt;&lt; "手机的默认构造函数调用" &lt;&lt; endl; &#125; Phone(string name) &#123; cout &lt;&lt; "手机的有参构造调用" &lt;&lt; endl; m_PhoneName = name; &#125; ~Phone() &#123; cout &lt;&lt; "手机的析构函数调用" &lt;&lt; endl; &#125; string m_PhoneName;&#125;;class Game&#123;public: Game() &#123; cout &lt;&lt; "Game的默认构造函数调用" &lt;&lt; endl; &#125; Game(string name) &#123; cout &lt;&lt; "Game的有参构造调用" &lt;&lt; endl; m_GameName = name; &#125; ~Game() &#123; cout &lt;&lt; "Game的析构函数调用" &lt;&lt; endl; &#125; string m_GameName;&#125;;class Person&#123;public: Person() &#123; cout &lt;&lt; "Person的默认构造函数调用" &lt;&lt; endl; &#125; Person(string name, string phoneName, string gameName) : m_Name(name), m_Phone(phoneName), m_Game(gameName) &#123; cout &lt;&lt; "Person的有参构造调用" &lt;&lt; endl; //m_Name = name; &#125; void playGame() &#123; cout &lt;&lt; m_Name &lt;&lt; " 拿着《" &lt;&lt; m_Phone.m_PhoneName &lt;&lt; "》牌手机 ，玩着《" &lt;&lt; m_Game.m_GameName &lt;&lt; "》游戏" &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; "Person的析构函数调用" &lt;&lt; endl; &#125; string m_Name; //姓名 Phone m_Phone; //手机 Game m_Game; //游戏&#125;;//类对象作为类成员时候，构造顺序先将类对象一一构造，然后构造自己， 析构的顺序是相反的void test01()&#123; Person p("狗蛋","苹果","切水果"); p.playGame();&#125;int main()&#123; test01(); system("pause"); return EXIT_SUCCESS;&#125; 输出是：手机的有参构造调用Game的有参构造调用Person的有参构造调用狗蛋 拿着《苹果》牌手机 ，玩着《切水果》游戏Person的析构函数调用Game的析构函数调用手机的析构函数调用 动态对象创建​ 当我们创建数组的时候，总是需要提前预定数组的长度，然后编译器分配预定长度的数组空间，在使用数组的时，会有这样的问题，数组也许空间太大了，浪费空间，也许空间不足，所以对于数组来讲，如果能根据需要来分配空间大小再好不过。 ​ 所以动态的意思意味着不确定性。 ​ 为了解决这个普遍的编程问题，在运行中可以创建和销毁对象是最基本的要求。当然c早就提供了动态内存分配（dynamic memory allocation）,函数malloc和free可以在运行时从堆中分配存储单元。 ​ 然而这些函数在c++中不能很好的运行，因为它不能帮我们完成对象的初始化工作。 对象创建当创建一个c++对象时会发生两件事: 为对象分配内存 调用构造函数来初始化那块内存 ​ 第一步我们能保证实现，需要我们确保第二步一定能发生。c++强迫我们这么做是因为使用未初始化的对象是程序出错的一个重要原因。 new operator​ C++中解决动态内存分配的方案是把创建一个对象所需要的操作都结合在一个称为new的运算符里。当用new创建一个对象时，它就在堆里为对象分配内存并调用构造函数完成初始化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; cout &lt;&lt; "默认构造调用" &lt;&lt; endl; &#125; Person(int a) &#123; cout &lt;&lt; "有参构造调用" &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125;&#125;;void test01()&#123; //Person p1; 栈区开辟 Person * p2 = new Person; //堆区开辟 //所有new出来的对象 都会返回该类型的指针 //malloc 返回 void* 还要强转 //malloc会调用构造吗？ 不会 new会调用构造 // new 运算符 malloc 函数 //释放 堆区空间 // delete也是运算符 配合 new用 malloc 配合 free用 delete p2;&#125;void test02()&#123; void *p = new Person(10); //当用void* 接受new出来的指针 ，会出现释放的问题 delete p; //无法释放p ，所以避免这种写法&#125;void test03()&#123; //通过new开辟数组 一定会调用默认构造函数,所以一定要提供默认构造 Person * pArray = new Person[10]; //Person pArray2[2] = &#123; Person(1), Person(2) &#125;; //在栈上开辟数组，可以指定有参构造 //释放数组 delete [] delete [] pArray;&#125;int main()&#123; //test01(); //test02(); test03(); system("pause"); return EXIT_SUCCESS;&#125; delete operator​ new表达式的反面是delete表达式。delete表达式先调用析构函数，然后释放内存。正如new表达式返回一个指向对象的指针一样，delete需要一个对象的地址。 ​ delete只适用于由new创建的对象。 ​ 如果正在删除的对象的指针是NULL,将不发生任何事，因此建议在删除指针后，立即把指针赋值为NULL，以免对它删除两次，对一些对象删除两次可能会产生某些问题。 delete void*可能会出错​ 如果对一个void*指针执行delete操作，这将可能成为一个程序错误，除非指针指向的内容是非常简单的，因为它将不执行析构函数。未调用析构函数，导致可用内存减少。 用于数组的new和delete​ 使用new和delete在堆上创建数组非常容易。 1234567891011//创建字符数组char* pStr = new char[100];//创建整型数组int* pArr1 = new int[100]; //创建整型数组并初始化int* pArr2 = new int[10]&#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;//释放数组内存delete[] pStr;delete[] pArr1;delete[] pArr2; ​ 当创建一个对象数组的时候，必须对数组中的每一个对象调用构造函数，除了在栈上可以聚合初始化，必须提供一个默认的构造函数。 使用new和delete采用相同形式12Person* person = new Person[10]; delete person; ​ 以上代码有什么问题吗？(vs下直接中断、qt下析构函数调用一次) ​ 使用了new也搭配使用了delete，问题在于Person有10个对象，那么其他9个对象可能没有调用析构函数，也就是说其他9个对象可能删除不完全，因为它们的析构函数没有被调用。 ​ 我们现在清楚使用new的时候发生了两件事: 一、分配内存；二、调用构造函数，那么调用delete的时候也有两件事：一、析构函数；二、释放内存。 ​ 那么刚才我们那段代码最大的问题在于：person指针指向的内存中到底有多少个对象，因为这个决定应该有多少个析构函数应该被调用。换句话说，person指针指向的是一个单一的对象还是一个数组对象，由于单一对象和数组对象的内存布局是不同的。更明确的说，数组所用的内存通常还包括“数组大小记录”，使得delete的时候知道应该调用几次析构函数。单一对象的话就没有这个记录。单一对象和数组对象的内存布局可理解为下图: 只是为了说明，编译器不一定如此实现，但是很多编译器是这样做的。 ​ 当我们使用一个delete的时候，我们必须让delete知道指针指向的内存空间中是否存在一个“数组大小记录”的办法就是我们告诉它。当我们使用delete[]，那么delete就知道是一个对象数组，从而清楚应该调用几次析构函数。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++const成员变量和函数]]></title>
    <url>%2F2018%2F07%2F10%2Fc%2B%2B%E5%B0%81%E8%A3%854-const%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在类中，如果你不希望某些数据被修改，可以使用const关键字加以限定。const可以用来修饰成员变量和成员函数。 const成员变量​ const成员变量的用法和普通const变量的用法相似，只需要在声明时加上const关键字。初始化const成员变量只有一种方法，就是通过构造函数的初始化列表。 const成员函数（常成员函数）​ const成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。const 成员函数也称为常成员函数。 ​ 我们通常将get函数设置为常成员函数。读取成员变量的函数的名字通常以get开头，后跟成员变量的名字，所以通常将它们称get函数。 ​ 常成员函数需要在声明和定义的时候在函数头部的结尾加上const关键字，请看下面的例子： 12345678910111213141516171819202122232425262728class Student&#123;public: Student(char *name, int age, float score); void show(); //声明常成员函数 char *getname() const; int getage() const; float getscore() const;private: char *m_name; int m_age; float m_score;&#125;;Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;void Student::show()&#123; cout&lt;&lt;m_name&lt;&lt;"的年龄是"&lt;&lt;m_age&lt;&lt;"，成绩是"&lt;&lt;m_score&lt;&lt;endl;&#125;//定义常成员函数char * Student::getname() const&#123; return m_name;&#125;int Student::getage() const&#123; return m_age;&#125;float Student::getscore() const&#123; return m_score;&#125; ​ getname()、getage()、getscore()三个函数的功能都很简单，仅仅是为了获取成员变量的值，没有任何修改成员变量的企图，所以我们加了const限制，这是一种保险的做法，同时也使得语义更加明显。 ​ 需要强调的是，必须在成员函数的声明和定义处同时加上const关键字。char *getname() const和char *getname()是两个不同的函数原型，如果只在一个地方加const会导致声明和定义处的函数原型冲突。 最后再来区分一下const的位置： 函数开头的const用来修饰函数的返回值，表示返回值是const类型，也就是不能被修改，例如const char * getname()。 函数头部的结尾加上const表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如char * getname() const。 const对象（常对象）​ 在C++ 中，const也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，就只能调用类的const成员（包括const成员变量和const成员函数）了。 ​ 定义常对象的语法和定义常量的语法类似：12const class object(params);class const object(params); 当然你也可以定义const指针：12const class *p = new class(params);class const *p = new class(params); ​ class为类名，object为对象名，params为实参列表，p为指针名。两种方式定义出来的对象都是常对象。 ​ 一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被const修饰的成员了（包括const成员变量和const成员函数），因为非const成员可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。 ​ 常对象使用举例： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class Student&#123;public: Student(char *name, int age, float score);public: void show(); char *getname() const; int getage() const; float getscore() const;private: char *m_name; int m_age; float m_score;&#125;;Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;void Student::show()&#123; cout&lt;&lt;m_name&lt;&lt;"的年龄是"&lt;&lt;m_age&lt;&lt;"，成绩是"&lt;&lt;m_score&lt;&lt;endl;&#125;char * Student::getname() const&#123; return m_name;&#125;int Student::getage() const&#123; return m_age;&#125;float Student::getscore() const&#123; return m_score;&#125;int main()&#123; const Student stu("小明", 15, 90.6); //stu.show(); //error cout&lt;&lt;stu.getname()&lt;&lt;"的年龄是"&lt;&lt;stu.getage()&lt;&lt;"，成绩是"&lt;&lt;stu.getscore()&lt;&lt;endl; const Student *pstu = new Student("李磊", 16, 80.5); //pstu -&gt; show(); //error cout&lt;&lt;pstu-&gt;getname()&lt;&lt;"的年龄是"&lt;&lt;pstu-&gt;getage()&lt;&lt;"，成绩是"&lt;&lt;pstu-&gt;getscore()&lt;&lt;endl; return 0;&#125; ​ 本例中，stu、pstu分别是常对象以及常对象指针，它们都只能调用const成员函数。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++静态成员变量和函数]]></title>
    <url>%2F2018%2F07%2F07%2Fc%2B%2B%E5%B0%81%E8%A3%853-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[static静态成员变量​ 对象的内存中包含了成员变量，不同的对象占用不同的内存，这使得不同对象的成员变量相互独立，它们的值不受其他对象的影响。例如有两个相同类型的对象a、b，它们都有一个成员变量m_name，那么修改a.m_name的值不会影响b.m_name的值。 ​ 可是有时候我们希望在多个对象之间共享数据，对象a改变了某份数据后对象b可以检测到。共享数据的典型使用场景是计数，以前面的Student类为例，如果我们想知道班级中共有多少名学生，就可以设置一份共享的变量，每次创建对象时让该变量加1。 ​ 在C++中，我们可以使用静态成员变量来实现多个对象共享数据的目标。静态成员变量是一种特殊的成员变量，它被关键字static修饰，例如： 1234567891011class Student&#123;public: Student(char *name, int age, float score); void show();public: static int m_total; //静态成员变量private: char *m_name; int m_age; float m_score;&#125;; ​ 这段代码声明了一个静态成员变量m_total，用来统计学生的人数。 ​ static成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为m_total分配一份内存，所有对象使用的都是这份内存中的数据。当某个对象修改了m_total，也会影响到其他对象。 ​ static成员变量必须在类声明的外部初始化，具体形式为：1type class::name = value; ​ type是变量的类型，class是类名，name是变量名，value是初始值。将上面的m_total初始化：1int Student::m_total = 0; ​ 静态成员变量在初始化时不能再加static，但必须要有数据类型。被private、protected、public修饰的静态成员变量都可以用这种方式初始化。 ​ 注意：static成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的static成员变量不能使用。 ​ static成员变量既可以通过对象来访问，也可以通过类来访问。请看下面的例子： 12345678//通过类类访问 static 成员变量Student::m_total = 10;//通过对象来访问 static 成员变量Student stu("小明", 15, 92.5f);stu.m_total = 20;//通过对象指针来访问 static 成员变量Student *pstu = new Student("李华", 16, 96);pstu -&gt; m_total = 20; ​ 这三种方式是等效的。 ​ 注意：static成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。具体来说，static成员变量和普通的static 变量类似，都在内存分区中的全局数据区分配内存。 下面来看一个完整的例子： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class Student&#123;public: Student(char *name, int age, float score); void show(); static int m_total; //静态成员变量private: char *m_name; int m_age; float m_score;&#125;;//初始化静态成员变量int Student::m_total = 0;Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; m_total++; //操作静态成员变量&#125;void Student::show()&#123; cout&lt;&lt;m_name&lt;&lt;"的年龄是"&lt;&lt;m_age&lt;&lt;"，成绩是"&lt;&lt;m_score&lt;&lt;"（当前共有"&lt;&lt;m_total&lt;&lt;"名学生）"&lt;&lt;endl;&#125;int main()&#123; //创建匿名对象 (new Student("小明", 15, 90)) -&gt; show(); (new Student("李磊", 16, 80)) -&gt; show(); (new Student("张华", 16, 99)) -&gt; show(); (new Student("王康", 14, 60)) -&gt; show(); return 0;&#125; 运行结果：小明的年龄是15，成绩是90（当前共有1名学生）李磊的年龄是16，成绩是80（当前共有2名学生）张华的年龄是16，成绩是99（当前共有3名学生）王康的年龄是14，成绩是60（当前共有4名学生） ​ 本例中将m_total声明为静态成员变量，每次创建对象时，会调用构造函数使m_total的值加1。 ​ 之所以使用匿名对象，是因为每次创建对象后只会使用它的show()函数，不再进行其他操作。不过使用匿名对象无法回收内存，会导致内存泄露，在中大型程序中不建议使用。 几点说明1) 一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。 2)static成员变量和普通static变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。 3) 静态成员变量必须初始化，而且只能在类体外进行。例如：1int Student::m_total = 10; ​ 初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为0。全局数据区的变量都有默认的初始值0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。 4) 静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循private、protected 和public关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。 static静态成员函数​ 在类中，static除了可以声明静态成员变量，还可以声明静态成员函数。普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。 ​ 编译器在编译一个普通成员函数时，会隐式地增加一个形参this，并把当前对象的地址赋值给this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。 ​ 普通成员变量占用对象的内存，静态成员函数没有this指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。 ​ 普通成员函数必须通过对象才能调用，而静态成员函数没有this指针，无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数。 ​ 静态成员函数与普通成员函数的根本区别在于：普通成员函数有this指针，可以访问类中的任意成员；而静态成员函数没有this指针，只能访问静态成员（包括静态成员变量和静态成员函数）。 ​ 下面是一个完整的例子，该例通过静态成员函数来获得学生的总人数和总成绩： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;class Student&#123;public: Student(char *name, int age, float score); void show();public: //声明静态成员函数 static int getTotal(); static float getPoints();private: static int m_total; //总人数 static float m_points; //总成绩private: char *m_name; int m_age; float m_score;&#125;;int Student::m_total = 0;float Student::m_points = 0.0;Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; m_total++; m_points += score;&#125;void Student::show()&#123; cout&lt;&lt;m_name&lt;&lt;"的年龄是"&lt;&lt;m_age&lt;&lt;"，成绩是"&lt;&lt;m_score&lt;&lt;endl;&#125;//定义静态成员函数int Student::getTotal()&#123; return m_total;&#125;float Student::getPoints()&#123; return m_points;&#125;int main()&#123; (new Student("小明", 15, 90.6)) -&gt; show(); (new Student("李磊", 16, 80.5)) -&gt; show(); (new Student("张华", 16, 99.0)) -&gt; show(); (new Student("王康", 14, 60.8)) -&gt; show(); int total = Student::getTotal(); float points = Student::getPoints(); cout&lt;&lt;"当前共有"&lt;&lt;total&lt;&lt;"名学生，总成绩是"&lt;&lt;points&lt;&lt;"，平均分是"&lt;&lt;points/total&lt;&lt;endl; return 0;&#125; 运行结果：小明的年龄是15，成绩是90.6李磊的年龄是16，成绩是80.5张华的年龄是16，成绩是99王康的年龄是14，成绩是60.8当前共有4名学生，总成绩是330.9，平均分是82.725 ​ 总人数m_total和总成绩m_points由各个对象累加得到，必须声明为 static 才能共享；getTotal()、getPoints()分别用来获取总人数和总成绩，为了访问static成员变量，我们将这两个函数也声明为static。 ​ 在C++中，静态成员函数的主要目的是访问静态成员。getTotal()、getPoints()当然也可以声明为普通成员函数，但是它们都只对静态成员进行操作，加上static语义更加明确。 ​ 和静态成员变量类似，静态成员函数在声明时要加static，在定义时不能加static。静态成员函数可以通过类来调用（一般都是这样做），也可以通过对象来调用，上例仅仅演示了如何通过类来调用。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象内存分布和编译实现]]></title>
    <url>%2F2018%2F07%2F02%2Fc%2B%2B%E5%B0%81%E8%A3%852-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%92%8C%E7%BC%96%E8%AF%91%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[类是创建对象的模板，不占用内存空间，不存在于编译后的可执行文件中；而对象是实实在在的数据，需要内存来存储。对象被创建时会在栈区或者堆区分配内存。 C++对象内存分布​ 直观的认识是，如果创建了 10 个对象，就要分别为这 10 个对象的成员变量和成员函数分配内存，如下图所示： ​ 不同对象的成员变量的值可能不同，需要单独分配内存来存储。但是不同对象的成员函数的代码是一样的，上面的内存模型保存了 10 分相同的代码片段，浪费了不少空间，可以将这些代码片段压缩成一份。 ​ 事实上编译器也是这样做的，编译器会将成员变量和成员函数分开存储：分别为每个对象的成员变量分配内存，但是所有对象都共享同一段函数代码。 如下图所示： ​ 成员变量在堆区或栈区分配内存，成员函数在代码区分配内存。 【示例】使用sizeof获取对象所占内存的大小： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;class Student&#123;private: char *m_name; int m_age; float m_score;public: void setname(char *name); void setage(int age); void setscore(float score); void show();&#125;;void Student::setname(char *name)&#123; m_name = name;&#125;void Student::setage(int age)&#123; m_age = age;&#125;void Student::setscore(float score)&#123; m_score = score;&#125;void Student::show()&#123; cout&lt;&lt;m_name&lt;&lt;"的年龄是"&lt;&lt;m_age&lt;&lt;"，成绩是"&lt;&lt;m_score&lt;&lt;endl;&#125;int main()&#123; //在栈上创建对象 Student stu; cout&lt;&lt;sizeof(stu)&lt;&lt;endl; //在堆上创建对象 Student *pstu = new Student(); cout&lt;&lt;sizeof(*pstu)&lt;&lt;endl; //类的大小 cout&lt;&lt;sizeof(Student)&lt;&lt;endl; return 0;&#125; 运行结果：123121212 ​ Student 类包含三个成员变量，它们的类型分别是char *、int、float，都占用 4个字节的内存，加起来共占用12个字节的内存。通过 sizeof 求得的结果等于12，恰好说明对象所占用的内存仅仅包含了成员变量。 ​ 类可以看做是一种复杂的数据类型，也可以使用 sizeof 求得该类型的大小。从运行结果可以看出，在计算类这种类型的大小时，只计算了成员变量的大小，并没有把成员函数也包含在内。 ​ 对象的大小只受成员变量的影响，和成员函数没有关系。 ​ 假设 stu 的起始地址为 0X1000，那么该对象的内存分布如下图所示： ​ m_name、m_age、m_score 按照声明的顺序依次排列，和结构体非常类似，也会有内存对齐的问题。 ​ 从上节的分析中可以看出，对象的内存中只保留了成员变量，除此之外没有任何其他信息，程序运行时不知道 stu 的类型为 Student，也不知道它还有四个成员函数 setname()、setage()、setscore()、show()，C++ 究竟是如何通过对象调用成员函数的呢？ C++函数的编译​ C++和C语言的编译方式不同。C语言中的函数在编译时名字不变，或者只是简单的加一个下划线_（不同的编译器有不同的实现），例如，func() 编译后为 func() 或_func()。 ​ 而C++中的函数在编译时会根据它所在的命名空间、它所属的类、以及它的参数列表（也叫参数签名）等信息进行重新命名，形成一个新的函数名。这个新的函数名只有编译器知道，对用户是不可见的。对函数重命名的过程叫做名字编码（Name Mangling），是通过一种特殊的算法来实现的。 ​ Name Mangling 的算法是可逆的，既可以通过现有函数名计算出新函数名，也可以通过新函数名逆向推演出原有函数名。Name Mangling 可以确保新函数名的唯一性，只要函数所在的命名空间、所属的类、包含的参数列表等有一个不同，最后产生的新函数名也不同。 ​ 如果你希望看到经 Name Mangling 产生的新函数名，可以只声明而不定义函数，这样调用函数时就会产生链接错误，从报错信息中就可以看到新函数名。请看下面的代码： 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;void display();void display(int);namespace ns&#123; void display();&#125;class Demo&#123;public: void display();&#125;;int main()&#123; display(); display(1); ns::display(); Demo obj; obj.display(); return 0;&#125; ​ 该例中声明了四个同名函数，包括两个具有重载关系的全局函数，一个位于命名空间 ns下的函数，以及一个属于类Demo的函数。它们都是只声明而未定义的函数。 ​ 在 VS 下编译源代码可以看到类似下面的错误信息： ​ 小括号中就是经 Name Mangling 产生的新函数名，它们都以?开始，以区别C语言中的_`。 ​ 上图是 VS2010 产生的错误信息，不同的编译器有不同的 Name Mangling 算法，产生的函数名也不一样。 __thiscall、cdecl是函数调用惯例。 ​ 除了函数，某些变量也会经 Name Mangling 算法产生新名字，这里不再赘述。 成员函数的调用​ 从上图可以看出，成员函数最终被编译成与对象无关的全局函数，如果函数体中没有成员变量，那问题就很简单，不用对函数做任何处理，直接调用即可。 ​ 如果成员函数中使用到了成员变量该怎么办呢？成员变量的作用域不是全局，不经任何处理就无法在函数内部访问。 ​ C++规定，编译成员函数时要额外添加一个参数，把当前对象的指针传递进去，通过指针来访问成员变量。 ​ 假设Demo类有两个int型的成员变量，分别是a和b，并且在成员函数display()中使用到了，如下所示： 1234void Demo::display()&#123; cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;b&lt;&lt;endl;&#125; ​ 那么编译后的代码类似于： 12345void new_function_name(Demo * const p)&#123; //通过指针p来访问a、b cout&lt;&lt;p-&gt;a&lt;&lt;endl; cout&lt;&lt;p-&gt;b&lt;&lt;endl;&#125; ​ 使用obj.display()调用函数时，也会被编译成类似下面的形式： 1new_function_name(&amp;obj); ​ 这样通过传递对象指针就完成了成员函数和成员变量的关联。这与我们从表明上看到的刚好相反，通过对象调用成员函数时，不是通过对象找函数，而是通过函数找对象。 ​ 这一切都是隐式完成的，对程序员来说完全透明，就好像这个额外的参数不存在一样。 ​ 最后需要提醒的是，Demo * const p中的 const表示指针不能被修改，p只能指向当前对象，不能指向其他对象。 this指针详解​ this是C++中的一个关键字，也是一个const指针，它指向当前对象，通过它可以访问当前对象的所有成员。 ​ 所谓当前对象，是指正在使用的对象。例如对于stu.show();，stu就是当前对象，this就指向stu。 ​ 下面是使用this的一个完整示例： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;class Student&#123;public: void setname(char *name); void setage(int age); void setscore(float score); void show();private: char *name; int age; float score;&#125;;void Student::setname(char *name)&#123; this-&gt;name = name;&#125;void Student::setage(int age)&#123; this-&gt;age = age;&#125;void Student::setscore(float score)&#123; this-&gt;score = score;&#125;void Student::show()&#123; cout&lt;&lt;this-&gt;name&lt;&lt;"的年龄是"&lt;&lt;this-&gt;age&lt;&lt;"，成绩是"&lt;&lt;this-&gt;score&lt;&lt;endl;&#125;int main()&#123; Student *pstu = new Student; pstu -&gt; setname("李华"); pstu -&gt; setage(16); pstu -&gt; setscore(96.5); pstu -&gt; show(); return 0;&#125; 运行结果：李华的年龄是16，成绩是96.5 ​ this只能用在类的内部，通过this可以访问类的所有成员，包括private、protected、public属性的。 ​ 本例中成员函数的参数和成员变量重名，只能通过this区分。以成员函数setname(char *name)为例，它的形参是name，和成员变量name重名，如果写作name = name;这样的语句，就是给形参name赋值，而不是给成员变量name赋值。而写作this-&gt;name = name;后，=左边的name就是成员变量，右边的name就是形参，一目了然。 ​ 注意，this是一个指针，要用-&gt;来访问成员变量或成员函数。 ​ this虽然用在类的内部，但是只有在对象被创建以后才会给this赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给this赋值。本例中，this的值和pstu的值是相同的。 ​ 我们不妨来证明一下，给Student类添加一个成员函数printThis()，专门用来输出this的值，如下所示： 123void Student::printThis()&#123; cout&lt;&lt;this&lt;&lt;endl;&#125; 然后在main()函数中创建对象并调用printThis()： 1234567Student *pstu1 = new Student;pstu1 -&gt; printThis();cout&lt;&lt;pstu1&lt;&lt;endl;Student *pstu2 = new Student;pstu2 -&gt; printThis();cout&lt;&lt;pstu2&lt;&lt;endl; 运行结果：0x7b17d80x7b17d80x7b17f00x7b17f0 ​ 可以发现，this确实指向了当前对象，而且对于不同的对象，this的值也不一样。 几点注意： this是const 指针，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。 this只能在成员函数内部使用，用在其他地方没有意义，也是非法的。 只有当对象被创建后this才有意义，因此不能在static成员函数中使用（后续会讲到static成员）。 this到底是什么​ this实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给this。不过 this这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。 ​ this作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给this赋值。 ​ 在上节中讲到，成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是this，它是成员函数和成员变量关联的桥梁。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++类的封装]]></title>
    <url>%2F2018%2F06%2F25%2Fc%2B%2B%E5%B0%81%E8%A3%851-%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[类的定义和对象的创建​ 类是创建对象的模板，一个类可以创建多个对象，每个对象都是类类型的一个变量；创建对象的过程也叫类的实例化。每个对象都是类的一个具体实例（Instance），拥有类的成员变量和成员函数 一个简单的类的定义： 123456789101112class Student&#123;public: //成员变量 char *name; int age; float score; //成员函数 void say()&#123; cout&lt;&lt;name&lt;&lt;"的年龄是"&lt;&lt;age&lt;&lt;"，成绩是"&lt;&lt;score&lt;&lt;endl; &#125;&#125;; class是C++中新增的关键字，专门用来定义类。 Student是类的名称；类名的首字母一般大写，以和其他的标识符区分开。 { }内部是类所包含的成员变量和成员函数，它们统称为类的成员（Member）；由{ }包围起来的部分有时也称为类体，和函数体的概念类似。 public也是C++的新增关键字。 类定义的最后有一个分号;，它是类定义的一部分，表示类定义结束了，不能省略。 类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。 创建对象有了Student类后，就可以通过它来创建对象了，例如： 1Student liLei; //创建对象 Student是类名，liLei是对象名。这和使用基本类型定义变量的形式类似： 1int a; //定义整型变量 从这个角度考虑，我们可以把Student看做一种新的数据类型，把liLei看做一个变量。 在创建对象时，class 关键字可要可不要，但是出于习惯我们通常会省略掉 class 关键字，例如： 1class Student LiLei; //正确Student LiLei; //同样正确 除了创建单个对象，还可以创建对象数组： 1Student allStu[100]; 该语句创建了一个allStu数组，它拥有100个元素，每个元素都是 Student类型的对象。 访问类的成员创建对象以后，可以使用点号.来访问成员变量和成员函数，这和通过结构体变量来访问它的成员类似，如下所示： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;//类通常定义在函数外面class Student&#123;public: //类包含的变量 char *name; int age; float score; //类包含的函数 void say()&#123; cout&lt;&lt;name&lt;&lt;"的年龄是"&lt;&lt;age&lt;&lt;"，成绩是"&lt;&lt;score&lt;&lt;endl; &#125;&#125;;int main()&#123; //创建对象 Student stu; stu.name = "小明"; stu.age = 15; stu.score = 92.5f; stu.say(); return 0;&#125; 运行结果：小明的年龄是15，成绩是92.5 stu是一个对象，占用内存空间，可以对它的成员变量赋值，也可以读取它的成员变量。 使用对象指针​ C语言中经典的指针在C++中仍然广泛使用，尤其是指向对象的指针，没有它就不能实现某些功能。 上面代码中创建的对象` stu `在栈上分配内存，需要使用`&amp;`获取它的地址，例如： 12Student stu;Student *pStu = &amp;stu; ​ pStu是一个指针，它指向Student类型的数据，也就是通过Student创建出来的对象。 ​ 当然，你也可以在堆上创建对象，这个时候就需要使用前面讲到的new关键字，例如： 1Student *pStu = new Student; ​ 在栈上创建出来的对象都有一个名字，比如stu，使用指针指向它不是必须的。但是通过new创建出来的对象就不一样了，它在堆上分配内存，没有名字，只能得到一个指向它的指针，所以必须使用一个指针变量来接收这个指针，否则以后再也无法找到这个对象了，更没有办法使用它。也就是说，使用new在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。 ​ 栈内存是程序自动管理的，不能使用delete删除在栈上创建的对象；堆内存由程序员管理，对象使用完毕后可以通过delete删除。在实际开发中，new和delete往往成对出现，以保证及时删除不再使用的对象，防止无用内存堆积。 ​ 有了对象指针后，可以通过箭头-&gt;来访问对象的成员变量和成员函数，这和通过结构体指针来访问它的成员类似，请看下面的示例： 1234pStu -&gt; name = "小明";pStu -&gt; age = 15;pStu -&gt; score = 92.5f;pStu -&gt; say(); 下面是一个完整的例子： 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class Student&#123;public: char *name; int age; float score; void say()&#123; cout&lt;&lt;name&lt;&lt;"的年龄是"&lt;&lt;age&lt;&lt;"，成绩是"&lt;&lt;score&lt;&lt;endl; &#125;&#125;;int main()&#123; Student *pStu = new Student; pStu -&gt; name = "小明"; pStu -&gt; age = 15; pStu -&gt; score = 92.5f; pStu -&gt; say(); delete pStu; //删除对象 return 0;&#125; 运行结果：小明的年龄是15，成绩是92.5 类的成员变量和成员函数​ 类的成员变量和普通变量一样，也有数据类型和名称，占用固定长度的内存。但是，在定义类的时候不能对成员变量赋值，因为类只是一种数据类型或者说是一种模板，本身不占用内存空间，而变量的值则需要内存来存储。 ​ 类的成员函数也和普通函数一样，都有返回值和参数列表，它与一般函数的区别是：成员函数是一个类的成员，出现在类体中，它的作用范围由类来决定；而普通函数是独立的，作用范围是全局的，或位于某个命名空间内。 ​ 上节我们在示例中给出了Student类的定义，如下所示： 123456789101112class Student&#123;public: //成员变量 char *name; int age; float score; //成员函数 void say()&#123; cout&lt;&lt;name&lt;&lt;"的年龄是"&lt;&lt;age&lt;&lt;"，成绩是"&lt;&lt;score&lt;&lt;endl; &#125;&#125;; ​ 这段代码在类体中定义了成员函数。你也可以只在类体中声明函数，而将函数定义放在类体外面，如下图所示： 123456789101112131415class Student&#123;public: //成员变量 char *name; int age; float score; //成员函数 void say(); //函数声明&#125;;//函数定义void Student::say()&#123; cout&lt;&lt;name&lt;&lt;"的年龄是"&lt;&lt;age&lt;&lt;"，成绩是"&lt;&lt;score&lt;&lt;endl;&#125; ​ 在类体中直接定义函数时，不需要在函数名前面加上类名，因为函数属于哪一个类是不言而喻的。 ​ 但当成员函数定义在类外时，就必须在函数名前面加上类名予以限定。::被称为域解析符（也称作用域运算符或作用域限定符），用来连接类名和函数名，指明当前函数属于哪个类。 ​ 成员函数必须先在类体中作原型声明，然后在类外定义，也就是说类体的位置应在函数定义之前。 在类体中和类体外定义成员函数的区别​ 在类体中和类体外定义成员函数是有区别的：在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。当然，在类体内部定义的函数也可以加inline关键字，但这是多余的，因为类体内部定义的函数默认就是内联函数。 ​ 内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以我建议在类体内部对成员函数作声明，而在类体外部进行定义，这是一种良好的编程习惯，实际开发中大家也是这样做的。 ​ 当然，如果你的函数比较短小，希望定义为内联函数，那也没有什么不妥的。 ​ 如果你既希望将函数定义在类体外部，又希望它是内联函数，那么可以在定义函数时加inline关键字。当然你也可以在函数声明处加inline，不过这样做没有效果，编译器会忽略函数声明处的inline。 下面是一个将内联函数定义在类外部的例子： 12345678910111213class Student&#123;public: char *name; int age; float score; void say(); //内联函数声明，可以增加 inline 关键字，但编译器会忽略&#125;;//函数定义inline void Student::say()&#123; cout&lt;&lt;name&lt;&lt;"的年龄是"&lt;&lt;age&lt;&lt;"，成绩是"&lt;&lt;score&lt;&lt;endl;&#125; 这样，say()就会变成内联函数。 ​ 这种在类体外定义inline函数的方式，必须将类的定义和成员函数的定义都放在同一个头文件中（或者同一个源文件中），否则编译时无法进行嵌入（将函数代码的嵌入到函数调用出）。 ​ 再次强调，虽然C++支持将内联函数定义在类的外部，但我强烈建议将函数定义在类的内部，这样它会自动成为内联函数，不必费力不讨好地将它定义在类的外部，这样并没有任何优势。 类的封装C和C++中struct区别 c语言struct只有变量 c++语言struct既有变量，也有函数 c语言类的封装​ 我们编写程序的目的是为了解决现实中的问题，而这些问题的构成都是由各种事物组成，我们在计算机中要解决这种问题，首先要做就是要将这个问题的参与者：事和物抽象到计算机程序中，也就是用程序语言表示现实的事物。 ​ 那么现在问题是如何用程序语言来表示现实事物？现实世界的事物所具有的共性就是每个事物都具有自身的属性，一些自身具有的行为，所以如果我们能把事物的属性和行为表示出来，那么就可以抽象出来这个事物。 ​ 比如我们要表示人这个对象，在c语言中，我们可以这么表示: 1234567891011121314151617181920212223242526typedef struct _Person&#123; char name[64]; int age;&#125;Person;typedef struct _Aninal&#123; char name[64]; int age; int type; //动物种类&#125;Ainmal;void PersonEat(Person* person)&#123; printf("%s在吃人吃的饭!\n",person-&gt;name);&#125;void AnimalEat(Ainmal* animal)&#123; printf("%s在吃动物吃的饭!\n", animal-&gt;name);&#125;int main()&#123; Person person; strcpy(person.name, "小明"); person.age = 30; AnimalEat(&amp;person); return EXIT_SUCCESS;&#125; ​ 定义一个结构体用来表示一个对象所包含的属性，函数用来表示一个对象所具有的行为，这样我们就表示出来一个事物，在c语言中，行为和属性是分开的，也就是说吃饭这个属性不属于某类对象，而属于所有的共同的数据，所以不单单是PeopleEat可以调用Person数据，AnimalEat也可以调用Person数据，那么万一调用错误，将会导致问题发生。 ​ 从这个案例我们应该可以体会到，属性和行为应该放在一起，一起表示一个具有属性和行为的对象。 c++类的封装​ 假如某对象的某项属性不想被外界获知，比如说漂亮女孩的年龄不想被其他人知道，那么年龄这条属性应该作为女孩自己知道的属性；或者女孩的某些行为不想让外界知道，只需要自己知道就可以。那么这种情况下，封装应该再提供一种机制能够给属性和行为的访问权限控制住。 ​ 所以说封装特性包含两个方面，一个是属性和变量合成一个整体，一个是给属性和函数增加访问权限。 访问属性 属性 对象内部 对象外部 public 公有 可访问 可访问 protected 保护 可访问 不可访问 private 私有 可访问 不可访问 1234567891011121314151617181920212223242526//封装两层含义//1. 属性和行为合成一个整体//2. 访问控制，现实事物本身有些属性和行为是不对外开放class Person&#123;//人具有的行为(函数)public: void Dese()&#123; cout &lt;&lt; "我有钱，年轻，个子又高，就爱嘚瑟!" &lt;&lt; endl;&#125;//人的属性(变量)public: int mTall; //多高，可以让外人知道protected: int mMoney; // 有多少钱,只能儿子孙子知道private: int mAge; //年龄，不想让外人知道&#125;;int main()&#123; Person p; p.mTall = 220; //p.mMoney 保护成员外部无法访问 //p.mAge 私有成员外部无法访问 p.Dese(); return EXIT_SUCCESS;&#125; ​ class默认访问权限为private,struct默认访问权限为public. 12345678910111213class A&#123; int mAge;&#125;;struct B&#123; int mAge;&#125;;void test()&#123; A a; B b; //a.mAge; //无法访问私有成员 b.mAge; //可正常外部访问&#125; 把变量（属性）和函数（操作）合成一个整体，封装在一个类中 对变量和函数进行访问控制 访问权限 在类的内部(作用域范围内)，没有访问权限之分，所有成员可以相互访问 在类的外部(作用域范围外)，访问权限才有意义：public，private，protected 在类的外部，只有public修饰的成员才能被访问，在没有涉及继承与派生时，private和protected是同等级的，外部不允许访问 将成员变量设置为private 可赋予客户端访问数据的一致性。 ​ 如果成员变量不是public，客户端唯一能够访问对象的方法就是通过成员函数。如果类中所有public权限的成员都是函数，客户在访问类成员时只会默认访问函数，不需要考虑访问的成员需不需要添加(),这就省下了许多搔首弄耳的时间。 可细微划分访问控制。 ​ 使用成员函数可使得我们对变量的控制处理更加精细。如果我们让所有的成员变量为public，每个人都可以读写它。如果我们设置为private，我们可以实现“不准访问”、“只读访问”、“读写访问”，甚至你可以写出“只写访问”。 123456789101112131415class AccessLevels&#123;public: //对只读属性进行只读访问 int getReadOnly()&#123; return readOnly; &#125; //对读写属性进行读写访问 void setReadWrite(int val)&#123; readWrite = val; &#125; int getReadWrite()&#123; return readWrite; &#125; //对只写属性进行只写访问 void setWriteOnly(int val)&#123; writeOnly = val; &#125;private: int readOnly; //对外只读访问 int noAccess; //外部不可访问 int readWrite; //读写访问 int writeOnly; //只写访问&#125;;]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++向上转型]]></title>
    <url>%2F2018%2F06%2F21%2Fc%2B%2B%E7%BB%A7%E6%89%BF4-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在C/C++中经常会发生数据类型的转换，例如将int类型的数据赋值给float类型的变量时，编译器会先把int类型的数据转换为float类型再赋值；反过来，float类型的数据在经过类型转换后也可以赋值给int类型的变量。 向上转型​ 数据类型转换的前提是，编译器知道如何对数据进行取舍。例如： 12int a = 10.9;printf("%d\n", a); ​ 输出结果为10，编译器会将小数部分直接丢掉（不是四舍五入）。再如： 12float b = 10;printf("%f\n", b); ​ 输出结果为10.000000，编译器会自动添加小数部分。 ​ 类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这在C++中称为向上转型（Upcasting）。相应地，将基类赋值给派生类称为向下转型（Downcasting）。 ​ 向上转型非常安全，可以由编译器自动完成；向下转型有风险，需要程序员手动干预。 向上转型和向下转型是面向对象编程的一种通用概念，它们也存在于Java、C#等编程语言中。 将派生类对象赋值给基类对象下面的例子演示了如何将派生类对象赋值给基类对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;//基类class A&#123;public: A(int a);public: void display();public: int m_a;&#125;;A::A(int a): m_a(a)&#123; &#125;void A::display()&#123; cout&lt;&lt;"Class A: m_a="&lt;&lt;m_a&lt;&lt;endl;&#125;//派生类class B: public A&#123;public: B(int a, int b);public: void display();public: int m_b;&#125;;B::B(int a, int b): A(a), m_b(b)&#123; &#125;void B::display()&#123; cout&lt;&lt;"Class B: m_a="&lt;&lt;m_a&lt;&lt;", m_b="&lt;&lt;m_b&lt;&lt;endl;&#125;int main()&#123; A a(10); B b(66, 99); //赋值前 a.display(); b.display(); cout&lt;&lt;"--------------"&lt;&lt;endl; //赋值后 a = b; a.display(); b.display(); return 0;&#125; 运行结果：Class A: m_a=10Class B: m_a=66, m_b=99----------------------------Class A: m_a=66Class B: m_a=66, m_b=99 ​ 本例中A是基类， B是派生类，a、b分别是它们的对象，由于派生类B包含了从基类A继承来的成员，因此可以将派生类对象b赋值给基类对象a。通过运行结果也可以发现，赋值后a所包含的成员变量的值已经发生了变化。 ​ 赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了成员变量，所以对象之间的赋值是成员变量的赋值，成员函数不存在赋值问题。运行结果也有力地证明了这一点，虽然有a=b;这样的赋值过程，但是a.display()始终调用的都是A类的display()函数。换句话说，对象之间的赋值不会影响成员函数，也不会影响this指针。 ​ 将派生类对象赋值给基类对象时，会舍弃派生类新增的成员，也就是“大材小用”，如下图所示： ​ 可以发现，即使将派生类对象赋值给基类对象，基类对象也不会包含派生类的成员，所以依然不同通过基类对象来访问派生类的成员。对于上面的例子，a.m_a是正确的，但a.m_b就是错误的，因为a不包含成员m_b。 ​ 这种转换关系是不可逆的，只能用派生类对象给基类对象赋值，而不能用基类对象给派生类对象赋值。理由很简单，基类不包含派生类的成员变量，无法对派生类的成员变量赋值。同理，同一基类的不同派生类对象之间也不能赋值。 ​ 要理解这个问题，还得从赋值的本质入手。赋值实际上是向内存填充数据，当数据较多时很好处理，舍弃即可；本例中将b赋值给a时（执行a=b;语句），成员m_b是多余的，会被直接丢掉，所以不会发生赋值错误。但当数据较少时，问题就很棘手，编译器不知道如何填充剩下的内存；如果本例中有b= a;这样的语句，编译器就不知道该如何给变量m_b赋值，所以会发生错误。 将派生类指针赋值给基类指针​ 除了可以将派生类对象赋值给基类对象（对象变量之间的赋值），还可以将派生类指针赋值给基类指针（对象指针之间的赋值）。我们先来看一个多继承的例子，继承关系为： 下面的代码实现了这种继承关系： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;using namespace std;//基类Aclass A&#123;public: A(int a);public: void display();protected: int m_a;&#125;;A::A(int a): m_a(a)&#123; &#125;void A::display()&#123; cout&lt;&lt;"Class A: m_a="&lt;&lt;m_a&lt;&lt;endl;&#125;//中间派生类Bclass B: public A&#123;public: B(int a, int b);public: void display();protected: int m_b;&#125;;B::B(int a, int b): A(a), m_b(b)&#123; &#125;void B::display()&#123; cout&lt;&lt;"Class B: m_a="&lt;&lt;m_a&lt;&lt;", m_b="&lt;&lt;m_b&lt;&lt;endl;&#125;//基类Cclass C&#123;public: C(int c);public: void display();protected: int m_c;&#125;;C::C(int c): m_c(c)&#123; &#125;void C::display()&#123; cout&lt;&lt;"Class C: m_c="&lt;&lt;m_c&lt;&lt;endl;&#125;//最终派生类Dclass D: public B, public C&#123;public: D(int a, int b, int c, int d);public: void display();private: int m_d;&#125;;D::D(int a, int b, int c, int d): B(a, b), C(c), m_d(d)&#123; &#125;void D::display()&#123; cout&lt;&lt;"Class D: m_a="&lt;&lt;m_a&lt;&lt;", m_b="&lt;&lt;m_b&lt;&lt;", m_c="&lt;&lt;m_c&lt;&lt;", m_d="&lt;&lt;m_d&lt;&lt;endl;&#125;int main()&#123; A *pa = new A(1); B *pb = new B(2, 20); C *pc = new C(3); D *pd = new D(4, 40, 400, 4000); pa = pd; pa -&gt; display(); pb = pd; pb -&gt; display(); pc = pd; pc -&gt; display(); cout&lt;&lt;"-----------------------"&lt;&lt;endl; cout&lt;&lt;"pa="&lt;&lt;pa&lt;&lt;endl; cout&lt;&lt;"pb="&lt;&lt;pb&lt;&lt;endl; cout&lt;&lt;"pc="&lt;&lt;pc&lt;&lt;endl; cout&lt;&lt;"pd="&lt;&lt;pd&lt;&lt;endl; return 0;&#125; 运行结果：Class A: m_a=4Class B: m_a=4, m_b=40Class C: m_c=400-----------------------pa=0x9b17f8pb=0x9b17f8pc=0x9b1800pd=0x9b17f8 ​ 本例中定义了多个对象指针，并尝试将派生类指针赋值给基类指针。与对象变量之间的赋值不同的是，对象指针之间的赋值并没有拷贝对象的成员，也没有修改对象本身的数据，仅仅是改变了指针的指向。 1) 通过基类指针访问派生类的成员​ 请读者先关注第68行代码，我们将派生类指针pd赋值给了基类指针pa，从运行结果可以看出，调用display()函数时虽然使用了派生类的成员变量，但是display()函数本身却是基类的。也就是说，将派生类指针赋值给基类指针时，通过基类指针只能使用派生类的成员变量，但不能使用派生类的成员函数，这看起来有点不伦不类，究竟是为什么呢？第71、74行代码也是类似的情况。 ​ pa本来是基类A的指针，现在指向了派生类D的对象，这使得隐式指针this 发生了变化，也指向了D类的对象，所以最终在display()内部使用的是D类对象的成员变量，相信这一点不难理解。 ​ 编译器虽然通过指针的指向来访问成员变量，但是却不通过指针的指向来访问成员函数：编译器通过指针的类型来访问成员函数。对于pa，它的类型是A，不管它指向哪个对象，使用的都是A类的成员函数。 ​ 概括起来说就是：编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数。 2) 赋值后值不一致的情况​ 本例中我们将最终派生类的指针pd分别赋值给了基类指针pa、pb、pc，按理说它们的值应该相等，都指向同一块内存，但是运行结果却有力地反驳了这种推论，只有pa、pb、pd三个指针的值相等，pc的值比它们都大。也就是说，执行pc = pd;语句后，pc和pd的值并不相等。 ​ 这非常出乎我们的意料，按照我们通常的理解，赋值就是将一个变量的值交给另外一个变量，不会出现不相等的情况，究竟是什么导致了pc和pd不相等呢？我们将在《将派生类指针赋值给基类指针时到底发生了什么？》一节中解开谜底。 将派生类引用赋值给基类引用​ 引用在本质上是通过指针的方式实现的，既然基类的指针可以指向派生类的对象，那么我们就有理由推断：基类的引用也可以指向派生类的对象，并且它的表现和指针是类似的。 ​ 修改上例中main()函数内部的代码，用引用取代指针： 12345678910111213int main()&#123; D d(4, 40, 400, 4000); A &amp;ra = d; B &amp;rb = d; C &amp;rc = d; ra.display(); rb.display(); rc.display(); return 0;&#125; 运行结果：Class A: m_a=4Class B: m_a=4, m_b=40Class C: m_c=400 ​ ra、rb、rc是基类的引用，它们都引用了派生类对象d，并调用了display()函数，从运行结果可以发现，虽然使用了派生类对象的成员变量，但是却没有使用派生类的成员函数，这和指针的表现是一样的。 ​ 引用和指针的表现之所以如此类似，是因为引用和指针并没有本质上的区别，引用仅仅是对指针进行了简单封装。 ​ 最后需要注意的是，向上转型后通过基类的对象、指针、引用只能访问从基类继承过去的成员（包括成员变量和成员函数），不能访问派生类新增的成员。 将派生类指针赋值给基类指针时到底发生了什么？​ 通过上节最后一个例子我们发现，将派生类的指针赋值给基类的指针后，它们的值有可能相等，也有可能不相等。例如执行pc = pd;语句后，pc的值为0x9b1800，pd的值为0x9b17f8，它们不相等。 ​ 我们通常认为，赋值就是将一个变量的值交给另外一个变量，这种想法虽然没错，但是有一点要注意，就是赋值以前编译器可能会对现有的值进行处理。例如将double类型的值赋给int类型的变量，编译器会直接抹掉小数部分，导致赋值运算符两边变量的值不相等。请看下面的例子： 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; double pi = 3.14159; int n = pi; cout&lt;&lt;pi&lt;&lt;", "&lt;&lt;n&lt;&lt;endl; return 0;&#125; 运行结果：3.14159, 3 ​ pi的值是3.14159，执行int n = pi;后n的值变为3，虽然是赋值，但是pi和n的值并不相等。 ​ 将派生类的指针赋值给基类的指针时也是类似的道理，编译器也可能会在赋值前进行处理。要理解这个问题，首先要清楚D类对象的内存模型，如下图所示： ​ 首先要明确的一点是，对象的指针必须要指向对象的起始位置。对于A类和B类来说，它们的子对象的起始地址和D类对象一样，所以将pd赋值给pa、pb时不需要做任何调整，直接传递现有的值即可；而C类子对象距离D类对象的开头有一定的偏移，将pd赋值给pc时要加上这个偏移，这样pc才能指向C类子对象的起始位置。也就是说，执行pc = pd;语句时编译器对pd的值进行了调整，才导致pc、pd的值不同。 下面的代码演示了将pd赋值给pc时编译器的调整过程：1pc = (C*)( (int)pd + sizeof(B) ); 如果我们把B、C类的继承顺序调整一下，让C在B前面，如下所示：1class D: public C, public B 那么输出结果就会变为：pa=0x317fcpb=0x317fcpc=0x317f8pd=0x317f8]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++虚继承和虚基类]]></title>
    <url>%2F2018%2F06%2F20%2Fc%2B%2B%E7%BB%A7%E6%89%BF3-%E8%99%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[多继承（Multiple Inheritance）是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。 多继承（Multiple Inheritance）​ 多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是菱形继承，如下图所示： ​ 类A派生出类B和类C，类D继承自类B和类C，这个时候类A中的成员变量和成员函数继承到类D中变成了两份，一份来自 A--&gt;B--&gt;D 这条路径，另一份来自A--&gt;C--&gt;D 这条路径。 ​ 在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。假如类A 有一个成员变量a，那么在类D中直接访问a就会产生歧义，编译器不知道它究竟来自 A --&gt;B--&gt;D 这条路径，还是来自 A--&gt;C--&gt;D 这条路径。下面是菱形继承的具体实现：123456789101112131415161718192021222324252627282930313233//间接基类Aclass A&#123;protected: int m_a;&#125;;//直接基类Bclass B: public A&#123;protected: int m_b;&#125;;//直接基类Cclass C: public A&#123;protected: int m_c;&#125;;//派生类Dclass D: public B, public C&#123;public: void seta(int a)&#123; m_a = a; &#125; //命名冲突 void setb(int b)&#123; m_b = b; &#125; //正确 void setc(int c)&#123; m_c = c; &#125; //正确 void setd(int d)&#123; m_d = d; &#125; //正确private: int m_d;&#125;;int main()&#123; D d; return 0;&#125; ​ 这段代码实现了上图所示的菱形继承，第25行代码试图直接访问成员变量 m_a，结果发生了错误，因为类B和类C中都有成员变量 m_a（从A类继承而来），编译器不知道选用哪一个，所以产生了歧义。 ​ 为了消除歧义，我们可以在m_a的前面指明它具体来自哪个类：1void seta(int a)&#123; B::m_a = a; &#125; ​ 这样表示使用B类的m_a。当然也可以使用C类的：1void seta(int a)&#123; C::m_a = a; &#125; 虚继承（Virtual Inheritance）​ 为了解决多继承时的命名冲突和冗余数据问题，C++提出了虚继承，使得在派生类中只保留一份间接基类的成员。 ​ 在继承方式前面加上virtual关键字就是虚继承，请看下面的例子： 123456789101112131415161718192021222324252627282930313233//间接基类Aclass A&#123;protected: int m_a;&#125;;//直接基类Bclass B: virtual public A&#123; //虚继承protected: int m_b;&#125;;//直接基类Cclass C: virtual public A&#123; //虚继承protected: int m_c;&#125;;//派生类Dclass D: public B, public C&#123;public: void seta(int a)&#123; m_a = a; &#125; //正确 void setb(int b)&#123; m_b = b; &#125; //正确 void setc(int c)&#123; m_c = c; &#125; //正确 void setd(int d)&#123; m_d = d; &#125; //正确private: int m_d;&#125;;int main()&#123; D d; return 0;&#125; ​ 这段代码使用虚继承重新实现了上图所示的菱形继承，这样在派生类D中就只保留了一份成员变量 m_a，直接访问就不会再有歧义了。 ​ 虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的A就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。 ​ 现在让我们重新梳理一下本例的继承关系，如下图所示： ​ 观察这个新的继承体系，我们会发现虚继承的一个不太直观的特征：必须在虚派生的真实需求出现前就已经完成虚派生的操作。在上图中，当定义D类时才出现了对虚派生的需求，但是如果B类和C类不是从A类虚派生得到的，那么D类还是会保留A类的两份成员。 ​ 换个角度讲，虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。 ​ 在实际开发中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题。通常情况下，使用虚继承的类层次是由一个人或者一个项目组一次性设计完成的。对于一个独立开发的类来说，很少需要基类中的某一个类是虚基类，况且新类的开发者也无法改变已经存在的类体系。 ​ C++标准库中的 iostream 类就是一个虚继承的实际应用案例。iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。此时istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员。 虚基类成员的可见性​ 因为在虚继承的最终派生类中只保1留了一份虚基类的成员，所以该成员可以被直接访问，不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，那么仍然可以直接访问这个被覆盖的成员。但是如果该成员被两条或多条路径覆盖了，那就不能直接访问了，此时必须指明该成员属于哪个类。 ​ 以图2中的菱形继承为例，假设D定义了一个名为x的成员变量，当我们在D中直接访问x时，会有三种可能性： 如果B和C中都没有x的定义，那么x将被解析为D的成员，此时不存在二义性。如果B或C其中的一个类定义了x，也不会有二义性，派生类的x比虚基类的x优先级更高。如果B和C中都定义了x，那么直接访问x将产生二义性问题。 ​ 可以看到，使用多继承经常会出现二义性问题，必须十分小心。上面的例子是简单的，如果继承的层次再多一些，关系更复杂一些，程序员就很容易陷人迷魂阵，程序的编写、调试和维护工作都会变得更加困难，因此我不提倡在程序中使用多继承，只有在比较简单和不易出现二义性的情况或实在必要时才使用多继承，能用单一继承解决的问题就不要使用多继承。 虚继承时的构造函数​ 在虚继承中，虚基类是由最终的派生类初始化的，换句话说，最终派生类的构造函数必须要调用虚基类的构造函数。对最终的派生类来说，虚基类是间接基类，而不是直接基类。这跟普通继承不同，在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。 下面我们以菱形继承为例来演示构造函数的调用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;//虚基类Aclass A&#123;public: A(int a);protected: int m_a;&#125;;A::A(int a): m_a(a)&#123; &#125;//直接派生类Bclass B: virtual public A&#123;public: B(int a, int b);public: void display();protected: int m_b;&#125;;B::B(int a, int b): A(a), m_b(b)&#123; &#125;void B::display()&#123; cout&lt;&lt;"m_a="&lt;&lt;m_a&lt;&lt;", m_b="&lt;&lt;m_b&lt;&lt;endl;&#125;//直接派生类Cclass C: virtual public A&#123;public: C(int a, int c);public: void display();protected: int m_c;&#125;;C::C(int a, int c): A(a), m_c(c)&#123; &#125;void C::display()&#123; cout&lt;&lt;"m_a="&lt;&lt;m_a&lt;&lt;", m_c="&lt;&lt;m_c&lt;&lt;endl;&#125;//间接派生类Dclass D: public B, public C&#123;public: D(int a, int b, int c, int d);public: void display();private: int m_d;&#125;;D::D(int a, int b, int c, int d): A(a), B(90, b), C(100, c), m_d(d)&#123; &#125;void D::display()&#123; cout&lt;&lt;"m_a="&lt;&lt;m_a&lt;&lt;", m_b="&lt;&lt;m_b&lt;&lt;", m_c="&lt;&lt;m_c&lt;&lt;", m_d="&lt;&lt;m_d&lt;&lt;endl;&#125;int main()&#123; B b(10, 20); b.display(); C c(30, 40); c.display(); D d(50, 60, 70, 80); d.display(); return 0;&#125; 运行结果：123m_a=10, m_b=20m_a=30, m_c=40m_a=50, m_b=60, m_c=70, m_d=80 ​ 请注意第50行代码，在最终派生类D的构造函数中，除了调用B和C的构造函数，还调用了A的构造函数，这说明D不但要负责初始化直接基类B和C，还要负责初始化间接基类A。而在以往的普通继承中，派生类的构造函数只负责初始化它的直接基类，再由直接基类的构造函数初始化间接基类，用户尝试调用间接基类的构造函数将导致错误。 ​ 现在采用了虚继承，虚基类A在最终派生类D中只保留了一份成员变量m_a，如果由B和C初始化 m_a，那么B和C在调用A的构造函数时很有可能给出不同的实参，这个时候编译器就会犯迷糊，不知道使用哪个实参初始化m_a。 ​ 为了避免出现这种矛盾的情况，C++干脆规定必须由最终的派生类D来初始化虚基类A，直接派生类B和C对 A的构造函数的调用是无效的。在第 50行代码中，调用B的构造函数时试图将m_a初始化为90，调用C的构造函数时试图将m_a初始化为100，但是输出结果有力地证明了这些都是无效的，m_a最终被初始化为50，这正是在D中直接调用A的构造函数的结果。 ​ 另外需要关注的是构造函数的执行顺序。虚继承时构造函数的执行顺序与普通继承时不同：在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何，编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数；而对于普通继承，就是按照构造函数出现的顺序依次调用的。 修改本例中第` 50 `行代码，改变构造函数出现的顺序： 1D::D(int a, int b, int c, int d): B(90, b), C(100, c), A(a), m_d(d)&#123; &#125; ​ 虽然我们将A()放在了最后，但是编译器仍然会先调用A()，然后再调用B()、C()，因为A()是虚基类的构造函数，比其他构造函数优先级高。如果没有使用虚继承的话，那么编译器将按照出现的顺序依次调用B()、C()、A()。 虚继承下的内存模型​ 简单的面向对象，只有单继承或多继承的情况下，内存模型很好理解，编译器实现起来也容易，C++的效率和C的效率不相上下。一旦和virtual关键字扯上关系，使用到虚继承或虚函数，内存模型就变得混乱起来，各种编译器的实现也不一致，让人抓狂。 ​ 这是因为C++标准仅对C++的实现做了框架‘性的概述，并没有规定细节如何实现，所以不同厂商的编译器在具体实现方案上会有所差异。 ​ 对于普通继承，基类子对象始终位于派生类对象的前面（也即基类成员变量始终在派生类成员变量的前面），而且不管继承层次有多深，它相对于派生类对象顶部的偏移量是固定的。请看下面的例子： 1234567891011121314151617181920212223242526272829303132class A&#123;protected: int m_a1; int m_a2;&#125;;class B: public A&#123;protected: int b1; int b2;&#125;;class C: public B&#123;protected: int c1; int c2;&#125;;class D: public C&#123;protected: int d1; int d2;&#125;;int main()&#123; A obj_a; B obj_b; C obj_c; D obj_d; return 0;&#125; ​ obj_a、obj_b、obj_c、obj_d 的内存模型如下所示： ​ A是最顶层的基类，在派生类B、C、D的对象中，A类子对象始终位于最前面，偏移量是固定的，为0。b1、b2 是派生类B的新增成员变量，它们的偏移量也是固定的，分别为8和12。c1、c2、d1、d2 也是同样的道理。 ​ 前面我们说过，编译器在知道对象首地址的情况下，通过计算偏移来存取成员变量。对于普通继承，基类成员变量的偏移是固定的，不会随着继承层级的增加而改变，存取起来非常方便。 ​ 而对于虚继承，恰恰和普通继承相反，大部分编译器会把基类成员变量放在派生类成员变量的后面，这样随着继承层级的增加，基类成员变量的偏移就会改变，就得通过其他方案来计算偏移量。 ​ 下面我们来一步一步地分析虚继承时的对象内存模型。 1) 修改上面的代码，使得A是B的虚基类： 1class B: virtual public A 此时obj_b、obj_c、obj_d的内存模型就会发生变化，如下图所示： **不管是虚基类的直接派生类还是间接派生类，虚基类的子对象始终位于派生类对象的最后面**。 2) 再假设A是B的虚基类，B又是C的虚基类，那么各个对象的内存模型如下图所示： 从上面的两张图中可以发现，虚继承时的派生类对象被分成了两部分： 不带阴影的一部分偏移量固定，不会随着继承层次的增加而改变，称为固定部分； 带有阴影的一部分是虚基类的子对象，偏移量会随着继承层次的增加而改变，称为共享部分。 当要访问对象的成员变量时，需要知道对象的首地址和变量的偏移，对象的首地址很好获得，关键是变量的偏移。对于固定部分，偏移是不变的，很好计算；而对于共享部分，偏移会随着继承层次的增加而改变，这就需要设计一种方案，在偏移不断变化的过程中准确地计算偏移。各个编译器正是在设计这一方案时出现了分歧，不同的编译器设计了不同的方案来计算共享部分的偏移。 对于虚继承，将派生类分为固定部分和共享部分，并把共享部分放在最后，几乎所有的编译器都在这一点上达成了共识。主要的分歧就是如何计算共享部分的偏移，可谓是百花齐放，没有统一标准。 cfront解决方案​ 早期的 cfront 编译器会在派生类对象中安插一些指针，每个指针指向一个虚基类的子对象，要存取继承来的成员变量，可以使用指针间接完成。 1) 如果A是B的虚基类，那么各个对象的实际内存模型如下所示： ​ 编译器会在直接派生类的对象 obj_b 中安插一个指针，指向虚基类A的起始位置，并且这个指针的偏移是固定的，不会随着继承层次的增加而改变。当要访问 a1、a2 时，要先通过对象指针找到pa，再通过pa找到 a1、a2，这样一来就比没有虚继承时多了一层间接。 ​ 假设p是obj_d的指针，现在要访问成员变量 a2： 1int member_a2 = p -&gt; a2; ​ 那么编译器内部会进行类似下面的转换： 12A *pa = (A*)( *(int*)( (int)p + sizeof(int)*2 ) );int member_a2 = *(int*)( (int)pa + sizeof(int) ); 2) 如果A是B的虚基类，同时B也是C的虚基类，那么各个对象的实际内存模型如下所示： ​ 当要访问 a1、a2 时，要先通过对象指针找到 pb，再通过 pb 找到 pa，最后才能通过 pa 找到 a1、a2，这样一来就比没有虚继承时多了两层间接。 ​ 通过上面的分析可以发现，这种方案的一个缺点就是，随着虚继承层次的增加，访问顶层基类需要的间接转换会越来越多，效率越来越低。 ​ 这种方案另外的一个缺点是：当有多个虚基类时，派生类要为每个虚基类都安插一个指针，会增加对象的体积。 ​ 例如，假设A、B、C、D类的继承关系为： ​ obj_d 的内存模型如下图所示： ​ D有三个虚基类，所以obj_d对象要额外背负三个指针 pa、pab、pc。 VC解决方案​ cfront 的后来者 VC 尝试对上面的方案进行了改进，一定程度上弥补了它的不足。 ​ VC 引入了虚基类表，如果某个派生类有一个或多个虚基类，编译器就会在派生类对象中安插一个指针，指向虚基类表。虚基类表其实就是一个数组，数组中的元素存放的是各个虚基类的偏移。 ​ 假设A是B的虚基类，那么各对象的内存模型如下图所示： ​ 假设A是B的虚基类，同时B又是C的虚基类，那么各对象的内存模型如下图所示： ​ 虚继承表中保存的是所有虚基类（包括直接继承和间接继承到的）相对于当前对象的偏移，这样通过派生类指针访问虚基类的成员变量时，不管继承层次都多深，只需要一次间接转换就可以。 ​ 另外，这种方案还可以避免有多个虚基类时让派生类对象额外背负过多的指针。例如，假设A、B、C、D类的继承关系为： ​ 那么 obj_d 的内存模型如下图所示： ​ 如此一来，D类虽然有三个虚基类，但它的对象obj_d只需要额外背负一个指针。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++单继承和多继承]]></title>
    <url>%2F2018%2F06%2F17%2Fc%2B%2B%E7%BB%A7%E6%89%BF2-%E5%8D%95%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[单继承没有继承时对象内存的分布情况很简单，成员变量和成员函数会分开存储： 对象的内存中只包含成员变量，存储在栈区或堆区（使用new创建对象）； 成员函数与对象内存分离，存储在代码区。 当存在继承关系时，内存模型会稍微复杂一些。 继承时的内存模型​ 有继承关系时，派生类的内存模型可以看成是基类成员变量和新增成员变量的总和，而所有成员函数仍然存储在另外一个区域——代码区，由所有对象共享。请看下面的代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;using namespace std;//基类Aclass A&#123;public: A(int a, int b);public: void display();protected: int m_a; int m_b;&#125;;A::A(int a, int b): m_a(a), m_b(b)&#123;&#125;void A::display()&#123; printf("m_a=%d, m_b=%d\n", m_a, m_b);&#125;//派生类Bclass B: public A&#123;public: B(int a, int b, int c); void display();private: int m_c;&#125;;B::B(int a, int b, int c): A(a, b), m_c(c)&#123; &#125;void B::display()&#123; printf("m_a=%d, m_b=%d, m_c=%d\n", m_a, m_b, m_c);&#125;int main()&#123; A obj_a(99, 10); B obj_b(84, 23, 95); obj_a.display(); obj_b.display(); return 0;&#125; ​ obj_a是基类对象，obj_b是派生类对象。假设obj_a的起始地址为0X1000，那么它的内存分布如下图所示： ​ 假设obj_b的起始地址为0X1100，那么它的内存分布如下图所示： ​ 可以发现，基类的成员变量排在前面，派生类的排在后面。 ​ 为了让大家理解更加透彻，我们不妨再由B类派生出一个C类： 1234567891011121314151617//声明并定义派生类Cclass C: public B&#123;public: C(char a, int b, int c, int d);public: void display();private: int m_d;&#125;;C::C(char a, int b, int c, int d): B(a, b, c), m_d(d)&#123; &#125;void C::display()&#123; printf("m_a=%d, m_b=%d, m_c=%d, m_d=%d\n", m_a, m_b, m_c, m_d);&#125;//创建C类对象obj_cC obj_c(84, 23, 95, 60);obj_c.display(); ​ 假设obj_c的起始地址为0X1200，那么它的内存分布如下图所示： ​ 成员变量按照派生的层级依次排列，新增成员变量始终在最后。 有成员变量遮蔽时的内存分布​ 更改上面的C 类，让它的成员变量遮蔽A类和B类的成员变量： 1234567891011121314151617181920//声明并定义派生类Cclass C: public B&#123;public: C(char a, int b, int c, int d);public: void display();private: int m_b; //遮蔽A类的成员变量 int m_c; //遮蔽B类的成员变量 int m_d; //新增成员变量&#125;;C::C(char a, int b, int c, int d): B(a, b, c), m_b(b), m_c(c), m_d(d)&#123; &#125;void C::display()&#123; printf("A::m_a=%d, A::m_b=%d, B::m_c=%d\n", m_a, A::m_b, B::m_c); printf("C::m_b=%d, C::m_c=%d, C::m_d=%d\n", m_b, m_c, m_d);&#125;//创建C类对象obj_cC obj_c(84, 23, 95, 60);obj_c.display(); ​ 假设obj_c的起始地址为0X1300，那么它的内存分布如下图所示： ​ 当基类A、B的成员变量被遮蔽时，仍然会留在派生类对象obj_c 的内存中，C类新增的成员变量始终排在基类A、B的后面。 ​ 总结：在派生类的对象模型中，会包含所有基类的成员变量。这种设计方案的优点是访问效率高，能够在派生类对象中直接访问基类变量，无需经过好几层间接计算。 继承中的构造和析构对象构造和析构的调用原则继承中的构造和析构 子类对象在创建时会首先调用父类的构造函数 父类构造函数执行完毕后，才会调用子类的构造函数 派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。 当父类构造函数有参数时，需要在子类初始化列表(参数列表)中显示调用父类构造函数 析构函数调用顺序和构造函数相反 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;//基类Peopleclass People&#123;protected: char *m_name; int m_age;public: People(char*, int);&#125;;People::People(char *name, int age): m_name(name), m_age(age)&#123;&#125;//派生类Studentclass Student: public People&#123;private: float m_score;public: Student(char *name, int age, float score); void display();&#125;;//People(name, age)就是调用基类的构造函数Student::Student(char *name, int age, float score): People(name, age), m_score(score)&#123; &#125;void Student::display()&#123; cout&lt;&lt;m_name&lt;&lt;"的年龄是"&lt;&lt;m_age&lt;&lt;"，成绩是"&lt;&lt;m_score&lt;&lt;"。"&lt;&lt;endl;&#125;int main()&#123; Student stu("小明", 16, 90.5); stu.display(); return 0;&#125; 运行结果为：小明的年龄是16，成绩是90.5。 ​ 请注意第23行代码： 1Student::Student(char *name, int age, float score): People(name, age), m_score(score)&#123; &#125; ​ People(name, age)就是调用基类的构造函数，并将name和age作为实参传递给它，m_score(score)是派生类的参数初始化表，它们之间以逗号,隔开。 也可以将基类构造函数的调用放在参数初始化表后面： 1Student::Student(char *name, int age, float score): m_score(score), People(name, age)&#123; &#125; ​ 但是不管它们的顺序如何，派生类构造函数总是先调用基类构造函数再执行其他代码（包括参数初始化表以及函数体中的代码），总体上看和下面的形式类似： 1234Student::Student(char *name, int age, float score)&#123; People(name, age); m_score = score;&#125; ​ 当然这段代码只是为了方便大家理解，实际上这样写是错误的，因为基类构造函数不会被继承，不能当做普通的成员函数来调用。换句话说，只能将基类构造函数的调用放在函数头部，不能放在函数体中。 继承与组合混搭的构造和析构 1234567891011121314151617181920212223242526272829303132333435363738394041class D&#123;public: D()&#123; cout &lt;&lt; "D类构造函数!" &lt;&lt; endl; &#125; ~D()&#123; cout &lt;&lt; "D类析构函数!" &lt;&lt; endl; &#125;&#125;;class A&#123;public: A()&#123; cout &lt;&lt; "A类构造函数!" &lt;&lt; endl; &#125; ~A()&#123; cout &lt;&lt; "A类析构函数!" &lt;&lt; endl; &#125;&#125;;class B : public A&#123;public: B()&#123; cout &lt;&lt; "B类构造函数!" &lt;&lt; endl; &#125; ~B()&#123; cout &lt;&lt; "B类析构函数!" &lt;&lt; endl; &#125;&#125;;class C : public B&#123;public: C()&#123; cout &lt;&lt; "C类构造函数!" &lt;&lt; endl; &#125; ~C()&#123; cout &lt;&lt; "C类析构函数!" &lt;&lt; endl; &#125;public: D d;&#125;;void test()&#123; C c;&#125; 多继承​ 派生类都只有一个基类，称为单继承（Single Inheritance）。除此之外，C++也支持多继承（Multiple Inheritance），即一个派生类可以有两个或多个基类。 ​ 多继承的语法也很简单，将多个基类用逗号隔开即可。例如已声明了类A、类B和类C，那么可以这样来声明派生类D：123class D: public A, private B, protected C&#123; //类D新增加的成员 &#125; ​ D是多继承形式的派生类，它以公有的方式继承A类，以私有的方式继承B类，以保护的方式继承C类。D根据不同的继承方式获取A、B、C中的成员，确定它们在派生类中的访问权限。 多继承下的构造函数​ 多继承形式下的构造函数和单继承形式基本相同，只是要在派生类的构造函数中调用多个基类的构造函数。以上面的A、B、C、D类为例，D类构造函数的写法为：123D(形参列表): A(实参列表), B(实参列表), C(实参列表)&#123; //其他操作 &#125; ​ 基类构造函数的调用顺序和和它们在派生类构造函数中出现的顺序无关，而是和声明派生类时基类出现的顺序相同。仍然以上面的A、B、C、D类为例，即使将D类构造函数写作下面的形式：123D(形参列表): B(实参列表), C(实参列表), A(实参列表)&#123; //其他操作 &#125; ​ 那么也是先调用A类的构造函数，再调用B类构造函数，最后调用C类构造函数。 ​ 下面是一个多继承的实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;using namespace std;//基类class BaseA&#123;public: BaseA(int a, int b); ~BaseA();protected: int m_a; int m_b;&#125;;BaseA::BaseA(int a, int b): m_a(a), m_b(b)&#123; cout&lt;&lt;"BaseA constructor"&lt;&lt;endl;&#125;BaseA::~BaseA()&#123; cout&lt;&lt;"BaseA destructor"&lt;&lt;endl;&#125;//基类class BaseB&#123;public: BaseB(int c, int d); ~BaseB();protected: int m_c; int m_d;&#125;;BaseB::BaseB(int c, int d): m_c(c), m_d(d)&#123; cout&lt;&lt;"BaseB constructor"&lt;&lt;endl;&#125;BaseB::~BaseB()&#123; cout&lt;&lt;"BaseB destructor"&lt;&lt;endl;&#125;//派生类class Derived: public BaseA, public BaseB&#123;public: Derived(int a, int b, int c, int d, int e); ~Derived();public: void show();private: int m_e;&#125;;Derived::Derived(int a, int b, int c, int d, int e): BaseA(a, b), BaseB(c, d), m_e(e)&#123; cout&lt;&lt;"Derived constructor"&lt;&lt;endl;&#125;Derived::~Derived()&#123; cout&lt;&lt;"Derived destructor"&lt;&lt;endl;&#125;void Derived::show()&#123; cout&lt;&lt;m_a&lt;&lt;", "&lt;&lt;m_b&lt;&lt;", "&lt;&lt;m_c&lt;&lt;", "&lt;&lt;m_d&lt;&lt;", "&lt;&lt;m_e&lt;&lt;endl;&#125;int main()&#123; Derived obj(1, 2, 3, 4, 5); obj.show(); return 0;&#125; ​ 运行结果：BaseA constructorBaseB constructorDerived constructor1, 2, 3, 4, 5Derived destructorBaseB destructorBaseA destructor ​ 从运行结果中还可以发现，多继承形式下析构函数的执行顺序和构造函数的执行顺序相同。 多继承命名冲突​ 当两个或多个基类中有同名的成员时，如果直接访问该成员，就会产生命名冲突，编译器不知道使用哪个基类的成员。这个时候需要在成员名字前面加上类名和域解析符::，以显式地指明到底使用哪个类的成员，消除二义性。 ​ 修改上面的代码，为BaseA和BaseB类添加show()函数，并将Derived类的show()函数更名为 display()： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;using namespace std;//基类class BaseA&#123;public: BaseA(int a, int b); ~BaseA();public: void show();protected: int m_a; int m_b;&#125;;BaseA::BaseA(int a, int b): m_a(a), m_b(b)&#123; cout&lt;&lt;"BaseA constructor"&lt;&lt;endl;&#125;BaseA::~BaseA()&#123; cout&lt;&lt;"BaseA destructor"&lt;&lt;endl;&#125;void BaseA::show()&#123; cout&lt;&lt;"m_a = "&lt;&lt;m_a&lt;&lt;endl; cout&lt;&lt;"m_b = "&lt;&lt;m_b&lt;&lt;endl;&#125;//基类class BaseB&#123;public: BaseB(int c, int d); ~BaseB(); void show();protected: int m_c; int m_d;&#125;;BaseB::BaseB(int c, int d): m_c(c), m_d(d)&#123; cout&lt;&lt;"BaseB constructor"&lt;&lt;endl;&#125;BaseB::~BaseB()&#123; cout&lt;&lt;"BaseB destructor"&lt;&lt;endl;&#125;void BaseB::show()&#123; cout&lt;&lt;"m_c = "&lt;&lt;m_c&lt;&lt;endl; cout&lt;&lt;"m_d = "&lt;&lt;m_d&lt;&lt;endl;&#125;//派生类class Derived: public BaseA, public BaseB&#123;public: Derived(int a, int b, int c, int d, int e); ~Derived();public: void display();private: int m_e;&#125;;Derived::Derived(int a, int b, int c, int d, int e): BaseA(a, b), BaseB(c, d), m_e(e)&#123; cout&lt;&lt;"Derived constructor"&lt;&lt;endl;&#125;Derived::~Derived()&#123; cout&lt;&lt;"Derived destructor"&lt;&lt;endl;&#125;void Derived::display()&#123; BaseA::show(); //调用BaseA类的show()函数 BaseB::show(); //调用BaseB类的show()函数 cout&lt;&lt;"m_e = "&lt;&lt;m_e&lt;&lt;endl;&#125;int main()&#123; Derived obj(1, 2, 3, 4, 5); obj.display(); return 0;&#125; ​ 请读者注意第64、65行代码，我们显式的指明了要调用哪个基类的show()函数。 多继承时的对象内存模型​ 我们来分析一下多继承时对象的内存模型。请读者先看下面的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;using namespace std;//基类Aclass A&#123;public: A(int a, int b);protected: int m_a; int m_b;&#125;;A::A(int a, int b): m_a(a), m_b(b)&#123; &#125;//基类Bclass B&#123;public: B(int b, int c);protected: int m_b; int m_c;&#125;;B::B(int b, int c): m_b(b), m_c(c)&#123; &#125;//派生类Cclass C: public A, public B&#123;public: C(int a, int b, int c, int d);public: void display();private: int m_a; int m_c; int m_d;&#125;;C::C(int a, int b, int c, int d): A(a, b), B(b, c), m_a(a), m_c(c), m_d(d)&#123; &#125;void C::display()&#123; printf("A::m_a=%d, A::m_b=%d\n", A::m_a, A::m_b); printf("B::m_b=%d, B::m_c=%d\n", B::m_b, B::m_c); printf("C::m_a=%d, C::m_c=%d, C::m_d=%d\n", C::m_a, C::m_c, m_d);&#125;int main()&#123; C obj_c(10, 20, 30, 40); obj_c.display(); return 0;&#125; 运行结果： A::m_a=10, A::m_b=20B::m_b=20, B::m_c=30C::m_a=10, C::m_c=30, C::m_d=40 ​ A、B是基类，C是派生类，假设obj_c的起始地址是0X1000，那么obj_c的内存分布如下图所示： 基类对象的排列顺序和继承时声明的顺序相同。 继承中的静态成员特性​ 静态成员函数和非静态成员函数的共同点: 他们都可以被继承到派生类中。 如果重新定义一个静态成员函数，所有在基类中的其他重载函数会被隐藏。 如果我们改变基类中一个函数的特征，所有使用该函数名的基类版本都会被隐藏。 静态成员函数不能是虚函数 123456789101112131415161718192021222324252627class Base&#123;public: static int getNum()&#123; return sNum; &#125; static int getNum(int param)&#123; return sNum + param; &#125;public: static int sNum;&#125;;int Base::sNum = 10;class Derived : public Base&#123;public: static int sNum; //基类静态成员属性将被隐藏#if 0 //重定义一个函数，基类中重载的函数被隐藏 static int getNum(int param1, int param2)&#123; return sNum + param1 + param2; &#125;#else //改变基类函数的某个特征，返回值或者参数个数，将会隐藏基类重载的函数 static void getNum(int param1, int param2)&#123; cout &lt;&lt; sNum + param1 + param2 &lt;&lt; endl; &#125;#endif&#125;;int Derived::sNum = 20;]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++类的继承]]></title>
    <url>%2F2018%2F06%2F16%2Fc%2B%2B%E7%BB%A7%E6%89%BF1-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承基本概念​ c++最重要的特征是代码重用，通过继承机制可以利用已有的数据类型来定义新的数据类型，新的类不仅拥有旧类的成员，还拥有新定义的成员。 ​ 一个B类继承于A类，或称从类A派生类B。这样的话，类A成为基类（父类）， 类B成为派生类（子类）。 ​ 派生类中的成员，包含两大部分： 一类是从基类继承过来的，一类是自己增加的成员。 从基类继承过过来的表现其共性，而新增的成员体现了其个性。 派生类定义派生类定义格式123Class 派生类名 : 继承方式 基类名&#123; //派生类新增的数据成员和成员函数&#125; 三种继承方式： public ： 公有继承 private ： 私有继承 protected ： 保护继承 从继承源上分： 单继承：指每个派生类只直接继承了一个基类的特征 多继承：指多个基类派生出一个派生类的继承关系,多继承的派生类直接继承了不止一个基类的特征 派生类访问控制​ 继承方式是public、protected、private ，不同的继承方式会影响基类成员在派生类中的访问权限。 1) public继承方式 基类中所有public成员在派生类中为public属性； 基类中所有protected成员在派生类中为protected属性； 基类中所有private成员在派生类中不能使用。 2) protected继承方式 基类中的所有public成员在派生类中为protected属性； 基类中的所有protected成员在派生类中为protected属性； 基类中的所有private成员在派生类中不能使用。 3) private继承方式 基类中的所有public成员在派生类中均为private属性； 基类中的所有protected成员在派生类中均为private属性； 基类中的所有private成员在派生类中不能使用。 通过上面的分析可以发现： 1) 基类成员在派生类中的访问权限不得高于继承方式中指定的权限。例如，当继承方式为protected时，那么基类成员在派生类中的访问权限最高也为protected，高于protected的会降级为protected，但低于protected不会升级。再如，当继承方式为public时，那么基类成员在派生类中的访问权限将保持不变。也就是说，继承方式中的public、protected、private是用来指明基类成员在派生类中的最高访问权限的。 2) 不管继承方式如何，基类中的private成员在派生类中始终不能使用（不能在派生类的成员函数中访问或调用）。 3) 如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为public或protected；只有那些不希望在派生类中使用的成员才声明为private。 4) 如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为protected。 ​ 注意，我们这里说的是基类的private成员不能在派生类中使用，并没有说基类的private成员不能被继承。实际上，基类的private成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。private成员的这种特性，能够很好的对派生类隐藏基类的实现，以体现面向对象的封装性。 继承方式/基类成员 public成员 protected成员 private成员 public继承 public protected 不可见 protected继承 protected protected 不可见 private继承 private private 不可见 ​ 由于private和protected继承方式会改变基类成员在派生类中的访问权限，导致继承关系复杂，所以实际开发中我们一般使用public。 【示例】演示类的继承关系。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;using namespace std;//基类Peopleclass People&#123;public: void setname(char *name); void setage(int age); void sethobby(char *hobby); char *gethobby();protected: char *m_name; int m_age;private: char *m_hobby;&#125;;void People::setname(char *name)&#123; m_name = name; &#125;void People::setage(int age)&#123; m_age = age; &#125;void People::sethobby(char *hobby)&#123; m_hobby = hobby; &#125;char *People::gethobby()&#123; return m_hobby; &#125;//派生类Studentclass Student: public People&#123;public: void setscore(float score);protected: float m_score;&#125;;void Student::setscore(float score)&#123; m_score = score; &#125;//派生类Pupilclass Pupil: public Student&#123;public: void setranking(int ranking); void display();private: int m_ranking;&#125;;void Pupil::setranking(int ranking)&#123; m_ranking = ranking; &#125;void Pupil::display()&#123; cout&lt;&lt;m_name&lt;&lt;"的年龄是"&lt;&lt;m_age&lt;&lt;"，考试成绩为"&lt;&lt;m_score&lt;&lt;"分，班级排名第"&lt;&lt;m_ranking&lt;&lt;"，TA喜欢"&lt;&lt;gethobby()&lt;&lt;"。"&lt;&lt;endl;&#125;int main()&#123; Pupil pup; pup.setname("小明"); pup.setage(15); pup.setscore(92.5f); pup.setranking(4); pup.sethobby("乒乓球"); pup.display(); return 0;&#125; 运行结果：小明的年龄是15，考试成绩为92.5分，班级排名第4，TA喜欢乒乓球。 ​ 这是一个多级继承的例子，Student继承自People，Pupil又继承自Student，它们的继承关系为People --&gt; Student --&gt; Pupil。Pupil是最终的派生类，它拥有基类的m_name、m_age、m_score、m_hobby成员变量以及setname()、setage()、sethobby()、gethobby()、setscore()成员函数。 ​ 注意，在派生类Pupil的成员函数display()中，我们借助基类的public成员函数gethobby()来访问基类的private成员变量m_bobby，因为m_hobby是private属性的，在派生类中不可见，所以只能借助基类的public成员函数sethobby()、gethobby()来访问。 ​ 在派生类中访问基类private成员的唯一方法就是借助基类的非private成员函数，如果基类没有非private成员函数，那么该成员在派生类中将无法访问。 改变访问权限​ 使用using关键字可以改变基类成员在派生类中的访问权限，例如将public改为private、将protected改为public。 ​ 注意：using只能改变基类中public和protected成员的访问权限，不能改变private成员的访问权限，因为基类中private成员在派生类中是不可见的，根本不能使用，所以基类中的private成员在派生类中无论如何都不能访问。 ​ using关键字使用示例： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;//基类Peopleclass People &#123;public: void show();protected: char *m_name; int m_age;&#125;;void People::show() &#123; cout &lt;&lt; m_name &lt;&lt; "的年龄是" &lt;&lt; m_age &lt;&lt; endl;&#125;//派生类Studentclass Student : public People &#123;public: void learning();public: using People::m_name; //将protected改为public using People::m_age; //将protected改为public float m_score;private: using People::show; //将public改为private&#125;;void Student::learning() &#123; cout &lt;&lt; "我是" &lt;&lt; m_name &lt;&lt; "，今年" &lt;&lt; m_age &lt;&lt; "岁，这次考了" &lt;&lt; m_score &lt;&lt; "分！" &lt;&lt; endl;&#125;int main() &#123; Student stu; stu.m_name = "小明"; stu.m_age = 16; stu.m_score = 99.5f; stu.show(); //compile error stu.learning(); return 0;&#125; ​ 代码中首先定义了基类People，它包含两个protected属性的成员变量和一个public属性的成员函数。定义Student类时采用public继承方式，People类中的成员在Student类中的访问权限默认是不变的。 ​ 不过，我们使用using改变了它们的默认访问权限，如代码第21~25行所示，将show()函数修改为private属性的，是降低访问权限，将name、age变量修改为public属性的，是提高访问权限。 ​ 因为show()函数是private属性的，所以代码第36行会报错。把该行注释掉，程序输出结果为：我是小明，今年16岁，这次考了99.5分！ 非自动继承的函数​ 不是所有的函数都能自动从基类继承到派生类中。构造函数和析构函数用来处理对象的创建和析构操作，构造和析构函数只知道对它们的特定层次的对象做什么，也就是说构造函数和析构函数不能被继承，必须为每一个特定的派生类分别创建。 ​ 另外operator=也不能被继承，因为它完成类似构造函数的行为。也就是说尽管我们知道如何由=右边的对象如何初始化=左边的对象的所有成员，但是这个并不意味着对其派生类依然有效。 ​ 在继承的过程中，如果没有创建这些函数，编译器会自动生成它们。 继承时的名字遮蔽​ 如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，那么就会遮蔽从基类继承过来的成员。所谓遮蔽，就是在派生类中使用该成员（包括在定义派生类时使用，也包括通过派生类对象访问该成员）时，实际上使用的是派生类新增的成员，而不是从基类继承来的。 ​ 下面是一个成员函数的名字遮蔽的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;//基类Peopleclass People&#123;public: void show();protected: char *m_name; int m_age;&#125;;void People::show()&#123; cout&lt;&lt;"嗨，大家好，我叫"&lt;&lt;m_name&lt;&lt;"，今年"&lt;&lt;m_age&lt;&lt;"岁"&lt;&lt;endl;&#125;//派生类Studentclass Student: public People&#123;public: Student(char *name, int age, float score);public: void show(); //遮蔽基类的show()private: float m_score;&#125;;Student::Student(char *name, int age, float score)&#123; m_name = name; m_age = age; m_score = score;&#125;void Student::show()&#123; cout&lt;&lt;m_name&lt;&lt;"的年龄是"&lt;&lt;m_age&lt;&lt;"，成绩是"&lt;&lt;m_score&lt;&lt;endl;&#125;int main()&#123; Student stu("小明", 16, 90.5); //使用的是派生类新增的成员函数，而不是从基类继承的 stu.show(); //使用的是从基类继承来的成员函数 stu.People::show(); return 0;&#125; 运行结果：小明的年龄是16，成绩是90.5嗨，大家好，我叫小明，今年16岁 ​ 本例中，基类People和派生类Student都定义了成员函数show()，它们的名字一样，会造成遮蔽。第37行代码中，stu是Student类的对象，默认使用Student类的show()函数。 ​ 但是，基类People中的show()函数仍然可以访问，不过要加上类名和域解析符，如第39行代码所示。 基类成员函数和派生类成员函数不构成重载​ 基类成员和派生类成员的名字一样时会造成遮蔽，这句话对于成员变量很好理解，对于成员函数要引起注意，不管函数的参数如何，只要名字一样就会造成遮蔽。换句话说，基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。 ​ 下面的例子很好的说明了这一点： 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;//基类Baseclass Base&#123;public: void func(); void func(int);&#125;;void Base::func()&#123; cout&lt;&lt;"Base::func()"&lt;&lt;endl; &#125;void Base::func(int a)&#123; cout&lt;&lt;"Base::func(int)"&lt;&lt;endl; &#125;//派生类Derivedclass Derived: public Base&#123;public: void func(char *); void func(bool);&#125;;void Derived::func(char *str)&#123; cout&lt;&lt;"Derived::func(char *)"&lt;&lt;endl; &#125;void Derived::func(bool is)&#123; cout&lt;&lt;"Derived::func(bool)"&lt;&lt;endl; &#125;int main()&#123; Derived d; d.func("c.biancheng.net"); d.func(true); d.func(); //compile error d.func(10); //compile error d.Base::func(); d.Base::func(100); return 0;&#125; ​ 本例中，Base类的func()、func(int)和 Derived 类的func(char *)、func(bool)四个成员函数的名字相同，参数列表不同，它们看似构成了重载，能够通过对象d访问所有的函数，实则不然，Derive类的func遮蔽了Base类的func，导致第26、27行代码没有匹配的函数，所以调用失败。 ​ 如果说有重载关系，那么也是Base类的两个func构成重载，而Derive类的两个func构成另外的重载。 类继承时的作用域嵌套​ 类其实也是一种作用域，每个类都会定义它自己的作用域，在这个作用域内我们再定义类的成员。当存在继承关系时，派生类的作用域嵌套在基类的作用域之内，如果一个名字在派生类的作用域内无法找到，编译器会继续到外层的基类作用域中查找该名字的定义。 ​ 换句话说，作用域能够彼此包含，被包含（或者说被嵌套）的作用域称为内层作用域（inner scope），包含着别的作用域的作用域称为外层作用域（outer scope）。一旦在外层作用域中声明（或者定义）了某个名字，那么它所嵌套着的所有内层作用域中都能访问这个名字。同时，允许在内层作用域中重新定义外层作用域中已有的名字。 ​ 假设Base是基类，Derived是派生类，那么它们的作用域的嵌套关系如下图所示： ​ 派生类的作用域位于基类作用域之内这一事实可能有点出人意料，毕竟在我们的代码中派生类和基类的定义是相互分离的。不过也恰恰因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样来使用基类的成员。 ​ 一个类作用域嵌套的例子： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;class A&#123;public: void func();public: int n;&#125;;void A::func()&#123; cout&lt;&lt;"c.biancheng.net"&lt;&lt;endl; &#125;class B: public A&#123;public: int n; int m;&#125;;class C: public B&#123;public: int n; int x;&#125;;int main()&#123; C obj; obj.n; obj.func(); cout&lt;&lt;sizeof(C)&lt;&lt;endl; return 0;&#125; 运行结果：c.biancheng.net20 本例中，B继承自A，C继承自B，它们作用域的嵌套关系如下图所示： ​ obj是C类的对象，通过obj访问成员变量n时，在C类的作用域中就能够找到了n这个名字。虽然A类和B类都有名字n，但编译器不会到它们的作用域中查找，所以是不可见的，也即派生类中的n遮蔽了基类中的n。 ​ 通过obj访问成员函数func()时，在C类的作用域中没有找到func这个名字，编译器继续到B类的作用域（外层作用域）中查找，仍然没有找到，再继续到A类的作用域中查找，结果就发现了func这个名字，于是查找结束，编译器决定调用A类作用域中的func()函数。 ​ 这个过程叫做名字查找（name lookup），也就是在作用域链中寻找与所用名字最匹配的声明（或定义）的过程。 ​ 对于成员变量这个过程很好理解，对于成员函数要引起注意，编译器仅仅是根据函数的名字来查找的，不会理会函数的参数。换句话说，一旦内层作用域有同名的函数，不管有几个，编译器都不会再到外层作用域中查找，编译器仅把内层作用域中的这些同名函数作为一组候选函数；这组候选函数就是一组重载函数。 ​ 说白了，只有一个作用域内的同名函数才具有重载关系，不同作用域内的同名函数是会造成遮蔽，使得外层函数无效。派生类和基类拥有不同的作用域，所以它们的同名函数不具有重载关系。 ​ 我们不妨再来回顾一下上节的例子： 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;//基类Baseclass Base&#123;public: void func(); void func(int);&#125;;void Base::func()&#123; cout&lt;&lt;"Base::func()"&lt;&lt;endl; &#125;void Base::func(int a)&#123; cout&lt;&lt;"Base::func(int)"&lt;&lt;endl; &#125;//派生类Derivedclass Derived: public Base&#123;public: void func(char *); void func(bool);&#125;;void Derived::func(char *str)&#123; cout&lt;&lt;"Derived::func(char *)"&lt;&lt;endl; &#125;void Derived::func(bool is)&#123; cout&lt;&lt;"Derived::func(bool)"&lt;&lt;endl; &#125;int main()&#123; Derived d; d.func("c.biancheng.net"); d.func(true); d.func(); //compile error d.func(10); //compile error d.Base::func(); d.Base::func(100); return 0;&#125; ​ 虽然Derived类和Base类都有同名的func函数，但它们位于不同的作用域，Derived类的func会遮蔽Base类的func。d是Derived类的对象，调用func函数时，编译器会先在Derived 类中查找“func”这个名字，发现有两个，也即void func(char*)和void func(bool)，这就是一组候选函数。 ​ 执行到第26、27行代码时，在候选函数中没有找到匹配的函数，所以调用失败，这时编译器会抛出错误信息，而不是再到Base类中查找同名函数。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++引用和指针的异同]]></title>
    <url>%2F2018%2F06%2F15%2Fc%2B%2B%E5%9F%BA%E7%A1%8011-%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"><![CDATA[引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样。 引用和指针的异同引用的含义​ 通过上节的讲解，相信各位读者对引用都有了一个概念上的认识，能够简单地使用引用编程了，但又感觉糊里糊涂，不明白它到底是什么，它和指针有点相似，但又不是一个东西。 ​ 首先来回顾一下上节的例子： 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 99; int &amp;b = a; cout&lt;&lt;a&lt;&lt;", "&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;&amp;a&lt;&lt;", "&lt;&lt;&amp;b&lt;&lt;endl; return 0;&#125; ​ 运行结果：1299, 990x28ff44, 0x28ff44 ​ 我们知道，变量是要占用内存的，虽然我们称b为变量，但是通过&amp;b获取到的却不是b的地址，而是a的地址，这会让我们觉得b这个变量不占用独立的内存，它和a指代的是同一份内存。 引用和指针的联系​ 请读者再继续看下面的例子： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int num = 99;class A&#123;public: A();private: int n; int &amp;r;&#125;;A::A(): n(0), r(num)&#123;&#125;int main ()&#123; A *a = new A(); cout&lt;&lt;sizeof(A)&lt;&lt;endl; //输出A类型的大小 cout&lt;&lt;hex&lt;&lt;showbase&lt;&lt;*((int*)a + 1)&lt;&lt;endl; //输出r的内容 cout&lt;&lt;&amp;num&lt;&lt;endl; //输出num变量的地址 return 0;&#125; ​ 运行结果：12380x4420000x442000 ​ 成员变量r是private属性的，不能直接通过对象来访问，但是借助强大的指针和类型转换，我们依然可以得到它的内容，只不过这种方法有点蹩脚。 ​ 第20行代码中，hex表示以十六进制输出，showbase表示添加十六进制前缀0x。 ​ 从运行结果可以看出： 成员变量r是占用内存的，如果不占用的话，sizeof(A)的结果应该为4。 r存储的内容是0x442000，也即变量num的地址。 这说明r的实现和指针非常类似。如果将r定义为int *类型的指针，并在构造函数中让它指向num，那么r占用的内存也是4个字节，存储的内容也是num的地址。 ​ 其实引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样，在32位环境下是4个字节，在64位环境下是8个字节，之所以不能获取引用的地址，是因为编译器进行了内部转换。 ​ 以下面的语句为例： 1234int a = 99;int &amp;r = a;r = 18;cout&lt;&lt;&amp;r&lt;&lt;endl; ​ 编译时会被转换成如下的形式： 1234int a = 99;int *r = &amp;a;*r = 18;cout&lt;&lt;r&lt;&lt;endl; ​ 使用&amp;r取地址时，编译器会对代码进行隐式的转换，使得代码输出的是r的内容（a的地址），而不是r的地址，这就是为什么获取不到引用变量的地址的原因。 ​ 也就是说，不是变量r不占用内存，而是编译器不让获取它的地址。 ​ 当引用作为函数参数时，也会有类似的转换。以下面的代码为例： 12345678910//定义函数void swap(int &amp;a, int &amp;b)&#123; int temp = a; a = b; b = temp;&#125;//调用函数int num1 = 10, num2 = 20;swap(num1, num2); ​ 编译时会被转换成如下的形式： 12345678910//定义函数void swap(int *a, int *b)&#123; int temp = *a; *a = *b; *b = temp;&#125;//调用函数int num1 = 10, num2 = 20;swap(&amp;num1, &amp;num2); ​ 引用虽然是基于指针实现的，但它比指针更加易用，从上面的两个例子也可以看出来，通过指针获取数据时需要加*，书写麻烦，而引用不需要，它和普通变量的使用方式一样。 ​ C++的发明人 Bjarne Stroustrup 也说过，他在C++中引入引用的直接目的是为了让代码的书写更加漂亮，尤其是在运算符重载中，不借助引用有时候会使得运算符的使用很麻烦。 引用和指针的区别​ 1) 引用必须在定义时初始化，并且以后也要从一而终，不能再指向其他数据；而指针没有这个限制，指针在定义时不必赋值，以后也能指向任意数据。 ​ 2) 可以有const指针，但是没有const引用。也就是说，引用变量不能定义为下面的形式： 12int a = 20;int &amp; const r = a; ​ 因为r本来就不能改变指向，加上const是多此一举。 ​ 3) 指针可以有多级，但是引用只能有一级。例如，int **p是合法的，而int &amp;&amp;r是不合法的。如果希望定义一个引用变量来指代另外一个引用变量，那么也只需要加一个&amp;，如下所示： 123int a = 10;int &amp;r = a;int &amp;rr = r; ​ 4) 指针和引用的自增（++）自减（--）运算意义不一样。对指针使用++表示指向下一份数据，对引用使用++表示它所指代的数据本身加1；自减（--）也是类似的道理。请看下面的例子： 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main ()&#123; int a = 10; int &amp;r = a; r++; cout&lt;&lt;r&lt;&lt;endl; int arr[2] = &#123; 27, 84 &#125;; int *p = arr; p++; cout&lt;&lt;*p&lt;&lt;endl; return 0;&#125; ​ 运行结果：121184]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++命名空间]]></title>
    <url>%2F2018%2F06%2F13%2Fc%2B%2B%E5%9F%BA%E7%A1%8010-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[一个中大型软件往往由多名程序员共同开发，会使用大量的变量和函数，不可避免地会出现变量或函数的命名冲突。当所有人的代码都测试通过，没有问题时，将它们结合到一起就有可能会出现命名冲突。 ​ 例如小李和小韩都参与了一个文件管理系统的开发，它们都定义了一个全局变量fp，用来指明当前打开的文件，将他们的代码整合在一起编译时，很明显编译器会提示fp重复定义（Redefinition）错误。 命名空间 为了解决合作开发时的命名冲突问题，C++引入了命名空间（Namespace）的概念。请看下面的例子： 123456namespace Li&#123; //小李的变量定义 FILE fp = NULL;&#125;namespace Han&#123; //小韩的变量定义 FILE fp = NULL&#125; ​ 小李与小韩各自定义了以自己姓氏为名的命名空间，此时再将他们的fp变量放在一起编译就不会有任何问题。 命名空间有时也被称为名字空间、名称空间。 ​ namespace是C++中的关键字，用来定义一个命名空间，语法格式为： 123namespace name&#123; //variables, functions, classes &#125; ​ name是命名空间的名字，它里面可以包含变量、函数、类、typedef、#define等，最后由{ }包围。 ​ 使用变量、函数时要指明它们所在的命名空间。以上面的fp变量为例，可以这样来使用： 12Li::fp = fopen("one.txt", "r"); //使用小李定义的变量 fpHan::fp = fopen("two.txt", "rb+"); //使用小韩定义的变量 fp ​ ::是一个新符号，称为域解析操作符，在C++中用来指明要使用的命名空间。 ​ 除了直接使用域解析操作符，还可以采用using关键字声明，例如： 123using Li::fp;fp = fopen("one.txt", "r"); //使用小李定义的变量 fpHan :: fp = fopen("two.txt", "rb+"); //使用小韩定义的变量 fp ​ 在代码的开头用using声明了Li::fp，它的意思是，using声明以后的程序中如果出现了未指明命名空间的fp，就使用Li::fp；但是若要使用小韩定义的fp，仍然需要Han::fp。 ​ using声明不仅可以针对命名空间中的一个变量，也可以用于声明整个命名空间。例如： 123using namespace Li;fp = fopen("one.txt", "r"); //使用小李定义的变量 fpHan::fp = fopen("two.txt", "rb+"); //使用小韩定义的变量 fp ​ 如果命名空间Li中还定义了其他的变量，那么同样具有fp变量的效果。在using声明后，如果有未具体指定命名空间的变量产生了命名冲突，那么默认采用命名空间Li中的变量。 ​ 命名空间内部不仅可以声明或定义变量，对于其它能在命名空间以外声明或定义的名称，同样也都能在命名空间内部进行声明或定义，例如类、函数、typedef、#define等都可以出现在命名空间中。 ​ 站在编译和链接的角度，代码中出现的变量名、函数名、类名等都是一种符号（Symbol）。有的符号可以指代一个内存位置，例如变量名、函数名；有的符号仅仅是一个新的名称，例如typedef定义的类型别名。 ​ 下面来看一个命名空间完整示例代码： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;//将类定义在命名空间中namespace Diy&#123; class Student&#123; public: char *name; int age; float score; public: void say()&#123; printf("%s的年龄是 %d，成绩是 %f\n", name, age, score); &#125; &#125;;&#125;int main()&#123; Diy::Student stu1; stu1.name = "小明"; stu1.age = 15; stu1.score = 92.5f; stu1.say(); return 0;&#125; 运行结果：小明的年龄是 15，成绩是 92.500000 C++和C头文件差别​ C++是在C语言的基础上开发的，早期的C++还不完善，不支持命名空间，没有自己的编译器，而是将C++代码翻译成C代码，再通过C编译器完成编译。这个时候的C++仍然在使用C语言的库，stdio.h、stdlib.h、string.h等头文件依然有效；此外C++也开发了一些新的库，增加了自己的头文件，例如： iostream.h：用于控制台输入输出头文件。 fstream.h：用于文件操作的头文件。 complex.h：用于复数计算的头文件。 和C语言一样，C++头文件仍然以.h为后缀，它们所包含的类、函数、宏等都是全局范围的。 ​ 后来C++引入了命名空间的概念，计划重新编写库，将类、函数、宏等都统一纳入一个命名空间，这个命名空间的名字就是std。std 是standard的缩写，意思是“标准命名空间”。 ​ 但是这时已经有很多用老式C++开发的程序了，它们的代码中并没有使用命名空间，直接修改原来的库会带来一个很严重的后果：程序员会因为不愿花费大量时间修改老式代码而极力反抗，拒绝使用新标准的C++代码。 ​ C++开发人员想了一个好办法，保留原来的库和头文件，它们在C++中可以继续使用，然后再把原来的库复制一份，在此基础上稍加修改，把类、函数、宏等纳入命名空间std下，就成了新版C++标准库。这样共存在了两份功能相似的库，使用了老式C++的程序可以继续使用原来的库，新开发的程序可以使用新版的C++库。 ​ 为了避免头文件重名，新版C++库也对头文件的命名做了调整，去掉了后缀.h，所以老式C++的iostream.h变成了iostream，fstream.h变成了fstream。而对于原来C语言的头文件，也采用同样的方法，但在每个名字前还要添加一个c字母，所以C语言的stdio.h变成了cstdio，stdlib.h变成了cstdlib。 ​ 需要注意的是，旧的C++头文件是官方所反对使用的，已明确提出不再支持，但旧的C头文件仍然可以使用，以保持对C的兼容性。实际上，编译器开发商不会停止对客户现有软件提供支持，可以预计，旧的C++头文件在未来数年内还是会被支持。 ​ 下面是我总结的C++ 头文件的现状： 1)、 旧的C++头文件，如iostream.h、fstream.h等将会继续被支持，尽管它们不在官方标准中。这些头文件的内容不在命名空间std中。 2)、 新的C++头文件，如iostream、fstream等包含的基本功能和对应的旧版头文件相似，但头文件的内容在命名空间std中。 注意：在标准化的过程中，库中有些部分的细节被修改了，所以旧的头文件和新的头文件不一定完全对应。 3) 、标准C头文件如stdio.h、stdlib.h等继续被支持。头文件的内容不在std中。 4) 、具有C库功能的新C++头文件具有如cstdio、cstdlib这样的名字。它们提供的内容和相应的旧的C头文件相同，只是内容在std中。 ​ 可以发现，对于不带.h的头文件，所有的符号都位于命名空间std中，使用时需要声明命名空间std；对于带.h的头文件，没有使用任何命名空间，所有符号都位于全局作用域。这也是C++标准所规定的。 ​ 不过现实情况和C++标准所期望的有些不同，对于原来C语言的头文件，即使按照C++的方式来使用，即#include这种形式，那么符号可以位于命名空间std中，也可以位于全局范围中，请看下面的两段代码。 1) 、使用命名空间std： 12345#include &lt;cstdio&gt;int main()&#123; std::printf("http://c.biancheng.net\n"); return 0;&#125; 2) 、不使用命名空间std： 12345#include &lt;cstdio&gt;int main()&#123; printf("http://c.biancheng.net\n"); return 0;&#125; ​ 这两种形式在Microsoft Visual C++和GCC下都能够编译通过，也就是说，大部分编译器在实现时并没有严格遵循C++标准，它们对两种写法都支持，程序员可以使用std也可以不使用。 ​ 第1)种写法是标准的，第2)种不标准，虽然它们在目前的编译器中都没有错误，但依然推荐使用第1)种写法，因为标准写法会一直被编译器支持，非标准写法可能会在以后的升级版本中不再支持。 使用C++的头文件​ 虽然C++几乎完全兼容C语言，C语言的头文件在C++中依然被支持，但C++新增的库更加强大和灵活，请读者尽量使用这些C++新增的头文件，例如iostream、fstream、string等。 ​ 前面我们使用了C语言的格式输出函数printf，引入了C语言的头文件stdio.h，将C代码和C++代码混合在了一起，不推荐这样做，请尽量使用C++的方式。下面的例子演示了如何使用C++库进行输入输出： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123; //声明命名空间std using namespace std; //定义字符串变量 string str; //定义 int 变量 int age; //从控制台获取用户输入 cin&gt;&gt;str&gt;&gt;age; //将数据输出到控制台 cout&lt;&lt;str&lt;&lt;"已经成立"&lt;&lt;age&lt;&lt;"年了！"&lt;&lt;endl; return 0;&#125; 运行结果：C语言中文网↙6↙C语言中文网已经成立6年了！ ​ string是C++中的字符串类，初学者可以将string看做一种内置的数据类型，就像int、float等，可以用来定义变量。cin用于从控制台获取用户输入，cout用于将数据输出到控制台。 ​ 读者暂时不需要深入了解这段代码的细节，只需要留意using namespace std;，它声明了命名空间std，后续如果有未指定命名空间的符号，那么默认使用std，代码中的string、cin、cout都位于命名空间 std。 ​ 在main()函数中声明命名空间std，它的作用范围就位于main()函数内部，如果在其他函数中又用到了 std，就需要重新声明，请看下面的例子： 1234567891011121314151617#include &lt;iostream&gt;void func()&#123; //必须重新声明 using namespace std; cout&lt;&lt;"http://c.biancheng.net"&lt;&lt;endl;&#125;int main()&#123; //声明命名空间std using namespace std; cout&lt;&lt;"C语言中文网"&lt;&lt;endl; func(); return 0;&#125; 如果希望在所有函数中都使用命名空间std，可以将它声明在全局范围中，例如： 123456789101112131415#include &lt;iostream&gt;//声明命名空间stdusing namespace std;void func()&#123; cout&lt;&lt;"http://c.biancheng.net"&lt;&lt;endl;&#125;int main()&#123; cout&lt;&lt;"C语言中文网"&lt;&lt;endl; func(); return 0;&#125; ​ 很多教程中都是这样做的，将std直接声明在所有函数外部，这样虽然使用方便，但在中大型项目开发中是不被推荐的，这样做增加了命名冲突的风险，推荐在函数内部声明std。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++函数的默认参数]]></title>
    <url>%2F2018%2F06%2F10%2Fc%2B%2B%E5%9F%BA%E7%A1%809-%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在C++中，定义函数时可以给形参指定一个默认的值，这样调用函数时如果没有给这个形参赋值（没有对应的实参），那么就使用这个默认的值。也就是说，调用函数时可以省略有默认值的参数。如果用户指定了参数的值，那么就使用用户指定的值，否则使用参数的默认值。 默认参数​ 所谓默认参数，指的是当函数调用中省略了实参时自动使用的一个值，这个值就是给形参指定的默认值。下面是一个简单的示例： 123456789101112131415161718#include&lt;iostream&gt;using namespace std;//带默认参数的函数void func(int n, float b=1.2, char c='@')&#123; cout&lt;&lt;n&lt;&lt;", "&lt;&lt;b&lt;&lt;", "&lt;&lt;c&lt;&lt;endl;&#125;int main()&#123; //为所有参数传值 func(10, 3.5, '#'); //为n、b传值，相当于调用func(20, 9.8, '@') func(20, 9.8); //只为n传值，相当于调用func(30, 1.2, '@') func(30); return 0;&#125; 运行结果：10, 3.5, #20, 9.8, @30, 1.2, @ ​ 本例定义了一个带有默认参数的函数func()，并在main()函数中进行了不同形式的调用。为参数指定默认值非常简单，直接在形参列表中赋值即可，与定义普通变量的形式类似。 ​ 指定了默认参数后，调用函数时就可以省略对应的实参了。 ​ 默认参数除了使用数值常量指定，也可以使用表达式指定，例如： 1234float d = 10.8;void func(int n, float b=d+2.9, char c='@')&#123; cout&lt;&lt;n&lt;&lt;", "&lt;&lt;b&lt;&lt;", "&lt;&lt;c&lt;&lt;endl;&#125; ​ C++规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。实参和形参的传值是从左到右依次匹配的，默认参数的连续性是保证正确传参的前提。 ​ 下面的写法是正确的： 12void func(int a, int b=10, int c=20)&#123; &#125;void func(int a, int b, int c=20)&#123; &#125; ​ 但这样写不可以： 12void func(int a, int b=10, int c=20, int d)&#123; &#125;void func(int a, int b=10, int c, int d=20)&#123; &#125; ​ 默认参数并非编程方面的重大突破，而只是提供了一种便捷的方式。在以后设计类时你将发现，通过使用默认参数，可以减少要定义的析构函数、方法以及方法重载的数量。 ​ 例子中，我们在函数定义处指定了默认参数。除了函数定义，你也可以在函数声明处指定默认参数。 默认参数指定位置​ 我们在函数定义处指定了默认参数。除了函数定义，你也可以在函数声明处指定默认参数。不过当出现函数声明时情况会变得稍微复杂，有时候你可以在声明处和定义处同时指定默认参数，有时候你只能在声明处指定，请看下面的例子（示例1）： 12345678910111213#include &lt;iostream&gt;using namespace std;void func(int a, int b = 10, int c = 36);int main()&#123; func(99); return 0;&#125;void func(int a, int b = 10, int c = 36)&#123; cout&lt;&lt;a&lt;&lt;", "&lt;&lt;b&lt;&lt;", "&lt;&lt;c&lt;&lt;endl;&#125; ​ 这段代码在编译时会报错，错误信息表明不能在函数定义和函数声明中同时指定默认参数。对代码稍作修改，将 func()函数的定义放到其他源文件中，如下所示（示例2）。 ​ main.cpp代码： 123456789#include &lt;iostream&gt;using namespace std;void func(int a, int b = 10, int c = 36);int main()&#123; func(99); return 0;&#125; ​ module.cpp代码： 123456#include &lt;iostream&gt;using namespace std;void func(int a, int b = 10, int c = 36)&#123; cout&lt;&lt;a&lt;&lt;", "&lt;&lt;b&lt;&lt;", "&lt;&lt;c&lt;&lt;endl;&#125; 运行结果：99, 10, 36 ​ 修改后的代码是可以编译通过的，这有点让人摸 不着头脑，为什么将func()的定义放到其他源文件中就不一样了呢？ ​ 这是因为C++规定，在给定的作用域中只能指定一次默认参数。 ​ 对于示例1，func()的定义和声明位于同一个源文件，它们的作用域也都是整个源文件，这样就导致在同一个文件作用域中指定了两次默认参数，违反了C++的规定。 ​ 对于示例2，func()的声明位于main.cpp，作用域也是main.cpp，而func()的定义位于module.cpp，作用域也是module.cpp，func()的声明和定义位于不同的作用域，相互之间不影响。 ​ C语言有四种作用域，分别是函数原型作用域、局部作用域（函数作用域）、块作用域、文件作用域（全局作用域），C++也有这几种作用域。 ​ 继续对代码进行修改，将func()定义处b、c的默认值分别设置为 5、57，而声明处b、c的默认值不变，依然为 10、36。编译并运行程序，发现输出结果与上面一样，这说明编译器使用的是当前作用域中的默认参数。站在编译器的角度看，它不管当前作用域中是函数声明还是函数定义，只要有默认参数就可以使用。 多次声明同一函数​ 在多文件编程时，我们通常的做法是将函数声明放在头文件中，并且一个函数只声明一次，但是多次声明同一函数也是合法的。 ​ 不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认参数。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认值，而且该形参右侧的所有形参必须都有默认值。 ​ 为了说明问题，我们不妨对main.cpp中的代码稍作修改： 1234567891011#include &lt;iostream&gt;using namespace std;//多次声明同一个函数void func(int a, int b, int c = 36);void func(int a, int b = 5, int c);int main()&#123; func(99); return 0;&#125; ​ 这种声明方式是正确的。第一次声明时为c指定了默认值，第二次声明时为b指定了默认值；第二次声明是添加默认参数。需要提醒的是，第二次声明时不能再次给c指定默认参数，否则就是重复声明同一个默认参数。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++bool类型]]></title>
    <url>%2F2018%2F06%2F05%2Fc%2B%2B%E5%9F%BA%E7%A1%808-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8Bbool%2F</url>
    <content type="text"><![CDATA[在C语言中，关系运算和逻辑运算的结果有两种，真和假：0表示假，非0表示真。 例如： 123456789#include &lt;stdio.h&gt;int main()&#123; int a, b, flag; scanf("%d %d", &amp;a, &amp;b); flag = a &gt; b; //flag保存关系运算结果 printf("flag = %d\n", flag); return 0;&#125; 运行结果： 10 20↙flag = 0 ​ C语言并没有彻底从语法上支持“真”和“假”，只是用0和非0来代表。这点在C++中得到了改善，C++新增了 bool类型（布尔类型），它一般占用1个字节长度。bool类型只有两个取值，true和false：true表示“真”，false表示“假”。 ​ bool是类型名字，也是C++中的关键字，它的用法和int、char、long是一样的，请看下面的例子： 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int a, b; bool flag; //定义布尔变量 cin&gt;&gt;a&gt;&gt;b; flag = a &gt; b; cout&lt;&lt;"flag = "&lt;&lt;flag&lt;&lt;endl; return 0;&#125; 10 20↙flag = 0 ​ 遗憾的是，在C++中使用cout输出bool变量的值时还是用数字1和0表示，而不是true或false。Java、PHP、JavaScript等也都支持布尔类型，但输出结果为true或false。 你也可以使用` true `或` false `显式地对` bool `变量赋值，例如： 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main()&#123; bool flag = true; if(flag)&#123; cout&lt;&lt;"true"&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;"false"&lt;&lt;endl; &#125; flag = false; if(flag)&#123; cout&lt;&lt;"true"&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;"false"&lt;&lt;endl; &#125; return 0;&#125; ​ 运行结果：truefalse 注意，true和false是C++中的关键字，true表示“真”，false表示“假”。 ​ 在C++的编码中，推荐使用bool变量来表示逻辑运算、关系运算以及开关变量的值。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++变量定义位置]]></title>
    <url>%2F2018%2F06%2F04%2Fc%2B%2B%E5%9F%BA%E7%A1%807-%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[C++不但在C语言的基础上进行了很多扩展，而且也对C语言部分做了细节上的改进，变量的定义位置就是其中之一。 ​ C89规定，所有局部变量都必须定义在函数开头，在定义好变量之前不能有其他的执行语句。C99标准取消这这条限制，但是VC/VS对C99的支持很不积极，仍然要求变量定义在函数开头。 C89和C99是两套不同的C语言标准，C99是C89的升级版。 请看下面的代码： 1234567891011#include &lt;stdio.h&gt;int main()&#123; int a; scanf("%d", &amp;a); int b; scanf("%d", &amp;b); int c = a + b; printf("%d\n", c); return 0;&#125; ​ 将代码保存到源文件main.c，那么它可以在GCC、Xcode下编译通过，但在VC/VS下会报错。GCC、Xcode对C99的支持非常好，可以在函数的任意位置定义变量；但VC/VS对C99的支持寥寥无几，必须在函数开头定义好所有变量。 将上面的代码再保存到源文件`main.cpp`，那么它在` GCC`、`Xcode`、`VC/VS `下都可以编译通过。这是因为 `C++ `取消了原来的限制，变量只要在使用之前定义好即可，不强制必须在函数开头定义所有变量。 注意源文件的后缀，.c是C语言代码，.cpp是C++代码，它们的编译方式不同。 ​ 取消限制带来的另外一个好处是，可以在for循环的控制语句中定义变量，请看下面的例子： 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int sum(int n)&#123; int total = 0; //在for循环的条件语句内部定义变量i for(int i=1; i&lt;=n ;i++)&#123; total += i; &#125; return total;&#125;int main()&#123; cout&lt;&lt;"Input a interge: "; int n; cin&gt;&gt;n; cout&lt;&lt;"Total: "&lt;&lt;sum(n)&lt;&lt;endl; return 0;&#125; 运行结果： 12Input a interge: 10Total: 55 ​ 在for内部定义循环控制变量i，会让代码看起来更加紧凑，并使得i的作用域被限制在整个for循环语句内部（包括循环条件和循环体），减小了命名冲突的概率。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++new和delete运算符]]></title>
    <url>%2F2018%2F06%2F03%2Fc%2B%2B%E5%9F%BA%E7%A1%806-new%E5%92%8Cdelete%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[在C语言中，动态分配内存用malloc()函数，释放内存用free()函数。如下所示： 12int *p = (int*) malloc( sizeof(int) * 10 ); //分配10个int型的内存空间free(p); //释放内存 ​ 在C++中，这两个函数仍然可以使用，但是C++又新增了两个关键字，new和delete：new用来动态分配内存，delete用来释放内存。 ​ 用new和delete分配内存更加简单： 12int *p = new int; //分配1个int型的内存空间delete p; //释放内存 ​ new操作符会根据后面的数据类型来推断所需空间的大小。 ​ 如果希望分配一组连续的数据，可以使用new[]： 12int *p = new int[10]; //分配10个int型的内存空间delete[] p; ​ 用new[]分配的内存需要用delete[]释放，它们是一一对应的。 ​ 和malloc()一样，new也是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收。为了避免内存泄露，通常new和delete、new[]和 delete[]操作符应该成对出现，并且不要和C语言中 malloc()、free()一起混用。 ​ 在C++中，建议使用new和delete来管理内存，它们可以使用C++的一些新特性，最明显的是可以自动调用构造函数和析构函数，后续我们将会讲解。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++重载、重定义与重载]]></title>
    <url>%2F2018%2F06%2F01%2Fc%2B%2B%E5%9F%BA%E7%A1%805-%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%AE%9A%E4%B9%89%E3%80%81%E9%87%8D%E5%86%99%E5%B7%AE%E5%BC%82%2F</url>
    <content type="text"><![CDATA[重载 同一个作用域 参数个数，参数顺序，参数类型不同 和函数返回值，没有关系 const也可以作为重载条件 12do(const Teacher&amp; t)&#123;&#125; do(Teacher&amp; t) 重定义（隐藏） 有继承 子类（派生类）重新定义父类（基类）的同名成员（非virtual函数） 重写（覆盖） 有继承 子类（派生类）重写父类（基类）的virtual函数 函数返回值，函数名字，函数参数，必须和基类中的虚函数一致 1234567891011121314151617class A&#123;public: //同一作用域下，func1函数重载 void func1()&#123;&#125; void func1(int a)&#123;&#125; void func1(int a,int b)&#123;&#125; void func2()&#123;&#125; virtual void func3()&#123;&#125;&#125;;class B : public A&#123;public: //重定义基类的func2,隐藏了基类的func2方法 void func2()&#123;&#125; //重写基类的func3函数，也可以覆盖基类func3 virtual void func3()&#123;&#125;&#125;;]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++内联函数]]></title>
    <url>%2F2018%2F05%2F30%2Fc%2B%2B%E5%9F%BA%E7%A1%803-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%2F</url>
    <content type="text"><![CDATA[函数是一个可以重复使用的代码块，CPU会一条一条地挨着执行其中的代码。CPU在执行主调函数代码时如果遇到了被调函数，主调函数就会暂停，CPU转而执行被调函数的代码；被调函数执行完毕后再返回到主调函数，主调函数根据刚才的状态继续往下执行。 ​ 一个C/C++程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条，这个链条的起点是main()，终点也是main()。当main()调用完了所有的函数，它会返回一个值（例如return 0;）来结束自己的生命，从而结束整个程序。 ​ 函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。 ​ 如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视。 内联函数消除函数调用​ 为了消除函数调用的时空开销，C++提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。 ​ 指定内联函数的方法很简单，只需要在函数定义处增加inline关键字。请看下面的例子： 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;//内联函数，交换两个数的值inline void swap(int *a, int *b)&#123; int temp; temp = *a; *a = *b; *b = temp;&#125;int main()&#123; int m, n; cin&gt;&gt;m&gt;&gt;n; cout&lt;&lt;m&lt;&lt;", "&lt;&lt;n&lt;&lt;endl; swap(&amp;m, &amp;n); cout&lt;&lt;m&lt;&lt;", "&lt;&lt;n&lt;&lt;endl; return 0;&#125; 运行结果：45 99↙45, 9999, 45 ​ 注意，要在函数定义处添加inline关键字，在函数声明处添加inline关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的inline关键字。 ​ 当编译器遇到函数调用swap(&amp;m, &amp;n)时，会用swap()函数的代码替换swap(&amp;m, &amp;n)，同时用实参代替形参。这样，程序第16行就被置换成： 1234int temp;temp = *(&amp;m);*(&amp;m) = *(&amp;n);*(&amp;n) = temp; ​ 编译器可能会将*(&amp;m)、*(&amp;n)分别优化为m、n。 ​ 当函数比较复杂时，函数调用的时空开销可以忽略，大部分的CPU时间都会花费在执行函数体代码上，所以我们一般是将非常短小的函数声明为内联函数。 ​ 由于内联函数比较短小，我们通常的做法是省略函数原型，将整个函数定义（包括函数头和函数体）放在本应该提供函数原型的地方。下面的例子是一个反面教材，这样的写法是不被推荐的： 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;//声明内联函数void swap1(int *a, int *b); //也可以添加inline，但编译器会忽略int main()&#123; int m, n; cin&gt;&gt;m&gt;&gt;n; cout&lt;&lt;m&lt;&lt;", "&lt;&lt;n&lt;&lt;endl; swap1(&amp;m, &amp;n); cout&lt;&lt;m&lt;&lt;", "&lt;&lt;n&lt;&lt;endl; return 0;&#125;//定义内联函数inline void swap1(int *a, int *b)&#123; int temp; temp = *a; *a = *b; *b = temp;&#125; ​ 使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数。 ​ 最后需要说明的是，对函数作inline声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为inline编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。 取代带参数的宏​ 宏是可以带参数的，它在形式上和函数非常相似。不过不像函数，宏仅仅是字符串替换，不是按值传递，所以在编写宏时要特别注意，一不小心可能就会踩坑。 ​ 使用宏的一个经典例子是求一个数的平方，如下所示： 123456789101112#include &lt;iostream&gt;using namespace std;#define SQ(y) y*yint main()&#123; int n, sq; cin&gt;&gt;n; sq = SQ(n); cout&lt;&lt;sq&lt;&lt;endl; return 0;&#125; 运行结果：9↙81 ​ 从表面上看这个宏定义是正确的，但当我们将宏调用SQ(n)换成SQ(n+1)后，就会出现意想不到的状况： 123456789101112#include &lt;iostream&gt;using namespace std;#define SQ(y) y*yint main()&#123; int n, sq; cin&gt;&gt;n; sq = SQ(n+1); cout&lt;&lt;sq&lt;&lt;endl; return 0;&#125; 运行结果：9↙ 19 ​ 我们期望的结果是100，但这里却是19，两者大相径庭。这是因为，宏展开仅仅是字符串的替换，不会进行任何计算或传值，上面的sq = SQ(n+1);在宏展开后会变为sq = n+1*n+1;，这显然是没有道理的。 ​ 如果希望得到正确的结果，应该将宏定义改为如下的形式： 1#define SQ(y) (y)*(y) ​ 这样宏调用sq = SQ(n+1);就会展开为sq = (n+1)*(n+1);，得到的结果就是100。 ​ 如果你认为这样就万事大吉了，那下面的结果会让你觉得考虑不周： 123456789101112#include &lt;iostream&gt;using namespace std;#define SQ(y) (y)*(y)int main()&#123; int n, sq; cin&gt;&gt;n; sq = 200 / SQ(n+1); cout&lt;&lt;sq&lt;&lt;endl; return 0;&#125; 运行结果：9↙200 之所以会出现这么奇怪的结果，是因为宏调用`sq = 200 / SQ(n+1);`会被展开为`sq = 200 / (n+1) * (n+1);`，当 n 被赋值 9 后，相当于`sq = 200 / 10 * 10`，结果显然是 200。 ​ 要想得到正确的结果，还应该对宏加以限制，在两边增加( )，如下所示： 1#define SQ(y) ( (y)*(y) ) ​ 这样宏调用sq = 200 / SQ(n+1);就会展开为sq = 200 / ( (n+1) * (n+1) );，得到的结果就是2。 ​ 宏定义是一项“细思极密”的工作，一不小心就会踩坑，而且不一定在编译和运行时发现，给程序埋下隐患。 ​ 如果我们将宏替换为内联函数，情况就没有那么复杂了，程序员就会游刃有余，请看下面的代码： 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;inline int SQ(int y)&#123; return y*y; &#125;int main()&#123; int n, sq; cin&gt;&gt;n; //SQ(n) sq = SQ(n); cout&lt;&lt;sq&lt;&lt;endl; //SQ(n+1) sq = SQ(n+1); cout&lt;&lt;sq&lt;&lt;endl; //200 / SQ(n+1) sq = 200 / SQ(n+1); cout&lt;&lt;sq&lt;&lt;endl; return 0;&#125; 运行结果：9↙811002 ​ 看，一切问题迎刃而解！发生函数调用时，编译器会先对实参进行计算，再将计算的结果传递给形参，并且函数执行完毕后会得到一个值，而不是得到一个表达式，这和简单的字符串替换相比省去了很多麻烦，所以在编写C++代码时我推荐使用内联函数来替换带参数的宏。 ​ 和宏一样，内联函数可以定义在头文件中（不用加static关键字），并且头文件被多次#include后也不会引发重复定义错误。这一点和非内联函数不同，非内联函数是禁止定义在头文件中的，它所在的头文件被多次#include后会引发重复定义错误。 ​ 内联函数在编译时会将函数调用处用函数体替换，编译完成后函数就不存在了，所以在链接时不会引发重复定义错误。这一点和宏很像，宏在预处理时被展开，编译时就不存在了。从这个角度讲，内联函数更像是编译期间的宏。 ​ 可以看到内联函数主要有两个作用，一是消除函数调用时的开销，二是取代带参数的宏。不过我更倾向于后者，取代带参数的宏更能凸显内联函数存在的意义。 类内部的内联函数​ 为了定义内联函数，通常必须在函数定义前面放一个inline关键字。但是在类内部定义内联函数时并不是必须的。任何在类内部定义的函数自动成为内联函数。 12345class Person&#123;public: Person()&#123; cout &lt;&lt; "构造函数!" &lt;&lt; endl; &#125; void PrintPerson()&#123; cout &lt;&lt; "输出Person!" &lt;&lt; endl; &#125;&#125; ​ 构造函数Person，成员函数PrintPerson在类的内部定义，自动成为内联函数。 规范使用内联函数​ inline关键字可以只在函数定义处添加，也可以只在函数声明处添加，也可以同时添加；但是在函数声明处添加inline关键字是无效的，编译器会忽略函数声明处的inline关键字。也就是说，inline是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。 ​ 尽管大多数教科书中在函数声明和函数定义处都增加了inline关键字，但我认为inline关键字不应该出现在函数声明处。这个细节虽然不会影响函数的功能，但是体现了高质量C++程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。 ​ 更为严格地说，内联函数不应该有声明，应该将函数定义放在本应该出现函数声明的地方，这是一种良好的编程风格。 ​ 在多文件编程中，我们通常将函数的定义放在源文件中，将函数的声明放在头文件中，希望调用函数时，引入对应的头文件即可，我们鼓励这种将函数定义和函数声明分开的做法。但这种做法不适用于内联函数，将内联函数的声明和定义分散到不同的文件中会出错，请看下面的例子。 ​ main.cpp代码： 12345678910#include &lt;iostream&gt;using namespace std;//内联函数声明void func();int main()&#123; func(); return 0;&#125; ​ module.cpp代码： 1234567#include &lt;iostream&gt;using namespace std;//内联函数定义inline void func()&#123; cout&lt;&lt;"inline function"&lt;&lt;endl;&#125; ​ 上面的代码能够正常编译，但在链接时会出错。func()是内联函数，编译期间会用它来替换函数调用处，编译完成后函数就不存在了，链接器在将多个目标文件（.o或.obj文件）合并成一个可执行文件时找不到func()函数的定义，所以会产生链接错误。 ​ 内联函数虽然叫做函数，在定义和声明的语法上也和普通函数一样，但它已经失去了函数的本质。函数是一段可以重复使用的代码，它位于虚拟地址空间中的代码区，也占用可执行文件的体积，而内联函数的代码在编译后就被消除了，不存在于虚拟地址空间中，没法重复使用。 ​ 内联函数看起来简单，但是有很多细节需要注意，从代码重复利用的角度讲，内联函数已经不再是函数了。我认为将内联函数作为带参宏的替代方案更为靠谱，而不是真的当做函数使用。 ​ 在多文件编程时，我建议将内联函数的定义直接放在头文件中，并且禁用内联函数的声明（声明是多此一举）。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++引用]]></title>
    <url>%2F2018%2F05%2F28%2Fc%2B%2B%E5%9F%BA%E7%A1%802-%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[引用(reference)引用基本用法​ 引用是c++对c的重要扩充。 ​ 在c/c++中指针的作用基本都是一样的，但是c++增加了另外一种给函数传递地址的途径，这就是按引用传递(pass-by-reference)，它也存在于其他一些编程语言中，并不是c++的发明。 变量名实质上是一段连续内存空间的别名，是一个标号(门牌号) 程序中通过变量来申请并命名内存空间 通过变量的名字可以使用存储空间 ​ 思考：对一段连续的内存空间只能取一个别名吗？ ​ c++中新增了引用的概念，引用可以作为一个已定义变量的别名。 基本语法1Type&amp; ref = val; 注意事项 &amp;在此不是求地址运算，而是起标识作用。 类型标识符是指目标变量的类型 必须在声明引用变量时进行初始化。 引用初始化之后不能改变。 不能有NULL引用。必须确保引用是和一块合法的存储单元关联。 可以建立对数组的引用。 变量的引用123456789101112131415161718192021222324252627282930313233343536373839//1. 认识引用void test01()&#123; int a = 10; //给变量a取一个别名b int&amp; b = a; cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "b:" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; "------------" &lt;&lt; endl; //操作b就相当于操作a本身 b = 100; cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "b:" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; "------------" &lt;&lt; endl; //一个变量可以有n个别名 int&amp; c = a; c = 200; cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "b:" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; "c:" &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; "------------" &lt;&lt; endl; //a,b,c的地址都是相同的 cout &lt;&lt; "a:" &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; "b:" &lt;&lt; &amp;b &lt;&lt; endl; cout &lt;&lt; "c:" &lt;&lt; &amp;c &lt;&lt; endl;&#125;//2. 使用引用注意事项void test02()&#123; //1) 引用必须初始化 //int&amp; ref; //报错:必须初始化引用 //2) 引用一旦初始化，不能改变引用 int a = 10; int b = 20; int&amp; ref = a; ref = b; //不能改变引用 //3) 不能对数组建立引用 int arr[10]; //int&amp; ref3[10] = arr;&#125; 数组的引用123456789101112131415161718192021//1. 建立数组引用方法一typedef int ArrRef[10];int arr[10];ArrRef&amp; aRef = arr;for (int i = 0; i &lt; 10;i ++)&#123; aRef[i] = i+1;&#125;for (int i = 0; i &lt; 10;i++)&#123; cout &lt;&lt; arr[i] &lt;&lt; " ";&#125;cout &lt;&lt; endl;//2. 建立数组引用方法二int(&amp;f)[10] = arr;for (int i = 0; i &lt; 10; i++)&#123; f[i] = i+10;&#125;for (int i = 0; i &lt; 10; i++)&#123; cout &lt;&lt; arr[i] &lt;&lt; " ";&#125;cout &lt;&lt; endl; 函数中的引用​ 最常见看见引用的地方是在函数参数和返回值中。当引用被用作函数参数的时，在函数内对任何引用的修改，将对还函数外的参数产生改变。当然，可以通过传递一个指针来做相同的事情，但引用具有更清晰的语法。 ​ 如果从函数中返回一个引用，必须像从函数中返回一个指针一样对待。当函数返回值时，引用关联的内存一定要存在。 12345678910111213141516171819202122232425262728293031//值传递void ValueSwap(int m,int n)&#123; int temp = m; m = n; n = temp;&#125;//地址传递void PointerSwap(int* m,int* n)&#123; int temp = *m; *m = *n; *n = temp;&#125;//引用传递void ReferenceSwap(int&amp; m,int&amp; n)&#123; int temp = m; m = n; n = temp;&#125;void test()&#123; int a = 10; int b = 20; //值传递 ValueSwap(a, b); cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; " b:" &lt;&lt; b &lt;&lt; endl; //地址传递 PointerSwap(&amp;a, &amp;b); cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; " b:" &lt;&lt; b &lt;&lt; endl; //引用传递 ReferenceSwap(a, b); cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; " b:" &lt;&lt; b &lt;&lt; endl;&#125; ​ 通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单： 函数调用时传递的实参不必加&amp;符 在被调函数中不必在参数前加*符 引用作为其它变量的别名而存在，因此在一些场合可以代替指针。C++主张用引用传递取代地址传递的方式，因为引用语法容易且不易出错。 123456789101112131415161718192021//返回局部变量引用int&amp; TestFun01()&#123; int a = 10; //局部变量 return a;&#125;//返回静态变量引用int&amp; TestFunc02()&#123; static int a = 20; cout &lt;&lt; "static int a : " &lt;&lt; a &lt;&lt; endl; return a;&#125;int main()&#123; //不能返回局部变量的引用 int&amp; ret01 = TestFun01(); //如果函数做左值，那么必须返回引用 TestFunc02(); TestFunc02() = 100; TestFunc02(); return EXIT_SUCCESS;&#125; 不能返回局部变量的引用。 函数当左值，必须返回引用。 引用的本质引用的本质在c++内部实现是一个指针常量. 1Type&amp; ref = val; // Type* const ref = &amp;val; ​ c++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同，只是这个过程是编译器内部实现，用户不可见。 12345678910111213//发现是引用，转换为 int* const ref = &amp;a;void testFunc(int&amp; ref)&#123; ref = 100; // ref是引用，转换为*ref = 100&#125;int main()&#123; int a = 10; int&amp; aRef = a; //自动转换为 int* const aRef = &amp;a;这也能说明引用为什么必须初始化 aRef = 20; //内部发现aRef是引用，自动帮我们转换为: *aRef = 20; cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "aRef:" &lt;&lt; aRef &lt;&lt; endl; testFunc(a); return EXIT_SUCCESS;&#125; 指针引用在c语言中如果想改变一个指针的指向而不是它所指向的内容，函数声明可能这样: 1void fun(int**); 给指针变量取一个别名。 12Type* pointer = NULL; Type*&amp; = pointer; 1234567891011121314151617181920212223struct Teacher&#123; int mAge;&#125;;//指针间接修改teacher的年龄void AllocateAndInitByPointer(Teacher** teacher)&#123; *teacher = (Teacher*)malloc(sizeof(Teacher)); (*teacher)-&gt;mAge = 200; &#125;//引用修改teacher年龄void AllocateAndInitByReference(Teacher*&amp; teacher)&#123; teacher-&gt;mAge = 300;&#125;void test()&#123; //创建Teacher Teacher* teacher = NULL; //指针间接赋值 AllocateAndInitByPointer(&amp;teacher); cout &lt;&lt; "AllocateAndInitByPointer:" &lt;&lt; teacher-&gt;mAge &lt;&lt; endl; //引用赋值,将teacher本身传到ChangeAgeByReference函数中 AllocateAndInitByReference(teacher); cout &lt;&lt; "AllocateAndInitByReference:" &lt;&lt; teacher-&gt;mAge &lt;&lt; endl; free(teacher);&#125; ​ 对于c++中的定义那个，语法清晰多了。函数参数变成指针的引用，用不着取得指针的地址。 常量引用​ 常量引用的定义格式: 1const Type&amp; ref = val; ​ 常量引用注意： 字面量不能赋给引用，但是可以赋给const引用 const修饰的引用，不能修改。 1234567891011121314void test01()&#123; int a = 100; const int&amp; aRef = a; //此时aRef就是a //aRef = 200; 不能通过aRef的值 a = 100; //OK cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "aRef:" &lt;&lt; aRef &lt;&lt; endl;&#125;void test02()&#123; //不能把一个字面量赋给引用 //int&amp; ref = 100; //但是可以把一个字面量赋给常引用 const int&amp; ref = 100; //int temp = 200; const int&amp; ret = temp;&#125; const引用使用场景​ 常量引用主要用在函数的形参，尤其是类的拷贝/复制构造函数。 ​ 将函数的形参定义为常量引用的好处: 引用不产生新的变量，减少形参与实参传递时的开销。 由于引用可能导致实参随形参改变而改变，将其定义为常量引用可以消除这种副作用。 ​ 如果希望实参随着形参的改变而改变，那么使用一般的引用，如果不希望实参随着形参改变，那么使用常引用。 1234//const int&amp; param防止函数中意外修改数据void ShowVal(const int&amp; param)&#123; cout &lt;&lt; "param:" &lt;&lt; param &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++const和c的异同]]></title>
    <url>%2F2018%2F05%2F25%2Fc%2B%2B%E5%9F%BA%E7%A1%801-const%E5%92%8Cc%E7%9A%84%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"><![CDATA[c语言中，const修饰的变量称为伪常量，编译器会分配内存，可以通过指针修改。 c++中，const修饰的变量是真正的常量，以key-value键值对的方式保存，不会分配内存。 C语言的const修饰的变量称为伪常量，不能直接修改，但可以通过指针修改。 1234567891011121314151617181920#include&lt;stdio.h&gt; int main()&#123; const int a = 10; //等价于 //int const a = 10; //a = 11;//err int s = 1; const int *p=&amp;s; //*p = 10;//err 改变p所指向的内容 p = NULL;//改变p是可以的 int *const p1 = &amp;s; //p1 = NULL;err *p1 = 100; return 0;&#125; ​ 不是指针变量的表达式，const放在类型的前后都没关系，但是在指针变量中，const的位置就有讲究了，此时要分清楚是指针变量的值是只读的还是指针所指向的内存空间是只读的。而且，C语言中，const是个假const： 12345678910111213141516#include&lt;stdio.h&gt; int main()&#123; const int a = 10; //等价于 //int const a = 10; //a = 11;//err //看似不能改变a的值，其实只是不能直接更改而已，但可以间接修改 int *p = &amp;a;//C语言中这种类型不符合是可以被接受的，c++中不行 *p = 100; printf("%d\n", a); return 0;&#125; ​ 运行结果显示a的值被改变。所以，在C语言中，const不是真正的常量，只是不能直接修改而已，因此，在那些必须要常量的场合，不能用const定义的变量。比如数组的维数，虽然在C99中支持了变长数组，但是很多时候我们使用的都不是VLA，因为VLA局限性比较大，不能初始化，还必须是局部变量。那么，C语言中的常量只有define和直接数字值还有就是枚举。 123456789101112131415161718#include&lt;stdio.h&gt; enum test&#123; saturday, sunday = 0, monday, tuesday, wednesday, thursday, friday&#125; ;int main()&#123; int a[friday] = &#123; 0 &#125;; return 0;&#125; ​ 枚举类型可以编译通过，因为它是真正的常量。这是在没有支持C99的前提下测试的。define自然支持就不再测试了。 ​ 那么，其实在很多时候，C语言中的代码加上了const修饰，也还是不安全的。 12345678910int main()&#123; int a = 10; int const *p2 = &amp;a; int * p1 = p2; *p1 = 100; printf("%d\n", a); return 0;&#125; ​ 上述代码还是会改变a的值，但这个例子一般我们不会这样写，不过从上面的代码中，我们可能会像下面这样写程序，因为很多时候，我们想用const指针修饰的形参。目的是不想实参被改变，但是如果不注意，还是达不到想要的效果： 1234567891011121314#include&lt;stdio.h&gt; void test(int const *p)&#123; int *p1 = p; *p1 = 100;&#125;int main()&#123; int a = 10; test(&amp;a); printf("%d\n", a); return 0;&#125; ​ 我们把形参的指针所指向的内存空间设置成const的，就是不想实参被改变，但是还是可能会被间接修改，所以，在编写代码的时候，我们不要使用上述代码的 1int *p1 = p; ​ 因为就算你形参用const保护了，后续忘记了用const去接这样的变量，还是无用的。这提醒我们注意，应该这样去写这句话：12int const *p1 = p;保证接它的变量也要是const的。 c++中的const用常量初始化const变量c++中，const是升级过的了 123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int const a = 10; //int *p = &amp;a;c++中，不允许这样的转换，而C语言中是可以的，c++对类型检查更为严格 int *p = (int *)&amp;a; *p=100; cout &lt;&lt; a &lt;&lt; endl; return 0;&#125; 用普通变量初始化const变量​ 此时，c++不再允许我们对此进行更改，这证明了，c++中const修饰的变量是真正的常量，是不是const修饰的就如果简单了呢？那么我们再试试换个方式： 12345678910111213#include&lt;iostream&gt;using namespace std;int main()&#123; int b = 10; int const a = b; //会分配内存 //int *p = &amp;a;c++中，不允许这样的转换，而C语言中是可以的，c++对类型检查更为严格 int *p = (int *)&amp;a; *p = 100; cout &lt;&lt; a &lt;&lt; endl; return 0;&#125; 1100 ​ 可以清楚地看到，我们改变了a的值，这也就是说，在c++中，如果用一个字面值给const修饰的变量赋值，例如int const a=10;这样的a就是常量，可以用来当做数组的维数。 ​ 如果用一个变量给const修饰的变量赋值，例如int const a=b;这样的a就是只读变量，不能直接修改，但可以间接修改，和c中一样了。 ​ 另外注意，由于c++中严格检查类型匹配问题，所以我们要知道，在const修饰的指针变量中，顶层const在有赋值效果的操作中将被忽略。 ​ 以下说下c和c++中const定义的常量的一些区别： ​ c++中用const定义了一个常量后，不会分配一个空间给它，而是将其写入符号表(symbol table),这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。但是const定义的常量本质上也是一个变量，是变量就会有地址，那么什么时候会分配内存？看看下面的代码： 123456789int main()&#123; const int a = 2; int* p = (int*)(&amp;a); //会分配临时内存 等于 int tmp=a; int *p=(int *)(&amp;tmp); *p = 30; cout&lt;&lt;&amp;a&lt;&lt;endl; cout&lt;&lt;p&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;*p&lt;&lt;endl;&#125; 结果：12340x28ff080x28ff08230 ​ 我们看到，通过int *p = (int*)(&amp;a);这种方法，可以直接修改const常量对应的内存空间中的值，但是这种修改不会影响到常量本身的值，因为用到a的时候，编译器根本不会去进行内存空间的读取。这就是c++的常量折叠（constant folding），即将const常量放在符号表中，而并不给其分配内存。编译器直接进行替换优化。除非需要用到a的存储空间的时候，编译器迫不得已才会分配一个空间给a，但之后a的值仍旧从符号表中读取，不管a的存储空间中的值如何变化，都不会对常量a产生影响。 ​ 但是在c中却不是这样。c没有constant folding的概念，用const定义一个常量的时候，编译器会直接开辟一个内存空间存放该常量。不会进行优化。同样的例子在c下面会产生不同的结果： 1234567891011 1 int main() 2 &#123; 3 const int a = 2; 4 int* p = (int*)(&amp;a); 5 *p = 30; 6 printf("%x\n",&amp;a); 7 printf("%x\n",p); 8 printf("%i\n",a); 9 printf("%i\n",*p);10 return 0;11 &#125; 结果：123428ff1828ff183030 ​ 我们看到，在c里面，一个被const定义为常量的值，堂而皇之地被修改了，而且编译器没有报任何错误 ！ ​ 如果我们进一步深入可以发现，对于以上两个例子来说，a都是定义在某个函数之内的(比如main()函数)，不管是c还是c++，本质上都只是将其当成一个普通的局部变量来对待，都只是在栈上分配空间。所以const根本就不能起到阻止修改其内存空间的作用，一个合法的强制类型转换就可以轻松搞定。c++比c好的地方就在于使用了constant folding的机制，使得常量的值跟对应的内存空间无关，从而保护了该常量值。 ​ 以上的例子是针对局部的const常量而言，对全局的const变量，c++仍旧采用constant folding策略，故以下代码是行得通的： 123//global variableconst int a = 3;int arr[a]; ​ 但是c会报错： error: variably modified &#39;arr&#39; at file scope, 原因在于gcc认为a只是一个普通的全局变量，而变量是不能用来指定数组的长度的。当然，这是针对全局数组而言，如果是局部的数组的话，就算是int a = 3; int arr[a];这种都是可以的，因为c里面还有一种叫变长数组的东西。 ​ 另外，对于a，在c和c++中如果我们仍然用int *p = (int*)(&amp;a);这种方法来修改它内存中的值，编译时不会报错，但是运行时会报段错误，因为a是放在只读的全局数据区中，修改该区中的数据会引发段错误。]]></content>
      <categories>
        <category>c++_language</category>
      </categories>
      <tags>
        <tag>c++_language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell模块化]]></title>
    <url>%2F2018%2F05%2F15%2Fshell12-%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[所谓模块化，就是把代码分散到多个文件或者文件夹。对于大中型项目，模块化是必须的，否则会在一个文件中堆积成千上万行代码，这简直是一种灾难。 模块化​ 基本上所有的编程语言都支持模块化，以达到代码复用的效果，比如，Java和Python中有import，C/C++中有#include。在Shell中，我们可以使用source命令来实现类似的效果。 ​ source命令的用法为： 1source filename 也可以简写为： 1. filename 两种写法的效果相同。对于第二种写法，注意点号.和文件名中间有一个空格。 ​ source是Shell 内置命令的一种，它会读取filename文件中的代码，并依次执行所有语句。你也可以理解为，source命令会强制执行脚本文件中的全部命令，而忽略脚本文件的权限。 【实例】创建两个脚本文件func.sh和main.sh：func.sh中包含了若干函数，main.sh是主文件，main.sh中会包含func.sh。 func.sh文件内容： 123456789101112#计算所有参数的和function sum()&#123; local total=0 for n in $@ do ((total+=n)) done echo $total return 0&#125; main.sh文件内容： 12345#!/bin/bashsource func.shecho $(sum 10 20 55 15) 运行main.sh，输出结果为：100 source后边可以使用相对路径，也可以使用绝对路径，这里我们使用的是相对路径。 避免重复引入​ 熟悉C/C++的读者都知道，C/C++中的头文件可以避免被重复引入；换句话说，即使被多次引入，效果也相当于一次引入。这并不是#include的功劳，而是我们在头文件中进行了特殊处理。 ​ Shell source命令和C/C++中的#include类似，都没有避免重复引入的功能，只要你使用一次source，它就引入一次脚本文件中的代码。 ​ 如果想在shell里避免重复引入，我们可以在模块中额外设置一个变量，使用if语句来检测这个变量是否存在，如果发现这个变量存在，就return出去。 ​ 这里需要强调一下return关键字。return在C++、C#、Java等大部分编程语言中只能退出函数，除此以外再无他用；但是在Shell中，return除了可以退出函数，还能退出由source命令引入的脚本文件。 ​ 所谓退出脚本文件，就是在被source引入的脚本文件（子文件）中，一旦遇到return关键字，后面的代码都不会再执行了，而是回到父脚本文件中继续执行source命令后面的代码。 ​ return只能退出由source命令引入的脚本文件，对其它引入脚本的方式无效。 ​ 下面我们通过一个实例来演示如何避免脚本文件被重复引入。本例会涉及到两个脚本文件，分别是主文件 main.sh和 模块文件module.sh。 ​ 模块文件module.sh： 123456if [ -n "$__MODULE_SH__" ]; then returnfi__MODULE_SH__='module.sh'echo "http://c.biancheng.net/shell/" 注意第一行代码，一定要是使用双引号把$__MODULE_SH__包围起来。 主文件main.sh： 123456#!/bin/bashsource module.shsource module.shecho "here executed" ./表示当前文件，你也可以直接写作source module.sh。 运行main.sh，输出结果为：http://c.biancheng.net/shell/here executed 我们在main.sh中两次引入module.sh，但是只执行了一次，说明第二次引入是无效的。 main.sh中的最后一条echo语句产生了输出结果，说明return只是退出了子文件，对父文件没有影响。]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell多命令组合]]></title>
    <url>%2F2018%2F05%2F12%2Fshell11-%E5%A4%9A%E5%91%BD%E4%BB%A4%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[组命令​ 所谓组命令，就是将多个命令划分为一组，或者看成一个整体。 ​ Shell组命令的写法有两种： { command1; command2; command3; ... }(command1; command2; command3;... ) ​ 两种写法的区别在于：由花括号{}包围起来的组命名在当前 Shell 进程中执行，而由小括号()包围起来的组命令会创建一个子 Shell，所有命令都在子 Shell 中执行。 ​ 对于第一种写法，花括号和命令之间必须有一个空格，并且最后一个命令必须用一个分号或者一个换行符结束。 ​ 组命令可以将多条命令的输出结果合并在一起，在使用重定向和管道时会特别方便。 ​ 例如，下面的代码将多个命令的输出重定向到out.txt： 123ls -l &gt; out.txt #&gt;表示覆盖echo "http://c.biancheng.net/shell/" &gt;&gt; out.txt #&gt;&gt;表示追加cat readme.txt &gt;&gt; out.txt ​ 本段代码共使用了三次重定向。 ​ 借助组命令，我们可以将以上三条命令合并在一起，简化成一次重定向：1&#123; ls -l; echo "http://c.biancheng.net/shell/"; cat readme.txt; &#125; &gt; out.txt ​ 或者写作：1(ls -l; echo "http://c.biancheng.net/shell/"; cat readme.txt) &gt; out.txt ​ 使用组命令技术，我们节省了一些打字时间。 ​ 类似的道理，我们也可以将组命令和管道结合起来：1&#123; ls -l; echo "http://c.biancheng.net/shell/"; cat readme.txt; &#125; | lpr ​ 这里我们把三个命令的输出结果合并在一起，并把它们用管道输送给命令lpr的输入，以便产生一个打印报告。 两种组命令形式的对比​ 虽然两种Shell组命令形式看起来相似，它们都能用在重定向中合并输出结果，但两者之间有一个很重要的不同：由{}包围的组命令在当前Shell进程中执行，由()包围的组命令会创建一个子Shell，所有命令都会在这个子Shell中执行。 ​ 在子Shell中执行意味着，运行环境被复制给了一个新的shell进程，当这个子Shell退出时，新的进程也会被销毁，环境副本也会消失，所以在子Shell环境中的任何更改都会消失（包括给变量赋值）。因此，在大多数情况下，除非脚本要求一个子Shell，否则使用{}比使用()更受欢迎，并且{}的进行速度更快，占用的内存更少。 进程替换​ 进程替换和命令替换非常相似。命令替换是把一个命令的输出结果赋值给另一个变量，例如dir_files=`ls -l`或date_time=$(date)；而进程替换则是把一个命令的输出结果传递给另一个（组）命令。 ​ 为了说明进程替换的必要性，我们先来看一个使用管道的例子： 12echo "http://c.biancheng.net/shell/" | readecho $REPLY ​ 以上代码输出结果总是为空，因为echo命令在父Shell中执行，而read命令在子Shell中执行，当read执行结束时，子Shell被销毁，REPLY变量也就消失了。管道中的命令总是在子Shell中执行的，任何给变量赋值的命令都会遭遇到这个问题。 使用 read 读取数据时，如果没有提供变量名，那么读取到的数据将存放到环境变量 REPLY 中。 ​ Shell进程替换有两种写法： ​ 一种用来产生标准输出，借助输入重定向，它的输出结果可以作为另一个命令的输入： 1&lt;(commands) ​ 另一种用来接受标准输入，借助输出重定向，它可以接收另一个命令的输出结果：1&gt;(commands) commands 是一组命令列表，多个命令之间以分号;分隔。注意，&lt;或&gt;与圆括号之间是没有空格的。 例如，为了解决上面遇到的问题，我们可以像下面这样使用进程替换： 12read &lt; &lt;(echo "http://c.biancheng.net/shell/")echo $REPLY 输出结果：http://c.biancheng.net/shell/ ​ 整体上来看，Shell把echo &quot;http://c.biancheng.net/shell/&quot;的输出结果作为read的输入。&lt;()用来捕获echo命令的输出结果，&lt;用来将该结果重定向到read。 注意，两个&lt;之间是有空格的，第一个&lt;表示输入重定向，第二个&lt;和()连在一起表示进程替换。 ​ 本例中的read命令和第二个echo命令都在当前Shell进程中运行，读取的数据也会保存到当前进程的 REPLY变量，大家都在一个进程中，所以使用echo能够成功输出。 ​ 而在前面的例子中我们使用了管道，echo命令在父进程中运行，read命令在子进程中运行，读取的数据也保存在子进程的REPLY变量中，echo命令和REPLY变量不在一个进程中，而子进程的环境变量对父进程是不可见的，所以读取失败。 ​ 再来看一个进程替换用作「接受标准输入」的例子：1echo "C语言中文网" &gt; &gt;(read; echo "你好，$REPLY") 运行结果：你好，C语言中文网 因为使用了重定向，read命令从echo &quot;C语言中文网&quot;的输出结果中读取数据。 进程替换的本质为了能够在不同进程之间传递数据，实际上进程替换会跟系统中的文件关联起来，这个文件的名字为/dev/fd/n（n 是一个整数）。该文件会作为参数传递给()中的命令，()中的命令对该文件是读取还是写入取决于进程替换格式是&lt;还是&gt;： 如果是&gt;()，那么该文件会给()中的命令提供输入；借助输出重定向，要输入的内容可以从其它命令而来。 如果是&lt;()，那么该文件会接收()中命令的输出结果；借助输入重定向，可以将该文件的内容作为其它命令的输入。 使用echo 命令可以查看进程替换对应的文件名： 123456[c.biancheng.net]$ echo &gt;(true)/dev/fd/63[c.biancheng.net]$ echo &lt;(true)/dev/fd/63[c.biancheng.net]$ echo &gt;(true) &lt;(true)/dev/fd/63 /dev/fd/62 ​ /dev/fd/目录下有很多序号文件，进程替换一般用的是63号文件，该文件是系统内部文件，我们一般查看不到。 ​ 我们通过下面的语句进行实例分析：1echo "shellscript" &gt; &gt;(read; echo "hello, $REPLY") ​ 第一个&gt;表示输出重定向，它把第一个echo命令的输出结果重定向到/dev/fd/63文件中。 ​ &gt;()中的第一个命令是read，它需要从标准输入中读取数据，此时就用/dev/fd/63作为输入文件，把该文件的内容交给 read 命令，接着使用 echo 命令输出 read `读取到的内容。 ​ 可以看到，/dev/fd/63文件起到了数据中转或者数据桥梁的作用，借助重定向，它将&gt;()内部的命令和外部的命令联系起来，使得数据能够在这些命令之间流通。 管道​ Shell可以将两个或者多个命令（程序或者进程）连接到一起，把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了管道（pipe）。 ​ Linux管道使用竖线|连接多个命令，这被称为管道符。Linux管道的具体语法格式如下： command1 | command2command1 | command2 [ | commandN... ] ​ 当在两个命令之间设置管道时，管道符|左边命令的输出就变成了右边命令的输入。只要第一个命令向标准输出写入，而第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道。大部分的Linux命令都可以用来形成管道。 这里需要注意，command1必须有正确输出，而 command2必须可以处理command2的输出结果；而且 command2只能处理command1的正确输出结果，不能处理command1 的错误信息。 为何使用管道我们先看下面一组命令，使用mysqldump（一个数据库备份程序）来备份一个叫做wiki的数据库：123mysqldump -u root -p '123456' wiki &gt; /tmp/wikidb.backupgzip -9 /tmp/wikidb.backupscp /tmp/wikidb.backup username@remote_ip:/backup/mysql/ 上述这组命令主要做了如下任务： mysqldump命令用于将名为wike的数据库备份到文件/tmp/wikidb.backup；其中-u和-p选项分别指出数据库的用户名和密码。 gzip命令用于压缩较大的数据库文件以节省磁盘空间；其中-9表示最慢的压缩速度最好的压缩效果。 scp命令（secure copy，安全拷贝）用于将数据库备份文件复制到IP地址为remote_ip的备份服务器的/backup/mysql/目录下。其中username是登录远程服务器的用户名，命令执行后需要输入密码。 上述三个命令依次执行。然而，如果使用管道的话，你就可以将mysqldump、gzip、ssh命令相连接，这样就避免了创建临时文件/tmp/wikidb.backup，而且可以同时执行这些命令并达到相同的效果。 使用管道后的命令如下所示：1mysqldump -u root -p '123456' wiki | gzip -9 | ssh username@remote_ip "cat &gt; /backup/wikidb.gz" 这些使用了管道的命令有如下特点： 命令的语法紧凑并且使用简单。 通过使用管道，将三个命令串联到一起就完成了远程mysql备份的复杂任务。 从管道输出的标准错误会混合到一起。 上述命令的数据流如下图所示： 重定向和管道的区别​ 管道改变了数据输入输出的方向，也有重定向的作用。那么，管道和重定向之间到底有什么不同呢？ ​ 简单地说，重定向操作符&gt;将命令与文件连接起来，用文件来接收命令的输出； ​ 而管道符|将命令与命令连接起来，用第二个命令来接收第一个命令的输出。如下所示：12command &gt; filecommand1 | command1 有些读者在学习管道时会尝试如下的命令，我们来看一下会发生什么：1command1 &gt; command2 答案是，有时尝试的结果将会很糟糕。这是一个实际的例子，一个Linux系统管理员以超级用户（root用户）的身份执行了如下命令： 12cd /usr/binls &gt; less 第一条命令将当前目录切换到了大多数程序所存放的目录，第二条命令是告诉Shell用ls命令的输出重写文件less。因为/usr/bin目录已经包含了名称为less（less程序）的文件，第二条命令用ls输出的文本重写了less程序，因此破坏了文件系统中的less程序。 这是使用重定向操作符错误重写文件的一个教训，所以在使用它时要谨慎。 管道实例【实例1】将ls命令的输出发送到grep命令： 12[c.biancheng.net]$ ls | grep log.txtlog.txt 上述命令是查看文件log.txt是否存在于当前目录下。 我们可以在命令的后面使用选项，例如使用-al选项： 12[c.biancheng.net]$ ls -al | grep log.txt-rw-rw-r--. 1 mozhiyan mozhiyan 0 4月 15 17:26 log.txt 管道符|与两侧的命令之间也可以不存在空格，例如将上述命令写作ls -al|grep log.txt；然而我还是推荐在管道符|和两侧的命令之间使用空格，以增加代码的可读性。 我们也可以重定向管道的输出到一个文件，比如将上述管道命令的输出结果发送到文件output.txt中： 123[c.biancheng.net]$ ls -al | grep log.txt &gt;output.txt[c.biancheng.net]$ cat output.txt-rw-rw-r--. 1 mozhiyan mozhiyan 0 4月 15 17:26 log.txt 【实例2】使用管道将cat命令的输出作为less命令的输入，这样就可以将cat命令的输出每次按照一个屏幕的长度显示，这对于查看长度大于一个屏幕的文件内容很有帮助。 1cat /var/log/message | less 【实例3】查看指定程序的进程运行状态，并将输出重定向到文件中。 123456789101112[c.biancheng.net]$ ps aux | grep httpd &gt; /tmp/ps.output[c.biancheng.net]$ cat /tem/ps.outputmozhiyan 4101 13776 0 10:11 pts/3 00:00:00 grep httpdroot 4578 1 0 Dec09 ? 00:00:00 /usr/sbin/httpdapache 19984 4578 0 Dec29 ? 00:00:00 /usr/sbin/httpdapache 19985 4578 0 Dec29 ? 00:00:00 /usr/sbin/httpdapache 19986 4578 0 Dec29 ? 00:00:00 /usr/sbin/httpdapache 19987 4578 0 Dec29 ? 00:00:00 /usr/sbin/httpdapache 19988 4578 0 Dec29 ? 00:00:00 /usr/sbin/httpdapache 19989 4578 0 Dec29 ? 00:00:00 /usr/sbin/httpdapache 19990 4578 0 Dec29 ? 00:00:00 /usr/sbin/httpdapache 19991 4578 0 Dec29 ? 00:00:00 /usr/sbin/httpd 【实例4】显示按用户名排序后的当前登录系统的用户的信息。 123[c.biancheng.net]$ who | sortmozhiyan :0 2019-04-16 12:55 (:0)mozhiyan pts/0 2019-04-16 13:16 (:0) ​ who命令的输出将作为sort命令的输入，所以这两个命令通过管道连接后会显示按照用户名排序的已登录用户的信息。 【实例5】统计系统中当前登录的用户数。 12[c.biancheng.net]$ who | wc -l5 管道与输入重定向输入重定向操作符&lt;可以在管道中使用，以用来从文件中获取输入，其语法类似下面这样： 12command1 &lt; input.txt | command2command1 &lt; input.txt | command2 -option | command3 例如，使用 tr 命令从os.txt文件中获取输入，然后通过管道将输出发送给sort或uniq等命令： 123456789101112131415161718192021222324252627282930[c.biancheng.net]$ cat os.txtredhatsusecentosubuntusolarishp-uxfedoracentosredhathp-ux[c.biancheng.net]$ tr a-z A-Z &lt;os.txt | sortCENTOSCENTOSFEDORAHP-UXHP-UXREDHATREDHATSOLARISSUSEUBUNTU[c.biancheng.net]$ tr a-z A-Z &lt;os.txt | sort | uniqCENTOSFEDORAHP-UXREDHATSOLARISSUSEUBUNTU 管道与输出重定向你也可以使用重定向操作符&gt;或&gt;&gt;将管道中的最后一个命令的标准输出进行重定向，其语法如下所示： 12command1 | command2 | ... | commandN &gt; output.txtcommand1 &lt; input.txt | command2 | ... | commandN &gt; output.txt 【实例1】使用mount命令显示当前挂载的文件系统的信息，并使用column命令格式化列的输出，最后将输出结果保存到一个文件中。 1234567891011[c.biancheng.net]$ mount | column -t &gt;mounted.txt[c.biancheng.net]$ cat mounted.txtproc on /proc type proc (rw,nosuid,nodev,noexec,relatime)sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)devtmpfs on /dev type devtmpfs (rw,nosuid,seclabel,size=496136k,nr_inodes=124034,mode=755)securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev,seclabel)devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,seclabel,gid=5,mode=620,ptmxmode=000)tmpfs on /run type tmpfs (rw,nosuid,nodev,seclabel,mode=755)tmpfs on /sys/fs/cgroup type tmpfs (rw,nosuid,nodev,noexec,seclabel,mode=755)#####此处省略部分内容##### 【实例2】使用tr命令将os.txt文件中的内容转化为大写，并使用sort命令将内容排序，使用uniq命令去除重复的行，最后将输出重定向到文件ox.txt.new。 1234567891011121314151617181920[c.biancheng.net]$ cat os.txtredhatsusecentosubuntusolarishp-uxfedoracentosredhathp-ux[c.biancheng.net]$ tr a-z A-Z &lt;os.txt | sort | uniq &gt;os.txt.new[c.biancheng.net]$ cat os.txt.newCENTOSFEDORAHP-UXREDHATSOLARISSUSEUBUNTU 过滤器​ 我们己经知道，将几个命令通过管道符组合在一起就形成一个管道。通常，通过这种方式使用的命令就被称为过滤器。过滤器会获取输入，通过某种方式修改其内容，然后将其输出。 ​ 简单地说，过滤器可以概括为以下两点： 如果一个Linux命令是从标准输入接收它的输入数据，并在标准输出上产生它的输出数据（结果），那么这个命令就被称为过滤器。 过滤器通常与Linux管道一起使用。 常用的被作为过滤器使用的命令如下所示： 命令 说明 awk 用于文本处理的解释性程序设计语言，通常被作为数据提取和报告的工具。 cut 用于将每个输入文件（如果没有指定文件则为标准输入）的每行的指定部分输出到标准输出。 grep 用于搜索一个或多个文件中匹配指定模式的行。 tar 用于归档文件的应用程序。 head 用于读取文件的开头部分（默认是10行）。如果没有指定文件，则从标准输入读取。 paste 用于合并文件的行。 sed 用于过滤和转换文本的流编辑器。 sort 用于对文本文件的行进行排序。 split 用于将文件分割成块。 strings 用于打印文件中可打印的字符串。 tac 与 cat 命令的功能相反，用于倒序地显示文件或连接文件。 tail 用于显示文件的结尾部分。 tee 用于从标准输入读取内容并写入到标准输出和文件。 tr 用于转换或删除字符。 uniq 用于报告或忽略重复的行。 wc 用于打印文件中的总行数、单词数或字节数。 接下来，我们通过几个实例来演示一下过滤器的使用。 在管道中使用awk命令​ 我们通过几个简单的实例来了解一下awk命令在管道中的使用。 【实例1】查看系统中的所有的账号名称，并按名称的字母顺序排序。 1234567891011[c.biancheng.net]$ awk -F: '&#123;print $1&#125;' /etc/passwd | sortadmapacheavahiavahi-autoipdbindaemondbusftpgames... ​ 在上例中，使用冒号:作为列分隔符，将文件/etc/passwd的内容分为了多列，并打印了第一列的信息（即用户名），然后将输出通过管道发送到了sort命令。 【实例2】列出当前账号最常使用的10个命令。 1234567891011[c.biancheng.net]$ history | awk '&#123;print $2&#125;' | sort | uniq -c | sort -rn | head140 echo 75 man 71 cat 63 su 53 ls 50 vi 47 cd 40 date 26 let 25 paste ​ 在上例中，history命令将输出通过管道发送到awk命令，awk命令默认使用空格作为列分隔符，将history的输出分为了两列，并把第二列内容作为输出通过管道发送到了sort命令，使用sort命令进行排序后，再将输出通过管道发送到了uniq命令，使用uniq命令统计了历史命令重复出现的次数，再用sort命令将uniq命令的输出按照重复次数从高到低排序，最后使用head命令默认列出前10个的信息。 【实例3】显示当前系统的总内存大小，单位为KB。 12[c.biancheng.net]$ free | grep Mem | awk '&#123;print $2&#125;'2029860 在管道中使用cut命令​ cut命令被用于文本处理。你可以使用这个命令来提取文件中指定列的内容。 【实例1】查看系统中登录Shell是“/bin/bash”的用户名和对应的用户主目录的信息： 123[c.biancheng.net]$ grep "bin/bash" /etc/passwd | cut -d: -f1,6root:/rootmozhiyan:/home/mozhiyan ​ 如果你对Linux系统有所了解，你会知道，/ctc/passwd文件被用来存放用户账号的信息，此文件中的每一行会记录一个账号的信息，每个字段之间用冒号分隔，第一个字段即是账号的账户名，而第六个字段就是账号的主目录的路径。 【实例2】查看当前机器的CPU类型。 12[c.biancheng.net]$ cat /proc/cpuinfo | grep name | cut -d: -f2 | uniqIntel(R) Core(TM) i5-2520M CPU @ 2.50GHz ​ 上例中，执行命令cat /proc/cpuinfo | grep name得到的内容如下所示： 12345[c.biancheng.net]$ cat /proc/cpuinfo | grep namemodel name : Intel(R) Core(TM) i5-2520M CPU @ 2.50GHzmodel name : Intel(R) Core(TM) i5-2520M CPU @ 2.50GHzmodel name : Intel(R) Core(TM) i5-2520M CPU @ 2.50GHzmodel name : Intel(R) Core(TM) i5-2520M CPU 0 2.50GHz ​ 然后，我们使用cut命令将上述输出内容以冒号作为分隔符，将内容分为了两列， 并显示第二列的内容，最后使用uniq命令去掉了重复的行。 【实例3】查看当前目录下的子目录数。 12[c.biancheng.net]$ ls -l | cut -c 1 | grep d | wc -l5 上述管道命令主要做了如下操作： 命令ls -l输出的内容中，每行的第一个字符表示文件的类型，如果第一个字符是d，就表示文件的类型是目录。 命令cut -c 1是截取每行的第一个字符。 命令grep d来获取文件类型是目录的行。 命令wc -l用来获得grep命令输出结果的行数，即目录个数。 在管道中使用grep命令​ grep命令是在管道中比较常用的一个命令。 【实例1】查看系统日志文件中的错误信息。 1[c.biancheng.net]$ grep -i "error:" /var/log/messages | less 【实例2】查看系统中HTTP服务的进程信息。 1234[c.biancheng.net]$ ps auxwww | grep httpdapache 18968 0.0 0.0 26472 10404 ? S Dec15 0:01 /usr/sbin/httpdapache 18969 0.0 0.0 25528 8308 ? S Dec15 0:01 /usr/sbin/httpdapache 18970 0.0 0.0 26596 10524 ? S Dec15 0:01 /usr/sbin/httpd 【实例3】查找我们的程序列表中所有命令名中包含关键字zip的命令。 123456[c.biancheng.net]$ ls /bin /usr/bin | sort | uniq | grep zipbunzip2bzip2bzip2recovergunzipgzip 【实例4】查看系统安装的kernel版本及相关的kernel软件包。 12345[c.biancheng.net]$ rpm -qa | grep kernelkernel-2.6.18-92.e15kernel-debuginfo-2.6.18-92.e15kernel-debuginfo-common-2.6.18-92.e15kernel-devel-2.6.18-92.e15 【实例5】查找/etc目录下所有包含IP地址的文件。 1[c.biancheng.net]$ find /etc -type f -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' &#123;&#125; \; 在管道中使用tar命令​ tar命令是Linux系统中最常用的打包文件的程序。 【实例1】你可以使用tar命令复制一个目录的整体结构。 1[c.biancheng.net]$ tar cf - /home/mozhiyan | ( cd /backup/; tar xf - ) 【实例2】跨网络地复制一个目录的整体结构。 1[c.biancheng.net]$ tar cf - /home/mozhiyan | ssh remote_host "( cd /backup/; tar xf - )" 【实例3】跨网络地压缩复制一个目录的整体结构。 1[c.biancheng.net]$ tar czf - /home/mozhiyan | ssh remote_host "( cd /backup/; tar xzf - )" 【实例4】检査tar归档文件的大小，单位为字节。 12[c.biancheng.net]$ cd /; tar cf - etc | wc -c215040 【实例5】检查tar归档文件压缩为tar.gz归裆文件后所占的大小。 12[c.biancheng.net]$ tar czf - etc.tar | wc -c58006 【实例6】检查tar归档文件压缩为tar.bz2归裆文件后所占的大小。 12[c.biancheng.net]$ tar cjf - etc.tar | wc -c50708 在管道中使用head命令​ 有时，你不需要一个命令的全部输出，可能只需要命令的前几行输出。这时，就可以使用head命令，它只打印命令的前几行输出。默认的输出行数为10行。 【实例1】显示ls命令的前10行输出。 1234567891011[c.biancheng.net]$ ls /usr/bin | headaddftinfoafmtoditaproposarchashawkbase64basenamebashbashbug 【实例2】显示ls命令的前5行内容。 123456[c.biancheng.net]$ ls / | head -n 5bincygdriveCygwin.batCygwin.icoCygwin-Terminal.ico 在管道中使用uniq命令​ uniq命令用于报告或删除重复的行。我们将使用一个测试文件进行管道中使用 uniq命令的实例讲解，其内容如下所示： 1234567[c.biancheng.net]$ cat testfileThis line occurs only once.This line occurs twice.This line occurs twice.This line occurs three times.This line occurs three times.This line occurs three times. 【实例1】去掉输出中重复的行。 1234[c.biancheng.net]$ sort testfile | uniqThis line occurs only once.This line occurs three times.This line occurs twice. 【实例2】显示输出中各重复的行出现的次数，并按次数多少倒序显示。 1234[c.biancheng.net]$ sort testfile | uniq -c | sort -nr3 This line occurs three times.2 This line occurs twice.1 This line occurs only once. 在管道中使用wc命令​ wc命令用于统计包含在文本流中的字符数、单同数和行数。 【实例1】统计当前登录到系统的用户数。 1[c.biancheng.net]$ who | wc -l 【实例2】统计当前的Linux系统中的进程数。 1[c.biancheng.net]$ ps -ef | wc -l]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell重定向]]></title>
    <url>%2F2018%2F05%2F11%2Fshell10-%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[重定向​ Linux Shell重定向分为两种，一种输入重定向，一种是输出重定向；从字面上理解，输入输出重定向就是「改变输入与输出的方向」的意思。 其实输入输出方向就是数据的流动方向： 输入方向就是数据从哪里流向程序。数据默认从键盘流向程序，如果改变了它的方向，数据就从其它地方流入，这就是输入重定向。 输出方向就是数据从程序流向哪里。数据默认从程序流向显示器，如果改变了它的方向，数据就流向其它地方，这就是输出重定向。 硬件设备和文件描述符​ 计算机的硬件设备有很多，常见的输入设备有键盘、鼠标、麦克风、手写板等，输出设备有显示器、投影仪、打印机等。不过，在Linux中，标准输入设备指的是键盘，标准输出设备指的是显示器。 ​ Linux中一切皆文件，包括标准输入设备（键盘）和标准输出设备（显示器）在内的所有计算机硬件都是文件。 为了表示和区分已经打开的文件，Linux会给每个文件分配一个ID，这个ID就是一个整数，被称为文件描述符（File Descriptor）。 文件描述符 文件名 类型 硬件 0 stdin 标准输入文件 键盘 1 stdout 标准输出文件 显示器 2 stderr 标准错误输出文件 显示器 ​ Linux程序在执行任何形式的I/O操作时，都是在读取或者写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示器，甚至是一个网络连接。 ​ stdin、stdout、stderr默认都是打开的，在重定向的过程中，0、1、2这三个文件描述符可以直接使用。 Shell输出重定向​ 输出重定向是指命令的结果不再输出到显示器上，而是输出到其它地方，一般是文件中。这样做的最大好处就是把命令的结果保存起来，当我们需要的时候可以随时查询。Bash支持的输出重定向符号如下表所示。 类 型 符 号 作 用 标准输出重定向 command &gt;file 以覆盖的方式，把command的正确输出结果输出到file文件中。 command &gt;&gt;file 以追加的方式，把command的正确输出结果输出到file文件中。 标准错误输出重定向 command 2&gt;file 以覆盖的方式，把command的错误信息输出到file文件中。 command 2&gt;&gt;file 以追加的方式，把command的错误信息输出到file文件中。 正确输出和错误信息同时保存 command &gt;file 2&gt;&amp;1 以覆盖的方式，把正确输出和错误信息同时保存到同一个文件（file）中。 command &gt;&gt;file 2&gt;&amp;1 以追加的方式，把正确输出和错误信息同时保存到同一个文件（file）中。 command &gt;file1 2&gt;file2 以覆盖的方式，把正确的输出结果输出到file1文件中，把错误信息输出到file2文件中。 command &gt;&gt;file1 2&gt;&gt;file2 以追加的方式，把正确的输出结果输出到file1文件中，把错误信息输出到file2文件中。 command &gt;file 2&gt;file 【不推荐】这两种写法会导致file被打开两次，引起资源竞争，所以stdout和stderr会互相覆盖。 command &gt;&gt;file 2&gt;&gt;file 【不推荐】这两种写法会导致 file被打开两次，引起资源竞争，所以stdout和stderr会互相覆盖。 在输出重定向中，&gt;代表的是覆盖，&gt;&gt;代表的是追加。 注意 输出重定向的完整写法其实是fd&gt;file或者fd&gt;&gt;file，其中fd表示文件描述符，如果不写，默认为1，也就是标准输出文件。 ​ 当是输出重定向时，文件描述符为1，一般都省略不写，command &gt;file等同于command 1&gt;file。当文件描述符为大于 1 的值时，比如 2，就必须写上。 ​ 需要重点说明的是，fd和&gt;之间不能有空格，否则 Shell 会解析失败；&gt;和file之间的空格可有可无。为了保持一致，我习惯在&gt;两边都不加空格。 ​ 下面的语句是一个反面教材： 1echo "c.biancheng.net" 1 &gt;log.txt 注意1和&gt;之间的空格。echo命令的输出结果是c.biancheng.net，我们的初衷是将输出结果重定向到 log.txt，但是当你打开log.txt文件后，发现文件的内容为c.biancheng.net 1，这就是多余的空格导致的解析错误。也就是说，Shell将该条语句理解成了下面的形式： 1echo "c.biancheng.net" 1 1&gt;log.txt 输出重定向【实例1】将echo命令的输出结果以追加的方式写入到demo.txt文件中。 123456#!/bin/bashfor str in "C语言中文网" "http://c.biancheng.net/" "成立7年了" "日IP数万"do echo $str &gt;&gt;demo.txt #将输入结果以追加的方式重定向到文件done 运行以上脚本，使用cat demo.txt查看文件内容，显示如下：C语言中文网http://c.biancheng.net/成立7年了日IP数万 【实例2】将ls -l命令的输出结果重定向到文件中。 123456789101112131415[c.biancheng.net]$ ls -l #先预览一下输出结果总用量 16drwxr-xr-x. 2 root root 21 7月 1 2016 abc-rw-r--r--. 1 mozhiyan mozhiyan 399 3月 11 17:12 demo.sh-rw-rw-r--. 1 mozhiyan mozhiyan 67 3月 22 17:16 demo.txt-rw-rw-r--. 1 mozhiyan mozhiyan 278 3月 16 17:17 main.c-rwxr-xr-x. 1 mozhiyan mozhiyan 187 3月 22 17:16 test.sh[c.biancheng.net]$ ls -l &gt;demo.txt #重定向[c.biancheng.net]$ cat demo.txt #查看文件内容总用量 12drwxr-xr-x. 2 root root 21 7月 1 2016 abc-rw-r--r--. 1 mozhiyan mozhiyan 399 3月 11 17:12 demo.sh-rw-rw-r--. 1 mozhiyan mozhiyan 0 3月 22 17:21 demo.txt-rw-rw-r--. 1 mozhiyan mozhiyan 278 3月 16 17:17 main.c-rwxr-xr-x. 1 mozhiyan mozhiyan 187 3月 22 17:16 test.sh 错误输出重定向命令正确执行是没有错误信息的，我们必须刻意地让命令执行出错，如下所示： 12345[c.biancheng.net]$ ls java #先预览一下错误信息ls: 无法访问java: 没有那个文件或目录[c.biancheng.net]$ ls java 2&gt;err.log #重定向[c.biancheng.net]$ cat err.log #查看文件ls: 无法访问java: 没有那个文件或目录 正确输出和错误信息同时保存【实例1】把正确结果和错误信息都保存到一个文件中，例如： 12345678910[c.biancheng.net]$ ls -l &gt;out.log 2&gt;&amp;1[c.biancheng.net]$ ls java &gt;&gt;out.log 2&gt;&amp;1[c.biancheng.net]$ cat out.log总用量 12drwxr-xr-x. 2 root root 21 7月 1 2016 abc-rw-r--r--. 1 mozhiyan mozhiyan 399 3月 11 17:12 demo.sh-rw-rw-r--. 1 mozhiyan mozhiyan 278 3月 16 17:17 main.c-rw-rw-r--. 1 mozhiyan mozhiyan 0 3月 22 17:39 out.log-rwxr-xr-x. 1 mozhiyan mozhiyan 187 3月 22 17:16 test.shls: 无法访问java: 没有那个文件或目录 out.log的最后一行是错误信息，其它行都是正确的输出结果。 【实例2】把正确结果和错误信息分开保存到不同的文件中，也即写成下面的形式： 1[c.biancheng.net]$ ls -l &gt;&gt;out.log 2&gt;&gt;err.log 这样一来，正确的输出结果会写入到out.log，而错误的信息则会写入到err.log。 /dev/null文件如果你既不想把命令的输出结果保存到文件，也不想把命令的输出结果显示到屏幕上，干扰命令的执行，那么可以把命令的所有结果重定向到/dev/null文件中。如下所示： 1[c.biancheng.net]$ ls -l &amp;&gt;/dev/null 大家可以把/dev/null当成Linux系统的垃圾箱，任何放入垃圾箱的数据都会被丢弃，不能恢复。 Shell输入重定向输入重定向就是改变输入的方向，不再使用键盘作为命令输入的来源，而是使用文件作为命令的输入。 符号 说明 command &lt;file 将file文件中的内容作为command的输入。 command &lt;&lt;END 从标准输入（键盘）中读取数据，直到遇见分界符END才停止（分界符可以是任意的字符串，用户自己定义）。 command &lt;file1 &gt;file2 将file1作为command的输入，并将command的处理结果输出到file2。 注意 输入重定向的完整写法其实是fd&lt;file，其中fd表示文件描述符，如果不写，默认为0，也就是标准输入文件。 ​ 当是输入重定向时，文件描述符为0，一般都省略不写，command &lt;file等同于command 0&lt;file。 输入重定向【示例1】统计文档中有多少行文字。 Linux wc命令可以用来对文本进行统计，包括单词个数、行数、字节数，它的用法如下： wc [选项] [文件名] 其中，-c选项统计字节数，-w选项统计单词数，-l选项统计行数。 统计readme.txt文件中有多少行文本： 1234567[c.biancheng.net]$ cat readme.txt #预览一下文件内容C语言中文网http://c.biancheng.net/成立7年了日IP数万[c.biancheng.net]$ wc -l &lt;readme.txt #输入重定向4 【实例2】逐行读取文件内容。 12345#!/bin/bashwhile read str; do echo $strdone &lt;readme.txt 运行结果：C语言中文网http://c.biancheng.net/成立7年了日IP数万 【实例3】统计用户在终端输入的文本的行数。 ​ 此处我们使用输入重定向符号&lt;&lt;，这个符号的作用是使用特定的分界符作为命令输入的结束标志，而不使用 Ctrl+D键。 1234567[c.biancheng.net]$ wc -l &lt;&lt;END&gt; 123&gt; 789&gt; abc&gt; xyz&gt; END4 wc命令会一直等待用输入，直到遇见分界符END才结束读取。 &lt;&lt;之后的分界符可以自由定义，只要再碰到相同的分界符，两个分界符之间的内容将作为命令的输入。 文件描述符​ 一个Linux进程启动后，会在内核空间中创建一个PCB控制块，PCB内部有一个文件描述符表（File descriptor table），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件。 除了文件描述符表，系统还需要维护另外两张表： 打开文件表（Open file table） i-node表（i-node table） 文件描述符表每个进程都有一个，打开文件表和i-node表整个系统只有一个，它们三者之间的关系如下图所示。 ​ 从本质上讲，这三种表都是结构体数组，0、1、2、73、1976等都是数组下标。表头只是注释，数组本身是没有的。实线箭头表示指针的指向，虚线箭头是注释。 ​ 从上图看文件描述符只是一个数组下标 通过文件描述符，可以找到文件指针，从而进入打开文件表。该表存储了以下信息： 文件偏移量，也就是文件内部指针偏移量。调用read()或者write()函数时，文件偏移量会自动更新，当然也可以使用lseek()直接修改。 状态标志，比如只读模式、读写模式、追加模式、覆盖模式等。 i-node表指针。 然而，要想真正读写文件，还得通过打开文件表的i-node指针进入i-node表，该表包含了诸如以下的信息： 文件类型，例如常规文件、套接字或FIFO。 文件大小。 时间戳，比如创建时间、更新时间。 文件锁。 对上图的进一步说明： 在进程A中，文件描述符1和20都指向了同一个打开文件表项，标号为23（指向了打开文件表中下标为23的数组元素），这可能是通过调用dup()、dup2()、fcntl()或者对同一个文件多次调用了open()函数形成的。 进程A的文件描述符2和进程B的文件描述符2都指向了同一个文件，这可能是在调用fork()后出现的（即进程A、B是父子进程关系），或者是不同的进程独自去调用open()函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。 进程A的描述符0和进程B的描述符3分别指向不同的打开文件表项，但这些表项均指向i-node表的同一个条目（标号为1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了open()调用。同一个进程两次打开同一个文件，也会发生类似情况。 有了以上对文件描述符的认知，我们很容易理解以下情形： 同一个进程的不同文件描述符可以指向同一个文件； 不同进程可以拥有相同的文件描述符； 不同进程的同一个文件描述符可以指向不同的文件（一般也是这样，除了0、1、2这三个特殊的文件）； 不同进程的不同文件描述符也可以指向同一个文件。 重定向本质​ 本章我们探索Shell是如何借助文件描述符实现重定向的。 ​ Linux系统每次读写文件的时候，都从文件描述符下手，通过文件描述符找到文件指针，然后进入打开文件表和i-node表，这两个表里面才真正保存了与打开文件相关的各种信息。 ​ 如果我们改变了文件指针的指向，那就可以改变文件描述符对应的真实文件。比如文件描述符1本来对应显示器，但是我们偷偷将文件指针指向了log.txt文件，那么文件描述符1也就和log.txt对应起来了。 ​ Linux系统提供的函数可以修改文件指针，比如dup()、dup2()；Shell也能修改文件指针，输入输出重定向就是这么干的。 ​ 因此，可以知道输入输出重定向就是通过修改文件指针实现的。更准确地说，发生重定向时，Linux会用文件描述符表（一个结构体数组）中的一个元素给另一个元素赋值，或者用一个结构体变量给数组元素赋值，整体上的资源开销相当低。 ​ 发生重定向的时候，文件描述符并没有改变，改变的是文件描述符对应的文件指针。对于标准输出，Linux系统始终向文件描述符1中输出内容，而不管它的文件指针指向哪里；只要我们修改了文件指针，就能向任意文件中输出内容。 以下面的语句为例来说明： 1[c.biancheng.net]$ echo "c.biancheng.net" 1&gt;log.txt ​ 文件描述符表本质上是一个结构体数组，假设这个结构体的名字叫做FD。发生重定向时，Linux系统首先会打开log.txt文件，并把各种信息添加到i-node表和文件打开表，然后再创建一个FD变量（通过这个变量其实就能读写文件了），并用这个变量给下标为1的数组元素赋值，覆盖原来的内容，这样就改变了文件指针的指向，完成了重定向。 Shell 对文件描述符的操作前面提到，&gt;是输出重定向符号，&lt;是输入重定向符号；更准确地说，它们应该叫做文件描述符操作符。&gt;和&lt;通过修改文件描述符改变了文件指针的指向，所以能够实现重定向的功能。 除了&gt;和&lt;，Shell还是支持&lt;&gt;，它的效果是前面两者的总和。 分类 用法 说明 输出 n&gt;filename 以输出的方式打开文件filename，并绑定到文件描述符n。n可以不写，默认为1，也即标准输出文件。 n&gt;&amp;m 用文件描述符m修改文件描述符n，或者说用文件描述符m的内容覆盖文件描述符n，结果就是n和 m都代表了同一个文件，因为n和m的文件指针都指向了同一个文件。因为使用的是&gt;，所以n和m只能用作命令的输出文件。n可以不写，默认为1。 n&gt;&amp;- 关闭文件描述符n及其代表的文件。n可以不写，默认为1。 &amp;&gt;filename 将正确输出结果和错误信息全部重定向到filename。 输入 n&lt;filename 以输入的方式打开文件filename，并绑定到文件描述符n。n可以不写，默认为0，也即标准输入文件。 n&lt;&amp;m 类似于n&gt;&amp;m，但是因为使用的是&lt;，所以n和m只能用作命令的输入文件。n可以不写，默认为0。 n&lt;&amp;- 关闭文件描述符n及其代表的文件。n可以不写，默认为0。 输入和输出 n&lt;&gt;filename 同时以输入和输出的方式打开文件filename，并绑定到文件描述符n，相当于 n&gt;filename和n&lt;filename的总和。n可以不写，默认为0。 【实例1】前面的文章中提到了下面这种用法： 1command &gt;file 2&gt;&amp;1 ​ 它省略了文件描述符1，所以等价于：1command 1&gt;file 2&gt;&amp;1 ​ 这个语句可以分成两步：先执行1&gt;file，让文件描述符1指向file；再执行2&gt;&amp;1，用文件描述符1修改文件描述符2，让2和1的内容一样。最终1和2都指向了同一个文件，也就是file。所以不管是向1还是向2中输出内容，最终都输出到file文件中。 ​ 这里需要注意执行顺序，多个操作符在一起会从左往右依次执行。对于上面的语句，就是先执行1&gt;file，再执行2&gt;&amp;1；如果写作下面的形式，那就南辕北辙了：1command 2&gt;&amp;1 1&gt;file Shell会先执行2&gt;&amp;1，这样1和2都指向了标准错误输出文件，也即显示器；接着执行1&gt;file，这样 1 就指向了file文件，但是2依然指向显示器。最终的结果是，正确的输出结果输出到了file文件，错误信息却还是输出到显示器。 【实例2】一个比较奇葩的重定向写法。 1[c.biancheng.net]$ echo "C语言中文网" 10&gt;log.txt &gt;&amp;10 先执行10&gt;log.txt，打开log.txt，并给它分配文件描述符10；接着执行&gt;&amp;10，用文件描述符10来修改文件描述符1（对于&gt;，省略不写的话默认为1），让1和10都指向log.txt文件，最终的结果是向log.txt文件中输出内容。 这条语句其实等价于echo &quot;C语言中文网&quot; &gt;log.txt，我之所以写得这么绕，是为了让大家理解各种操作符的用法。 文件描述符 10 只用了一次，我们在末尾最好将它关闭，这是一个好习惯。 1[c.biancheng.net]$ echo "C语言中文网" 10&gt;log.txt &gt;&amp;10 10&gt;&amp;- 永久性地重定向​ exec是Shell内置命令，它有两种用法，一种是执行Shell命令，一种是操作文件描述符。 ​ 使用exec命令可以永久性地重定向，后续命令的输入输出方向也被确定了，直到再次遇到exec命令才会改变重定向的方向；换句话说，一次重定向，永久有效。 请看下面的例子： 12345[mozhiyan@localhost ~]$ echo "c.biancheng.net" &gt; log.txt[mozhiyan@localhost ~]$ echo "C语言中文网"C语言中文网[mozhiyan@localhost ~]$ cat log.txtc.biancheng.net ​ 第一个echo命令使用了重定向，将内容输出到log.txt文件；第二个echo命令没有再次使用重定向，内容就直接输出到显示器上了。很明显，重定向只对第一个echo有效，对第二个echo无效。 ​ 有些脚本文件的输出内容很多，我们不希望直接输出到显示器上，或者我们需要把输出内容备份到文件中，方便以后检索，按照以前的思路，必须在每个命令后面都使用一次重定向，写起来非常麻烦。如果以后想修改重定向的方向，那工作量也是不小的。 ​ exec命令就是为解决这种困境而生的，它可以让重定向对当前Shell进程中的所有命令有效，它的用法为： 1exec 文件描述符操作 在上章节讲到的所有对文件描述符的操作方式exec都支持，请看下面的例子： 1234567891011[mozhiyan@localhost ~]$ echo "重定向未发生"重定向未发生[mozhiyan@localhost ~]$ exec &gt;log.txt[mozhiyan@localhost ~]$ echo "c.biancheng.net"[mozhiyan@localhost ~]$ echo "C语言中文网"[mozhiyan@localhost ~]$ exec &gt;&amp;2[mozhiyan@localhost ~]$ echo "重定向已恢复"重定向已恢复[mozhiyan@localhost ~]$ cat log.txtc.biancheng.netC语言中文网 对代码的说明： exec &gt;log.txt将当前Shell进程的所有标准输出重定向到log.txt文件，它等价于exec 1&gt;log.txt。 后面的两个echo命令都没有在显示器上输出，而是输出到了log.txt文件。 exec &gt;&amp;2用来恢复重定向，让标准输出重新回到显示器，它等价于exec 1&gt;&amp;2。2是标准错误输出的文件描述符，它也是输出到显示器，并且没有遭到破坏，我们用2来覆盖1，就能修复1，让1重新指向显示器。 接下来的echo命令将结果输出到显示器上，证明exec &gt;&amp;2奏效了。 最后我们用cat命令来查看log.txt文件的内容，发现就是中间两个echo命令的输出。 重定向的恢复​ 类似echo &quot;1234&quot; &gt;log.txt这样的重定向只是临时的，当前命名执行完毕后会自动恢复到显示器，我们不用担心。但是诸如exec &gt;log.txt这种使用exec命令的重定向都是持久的，如果我们想再次回到显示器，就必须手动恢复。 ​ 以输出重定向为例，手动恢复的方法有两种： /dev/tty文件代表的就是显示器，将标准输出重定向到/dev/tty即可，也就是exec &gt;/dev/tty。 如果还有别的文件描述符指向了显示器，那么也可以别的文件描述符来恢复标号为1的文件描述符，例如 exec &gt;&amp;2。注意，如果文件描述符2也被重定向了，那么这种方式就无效了。 下面的例子演示了输入重定向的恢复： 123456789101112131415#!/bin/bashexec 6&lt;&amp;0 #先将0号文件描述符保存exec &lt;nums.txt #输入重定向sum=0while read n; do ((sum += n))doneecho "sum=$sum"exec 0&lt;&amp;6 6&lt;&amp;- #恢复输入重定向，并关闭文件描述符6read -p "请输入名字、网址和年龄：" name url ageecho "$name已经$age岁了，它的网址是 $url" 将代码保存到test.txt，并执行下面的命令： 123456789101112[mozhiyan@localhost ~]$ cat nums.txt8033129711002228[mozhiyan@localhost ~]$ bash ./test.shsum=643请输入名字、网址和年龄：C语言中文网 http://c.biancheng.net 7C语言中文网已经7岁了，它的网址是 http://c.biancheng.net 代码块重定向​ 所谓代码块，就是由多条语句组成的一个整体；for、while、until循环，或者if...else、case...in选择结构，或者由{ }包围的命令都可以称为代码块。 ​ 将重定向命令放在代码块的结尾处，就可以对代码块中的所有命令实施重定向。 【实例1】使用 while 循环不断读取nums.txt中的数字，计算它们的总和。 1234567#!/bin/bashsum=0while read n; do ((sum += n))done &lt;nums.txt #输入重定向echo "sum=$sum" 将代码保存到test.sh并运行： 12345678910[c.biancheng.net]$ cat nums.txt8033129711002228[c.biancheng.net]$ . ./test.shsum=643 对上面的代码进行改进，记录while的读取过程，并将输出结果重定向到log.txt文件： 12345678#!/bin/bashsum=0while read n; do ((sum += n)) echo "this number: $n"done &lt;nums.txt &gt;log.txt #同时使用输入输出重定向echo "sum=$sum" 将代码保存到test.sh并运行： 12345678910[c.biancheng.net]$ . ./test.shsum=643[c.biancheng.net]$ cat log.txtthis number: 80this number: 33this number: 129this number: 71this number: 100this number: 222this number: 8 【实例2】对{}包围的代码使用重定向。 123456789101112131415#!/bin/bash&#123; echo "C语言中文网"; echo "http://c.biancheng.net"; echo "7"&#125; &gt;log.txt #输出重定向&#123; read name; read url; read age&#125; &lt;log.txt #输入重定向echo "$name已经$age岁了，它的网址是 $url" 将代码保存到 test.sh并运行： 123456[c.biancheng.net]$ . ./test.shC语言中文网已经7岁了，它的网址是 http://c.biancheng.net[c.biancheng.net]$ cat log.txtC语言中文网http://c.biancheng.net7 内嵌文档(Here Document)​ Shell还有一种特殊形式的重定向叫做“Here Document”，目前没有统一的翻译，你可以将它理解为“嵌入文档”“内嵌文档”“立即文档”。 ​ 所谓文档，就是命令需要处理的数据或者字符串；所谓嵌入，就是把数据和代码放在一起，而不是分开存放（比如将数据放在一个单独的文件中）。有时候命令需要处理的数据量很小，将它放在一个单独的文件中有点“大动干戈”，不如直接放在代码中来得方便。 ​ Here Document的基本用法为： 123command &lt;&lt;END documentEND ​ command是Shell命令，&lt;&lt;END是开始标志，END是结束标志，document是输入的文档（也就是一行一行的字符串）。 ​ 这种写法告诉Shell把document部分作为命令需要处理的数据，直到遇见终止符END为止（终止符END不会被读取）。 ​ 注意，终止符END必须独占一行，并且要定顶格写。 ​ 分界符（终止符）可以是任意的字符串，由用户自己定义，比如 END、MARKER 等。分界符可以出现在正常的数据流中，只要它不是顶格写的独立的一行，就不会被作为结束标志。 【实例1】cat 命令一般是从文件中读取内容，并将内容输出到显示器上，借助 Here Document，cat 命令可以从键盘上读取内容。 12345678[mozhiyan@localhost ~]$ cat &lt;&lt;END&gt; Shell教程&gt; http://c.biancheng.net/shell/&gt; 已经进行了三次改版&gt; ENDShell教程http://c.biancheng.net/shell/已经进行了三次改版 &lt;是第二层命令提示符。 正文中也可以出现结束标志END，只要它不是独立的一行，并且不顶格写，就没问题。 12345678[mozhiyan@localhost ~]$ cat &lt;&lt;END&gt; END可以出现在行首&gt; 出现在行尾的END&gt; 出现在中间的END也是允许的&gt; ENDEND可以出现在行首出现在行尾的END出现在中间的END也是允许的 【实例2】在脚本文件中使用Here Document，并将document中的内容转换为大写。 1234567#!/bin/bash#在脚本文件中使用立即文档tr a-z A-Z &lt;&lt;ENDone two threeHere DocumentEND 将代码保存到test.sh并运行，结果为： 12ONE TWO THREEHERE DOCUMENT 忽略命令替换默认情况下，正文中出现的变量和命令也会被求值或运行，Shell会先将它们替换以后再交给command，请看下面的例子： 1234567[mozhiyan@localhost ~]$ name=C语言中文网[mozhiyan@localhost ~]$ url=http://c.biancheng.net[mozhiyan@localhost ~]$ age=7[mozhiyan@localhost ~]$ cat &lt;&lt;END&gt; $&#123;name&#125;已经$&#123;age&#125;岁了，它的网址是 $&#123;url&#125;&gt; ENDC语言中文网已经7岁了，它的网址是 http://c.biancheng.net 你可以将分界符用单引号或者双引号包围起来使Shell替换失效： 1234567[mozhiyan@localhost ~]$ name=C语言中文网[mozhiyan@localhost ~]$ url=http://c.biancheng.net[mozhiyan@localhost ~]$ age=7[mozhiyan@localhost ~]$ cat &lt;&lt;'END' #使用单引号包围&gt; $&#123;name&#125;已经$&#123;age&#125;岁了，它的网址是 $&#123;url&#125;&gt; END$&#123;name&#125;已经$&#123;age&#125;岁了，它的网址是 $&#123;url&#125; 忽略制表符默认情况下，行首的制表符也被当做正文的一部分。 1234567#!/bin/bashcat &lt;&lt;END Shell教程 http://c.biancheng.net/shell/ 已经进行了三次改版END 将代码保存到 test.sh 并运行，结果如下： ​ Shell教程​ http://c.biancheng.net/shell/​ 已经进行了三次改版 这里的制表符仅仅是为了格式对齐，我们并不希望它作为正文的一部分，为了达到这个目的，你可以在&lt;&lt;和END之间增加-，请看下面的代码： 12345678#!/bin/bash#增加了减号-cat &lt;&lt;-END Shell教程 http://c.biancheng.net/shell/ 已经进行了三次改版END 这次的运行结果为：Shell教程http://c.biancheng.net/shell/已经进行了三次改版 如果你尝试在脚本嵌入一小块多行数据，使用Here Document是很有用的，而嵌入很大的数据块是一个不好的习惯。你应该保持你的逻辑（你的代码）和你的输入（你的数据）分离，最好是在不同的文件中，除非是输入一个很小的数据集。 Here Document最常用的功能还是向用户显示命令或者脚本的用法信息，例如类似下面的函数： 1234567usage()&#123; cat &lt;&lt;-END usage: command [-x] [-v] [-z] [file ...] A short explanation of the operation goes here. It might be a few lines long, but shouldn't be excessive.END&#125; 内嵌字符串(Here String)​ Here String是Here Document的一个变种，它的用法如下： 1command &lt;&lt;&lt; string ​ command是 Shell命令，string是字符串（它只是一个普通的字符串，并没有什么特别之处）。 ​ 这种写法告诉Shell把string部分作为命令需要处理的数据。例如，将小写字符串转换为大写： 12[mozhiyan@localhost ~]$ tr a-z A-Z &lt;&lt;&lt; oneONE ​ Here String对于这种发送较短的数据到进程是非常方便的，它比Here Document更加简洁。 双引号和单引号​ 一个单词不需要使用引号包围，但如果string中带有空格，则必须使用双引号或者单引号包围，如下所示： 12[mozhiyan@localhost ~]$ tr a-z A-Z &lt;&lt;&lt; "one two three"ONE TWO THREE ​ 双引号和单引号是有区别的，双引号会解析其中的变量（当然不写引号也会解析），单引号不会。 请看下面的代码： 1234567[mozhiyan@localhost ~]$ var=two[mozhiyan@localhost ~]$ tr a-z A-Z &lt;&lt;&lt;"one $var there"ONE TWO THERE[mozhiyan@localhost ~]$ tr a-z A-Z &lt;&lt;&lt;'one $var there'ONE $VAR THERE[mozhiyan@localhost ~]$ tr a-z A-Z &lt;&lt;&lt;one$&#123;var&#125;thereONETWOTHERE 有了引号的包围，Here String还可以接收多行字符串作为命令的输入，如下所示： 123456[mozhiyan@localhost ~]$ tr a-z A-Z &lt;&lt;&lt;"one two there&gt; four five six&gt; seven eight"ONE TWO THEREFOUR FIVE SIXSEVEN EIGHT]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell函数]]></title>
    <url>%2F2018%2F05%2F09%2Fshell9-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Shell 函数的本质是一段可以重复使用的脚本代码，这段代码被提前编写好了，放在了指定的位置，使用时直接调取即可。 ​ Shell函数定义的语法格式如下： 1234function name() &#123; statements [return value]&#125; 对各个部分的说明： function是 Shell 中的关键字，专门用来定义函数； name是函数名； statements是函数要执行的代码，也就是一组语句； return value表示函数的返回值，其中return 是Shell关键字，专门用在函数中返回一个值；这一部分可以写也可以不写。 由{ }包围的部分称为函数体，调用一个函数，实际上就是执行函数体中的代码。 函数调用 调用Shell函数时可以给它传递参数，也可以不传递。如果不传递参数，直接给出函数名字即可： 1name 如果传递参数，那么多个参数之间以空格分隔： 1name param1 param2 param3 不管是哪种形式，函数名字后面都不需要带括号。 实例演示1) 定义一个函数，输出 Shell 教程的地址： 123456789#!/bin/bash#函数定义function url()&#123; echo "http://c.biancheng.net/shell/"&#125;#函数调用url 运行结果： http://c.biancheng.net/shell/ 你可以将调用放在定义的前面： 123456789#!/bin/bash#函数调用url#函数定义function url()&#123; echo "http://c.biancheng.net/shell/"&#125; 2) 定义一个函数，计算所有参数的和： 123456789101112131415#!/bin/bashfunction getsum()&#123; local sum=0 for n in $@ do ((sum+=n)) done return $sum&#125;getsum 10 20 55 15 #调用函数并传递参数echo $? ​ $@表示函数的所有参数，$?表示函数的退出状态（返回值）。 函数参数​ 函数参数是Shell位置参数的一种，在函数内部可以使用$n来接收，例如，$1表示第一个参数，$2表示第二个参数，依次类推。 ​ 除了$n ，还有另外三个比较重要的变量： $#可以获取传递的参数的个数； $@或者$*可以一次性获取所有的参数 123456789101112#!/bin/bash#定义函数function show()&#123; echo "Tutorial: $1" echo "URL: $2" echo "Author: "$3 echo "Total $# parameters"&#125;#调用函数show C# http://c.biancheng.net/csharp/ Tom 运行结果： Tutorial: C# URL: http://c.biancheng.net/csharp/ Author: Tom Total 3 parameters 函数返回值​ 在C++、Java、C#、Python等大部分编程语言中，返回值是指函数被调用之后，执行函数体中的代码所得到的结果，这个结果就通过return语句返回。 ​ 但是Shell中的返回值表示的是函数的退出状态：返回值为 0 表示函数执行成功了，返回值为非 0 表示函数执行失败（出错）了。if、while、for等语句都是根据函数的退出状态来判断条件是否成立。 ​ Shell函数的返回值只能是一个介于0~255之间的整数，其中只有 0 表示成功，其它值都表示失败。 ​ 如果函数体中没有return语句，那么使用默认的退出状态，也就是最后一条命令的退出状态。如果这就是你想要的，那么更加严谨的写法为： 1return $? ​ $?是一个特殊变量，用来获取上一个命令的退出状态，或者上一个函数的返回值。 得到函数的处理结果这个问题有两种解决方案： 一种是借助全局变量，将得到的结果赋值给全局变量； 一种是在函数内部使用echo、printf命令将结果输出，在函数外部使用$()捕获结果。 定义一个函数getsum，计算从m加到n的和，并使用以上两种解决方案。 【实例1】将函数处理结果赋值给一个全局变量。 1234567891011121314151617181920#!/bin/bashsum=0 #全局变量function getsum()&#123; for((i=$1; i&lt;=$2; i++)); do ((sum+=i)) #改变全局变量 done return $? #返回上一条命令的退出状态&#125;read mread nif getsum $m $n; then echo "The sum is $sum" #输出全局变量else echo "Error!"fi 运行结果： 1 100 The sum is 5050 【实例2】在函数内部使用echo输出结果。 1234567891011121314151617181920#!/bin/bashfunction getsum()&#123; local sum=0 #局部变量 for((i=$1; i&lt;=$2; i++)); do ((sum+=i)) done echo $sum return $?&#125;read mread ntotal=$(getsum $m $n)echo "The sum is $total"#也可以省略 total 变量，直接写成下面的形式#echo "The sum is "$(getsum $m $n) 运行结果： 1↙ 100↙ The sum is 5050 ​ 代码中总共执行了两次echo命令，但是却只输出一次，这是因为$()捕获了第一个echo的输出结果，它并没有真正输出到终端上。]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell循环]]></title>
    <url>%2F2018%2F05%2F07%2Fshell8-%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[while循环while循环是Shell脚本中最简单的一种循环，当条件满足时，while重复地执行一组语句，当条件不满足时，就退出while循环。 ​ while循环的用法如下： 1234while conditiondo statementsdone ​ condition表示判断条件，statements表示要执行的语句（可以只有一条，也可以有多条），do和done都是 Shell中的关键字。 while循环的执行流程为： 先对condition进行判断，如果该条件成立，就进入循环，执行while循环体中的语句，也就是do和done之间的语句。这样就完成了一次循环。 每一次执行到done的时候都会重新判断condition是否成立，如果成立，就进入下一次循环，继续执行do和done之间的语句，如果不成立，就结束整个while循环，执行done后面的其它Shell代码。 如果一开始condition就不成立，那么程序就不会进入循环体，do和done之间的语句就没有执行的机会。 注意，在while循环体中必须有相应的语句使得condition越来越趋近于“不成立”，只有这样才能最终退出循环，否则while就成了死循环，会一直执行下去，永无休止。 【实例1】计算从 1 加到 100 的和。 1234567891011#!/bin/bashi=1sum=0while ((i &lt;= 100))do ((sum += i)) ((i++))doneecho "The sum is: $sum" ​ 运行结果：​ The sum is: 5050 for循环C语言风格的for循环C语言风格的for循环的用法如下： 1234for((exp1; exp2; exp3))do statementsdone 几点说明： exp1、exp2、exp3是三个表达式，其中exp2是判断条件，for循环根据exp2的结果来决定是否继续下一次循环； statements是循环体语句，可以有一条，也可以有多条； do和done是Shell中的关键字。 它的运行过程为： 1) 先执行exp1。 2) 再执行exp2，如果它的判断结果是成立的，则执行循环体中的语句，否则结束整个for循环。 3) 执行完循环体后再执行exp3。 4) 重复执行步骤2)和3)，直到exp2的判断结果不成立，就结束循环。 ​ exp1仅在第一次循环时执行，以后都不会再执行，可以认为这是一个初始化语句。exp2一般是一个关系表达式，决定了是否还要继续下次循环，称为“循环条件”。exp3很多情况下是一个带有自增或自减运算的表达式，以使循环条件逐渐变得“不成立”。 ​ 计算从 1 加到 100 的和。 12345678910#!/bin/bashsum=0for ((i=1; i&lt;=100; i++))do ((sum += i))doneecho "The sum is: $sum" ​ 运行结果：​ The sum is: 5050 for 循环中的三个表达式​ for循环中的exp1（初始化语句）、exp2（判断条件）和exp3（自增或自减）都是可选项，都可以省略（但分号;必须保留）。 1) 修改“从1加到100的和”的代码，省略exp1： 1234567891011#!/bin/bashsum=0i=1for ((; i&lt;=100; i++))do ((sum += i))doneecho "The sum is: $sum" 2) 省略exp2，就没有了判断条件，如果不作其他处理就会成为死循环，我们可以在循环体内部使用break关键字强制结束循环： 12345678910111213#!/bin/bashsum=0for ((i=1; ; i++))do if(( i&gt;100 )); then break fi ((sum += i))doneecho "The sum is: $sum" 3) 省略了exp3，就不会修改exp2中的变量，这时可在循环体中加入修改变量的语句。例如： 12345678#!/bin/bashsum=0for ((i=1; i&lt;=100; ))do ((sum += i)) ((i++))doneecho "The sum is: $sum" Python风格的for in循环​ Python风格的for in循环的用法如下： 1234for variable in value_listdo statementsdone ​ variable表示变量，value_list表示取值列表，in是Shell中的关键字。 in value_list部分可以省略，省略后的效果相当于in $@。 ​ 每次循环都会从value_list中取出一个值赋给变量variable，然后进入循环体（do和done之间的部分），执行循环体中的statements。直到取完value_list中的所有值，循环就结束了。1234567891011#!/bin/bashsum=0for n in 1 2 3 4 5 6do echo $n ((sum+=n))doneecho "The sum is "$sum ​ 运行结果：1234567123456The sum is 21 对value_list的说明1) 直接给出具体的值​ 可以在 in 关键字后面直接给出具体的值，多个值之间以空格分隔，比如1 2 3 4 5、&quot;abc&quot; &quot;390&quot; &quot;tom&quot;等。 123456#!/bin/bashfor str in "C语言中文网" "http://c.biancheng.net/" "成立7年了" "日IP数万"do echo $strdone 运行结果： C语言中文网 http://c.biancheng.net/ 成立7年了 日IP数万 2) 给出一个取值范围给出一个取值范围的具体格式为： 1&#123;start..end&#125; ​ start表示起始值，end表示终止值；注意中间用两个点号相连，而不是三个点号。这种形式只支持数字和字母。 ​ 例如，计算从 1 加到 100 的和： 12345678910#!/bin/bashsum=0for n in &#123;1..100&#125;do ((sum+=n))doneecho $sum ​ 运行结果：5050 3) 使用命令的执行结果​ 使用$()都可以取得命令的执行结果。 ​ 计算从 1 到 100 之间所有偶数的和： 1234567891011121314#!/bin/bashsum=0for n in $(seq 2 2 100) # seq 2 2 100表示从 2 开始，每次增加 2，到 100 结束。do ((sum+=n))doneecho $sumfor filename in $(ls *.sh)do echo $filenamedone ​ 运行结果：​ 2550​ demo.sh​ test.sh​ abc.sh 4) 使用Shell通配符​ Shell通配符可以认为是一种精简化的正则表达式，通常用来匹配目录或者文件。 123456#!/bin/bashfor filename in *.shdo echo $filenamedone 运行结果： demo.sh test.sh abc.sh 5) 使用特殊变量​ Shell中有多个特殊的变量，在value_list中就可以使用它们。 12345678910#!/bin/bashfunction func()&#123; for str in $@ do echo $str done&#125;func C++ Java Python C# 运行结果： C++ Java Python C# select in循环​ select in循环用来增强交互性，它可以显示出带编号的菜单，用户输入不同的编号就可以选择不同的菜单，并执行不同的功能。 ​ select in循环的用法如下： 1234select variable in value_listdo statementsdone ​ variable表示变量，value_list表示取值列表，in是Shell中的关键字。 ​ select in循环的例子： 1234567#!/bin/bashecho "What is your favourite OS?"select name in "Linux" "Windows" "Mac OS" "UNIX" "Android"do echo "You have selected $&#123;name&#125;"done 运行结果： 123456789101112131415What is your favourite OS?1) Linux2) Windows3) Mac OS4) UNIX5) Android#? 4↙You have selected UNIX#? 1↙You have selected Linux#? 9↙You have selected#? 2↙You have selected Windows#?^D ​ #?用来提示用户输入菜单编号；^D表示按下Ctrl+D组合键，它的作用是结束select in循环。 运行到select语句后，取值列表value_list中的内容会以菜单的形式显示出来。 用户输入菜单编号，就表示选中了某个值，这个值就会赋给变量variable，然后再执行循环体中的 statements（do和done之间的部分）。 如果用户输入的菜单编号不在范围之内，例如上面我们输入的 9，那么就会给 variable 赋一个空值；如果用户输入一个空值（什么也不输入，直接回车），会重新显示一遍菜单。 注意，select是无限循环（死循环），输入空值，或者输入的值无效，都不会结束循环，只有遇到break语句，或者按下Ctrl+D组合键才能结束循环。 完整实例​ select in通常和case in一起使用，在用户输入不同的编号时可以做出不同的反应。 ​ 修改上面的代码，加入 case in 语句： 123456789101112131415161718192021222324252627282930#!/bin/bashecho "What is your favourite OS?"select name in "Linux" "Windows" "Mac OS" "UNIX" "Android"do case $name in "Linux") echo "Linux是一个类UNIX操作系统，它开源免费，运行在各种服务器设备和嵌入式设备。" break ;; "Windows") echo "Windows是微软开发的个人电脑操作系统，它是闭源收费的。" break ;; "Mac OS") echo "Mac OS是苹果公司基于UNIX开发的一款图形界面操作系统，只能运行与苹果提供的硬件之上。" break ;; "UNIX") echo "UNIX是操作系统的开山鼻祖，现在已经逐渐退出历史舞台，只应用在特殊场合。" break ;; "Android") echo "Android是由Google开发的手机操作系统，目前已经占据了70%的市场份额。" break ;; *) echo "输入错误，请重新输入" esacdone]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shellIF条件]]></title>
    <url>%2F2018%2F05%2F04%2Fshell7-IF%E6%9D%A1%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Shell 也支持选择结构，并且有两种形式，分别是if else语句和case in语句。 if语句​ 最简单的用法就是只使用if语句，它的语法格式为： 123456789if conditionthen statement(s)fi# 或者if condition; then statement(s)fi ​ condition是判断条件，如果condition成立（返回“真”），那么then后边的语句将会被执行；如果condition不成立（返回“假”），那么不会执行任何语句。 ​ 当if和then位于同一行的时候， 请注意condition后边的分号;， 这个分号是必须的，否则会有语法错误。 从本质上讲，if检测的是命令的退出状态 。 注意，最后必须以fi来闭合，fi就是if倒过来拼写。 ​ 使用if语句来比较两个数字的大小： 123456789#!/bin/basha=50b=50if (( $a == $b ))then echo "a和b相等"fi ​ 运行结果：a和b相等 if else语句​ 如果有两个分支，就可以使用if else语句，它的格式为： 123456if conditionthen statement1else statement2fi ​ 如果condition成立，那么 then 后边的statement1语句将会被执行；否则，执行else后边的statement2语句。 1234567891011#!/bin/basha=45b=50if (( $a == $b ))then echo "a和b相等"else echo "a和b不相等，输入错误"fi ​ 运行结果：a和b不相等，输入错误 if elif else语句​ Shell支持任意数目的分支，当分支比较多时，可以使用if elif else结构，它的格式为： 12345678910111213if condition1then statement1elif condition2then statement2elif condition3then statement3……else statementnfi 整条语句的执行逻辑为： 如果condition1成立，那么就执行if后边的statement1；如果condition1不成立，那么继续执行elif，判断condition2。 如果condition2成立，那么就执行statement2；如果condition2不成立，那么继续执行后边的elif，判断condition3。 如果condition3成立，那么就执行statement3；如果condition3不成立，那么继续执行后边的elif。 如果所有的if和elif判断都不成立，就进入最后的else，执行statementn。 12345678910111213141516171819#!/bin/bashage=19if (( $age &lt;= 2 )); then echo "婴儿"elif (( $age &gt;= 3 &amp;&amp; $age &lt;= 8 )); then echo "幼儿"elif (( $age &gt;= 9 &amp;&amp; $age &lt;= 17 )); then echo "少年"elif (( $age &gt;= 18 &amp;&amp; $age &lt;=25 )); then echo "成年"elif (( $age &gt;= 26 &amp;&amp; $age &lt;= 40 )); then echo "青年"elif (( $age &gt;= 41 &amp;&amp; $age &lt;= 60 )); then echo "中年"else echo "老年"fi ​ 运行结果：成年 退出状态​ 每一条Shell命令，不管是Bash内置命令（例如cd、echo），还是外部的Linux 命令（例如ls、awk），还是自定义的Shell函数，当它退出（运行结束）时，都会返回一个比较小的整数值给调用（使用）它的程序，这就是命令的退出状态（exit statu）。 ​ if语句的判断条件，从本质上讲，判断的就是命令的退出状态。 按照惯例来说，退出状态为0表示“成功”；也就是说，程序执行完成并且没有遇到任何问题。除0以外的其它任何退出状态都为“失败”。 12345678#!/bin/bashread aread b(( $a == $b ));echo "退出状态："$? 运行结果1：1232626退出状态：0 运行结果2：1231739退出状态：1 退出状态和逻辑运算符的组合​ Shell if语句的一个神奇之处是允许我们使用逻辑运算符将多个退出状态组合起来，这样就可以一次判断多个条件了。 运算符 使用格式 说明 &amp;&amp; expression1 &amp;&amp; expression2 逻辑与运算符，当expression1和expression2 同时成立时，整个表达式才成立。 如果检测到expression1的退出状态为 0，就不会再检测expression2了，因为不管expression2的退出状态是什么，整个表达式必然都是不成立的，检测了也是多此一举。 ` ` ` expression1 expression2` 逻辑或运算符，expression1和expression2两个表达式中只要有一个成立，整个表达式就成立。 如果检测到expression1的退出状态为 1，就不会再检测expression2了，因为不管expression2的退出状态是什么，整个表达式必然都是成立的，检测了也是多此一举。 ! !expression 逻辑非运算符，相当于“取反”的效果。如果expression成立，那么整个表达式就不成立；如果expression不成立，那么整个表达式就成立。 【实例】将用户输入的URL写入到文件中。123456789101112#!/bin/bashread filenameread urlif test -w $filename &amp;&amp; test -n $urlthen echo $url &gt; $filename echo "写入成功"else echo "写入失败"fi ​ 在Shell脚本文件所在的目录新建一个文本文件并命名为urls.txt，然后运行Shell脚本，运行结果为： urls.txt↙ http://c.biancheng.net/shell/↙ 写入成功 test命令​ test是Shell内置命令，用来检测某个条件是否成立。test通常和if语句一起使用，并且大部分if语句都依赖test。 ​ Shell test命令的用法为： 12test expression[ expression ] ​ 当test判断expression成立时，退出状态为0，否则为非0值。test命令也可以简写为[]， 注意[]和expression之间的空格，这两个空格是必须的，否则会导致语法错误。[]的写法更加简洁，比test使用频率高。 12345678910111213141516171819#!/bin/bashread ageif test $age -le 2; then echo "婴儿"elif test $age -ge 3 &amp;&amp; test $age -le 8; then echo "幼儿"elif [ $age -ge 9 ] &amp;&amp; [ $age -le 17 ]; then echo "少年"elif [ $age -ge 18 ] &amp;&amp; [ $age -le 25 ]; then echo "成年"elif test $age -ge 26 &amp;&amp; test $age -le 40; then echo "青年"elif test $age -ge 41 &amp;&amp; [ $age -le 60 ]; then echo "中年"else echo "老年"fi 1) 与文件检测相关的test选项 文件类型判断 选 项 作 用 -b filename 判断文件是否存在，并且是否为块设备文件。 -c filename 判断文件是否存在，并且是否为字符设备文件。 -d filename 判断文件是否存在，并且是否为目录文件。 -e filename 判断文件是否存在。 -f filename 判断文件是否存在，井且是否为普通文件。 -L filename 判断文件是否存在，并且是否为符号链接文件。 -p filename 判断文件是否存在，并且是否为管道文件。 -s filename 判断文件是否存在，并且是否为非空。 -S filename 判断该文件是否存在，并且是否为套接字文件。 文件权限判断 选 项 作 用 -r filename 判断文件是否存在，并且是否拥有读权限。 -w filename 判断文件是否存在，并且是否拥有写权限。 -x filename 判断文件是否存在，并且是否拥有执行权限。 -u filename 判断文件是否存在，并且是否拥有SUID权限。 -g filename 判断文件是否存在，并且是否拥有SGID权限。 -k filename 判断该文件是否存在，并且是否拥有SBIT权限。 文件比较 选 项 作 用 filename1 -nt filename2 判断filename1的修改时间是否比filename2的新。 filename -ot filename2 判断filename1的修改时间是否比filename2的旧。 filename1 -ef filename2 判断filename1是否和filename2的inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法 ​ 文件检测举例： 123456789101112#!/bin/bashread filenameread urlif test -w $filename &amp;&amp; test -n $urlthen echo $url &gt; $filename echo "写入成功"else echo "写入失败"fi ​ 在Shell 脚本文件所在的目录新建一个文本文件并命名为urls.txt，然后运行Shell脚本，运行结果为：​ urls.txt↙​ http://c.biancheng.net/shell/↙​ 写入成功 2) 与数值比较相关的test选项 注意，test只能用来比较整数，小数相关的比较还得依赖bc 命令。 选 项 作 用 num1 -eq num2 判断num1是否和num2 相等。 num1 -ne num2 判断num1是否和num2不相等。 num1 -gt num2 判断num1是否大于num2 。 num1 -lt num2 判断num1是否小于num2。 num1 -ge num2 判断num1是否大于等于num2。 num1 -le num2 判断num1是否小于等于num2。 数值比较举例： 12345678910#!/bin/bashread a bif test $a -eq $bthen echo "两个数相等"else echo "两个数不相等"fi 运行结果1：1210 10两个数相等 运行结果2：1210 20两个数不相等 3) 与字符串判断相关的test选项 选 项 作 用 -z str 判断字符串str是否为空。 -n str 判断宇符串str是否为非空。 str1 = str2 str1 == str2 =和==是等价的，都用来判断str1是否和str2相等。 str1 != str2 判断str1是否和str2不相等。 str1 \&gt; str2 判断str1是否大于str2。\&gt;是&gt;的转义字符，这样写是为了防止&gt;被误认为成重定向运算符。 str1 \&lt; str2 判断str1是否小于str2。同样，\&lt;也是转义字符。 ​ 有C语言、C++、Python、Java等编程经验的读者请注意，==、&gt;、&lt;在大部分编程语言中都用来比较数字，而在Shell中，它们只能用来比较字符串，不能比较数字，这是非常奇葩的，大家要习惯。​ 其次，不管是比较数字还是字符串，Shell都不支持&gt;=和&lt;=运算符，切记。 ​ 字符串比较举例： 12345678910111213141516171819#!/bin/bashread str1read str2#检测字符串是否为空if [ -z "$str1" ] || [ -z "$str2" ]then echo "字符串不能为空" exit 0fi#比较字符串if [ $str1 = $str2 ]then echo "两个字符串相等"else echo "两个字符串不相等"fi 运行结果： http://c.biancheng.net/ http://c.biancheng.net/shell/ 两个字符串不相等 4) 与逻辑运算相关的test选项 选 项 作 用 expression1 -a expression 逻辑与，表达式expression1和expression2都成立，最终的结果才是成立的。 expression1 -o expression2 逻辑或，表达式expression1和expression2 有一个成立，最终的结果就成立。 !expression 逻辑非，对 expression进行取反。 改写上面的代码，使用逻辑运算选项： 12345678910111213141516171819#!/bin/bashread str1read str2#检测字符串是否为空if [ -z "$str1" -o -z "$str2" ] #使用 -o 选项取代之前的 ||then echo "字符串不能为空" exit 0fi#比较字符串if [ $str1 = $str2 ]then echo "两个字符串相等"else echo "两个字符串不相等"fi 在test中使用变量建议用双引号包围起来​ test和[]都是命令，一个命令本质上对应一个程序或者一个函数。即使是一个程序，它也有入口函数，例如C语言程序的入口函数是main()，运行C语言程序就从main()函数开始，所以也可以将一个程序等效为一个函数，这样我们就不用再区分函数和程序了，直接将一个命令和一个函数对应起来即可。 ​ 使用一个命令其实就是调用一个函数，命令后面附带的选项和参数最终都会作为实参传递给函数。 假设 test 命令对应的函数是func()，使用test -z $str1 如果$str1是一个正常的字符串，比如abc123，那么替换后的效果就是test -z abc123，调用func()函数的形式就是func(&quot;-z abc123&quot;)。test 命令后面附带的所有选项和参数会被看成一个整体，并作为实参传递进函数。 如果$str1是一个空字符串，那么替换后的效果就是test -z，调用func()函数的形式就是func(&quot;-z &quot;)，这就比较奇怪了，因为-z选项没有和参数成对出现，func()在分析时就会出错。 如果我们给$str1 变量加上双引号，当$str1是空字符串时，test -z &quot;$str1&quot;就会被替换为test -z &quot;&quot;，调用func()函数的形式就是func(&quot;-z \&quot;\&quot;&quot;)，很显然，-z选项后面跟的是一个空字符串（\&quot;表示转义字符），这样func()在分析时就不会出错了。 ​ 所以，当你在 test 命令中使用变量时，我强烈建议将变量用双引号&quot;&quot;包围起来，这样能避免变量为空值时导致的很多奇葩问题。 [[]]详解：检测某个条件是否成立​ [[ ]]是Shell内置关键字，它和test 命令类似，也用来检测某个条件是否成立。可以认为[[ ]]是 test 的升级版，对细节进行了优化，并且扩展了一些功能。 ​ [[ ]]的用法为： 1[[ expression ]] ​ 当[[ ]]判断expression成立时，退出状态为0，否则为非0值。注意[[ ]]和expression之间的空格，这两个空格是必须的，否则会导致语法错误。 [[]]不需要注意某些细枝末节​ [[]]是Shell内置关键字，不是命令，在使用时没有给函数传递参数的过程，所以test命令的某些注意事项在[[ ]]中就不存在了，具体包括： 不需要把变量名用双引号&quot;&quot;包围起来，即使变量是空值，也不会出错。 不需要、也不能对&gt;、&lt;进行转义，转义后会出错。 1234567891011121314#!/bin/bashread str1read str2if [[ -z $str1 ]] || [[ -z $str2 ]] #不需要对变量名加双引号then echo "字符串不能为空"elif [[ $str1 &lt; $str2 ]] #不需要也不能对 &lt; 进行转义then echo "str1 &lt; str2"else echo "str1 &gt;= str2"fi 运行结果： http://c.biancheng.net/shell/ http://data.biancheng.net/ str1 &lt; str2 [[]]支持逻辑运算符​ 对多个表达式进行逻辑运算时，可以使用逻辑运算符将多个 test 命令连接起来，例如：12[ -z "$str1" ] || [ -z "$str2" ][ -z "$str1" -o -z "$str2" ] ​ [[]]支持&amp;&amp;、||和!三种逻辑运算符。 完美的写法是在[[]]命令中使用逻辑运算符将多个表达式连接起来。使用[[]]对上面的语句进行改进： 12[[ -z $str1 || -z $str2 ]][[ -z $str1 ]] || [[ -z $str2 ]] [[]]支持正则表达式 在Shell [[]]中，可以使用=~ 来检测字符串是否符合某个正则表达式，它的用法为： 1[[ str =~ regex ]] ​ str表示字符串，regex表示正则表达式。 ​ 下面的代码检测一个字符串是否是手机号： 12345678910#!/bin/bashread telif [[ $tel =~ ^1[0-9]&#123;10&#125;$ ]]then echo "你输入的是手机号码"else echo "你输入的不是手机号码"fi ​ 运行结果1：1213203451100你输入的是手机号码 ​ 运行结果2：12132034511009你输入的不是手机号码 对^1[0-9]{10}$ 的说明： ^匹配字符串的开头（一个位置）； [0-9]{10}匹配连续的十个数字； $匹配字符串的末尾（一个位置）。 case in语句​ 当分支较多，并且判断条件比较简单时，使用case in语句就比较方便了。case in的基本格式如下： 1234567891011121314case expression in pattern1) statement1 ;; pattern2) statement2 ;; pattern3) statement3 ;; …… *) statementnesac case、in和esac都是Shell关键字，expression表示表达式，pattern表示匹配模式。 expression既可以是一个变量、一个数字、一个字符串，还可以是一个数学计算表达式，或者是命令的执行结果，只要能够得到expression的值就可以。 pattern可以是一个数字、一个字符串，甚至是一个简单的正则表达式。 case会将expression 的值与pattern1、pattern2、pattern3逐个进行匹配： 如果expression和某个模式（比如pattern2）匹配成功，就会执行这模式（比如pattern2）后面对应的所有语句（该语句可以有一条，也可以有多条），直到遇见双分号;;才停止；然后整个case语句就执行完了，程序会跳出整个case语句，执行esac后面的其它语句。 如果expression没有匹配到任何一个模式，那么就执行*)后面的语句（*表示其它所有值），直到遇见双分号;;或者esac才结束。*)相当于多个if分支语句中最后的else部分。 如果你有C语言、C++、Java等编程经验，这里的;;和*)就相当于其它编程语言中的break和default。 对*) 的几点说明： Shell case in语句中的*)用来“托底”，万一expression没有匹配到任何一个模式，*)部分可以做一些“善后”工作，或者给用户一些提示。 可以没有*)部分。如果expression没有匹配到任何一个模式，那么就不执行任何操作。 最后一个分支可以写;;，也可以不写，因为无论如何，执行到esac都会结束整个case in语句。 代码如下所示 ： 123456789101112131415161718192021222324252627282930#!/bin/bashprintf "Input integer number: "read numcase $num in 1) echo "Monday" ;; 2) echo "Tuesday" ;; 3) echo "Wednesday" ;; 4) echo "Thursday" ;; 5) echo "Friday" ;; 6) echo "Saturday" ;; 7) echo "Sunday" ;; *) echo "error"esac 运行结果： Input integer number:3↙ Wednesday]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell数学计算方法]]></title>
    <url>%2F2018%2F05%2F03%2Fshell6-%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在Bash Shell中，如果不特别指明，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。 12345678910[c.biancheng.net]$ echo 2+82+8[c.biancheng.net]$ a=23[c.biancheng.net]$ b=$a+55[c.biancheng.net]$ echo $b23+55[c.biancheng.net]$ b=90[c.biancheng.net]$ c=$a+$b[c.biancheng.net]$ echo $c23+90 ​ 默认情况下，Shell不会直接进行算术运算，而是把+两边的数据（数值或者变量）当做字符串，把+当做字符串连接符，最终的结果是把两个字符串拼接在一起形成一个新的字符串。 (())：对整数进行数学运算​ 双小括号(( ))是Bash Shell中专门用来进行整数运算的命令，注意：(( ))只能进行整数运算，不能对小数（浮点数）或者字符串进行运算。后续讲到的bc命令可以用于小数运算。 (( )) 的用法​ 双小括号 (( )) 的语法格式为： 1((表达式)) ​ 表达式可以只有一个，也可以有多个，多个表达式之间以逗号,分隔。对于多个表达式的情况，以最后一个表达式的值作为整个(( ))命令的执行结果。 ​ 可以使用$获取(( ))命令的结果，这和使用$获得变量值是类似的。 运算操作符/运算命令 说明 ((a=10+66))((b=a-15)) ((c=a+b)) 这种写法可以在计算完成后给变量赋值。以((b=a-15))为例，即将a-15的运算结果赋值给变量 c。 注意，使用变量时不用加$前缀，(( ))会自动解析变量名。 a=$((10+66) b=$((a-15)) c=$((a+b)) 可以在 (( )) 前面加上$符号获取(( ))命令的执行结果，也即获取整个表达式的值。以c=$((a+b))为例，即将a+b这个表达式的运算结果赋值给变量 c。 注意，类似c=((a+b))这样的写法是错误的，不加$就不能取得表达式的结果。 ((a&gt;7 &amp;&amp; b==c)) (( ))也可以进行逻辑运算，在if语句中常会使用逻辑运算。 echo $((a+10)) 需要立即输出表达式的运算结果时，可以在(( ))前面加$符号。 ((a=3+5, b=a+10)) 对多个表达式同时进行计算。 ​ 在 (( )) 中使用变量无需加上$前缀，(( )) 会自动解析变量名。 (( )) 实例演示123456789101112131415161718192021222324252627[c.biancheng.net]$ echo $((6-3))3[c.biancheng.net]$ i=5[c.biancheng.net]$ ((i=i*2)) #可以简写为 ((i*=2))。[c.biancheng.net]$ echo $i #使用 echo 输出变量结果时要加 $。10[c.biancheng.net]$ a=$((100*(100+1)/2)) #利用公式计算1+2+3+...+100的和。[c.biancheng.net]$ echo $a5050[c.biancheng.net]$ echo $((100*(100+1)/2)) #也可以直接输出表达式的结果。5050[c.biancheng.net]$ echo $((8==8)) #判断是否相等。1[c.biancheng.net]$ if ((8&gt;7&amp;&amp;5==5))&gt; then&gt; echo yes&gt; fiyes[c.biancheng.net]$ a=10[c.biancheng.net]$ echo $((a++)) #如果++在a的后面，那么在输出整个表达式时，会输出a的值,因为a为10，所以表达式的值为10。10[c.biancheng.net]$ ((a=3+5, b=a+10)) #先计算第一个表达式，再计算第二个表达式[c.biancheng.net]$ echo $a $b8 18[c.biancheng.net]$ c=$((4+8, a+b)) #以最后一个表达式的结果作为整个(())命令的执行结果[c.biancheng.net]$ echo $c26 let命令：对整数进行数学运算​ let命令和双小括号(( ))的用法是类似的，它们都是用来对整数进行运算。注意：和双小括号(( ))一样，let命令也只能进行整数运算，不能对小数（浮点数）或者字符串进行运算。 ​ Shell let命令的语法格式为： 123let 表达式let "表达式"let '表达式' ​ 它们都等价于((表达式))。当表达式中含有 Shell 特殊字符（例如 |）时，需要用双引号&quot; &quot;或者单引号&#39; &#39;将表达式包围起来。 ​ 和(( ))类似，let命令也支持一次性计算多个表达式，并且以最后一个表达式的值作为整个let命令的执行结果。但是，对于多个表达式之间的分隔符，let和(( ))是有区别的： let命令以空格来分隔多个表达式； (( ))以逗号,来分隔多个表达式。 let命令实例演示123456789[c.biancheng.net]$ i=2[c.biancheng.net]$ let i+=8[c.biancheng.net]$ echo $i10[c.biancheng.net]$ a=10 b=35[c.biancheng.net]$ let a+=6 c=a+b #多个表达式以空格为分隔[c.biancheng.net]$ echo $a $c16 51 $[]：对整数进行数学运算​ $[]也只能进行整数运算。 ​ Shell $[]的用法如下： 1$[表达式] ​ $[]会对表达式进行计算，并取得计算结果。如果表达式中包含了变量，那么你可以加$，也可以不加。 ​ 举例： 1234567891011121314151617[c.biancheng.net]$ echo $[3*5] #直接输出结算结果15[c.biancheng.net]$ echo $[(3+4)*5] #使用()35[c.biancheng.net]$ n=6[c.biancheng.net]$ m=$[n*2] #将计算结果赋值给变量[c.biancheng.net]$ echo $[m+n]18[c.biancheng.net]$ echo $[$m*$n] #在变量前边加$也是可以的72[c.biancheng.net]$ echo $[4*(m+n)]72[c.biancheng.net]$ $[3+4]bash: 7: 未找到命令...[c.biancheng.net]$ $[m+3]bash: 15: 未找到命令... expr命令：对整数进行运算​ expr是一个功能强大，并且比较复杂的命令，它除了可以实现整数计算，还可以结合一些选项对字符串进行处理。 ​ Shell expr对于整数计算的用法为： 1expr 表达式 ​ expr对表达式的格式有几点特殊的要求： 出现在表达式中的运算符、数字、变量和小括号的左右两边至少要有一个空格，否则会报错。 有些特殊符号必须用反斜杠\进行转义（屏蔽其特殊含义），比如乘号*和小括号()，如果不用\转义，那么Shell会把它们误解为正则表达式中的符号（*对应通配符，()对应分组）。 使用变量时要加$前缀。 1234567891011121314151617181920[c.biancheng.net]$ expr 2 +3 #错误：加号和 3 之前没有空格expr: 语法错误[c.biancheng.net]$ expr 2 + 3 #这样才是正确的5[c.biancheng.net]$ expr 4 * 5 #错误：乘号没有转义expr: 语法错误[c.biancheng.net]$ expr 4 \* 5 #使用 \ 转义后才是正确的20[c.biancheng.net]$ expr ( 2 + 3 ) \* 4 #小括号也需要转义bash: 未预期的符号 `2' 附近有语法错误[c.biancheng.net]$ expr \( 2 + 3 \) \* 4 #使用 \ 转义后才是正确的20[c.biancheng.net]$ n=3[c.biancheng.net]$ expr n + 2 #使用变量时要加 $expr: 非整数参数[c.biancheng.net]$ expr $n + 2 #加上 $ 才是正确的5[c.biancheng.net]$ m=7[c.biancheng.net]$ expr $m \* \( $n + 5 \)56 bc命令：一款数学计算器​ bc命令可以很方便的进行浮点运算 ​ 在Shell脚本中，我们可以借助管道或者输入重定向来使用bc计算器。 管道是Linux进程间的一种通信机制，它可以将前一个命令（进程）的输出作为下一个命令（进程）的输入，两个命令之间使用竖线|分隔。 通常情况下，一个命令从终端获得用户输入的内容，如果让它从其他地方（比如文件）获得输入，那么就需要重定向。 借助管道使用bc计算器​ 如果读者希望直接输出bc的计算结果，那么可以使用下面的形式： 12echo "expression" | bcvariable=$(echo "expression" | bc) # variable 就是变量名,可以将 bc 的计算结果赋值给 Shell 变量 ​ expression就是希望计算的数学表达式，它必须符合bc的语法，上面我们已经进行了介绍。在expression中，还可以使用Shell脚本中的变量。 最简单的形式12345[c.biancheng.net]$ echo "3*8"|bc24[c.biancheng.net]$ ret=$(echo "4+9"|bc)[c.biancheng.net]$ echo $ret13 使用bc中的变量 变量名 作 用 scale 指定精度，也即小数点后的位数；默认为0，也即不使用小数部分。 ibase 指定输入的数字的进制，默认为十进制。 obase 指定输出的数字的进制，默认为十进制。 last或者. 表示最近打印的数字 12345678910111213141516[c.biancheng.net]$ echo "scale=4;3*8/7"|bc3.4285[c.biancheng.net]$ echo "scale=4;3*8/7;last*5"|bc3.428517.1425#十进制转十六进制[mozhiyan@localhost ~]$ m=31[mozhiyan@localhost ~]$ n=$(echo "obase=16;$m"|bc)[mozhiyan@localhost ~]$ echo $n1F#十六进制转十进制[mozhiyan@localhost ~]$ m=1E[mozhiyan@localhost ~]$ n=$(echo "obase=10;ibase=16;$m"|bc)[mozhiyan@localhost ~]$ echo $n30 使用bc中的内置函数​ 除了内置变量，bc还有一些内置函数， 要想使用这些数学函数，在输入bc命令时需要使用-l选项，表示启用数学库 。如下表所示： 函数名 作用 s(x) 计算x的正弦值，x是弧度值。 c(x) 计算x的余弦值，x是弧度值。 a(x) 计算x的反正切值，返回弧度值。 l(x) 计算x的自然对数。 e(x) 求e的x次方。 j(n, x) 贝塞尔函数，计算从n到x的阶数 123[c.biancheng.net]$ x=4[c.biancheng.net]$ echo "scale=5;n=$x+2;e(n)"|bc -l403.42879 借助输入重定向使用bc计算器​ 可以使用下面的形式将bc的计算结果赋值给Shell变量： 1234variable=$(bc &lt;&lt; EOFexpressionsEOF) ​ 其中，variable是 Shell 变量名，express是要计算的数学表达式（可以换行，和进入bc以后的书写形式一样），EOF是数学表达式的开始和结束标识（你也可以换成其它的名字，比如aaa、bbb等）。 请看下面的例子： 123456789[c.biancheng.net]$ m=1E[c.biancheng.net]$ n=$(bc &lt;&lt; EOF&gt; obase=10;&gt; ibase=16;&gt; print $m&gt; EOF&gt; )[c.biancheng.net]$ echo $n30]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell内建命令]]></title>
    <url>%2F2018%2F05%2F03%2Fshell5-%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[所谓Shell内建命令，就是由Bash自身提供的命令，而不是文件系统中的某个可执行文件 alias：给命令创建别名​ alisa用来给命令创建一个别名。若直接输入该命令且不带任何参数，则列出当前Shell进程中使用了哪些别名。 12345678[mozhiyan@localhost ~]$ aliasalias cp='cp -i'alias l.='ls -d .* --color=tty'alias ll='ls -l --color=tty'alias ls='ls --color=tty'alias mv='mv -i'alias rm='rm -i'alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde' alias命令自定义别名​ 使用alias命令自定义别名的语法格式为：1alias new_name=&apos;command&apos; ​ 通过date命令可以获得当前的UNIX时间戳，具体写法为date +%s，如果你嫌弃它太长或者不容易记住，那可以给它定义一个别名。 12345678910#!/bin/bashalias timestamp='date +%s'begin=`timestamp` sleep 20sfinish=$(timestamp)difference=$((finish - begin))echo "run time: $&#123;difference&#125;s" ​ 运行脚本，20 秒后看到输出结果：run time: 20s unalias命令删除别名使用unalias内建命令可以删除当前Shell进程中的别名。unalias有两种使用方法： 第一种用法是在命令后跟上某个命令的别名，用于删除指定的别名。 第二种用法是在命令后接-a参数，删除当前Shell进程中所有的别名。 echo命令：输出字符串​ echo是一个Shell内建命令，用来在终端输出字符串，并在最后默认加上换行符。 123456789#!/bin/bashname="Shell教程"url="http://c.biancheng.net/shell/"echo "读者，你好！" #直接输出字符串echo $url #输出变量echo "$&#123;name&#125;的网址是：$&#123;url&#125;" #双引号包围的字符串中可以解析变量echo '$&#123;name&#125;的网址是：$&#123;url&#125;' #单引号包围的字符串中不能解析变量 ​ 运行结果： 1234读者，你好！http://c.biancheng.net/shell/Shell教程的网址是：http://c.biancheng.net/shell/$&#123;name&#125;的网址是：$&#123;url&#125; exit命令：退出当前进程​ exit是一个Shell内置命令，用来退出当前Shell进程，并返回一个退出状态；使用$?可以接收这个退出状态。 ​ exit命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。 一般情况下，退出状态为 0 表示成功，退出状态为非 0 表示执行失败（出错）了。exit退出状态只能是一个介于0~255之间的整数，其中只有 0 表示成功，其它值都表示失败。 12345#!/bin/bashecho "befor exit"exit 8echo "after exit" 运行该脚本： 12[mozhiyan@localhost ~]$ bash ./test.shbefor exit 可以看到，&quot;after exit&quot;并没有输出，这说明遇到exit命令后，test.sh执行就结束了。 declare命令：设置变量属性​ declare是Shell内建命令，用来设置变量的属性。​ declare命令的用法如下所示： 1declare [+/-] [aAfFgilprtux] [变量名=变量值] ​ 其中，-表示设置属性，+表示取消属性，aAfFgilprtux都是具体的选项，它们的含义如下表所示： 选项 含义 -f [name] 列出之前由用户在脚本中定义的函数名称和函数体。 -F [name] 仅列出自定义函数名称。 -g name 在 Shell 函数内部创建全局变量。 -p [name] 显示指定变量的属性和值。 -a name 声明变量为普通数组。 -A name 声明变量为关联数组（支持索引下标为字符串）。 -i name 将变量定义为整数型。 -r name[=value] 将变量定义为只读（不可修改和删除），等价于readonly name。 -x name[=value] 将变量设置为环境变量，等价于export name[=value]。 1234567891011121314#!/bin/bashdeclare -i m n ret #将多个变量声明为整数m=10n=30ret=$m+$necho $ret # 40declare -r n=10n=20 # bash: n: 只读变量echo $n # 10declare -r n=10declare -p n # declare -r n="10"]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell数组]]></title>
    <url>%2F2018%2F05%2F02%2Fshell4-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Shell并且没有限制数组的大小，理论上可以存放无限量的数据。Shell数组元素的下标也是从 0 开始计数。获取数组中的元素要使用下标[ ]，下标可以是一个整数，也可以是一个结果为整数的表达式；当然，下标必须大于等于 0。 常用的Bash Shell只支持一维数组，不支持多维数组。 数组的定义​ 在 Shell 中，用括号( )来表示数组，数组元素之间用空格来分隔。由此，定义数组的一般形式为： 1array_name=(ele1 ele2 ele3 ... elen) ​ 注意，赋值号=两边不能有空格，必须紧挨着数组名和数组元素。 ​ Shell 是弱类型的，它并不要求所有数组元素的类型必须相同。 此外，你也无需逐个元素地给数组赋值，可以只给特定元素赋值。 ​ 定义数组的实例： 123nums=(29 100 13 8 91 44)arr=(20 56 "http://c.biancheng.net/shell/")ages=([3]=24 [5]=19 [10]=12) # 只给第 3、5、10 个元素赋值，所以数组长度是 3 ​ Shell数组的长度不是固定的，定义之后还可以增加元素。例如，对于上面的nums数组，它的长度是 6，使用下面的代码会在最后增加一个元素，使其长度扩展到 7：1nums[6]=88 获取数组元素​ 获取数组元素的值，一般使用下面的格式： 1$&#123;array_name[index]&#125; ​ 其中，array_name是数组名，index是下标。例如： 1234n=$&#123;nums[2]&#125; # 表示获取 nums 数组的第二个元素，然后赋值给变量 n。echo $&#123;nums[3]&#125; # 表示输出 nums 数组的第 3 个元素。$&#123;nums[*]&#125; # 使用@或*可以获取数组中的所有元素$&#123;nums[@]&#125; # 使用@或*可以获取数组中的所有元素 ​ 完整的演示： 1234567#!/bin/bashnums=(29 100 13 8 91 44)echo $&#123;nums[@]&#125; #输出所有数组元素nums[10]=66 #给第10个元素赋值（此时会增加数组长度）echo $&#123;nums[*]&#125; #输出所有数组元素echo $&#123;nums[4]&#125; #输出第4个元素 ​ 运行结果： 12329 100 13 8 91 4429 100 13 8 91 44 6691 获取数组长度​ 所谓数组长度，就是数组元素的个数。 利用@或*，可以将数组扩展成列表，然后使用#来获取数组元素的个数，格式如下： 123$&#123;#array_name[@]&#125;$&#123;#array_name[*]&#125;$&#123;#arr[2]&#125; # 获取 arr 数组的第 2 个元素（假设它是字符串）的长度。 ​ 其中array_name表示数组名。两种形式是等价的，选择其一即可。 数组拼接​ 所谓Shell数组拼接（数组合并），就是将两个数组连接成一个数组。 ​ 拼接数组的思路是：先利用@或*，将数组扩展成列表，然后再合并到一起。具体格式如下： 12array_new=($&#123;array1[@]&#125; $&#123;array2[@]&#125;)array_new=($&#123;array1[*]&#125; $&#123;array2[*]&#125;) ​ array1和array2是需要拼接的数组，array_new是拼接后形成的新数组。 1234567#!/bin/basharray1=(23 56)array2=(99 "http://c.biancheng.net/shell/")array_new=($&#123;array1[@]&#125; $&#123;array2[*]&#125;)echo $&#123;array_new[@]&#125; #也可以写作 $&#123;array_new[*]&#125; ​ 运行结果： 123 56 99 http://c.biancheng.net/shell/ 删除数组元素​ 在Shell中，使用unset关键字来删除数组元素，具体格式如下：12unset array_name[index]unset array_name ​ 其中，array_name表示数组名，index表示数组下标。 如果不写下标， 就是删除整个数组，所有元素都会消失。 12345678#!/bin/basharr=(23 56 99 "http://c.biancheng.net/shell/")unset arr[1]echo $&#123;arr[@]&#125;unset arrecho $&#123;arr[*]&#125; 运行结果： 123 99 http://c.biancheng.net/shell/ 关联数组​ 关联数组也称为“键值对（key-value）”数组，键（key）也即字符串形式的数组下标，值（value）也即元素值。 ​ 不同于普通数组，关联数组必须使用带有-A选项的declare命令创建。我们可以创建一个叫做 color 的关联数组，并用颜色名字作为下标；也可以在定义的同时赋值： 123456declare -A colorcolor["red"]="#ff0000"color["green"]="#00ff00"color["blue"]="#0000ff"declare -A color=(["red"]="#ff0000", ["green"]="#00ff00", ["blue"]="#0000ff") 访问关联数组元素 访问关联数组元素的方式几乎与普通数组相同，具体形式为： 12array_name["index"]$&#123;array_name["index"]&#125; # 加上$&#123;&#125;即可获取数组元素的值 例如： 123456color["white"]="#ffffff"color["black"]="#000000"# 加上$&#123;&#125;即可获取数组元素的值echo $&#123;color["white"]&#125;white=$&#123;color["black"]&#125; 获取所有元素的下标和值​ 使用下面的形式可以获得关联数组的所有元素值：12$&#123;array_name[@]&#125;$&#123;array_name[*]&#125; ​ 使用下面的形式可以获取关联数组的所有下标值：12$&#123;!array_name[@]&#125;$&#123;!array_name[*]&#125; 获取关联数组长度​ 使用下面的形式可以获得关联数组的长度：12$&#123;#array_name[*]&#125;$&#123;#array_name[@]&#125; ​ 关联数组实例演示： 12345678910111213141516171819202122232425262728#!/bin/bashdeclare -A colorcolor["red"]="#ff0000"color["green"]="#00ff00"color["blue"]="#0000ff"color["white"]="#ffffff"color["black"]="#000000"#获取所有元素值for value in $&#123;color[*]&#125;do echo $valuedoneecho "****************"#获取所有元素下标（键）for key in $&#123;!color[*]&#125;do echo $keydoneecho "****************"#列出所有键值对for key in $&#123;!color[@]&#125;do echo "$&#123;key&#125; -&gt; $&#123;color[$key]&#125;"done 运行结果：1234567891011121314151617#ff0000#0000ff#ffffff#000000#00ff00***************redbluewhiteblackgreen***************red -&gt; #ff0000blue -&gt; #0000ffwhite -&gt; #ffffffblack -&gt; #000000green -&gt; #00ff00]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell字符串]]></title>
    <url>%2F2018%2F04%2F29%2Fshell3-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[字符串（String）就是一系列字符的组合。字符串可以由单引号&#39; &#39;包围，也可以由双引号&quot; &quot;包围，也可以不用引号。 表现形式​ 字符串举例： 123str1=c.biancheng.netstr2="shell script"str3='C语言中文网' 下面我们说一下三种形式的区别： 1) 由单引号&#39; &#39;包围的字符串： 任何字符都会原样输出，在其中使用变量是无效的。 字符串中不能出现单引号，即使对单引号进行转义也不行。 2) 由双引号&quot; &quot;包围的字符串： 如果其中包含了某个变量，那么该变量会被解析（得到该变量的值），而不是原样输出。 字符串中可以出现双引号，只要它被转义了就行。 3) 不被引号包围的字符串 不被引号包围的字符串中出现变量时也会被解析，这一点和双引号&quot; &quot;包围的字符串一样。 字符串中不能出现空格，否则空格后边的字符串会作为其他变量或者命令解析。 我们通过代码来演示一下三种形式的区别： 12345678910#!/bin/bashn=74str1=c.biancheng.net$n str2="shell \"script\" $n"str3='C语言中文网 $n'echo $str1echo $str2echo $str3 运行结果： 123c.biancheng.net74shell "script" 74C语言中文网 $n ​ str1中包含了$n，它被解析为变量n的引用。$n后边有空格，紧随空格的是str2；Shell 将str2解释为一个新的变量名，而不是作为字符串str1的一部分。 ​ str2中包含了引号，但是被转义了（由反斜杠\开头的表示转义字符）。str2中也包含了$n，它也被解析为变量n的引用。 ​ str3中也包含了$n，但是仅仅是作为普通字符，并没有解析为变量n的引用。 获取字符串长度 在Shell中获取字符串长度很简单，具体方法如下： 1$&#123;#string_name&#125; ​ string_name表示字符串名字。 ​ 下面是具体的演示： 1234#!/bin/bashstr="http://c.biancheng.net/shell/"echo $&#123;#str&#125; ​ 运行结果：29 字符串拼接​ 在Shell中你不需要使用任何运算符，将两个字符串并排放在一起就能实现拼接，非常简单粗暴。 12345678910111213141516#!/bin/bashname="Shell"url="http://c.biancheng.net/shell/"str1=$name$url #中间不能有空格str2="$name $url" #如果被双引号包围，那么中间可以有空格str3=$name": "$url #中间可以出现别的字符串str4="$name: $url" #这样写也可以str5="$&#123;name&#125;Script: $&#123;url&#125;index.html" #这个时候需要给变量名加上大括号echo $str1echo $str2echo $str3echo $str4echo $str5 运行结果： 12345Shellhttp://c.biancheng.net/shell/Shell http://c.biancheng.net/shell/Shell: http://c.biancheng.net/shell/Shell: http://c.biancheng.net/shell/ShellScript: http://c.biancheng.net/shell/index.html 字符串截取​ Shell截取字符串通常有两种方式：从指定位置开始截取和从指定字符（子字符串）开始截取。 从指定位置开始截取​ 这种方式需要两个参数：除了指定起始位置，还需要截取长度，才能最终确定要截取的字符串。 1) 从字符串左边开始计数​ 如果想从字符串的左边开始计数，那么截取字符串的具体格式如下： 1$&#123;string: start :length&#125; ​ 其中，string是要截取的字符串，start是起始位置（从左边开始，从0开始计数），length是要截取的长度（省略的话表示直到字符串的末尾）。 ​ 例如： 123url="c.biancheng.net"echo $&#123;url: 2: 9&#125;echo $&#123;url: 2&#125; #省略 length，截取到字符串末尾 结果为： 12bianchengbiancheng.net 2) 从右边开始计数​ 如果想从字符串的右边开始计数，那么截取字符串的具体格式如下： 1$&#123;string: 0-start :length&#125; ​ 同第 1) 种格式相比，第 2) 种格式仅仅多了0-，这是固定的写法，专门用来表示从字符串右边开始计数。 ​ 这里需要强调两点： 从左边开始计数时，起始数字是 0（这符合程序员思维）；从右边开始计数时，起始数字是 1。计数方向不同，起始数字也不同。 不管从哪边开始计数，截取方向都是从左到右。 例如： 123url="c.biancheng.net"echo $&#123;url: 0-13: 9&#125;echo $&#123;url: 0-13&#125; #省略 length，直接截取到字符串末尾 结果为： 12bianchengbiancheng.net 从指定字符（子字符串）开始截取​ 这种截取方式无法指定字符串长度，只能从指定字符（子字符串）截取到字符串末尾。 1) 使用#号截取右边字符​ 使用# 号可以截取指定字符（或者子字符串）右边的所有字符，具体格式如下： 12$&#123;string#*chars&#125; # 从第一个指定字符（子字符串）匹配结束$&#123;string##*chars&#125; # 直到最后一个指定字符（子字符串）再匹配结束 ​ 其中，string表示要截取的字符，chars是指定的字符（或者子字符串），*是通配符的一种，表示任意长度的字符串。*chars连起来使用的意思是：忽略左边的所有字符，直到遇见chars（chars不会被截取）。 1234567891011url="http://c.biancheng.net/index.html"echo $&#123;url#*:&#125; # 结果为//c.biancheng.net/index.htmlecho $&#123;url#*p:&#125; # 结果为//c.biancheng.net/index.htmlecho $&#123;url#*ttp:&#125; # 结果为//c.biancheng.net/index.htmlecho $&#123;url#http://&#125; # 结果为c.biancheng.net/index.htmlecho $&#123;url#*/&#125; # 结果为/c.biancheng.net/index.html。url 字符串中有三个/，输出结果表明，Shell 遇到第一个/就匹配结束了。echo $&#123;url##*/&#125; # 结果为 index.htmlstr="---aa+++aa@@@"echo $&#123;str#*aa&#125; #结果为 +++aa@@@echo $&#123;str##*aa&#125; #结果为 @@@ 2) 使用%截取左边字符​ 使用%号可以截取指定字符（或者子字符串）左边的所有字符，具体格式如下： 1$&#123;string%chars*&#125; ​ 请注意*的位置，因为要截取chars左边的字符，而忽略chars右边的字符，所以*应该位于chars的右侧。其他方面%和#的用法相同，这里不再赘述，仅举例说明： 123456789#!/bin/bashurl="http://c.biancheng.net/index.html"echo $&#123;url%/*&#125; #结果为 http://c.biancheng.netecho $&#123;url%%/*&#125; #结果为 http:str="---aa+++aa@@@"echo $&#123;str%aa*&#125; #结果为 ---aa+++echo $&#123;str%%aa*&#125; #结果为 ---]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell特殊变量]]></title>
    <url>%2F2018%2F04%2F25%2Fshell2-%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Shell位置参数​ 运行Shell脚本文件时我们可以给它传递一些参数，这些参数在脚本文件内部可以使用$n的形式来接收，例如，$1表示第一个参数，$2表示第二个参数，依次类推。 ​ 同样，在调用函数时也可以传递参数。Shell函数参数的传递和其它编程语言不同，没有所谓的形参和实参，在定义函数时也不用指明参数的名字和数目。换句话说，定义Shell函数时不能带参数，但是在调用函数时却可以传递参数，这些传递进来的参数，在函数内部就也使用$n的形式接收，例如，$1表示第一个参数，$2表示第二个参数，依次类推。 ​ 这种通过$n的形式来接收的参数，在Shell中称为位置参数。 ​ 在讲解变量的命名时，我们提到：变量的名字必须以字母或者下划线开头，不能以数字开头；但是位置参数却偏偏是数字，这和变量的命名规则是相悖的，所以我们将它们视为“特殊变量”。除了$n，Shell 中还有$#、$*、$@、$?、$$几个特殊参数，我们将在下节讲解。 1) 给脚本文件传递位置参数请编写下面的代码，并命名为test.sh： 123#!/bin/bashecho "Language: $1"echo "URL: $2" 运行test.sh，并附带参数： 1234[mozhiyan@localhost ~]$ cd demo[mozhiyan@localhost demo]$ . ./test.sh Shell http://c.biancheng.net/shell/Language: ShellURL: http://c.biancheng.net/shell/ 其中Shell是第一个位置参数，http://c.biancheng.net/shell/是第二个位置参数，两者之间以空格分隔。 2) 给函数传递位置参数 请编写下面的代码，并命名为test.sh： 123456789#!/bin/bash#定义函数function func()&#123; echo "Language: $1" echo "URL: $2"&#125;#调用函数 func C++ http://c.biancheng.net/cplus/ 运行test.sh： 1234[mozhiyan@localhost ~]$ cd demo[mozhiyan@localhost demo]$ . ./test.shLanguage: C++URL: http://c.biancheng.net/cplus/ 注意事项​ 如果参数个数太多，达到或者超过了 10 个，那么就得用${n}的形式来接收了，例如 ${10}、${23}。{ }的作用是为了帮助解释器识别参数的边界，这跟使用变量时加{ }是一样的效果。 Shell特殊变量 变量 含义 $0 当前脚本的文件名。 $n（n≥1） 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有参数。当被双引号&quot; &quot;包含时，$@与$*稍有不同。 $? 上个命令的退出状态，或函数的返回值。 $$ 当前 Shell 进程ID。对于Shell脚本，就是这些脚本所在的进程 ID。 1) 给脚本文件传递参数 编写下面的代码，并保存为test.sh： 123456789#!/bin/bashecho "Process ID: $$"echo "File Name: $0"echo "First Parameter : $1"echo "Second Parameter : $2"echo "All parameters 1: $@"echo "All parameters 2: $*"echo "Total: $#" 运行test.sh，并附带参数： 12345678[mozhiyan@localhost demo]$ . ./test.sh Shell LinuxProcess ID: 5943File Name: bashFirst Parameter : ShellSecond Parameter : LinuxAll parameters 1: Shell LinuxAll parameters 2: Shell LinuxTotal: 2 2) 给函数传递参数编写下面的代码，并保存为test.sh： 1234567891011121314#!/bin/bash#定义函数function func()&#123; echo "Language: $1" echo "URL: $2" echo "First Parameter : $1" echo "Second Parameter : $2" echo "All parameters 1: $@" echo "All parameters 2: $*" echo "Total: $#"&#125;#调用函数func Java http://c.biancheng.net/java/ 运行结果为： 1234567Language: JavaURL: http://c.biancheng.net/java/First Parameter : JavaSecond Parameter : http://c.biancheng.net/java/All parameters 1: Java http://c.biancheng.net/java/All parameters 2: Java http://c.biancheng.net/java/Total: 2 命令$*和$@的区别​ 当$*和$@不被双引号&quot; &quot;包围时，它们之间没有任何区别，都是将接收到的每个参数看做一份数据，彼此之间以空格来分隔。 ​ 但是当它们被双引号&quot; &quot; 包含时，就会有区别了： &quot;$*&quot;会将所有的参数从整体上看做一份数据，而不是把每个参数都看做一份数据。 &quot;$@&quot;仍然将每个参数都看作一份数据，彼此之间是独立的。 比如传递了 5 个参数，那么对于&quot;$*&quot;来说，这 5 个参数会合并到一起形成一份数据，它们之间是无法分割的；而对于&quot;$@&quot;来说，这 5 个参数是相互独立的，它们是 5 份数据。 ​ 如果使用 echo 直接输出&quot;$*&quot;和&quot;$@&quot;做对比，是看不出区别的；但如果使用 for 循环来逐个输出数据，立即就能看出区别来。 编写下面的代码，并保存为test.sh： 12345678910111213#!/bin/bashecho "print each param from \"\$*\""for var in "$*"do echo "$var"done echo "print each param from \"\$@\""for var in "$@"do echo "$var"done 运行test.sh，并附带参数： 12345678[mozhiyan@localhost demo]$ . ./test.sh a b c dprint each param from "$*"a b c dprint each param from "$@"abcd ​ 从运行结果可以发现，对于&quot;$*&quot;，只循环了 1 次，因为它只有 1 分数据；对于&quot;$@&quot;，循环了 5 次，因为它有 5 份数据。 命令$?的含义​ $?是一个特殊变量，用来获取上一个命令的退出状态，或者上一个函数的返回值。 ​ 所谓退出状态，就是上一个命令执行后的返回结果。退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1，这和C语言的main()函数是类似的。 1) $?获取上一个命令的退出状态 编写下面的代码，并保存为test.sh： 12345678#!/bin/bashif [ "$1" == 100 ]then exit 0 #参数正确，退出状态为0else exit 1 #参数错误，退出状态1fi exit表示退出当前shell进程，我们必须在新进程中运行test.sh，否则当前Shell会话（终端窗口）会被关闭，我们就无法取得它的退出状态了。 例如，运行test.sh时传递参数 100： 1234[mozhiyan@localhost ~]$ cd demo[mozhiyan@localhost demo]$ bash ./test.sh 100 #作为一个新进程运行[mozhiyan@localhost demo]$ echo $?0 再如，运行test.sh时传递参数 89： 123[mozhiyan@localhost demo]$ bash ./test.sh 89 #作为一个新进程运行[mozhiyan@localhost demo]$ echo $?1 2)$?获取函数的返回值 编写下面的代码，并保存为test.sh： 1234567891011#!/bin/bash#得到两个数相加的和function add()&#123; return `expr $1 + $2`&#125;#调用函数add 23 50 #获取函数返回值echo $? 运行结果：73 ​ 严格来说，Shell函数中的return关键字用来表示函数的退出状态，而不是函数的返回值；Shell不像其它编程语言，没有专门处理返回值的关键字。]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell变量]]></title>
    <url>%2F2018%2F04%2F22%2Fshell1-%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[变量是任何一种编程语言都必不可少的组成部分，变量用来存放各种数据。脚本语言在定义变量时通常不需要指明类型，直接赋值就可以，Shell变量也遵循这个规则。 ​ 在Bash shell中，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。 ​ 这意味着，Bash shell在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串，这一点和大部分的编程语言不同。例如在C语言或者C++中，变量分为整数、小数、字符串、布尔等多种类型。 ​ 当然，如果有必要，你也可以使用Shell declare关键字显式定义变量的类型，但在一般情况下没有这个需求，Shell开发者在编写代码时自行注意值的类型即可。 定义变量Shell支持以下三种定义变量的方式： 123variable=valuevariable='value'variable="value" ​ variable是变量名，value是赋给变量的值。如果value不包含任何空白符（例如空格、Tab缩进等），那么可以不使用引号；如果value包含了空白符，那么就必须使用引号包围起来。使用单引号和使用双引号也是有区别的，稍后我们会详细说明。 注意，赋值号=的周围不能有空格，这可能和你熟悉的大部分编程语言都不一样。 变量名由数字、字母、下划线组成； 必须以字母或者下划线开头； 不能使用Shell里的关键字（通过help命令可以查看保留关键字）。 变量定义举例： 123456url=http://c.biancheng.net/shell/echo $urlname='C语言中文网'echo $nameauthor="严长生"echo $author 使用变量​ 使用一个定义过的变量，只要在变量名前面加美元符号$ 即可，如： 123author="严长生"echo $authorecho $&#123;author&#125; ​ 变量名外面的花括号{ }是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况： 12skill="Java"echo "I am good at $&#123;skill&#125;Script" ​ 如果不给skill变量加花括号，写成echo &quot;I am good at $skillScript&quot; ，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。 ​ 推荐给所有变量加上花括号{ }，这是个良好的编程习惯。 修改变量的值​ 已定义的变量，可以被重新赋值，如： 1234url="http://c.biancheng.net"echo $&#123;url&#125;url="http://c.biancheng.net/shell/"echo $&#123;url&#125; ​ 第二次对变量赋值时不能在变量名前加$，只有在使用变量时才能加$。 单引号和双引号的区别​ 前面我们还留下一个疑问，定义变量时，变量的值可以由单引号&#39; &#39;包围，也可以由双引号&quot; &quot;包围，它们到底有什么区别呢？不妨以下 面的代码为例来说明： 1234567#!/bin/bashurl="http://c.biancheng.net"website1='C语言中文网：$&#123;url&#125;'website2="C语言中文网：$&#123;url&#125;"echo $website1echo $website2 ​ 运行结果：C语言中文网：${url}C语言中文网：http://c.biancheng.net ​ 以单引号&#39; &#39;包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。 ​ 以双引号&quot; &quot;包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。 ​ 我的建议：如果变量的内容是数字，那么可以不加引号；如果真的需要原样输出就加单引号；其他没有特别要求的字符串等最好都加上双引号，定义变量时加双引号是最常见的使用场景。 将命令的结果赋值给变量​ Shell也支持将命令的执行结果赋值给变量，常见的有以下两种方式： 12variable=`command`variable=$(command) ​ 第一种方式把命令用反引号（位于Esc键的下方）包围起来，反引号和单引号非常相似，容易产生混淆，所以不推荐使用这种方式；第二种方式把命令用$()包围起来，区分更加明显，所以推荐使用这种方式。 ​ 例如，我在demo目录中创建了一个名为log.txt的文本文件，用来记录我的日常工作。下面的代码中，使用 cat命令将log.txt的内容读取出来，并赋值给一个变量，然后使用 echo 命令输出。 1234567[mozhiyan@localhost ~]$ cd demo[mozhiyan@localhost demo]$ log=$(cat log.txt)[mozhiyan@localhost demo]$ echo $log严长生正在编写Shell教程，教程地址：http://c.biancheng.net/shell/[mozhiyan@localhost demo]$ log=`cat log.txt`[mozhiyan@localhost demo]$ echo $log严长生正在编写Shell教程，教程地址：http://c.biancheng.net/shell/ 只读变量​ 使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 下面的例子尝试更改只读变量，结果报错： 12345#!/bin/bashmyUrl="http://c.biancheng.net/shell/"readonly myUrlmyUrl="http://c.biancheng.net/shell/" 运行脚本，结果如下： 1bash: myUrl: This variable is read only. 删除变量​ 使用 unset 命令可以删除变量。语法： 1unset variable_name ​ 变量被删除后不能再次使用；unset命令不能删除只读变量。 ​ 举个例子： 123456#!/bin/shmyUrl="http://c.biancheng.net/shell/"unset myUrlecho $myUrl ​ 上面的脚本没有任何输出。 Shell变量的作用域（Scope） ，就是Shell变量的有效范围（可以使用的范围）。 ​ 在不同的作用域中，同名的变量不会相互干涉，就好像 A 班有个叫小明的同学，B 班也有个叫小明的同学，虽然他们都叫小明（对应于变量名），但是由于所在的班级（对应于作用域）不同，所以不会造成混乱。但是如果同一个班级中有两个叫小明的同学，就必须用类似于“大小明”、“小小明”这样的命名来区分他们。 ​ Shell变量的作用域可以分为三种： 有的变量只能在函数内部使用，这叫做局部变量（local variable）； 有的变量可以在当前Shell进程中使用，这叫做全局变量（global variable）； 而有的变量还可以在子进程中使用，这叫做环境变量（environment variable）。 Shell局部变量​ Shell也支持自定义函数，但是Shell函数和C++、Java、C#等其他编程语言函数的一个不同点就是：在 Shell 函数中定义的变量默认也是全局变量，它和在函数外部定义变量拥有一样的效果。请看下面的代码： 123456789#!/bin/bash#定义函数function func()&#123; a=99&#125;#调用函数func#输出函数内部的变量echo $a ​ 输出结果：​ 99 ​ a是在函数内部定义的，但是在函数外部也可以得到它的值，证明它的作用域是全局的，而不是仅限于函数内部。要想变量的作用域仅限于函数内部，可以在定义时加上local命令，此时该变量就成了局部变量。请看下面的代码： 123456789#!/bin/bash#定义函数function func()&#123; local a=99&#125;#调用函数func#输出函数内部的变量echo $a ​ 输出结果为空，表明变量a在函数外部无效，是一个局部变量。 ​ Shell变量的这个特性和JavaScript中的变量是类似的。在JavaScript函数内部定义的变量，默认也是全局变量，只有加上var关键字，它才会变成局部变量。 Shell全局变量​ 所谓全局变量，就是指变量在当前的整个Shell进程中都有效。每个Shell进程都有自己的作用域，彼此之间互不影响。在Shell中定义的变量，默认就是全局变量。 ​ 想要实际演示全局变量在不同Shell进程中的互不相关性，可在图形界面下同时打开两个Shell，或使用两个终端远程连接到服务器（SSH）。 ​ 首先打开一个Shell窗口，定义一个变量a并赋值为99，然后打印，这时在同一个Shell窗口中是可正确打印变量a的值的。然后再打开一个新的Shell窗口，同样打印变量a的值，但结果却为空，如图 1 所示。 ​ 这说明全局变量 a 仅仅在定义它的第一个Shell进程中有效，对新的Shell进程没有影响。这很好理解，就像小王家和小徐家都有一部电视机（变量名相同），但是同一时刻小王家和小徐家的电视中播放的节目可以是不同的（变量值不同）。 ​ 需要强调的是，全局变量的作用范围是当前的Shell进程，而不是当前的Shell脚本文件，它们是不同的概念。打开一个Shell窗口就创建了一个Shell进程，打开多个 Shell 窗口就创建了多个Shell进程，每个Shell进程都是独立的，拥有不同的进程ID。在一个Shell进程中可以使用source命令执行多个Shell脚本文件，此时全局变量在这些脚本文件中都有效。 ​ 例如，现在有两个Shell脚本文件，分别是a.sh和b.sh。a.sh的代码如下： 123#!/bin/bashecho $ab=200 ​ b.sh的代码如下： 12#!/bin/bashecho $b ​ 打开一个Shell窗口，输入以下命令： 12345[c.biancheng.net]$ a=99[c.biancheng.net]$ . ./a.sh99[c.biancheng.net]$ . ./b.sh200 ​ 这三条命令都是在一个进程中执行的，从输出结果可以发现，在Shell窗口中以命令行的形式定义的变量a，在a.sh中有效；在a.sh中定义的变量b，在b.sh中也有效，变量b的作用范围已经超越了a.sh。 ​ 注意，必须在当前进程中运行 Shell 脚本，不能在新进程中运行 Shell 脚本。 Shell环境变量​ 全局变量只在当前Shell进程中有效，对其它Shell进程和子进程都无效。如果使用export 命令将全局变量导出，那么它就在所有的子进程中也有效了，这称为“环境变量”。 ​ 环境变量被创建时所处的Shell进程称为父进程，如果在父进程中再创建一个新的进程来执行Shell命令，那么这个新的进程被称作Shell子进程。当Shell子进程产生时，它会继承父进程的环境变量为自己所用，所以说环境变量可从父进程传给子进程。不难理解，环境变量还可以传递给孙进程。 ​ 注意，两个没有父子关系的Shell进程是不能传递环境变量的，并且环境变量只能向下传递而不能向上传递，即“传子不传父”。 ​ 创建Shell子进程最简单的方式是运行bash命令，如图 2 所示。 ​ 通过exit命令可以一层一层地退出Shell。 ​ 下面演示一下环境变量的使用： 123456789101112131415[c.biancheng.net]$ a=22 #定义一个全局变量[c.biancheng.net]$ echo $a #在当前Shell中输出a，成功22[c.biancheng.net]$ bash #进入Shell子进程[c.biancheng.net]$ echo $a #在子进程中输出a，失败[c.biancheng.net]$ exit #退出Shell子进程，返回上一级Shellexit[c.biancheng.net]$ export a #将a导出为环境变量[c.biancheng.net]$ bash #重新进入Shell子进程[c.biancheng.net]$ echo $a #在子进程中再次输出a，成功22[c.biancheng.net]$ exit #退出Shell子进程exit[c.biancheng.net]$ exit #退出父进程，结束整个Shell会话 ​ 可以发现，默认情况下，a在Shell子进程中是无效的；使用export将a导出为环境变量后，在子进程中就可以使用了。 ​ export a这种形式是在定义变量a以后再将它导出为环境变量，如果想在定义的同时导出为环境变量，可以写作export a=22。 ​ 我们一直强调的是环境变量在 Shell 子进程中有效，并没有说它在所有的Shell进程中都有效；如果你通过终端创建了一个新的Shell窗口，那它就不是当前Shell的子进程，环境变量对这个新的Shell进程仍然是无效的。请看下图： ​ 第一个窗口中的环境变量a在第二个窗口中就无效。 环境变量也是临时的​ 通过export导出的环境变量只对当前Shell进程以及所有的子进程有效，如果最顶层的父进程被关闭了，那么环境变量也就随之消失了，其它的进程也就无法使用了，所以说环境变量也是临时的。 Shell命令替换Shell命令替换是指将命令的输出结果赋值给某个变量。比如，在某个目录中输入ls命令可查看当前目录中所有的文件，但如何将输出内容存入某个变量中呢？这就需要使用命令替换了，这也是Shell编程中使用非常频繁的功能。 ​ Shell中有两种方式可以完成命令替换，一种是反引号，一种是$()，使用方法如下： 12variable=`commands`variable=$(commands) ​ 其中，variable是变量名，commands是要执行的命令。commands可以只有一个命令，也可以有多个命令，多个命令之间以分号;分隔。 ​ 例如，date命令用来获得当前的系统时间，使用命令替换可以将它的结果赋值给一个变量。 123456#!/bin/bashbegin_time=`date` #开始时间，使用``替换sleep 20s #休眠20秒finish_time=$(date) #结束时间，使用$()替换echo "Begin time: $begin_time"echo "Finish time: $finish_time" ​ 运行脚本，20 秒后可以看到输出结果： 12Begin time: 2019年 04月 19日 星期五 09:59:58 CSTFinish time: 2019年 04月 19日 星期五 10:00:18 CST ​ 使用 data 命令的%s格式控制符可以得到当前的UNIX时间戳，这样就可以直接计算脚本的运行时间了。UNIX时间戳是指从1970 年 1 月 1 日 00:00:00到目前为止的秒数。 12345678#!/bin/bashbegin_time=`date +%s` #开始时间，使用``替换sleep 20s #休眠20秒finish_time=$(date +%s) #结束时间，使用$()替换run_time=$((finish_time - begin_time)) #时间差echo "begin time: $begin_time"echo "finish time: $finish_time"echo "run time: $&#123;run_time&#125;s" ​ 运行脚本，20 秒后可以看到输出结果： 123begin time: 1555639864finish time: 1555639884run time: 20s ​ 第 6 行代码中的(( ))是 Shell 数学计算命令。和C++、C#、Java 等编程语言不同，在 Shell 中进行数据计算不那么方便，必须使用专门的数学计算命令，(( ))就是其中之一。 ​ 注意，如果被替换的命令的输出内容包括多行（也即有换行符），或者含有多个连续的空白符，那么在输出变量时应该将变量用双引号包围，否则系统会使用默认的空白符来填充，这会导致换行无效，以及连续的空白符被压缩成一个。请看下面的代码： 12345#!/bin/bashLSL=`ls -l`echo $LSL #不使用双引号包围echo "--------------------------" #输出分隔符echo "$LSL" #使用引号包围 运行结果： 123456total 8 drwxr-xr-x. 2 root root 21 7月 1 2016 abc -rw-rw-r--. 1 mozhiyan mozhiyan 147 10月 31 10:29 demo.sh -rw-rw-r--. 1 mozhiyan mozhiyan 35 10月 31 10:20 demo.sh~--------------------------total 8drwxr-xr-x. 2 root root 21 7月 1 2016 abc-rw-rw-r--. 1 mozhiyan mozhiyan 147 10月 31 10:29 demo.sh-rw-rw-r--. 1 mozhiyan mozhiyan 35 10月 31 10:20 demo.sh~ ​ 所以，为了防止出现格式混乱的情况，我建议在输出变量时加上双引号。 再谈反引号和 $()​ 原则上讲，上面提到的两种变量替换的形式是等价的，可以随意使用；但是，反引号毕竟看起来像单引号，有时候会对查看代码造成困扰，而使用$()就相对清晰，能有效避免这种混乱。而且有些情况必须使用$()；$()支持嵌套，反引号不行。 ​ 下面的例子演示了使用计算ls命令列出的第一个文件的行数，这里使用了两层嵌套。 123[c.biancheng.net]$ Fir_File_Lines=$(wc -l $(ls | sed -n '1p'))[c.biancheng.net]$ echo "$Fir_File_Lines"36 anaconda-ks.cfg ​ 要注意的是，$()仅在Bash Shell中有效，而反引号可在多种Shell中使用。所以这两种命令替换的方式各有特点，究竟选用哪种方式全看个人需求。]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之union共同体]]></title>
    <url>%2F2018%2F03%2F10%2Fc%E8%AF%AD%E8%A8%804-union%E5%85%B1%E7%94%A8%E4%BD%93%2F</url>
    <content type="text"><![CDATA[通过前面的讲解，我们知道结构体（Struct）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在C语言中，还有另外一种和结构体非常类似的语法，叫做共用体（Union），它的定义格式为： 123union 共用体名&#123; 成员列表 &#125;; 共用体有时也被称为联合或者联合体，这也是Union这个单词的本意。 ​ 结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。 **结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。** ​ 共用体也是一种自定义类型，可以通过它来创建变量，例如： 123456union data&#123; int n; char ch; double f;&#125;;union data a, b, c; ​ 上面是先定义共用体，再创建变量，也可以在定义共用体的同时创建变量： 12345union data&#123; int n; char ch; double f;&#125; a, b, c; ​ 如果不再定义新的变量，也可以将共用体的名字省略： 12345union&#123; int n; char ch; double f;&#125; a, b, c; ​ 共用体data中，成员f占用的内存最多，为8个字节，所以data类型的变量（也就是a、b、c）也占用8个字节的内存，请看下面的演示： 12345678910111213141516171819202122#include &lt;stdio.h&gt;union data&#123; int n; char ch; short m;&#125;;int main()&#123; union data a; printf("%d, %d\n", sizeof(a), sizeof(union data) ); a.n = 0x40; printf("%X, %c, %hX\n", a.n, a.ch, a.m); a.ch = '9'; printf("%X, %c, %hX\n", a.n, a.ch, a.m); a.m = 0x2059; printf("%X, %c, %hX\n", a.n, a.ch, a.m); a.n = 0x3E25AD54; printf("%X, %c, %hX\n", a.n, a.ch, a.m); return 0;&#125; ​ 运行结果： 123454, 440, @, 4039, 9, 392059, Y, 20593E25AD54, T, AD54 ​ 这段代码不但验证了共用体的长度，还说明共用体成员之间会相互影响，修改一个成员的值会影响其他成员。 ​ 要想理解上面的输出结果，弄清成员之间究竟是如何相互影响的，就得了解各个成员在内存中的分布。以上面的 data为例，各个成员在内存中的分布如下： ​ 成员n、ch、m在内存中“对齐”到一头，对ch赋值修改的是前一个字节，对m赋值修改的是前两个字节，对n赋值修改的是全部字节。也就是说，ch、m会影响到n的一部分数据，而n会影响到ch、m的全部数据。 ​ 上图是在绝大多数PC机上的内存分布情况，如果是51单片机，情况就会有所不同： 共用体的应用​ 共用体在一般的编程中应用较少，在单片机中应用较多。对于PC机，经常使用到的一个实例是： 现有一张关于学生信息和教师信息的表格。学生信息包括姓名、编号、性别、职业、分数，教师的信息包括姓名、编号、性别、职业、教学科目。请看下面的表格： Name Num Sex Profession Score / Course HanXiaoXiao 501 f s 89.5 YanWeiMin 1011 m t math LiuZhenTao 109 f t English ZhaoFeiYan 982 m s 95.0 ​ f和m分别表示女性和男性，s表示学生，t表示教师。可以看出，学生和教师所包含的数据是不同的。现在要求把这些信息放在同一个表格中，并设计程序输入人员信息然后输出。 ​ 如果把每个人的信息都看作一个结构体变量的话，那么教师和学生的前4个成员变量是一样的，第5个成员变量可能是score或者course。当第4个成员变量的值是s的时候，第5个成员变量就是score；当第4个成员变量的值是t的时候，第5个成员变量就是course。 ​ 经过上面的分析，我们可以设计一个包含共用体的结构体，请看下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define TOTAL 4 //人员总数struct&#123; char name[20]; int num; char sex; char profession; union&#123; float score; char course[20]; &#125; sc;&#125; bodys[TOTAL];int main()&#123; int i; //输入人员信息 for(i=0; i&lt;TOTAL; i++)&#123; printf("Input info: "); scanf("%s %d %c %c", bodys[i].name, &amp;(bodys[i].num), &amp;(bodys[i].sex), &amp;(bodys[i].profession)); if(bodys[i].profession == 's')&#123; //如果是学生 scanf("%f", &amp;bodys[i].sc.score); &#125;else&#123; //如果是老师 scanf("%s", bodys[i].sc.course); &#125; fflush(stdin); &#125; //输出人员信息 printf("\nName\t\tNum\tSex\tProfession\tScore / Course\n"); for(i=0; i&lt;TOTAL; i++)&#123; if(bodys[i].profession == 's')&#123; //如果是学生 printf("%s\t%d\t%c\t%c\t\t%f\n", bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.score); &#125;else&#123; //如果是老师 printf("%s\t%d\t%c\t%c\t\t%s\n", bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.course); &#125; &#125; return 0;&#125; 运行结果： 12345678910Input info: HanXiaoXiao 501 f s 89.5↙Input info: YanWeiMin 1011 m t math↙Input info: LiuZhenTao 109 f t English↙Input info: ZhaoFeiYan 982 m s 95.0↙Name Num Sex Profession Score / CourseHanXiaoXiao 501 f s 89.500000YanWeiMin 1011 m t mathLiuZhenTao 109 f t EnglishZhaoFeiYan 982 m s 95.000000]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之typedef用法]]></title>
    <url>%2F2018%2F03%2F08%2Fc%E8%AF%AD%E8%A8%804-typedef%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[C语言允许为一个数据类型起一个新的别名，就像给人起“绰号”一样。 ​ 起别名的目的不是为了提高程序运行效率，而是为了编码方便。例如有一个结构体的名字是stu，要想定义一个结构体变量就得这样写：1struct stu stu1; ​ struct看起来就是多余的，但不写又会报错。如果为struct stu起了一个别名STU，书写起来就简单了：1STU stu1; ​ 这种写法更加简练，意义也非常明确，不管是在标准头文件中还是以后的编程实践中，都会大量使用这种别名。 ​ 使用关键字typedef可以为类型起一个新的别名。typedef的用法一般为： 1typedef oldName newName; ​ oldName是类型原来的名字，newName是类型新的名字。例如： 1234typedef int INTEGER;INTEGER a, b;a = 1;b = 2; ​ INTEGER a, b;等效于int a, b;。 ​ typedef还可以给数组、指针、结构体等类型定义别名。先来看一个给数组类型定义别名的例子：1typedef char ARRAY20[20]; ​ 表示ARRAY20是类型char [20]的别名。它是一个长度为20的数组类型。接着可以用ARRAY20定义数组：1ARRAY20 a1, a2, s1, s2; ​ 它等价于：1char a1[20], a2[20], s1[20], s2[20]; ​ 注意，数组也是有类型的。例如char a1[20];定义了一个数组a1，它的类型就是char [20]。 ​ 又如，为结构体类型定义别名： 12345typedef struct stu&#123; char name[20]; int age; char sex;&#125; STU; ​ STU是struct stu的别名，可以用STU定义结构体变量：1STU body1,body2; ​ 它等价于：1struct stu body1, body2; ​ 再如，为指针类型定义别名：1typedef int (*PTR_TO_ARR)[4]; ​ 表示PTR_TO_ARR是类型int * [4]的别名，它是一个二维数组指针类型。接着可以使用PTR_TO_ARR定义二维数组指针：1PTR_TO_ARR p1, p2; ​ 按照类似的写法，还可以为函数指针类型定义别名：12typedef int (*PTR_TO_FUNC)(int, int);PTR_TO_FUNC pfunc; 【示例】为指针定义别名。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;typedef char (*PTR_TO_ARR)[30];typedef int (*PTR_TO_FUNC)(int, int);int max(int a, int b)&#123; return a&gt;b ? a : b;&#125;char str[3][30] = &#123; "http://c.biancheng.net", "C语言中文网", "C-Language"&#125;;int main()&#123; PTR_TO_ARR parr = str; PTR_TO_FUNC pfunc = max; int i; printf("max: %d\n", (*pfunc)(10, 20)); for(i=0; i&lt;3; i++)&#123; printf("str[%d]: %s\n", i, *(parr+i)); &#125; return 0;&#125; 运行结果：max: 20str[0]: http://c.biancheng.netstr[1]: C语言中文网str[2]: C-Language ​ 需要强调的是，typedef是赋予现有类型一个新的名字，而不是创建新的类型。为了“见名知意”，请尽量使用含义明确的标识符，并且尽量大写。 typedef和#define的区别​ typedef在表现上有时候类似于#define，但它和宏替换之间存在一个关键性的区别。正确思考这个问题的方法就是把typedef看成一种彻底的“封装”类型，声明之后不能再往里面增加别的东西。 1) 可以使用其他类型说明符对宏类型名进行扩展，但对typedef所定义的类型名却不能这样做。如下所示：12345#define INTERGE intunsigned INTERGE n; //没问题typedef int INTERGE;unsigned INTERGE n; //错误，不能在 INTERGE 前面添加 unsigned 2) 在连续定义几个变量的时候，typedef能够保证定义的所有变量均为同一类型，而#define则无法保证。例如：12#define PTR_INT int *PTR_INT p1, p2; ​ 经过宏替换以后，第二行变为：1int *p1, p2; ​ 这使得p1、p2成为不同的类型：p1是指向int类型的指针，p2是int类型。 ​ 相反，在下面的代码中：12typedef int * PTR_INTPTR_INT p1, p2; ​ p1、p2类型相同，它们都是指向int类型的指针。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之extern关键字]]></title>
    <url>%2F2018%2F03%2F05%2Fc%E8%AF%AD%E8%A8%804-extern%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[extern关键字​ 我们知道，C语言代码是由上到下依次执行的，不管是变量还是函数，原则上都要先定义再使用，否则就会报错。但在实际开发中，经常会在函数或变量定义之前就使用它们，这个时候就需要提前声明。 ​ 所谓声明（Declaration），就是告诉编译器我要使用这个变量或函数，你现在没有找到它的定义不要紧，请不要报错，稍后我会把定义补上。 ​ 例如，我们知道使用printf()、puts()、scanf()、getchar()等函数要引入stdio.h这个头文件，很多初学者认为stdio.h中包含了函数定义（也就是函数体），只要有了头文件程序就能运行。其实不然，头文件中包含的都是函数声明，而不是函数定义，函数定义都在系统库中，只有头文件没有系统库在链接时就会报错，程序根本不能运行。 1) 函数的声明​ 之前我们讲到了函数声明，那时并没有使用extern关键字，这是因为，函数的定义有函数体，函数的声明没有函数体，编译器很容易区分定义和声明，所以对于函数声明来说，有没有extern都是一样的。 ​ 总结起来，函数声明有四种形式：123456//不使用 externdatatype function( datatype1 name1, datatype2 name2, ... );datatype function( datatype1, datatype2, ... );//使用 externextern datatype function( datatype1 name1, datatype2 name2, ... );extern datatype function( datatype1, datatype2, ... ); 2) 变量的声明​ 变量和函数不同，编译器只能根据extern来区分，有extern才是声明，没有extern就是定义。 ​ 变量的定义有两种形式，你可以在定义的同时初始化，也可以不初始化：12datatype name = value;datatype name; ​ 而变量的声明只有一种形式，就是使用extern关键字：1extern datatype name; ​ 另外，变量也可以在声明的同时初始化，格式为：1extern datatype name = value; ​ 这种似是而非的方式是不被推荐的，有的编译器也会给出警告，我们不再深入讨论，也建议各位读者把定义和声明分开，尽量不要这样写。 ​ extern是“外部”的意思，很多教材讲到，extern用来声明一个外部（其他文件中）的变量或函数，也就是说，变量或函数的定义在其他文件中。 ​ 不过我认为这样讲不妥，因为除了定义在外部，定义在当前文件中也是正确的。例如，将module.c中的int m = 100;移动到main.c中的任意位置都是可以的。所以我认为，extern是用来声明的，不管具体的定义是在当前文件内部还是外部，都是正确的。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之enum枚举]]></title>
    <url>%2F2018%2F02%2F25%2Fc%E8%AF%AD%E8%A8%804-enum%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[​ 了解C语言enum枚举类型定义变量 一次定义多个常量​ 比如说我们的程序中处理问题时与星期几有关，可能要将星期一转换为数字1，星期二转换为数字2，一直到数字7，在不用enum关键字的情况下，可以使用define来定义，但是大家会觉得很麻烦，因为你要一个一个的定义，星期的还好说，只有7天，如果是月份呢，一年有12个月份，那就要写12个define，非常的不方面，如果利用enum的话就会非常的方便。 12345678910#include&lt;stdio.h&gt;enum week &#123;Mon=1,Tue,Wed,Thu,Fri,Sat,Sun&#125;;int main()&#123; printf("%d",Tue); return 0;&#125; ​ 这样定义以后，Mon的值为1，Tue的值为2，Wed的值为3，一次类推。 然后就可以像使用define之后的常量一样的使用定义的7个值了。 ​ 如果开头不写Mon=1的话，Mon的默认值为0，然后从0开始增长。例如： 1enum color &#123;red,blue,green,yellow&#125;; ​ 如果这样定义的话，red的值为0，blue的值为1，然后一次增长。 ​ 如果从中间开始赋值的话： 1enum color &#123;red,blue,green=5,yellow&#125;; ​ 那么red到blue是按照默认的从0开始增长的，green就是定义的值5，green之后的值都是从5开始增长的。 ​ 当然你也可以为每个枚举的变量都赋值，这样就和全都用define定义是一样的了，如果枚举中有某个值没有被赋值，那么它将是从前一个赋值的变 量开始，一次增加1。 限定变量的范围​ 比如我们的应用程序中要处理有关月份的东西，显然月份只能取1-12中的某个数字，为了保证程序的正确性和健壮性，我们应该使用enum。 1234567891011#include&lt;stdio.h&gt;enum Month &#123;Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125;;int main()&#123; enum Month a = Feb; printf("%d",a); return 0;&#125; ​ 比如像这样，定义的枚举类型a的取值只能是那12个变量中的一个，如果赋予了其他的变量，编译器就会报错。 enum另几种用法 在定义enum的同时，声明变量： 1enum Month &#123;Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125; a,b; ​ 这样就声明了两个枚举类型a和b 定义完enum之后再声明变量： 12enum Month &#123;Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125;;enum Month a = Feb; 定义匿名的枚举变量 1enum &#123;Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125; a; ​ 这样的话，只能使用a这一个枚举类型的变量，不能再定义其他的枚举类型。 typedef enum则是用来定义一个数据类型，那么该类型的变量值只能在enum定义的范围内取。 12typedef enum &#123;Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125; Day;Day a, b; 注意与宏定义区别： ​ enum用来定义一系列宏定义常量区别用，相当于一系列的#define xx xx，当然它后面的标识符也可当作一个类型标识符； ​ typedef enum则是用来定义一个数据类型，那么该类型的变量值只能在enum定义的范围内取。两者在这点上是没有差别的。 ​ 注意：同一个程序中不能定义同名的枚举类型，不同的枚举类型中也不能存在同名的命名常量]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之const使用]]></title>
    <url>%2F2018%2F02%2F24%2Fc%E8%AF%AD%E8%A8%804-const%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[有时候我们希望定义这样一种变量，它的值不能被改变，在整个作用域中都保持固定。例如，用一个变量来表示班级的最大人数，或者表示缓冲区的大小。为了满足这一要求，可以使用const关键字对变量加以限定： 1const int MaxNum = 100; //班级的最大人数 ​ 这样MaxNum的值就不能被修改了，任何对MaxNum赋值的行为都将引发错误： 1MaxNum = 90; //错误，试图向 const 变量写入数据 ​ 我们经常将const变量称为常量（Constant）。创建常量的格式通常为：1const type name = value; ​ const和type都是用来修饰变量的，它们的位置可以互换，也就是将type放在const前面：1type const name = value; ​ 但我们通常采用第一种方式，不采用第二种方式。另外建议将常量名的首字母大写，以提醒程序员这是个常量。 ​ 由于常量一旦被创建后其值就不能再改变，所以常量必须在定义的同时赋值（初始化），后面的任何赋值行为都将引发错误。一如既往，初始化常量可以使用任意形式的表达式，如下所示： 123456789101112131415#include &lt;stdio.h&gt;int getNum()&#123; return 100;&#125;int main()&#123; int n = 90; const int MaxNum1 = getNum(); //运行时初始化 const int MaxNum2 = n; //运行时初始化 const int MaxNum3 = 80; //编译时初始化 printf("%d, %d, %d\n", MaxNum1, MaxNum2, MaxNum3); return 0;&#125; 运行结果：100, 90, 80 const和指针​ const也可以和指针变量一起使用，这样可以限制指针变量本身，也可以限制指针指向的数据。const 和指针一起使用会有几种不同的顺序，如下所示： 123const int *p1;int const *p2;int * const p3; ​ 在最后一种情况下，指针是只读的，也就是p3本身的值不能被修改；在前面两种情况下，指针所指向的数据是只读的，也就是p1、p2本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。 ​ 当然，指针本身和它指向的数据都有可能是只读的，下面的两种写法能够做到这一点： 12const int * const p4;int const * const p5; ​ const和指针结合的写法多少有点让初学者摸不着头脑，大家可以这样来记忆：const离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针指向的数据，如果近的和远的都有，那么就同时修饰指针变量以及它指向的数据。 const和函数形参​ 在C语言中，单独定义const变量没有明显的优势，完全可以使用#define命令代替。const通常用在函数形参中，如果形参是一个指针，为了防止在函数内部修改指针指向的数据，就可以用const来限制。 ​ 在C语言标准库中，有很多函数的形参都被const限制了，下面是部分函数的原型： 1234567size_t strlen ( const char * str );int strcmp ( const char * str1, const char * str2 );char * strcat ( char * destination, const char * source );char * strcpy ( char * destination, const char * source );int system (const char* command);int puts ( const char * str );int printf ( const char * format, ... ); ​ 我们自己在定义函数时也可以使用const对形参加以限制，例如查找字符串中某个字符出现的次数： 123456789101112131415161718192021#include &lt;stdio.h&gt;size_t strnchr(const char *str, char ch)&#123; int i, n = 0, len = strlen(str); for(i=0; i&lt;len; i++)&#123; if(str[i] == ch)&#123; n++; &#125; &#125; return n;&#125;int main()&#123; char *str = "http://c.biancheng.net"; char ch = 't'; int n = strnchr(str, ch); printf("%d\n", n); return 0;&#125; 运行结果：3 ​ 根据strnchr()的功能可以推断，函数内部要对字符串str进行遍历，不应该有修改的动作，用const加以限制，不但可以防止由于程序员误操作引起的字符串修改，还可以给用户一个提示，函数不会修改你提供的字符串，请你放心。 const和非const类型转换​ 当一个指针变量str1被const限制时，并且类似const char *str1这种形式，说明指针指向的数据不能被修改；如果将str1 赋值给另外一个未被const修饰的指针变量str2，就有可能发生危险。因为通过str1不能修改数据，而赋值后通过str2能够修改数据了，意义发生了转变，所以编译器不提倡这种行为，会给出错误或警告。 ​ 也就是说，const char *和char *是不同的类型，不能将const char *类型的数据赋值给char *类型的变量。但反过来是可以的，编译器允许将char *类型的数据赋值给const char *类型的变量。 ​ 这种限制很容易理解，char *指向的数据有读取和写入权限，而const char *指向的数据只有读取权限，降低数据的权限不会带来任何问题，但提升数据的权限就有可能发生危险。 ​ C语言标准库中很多函数的参数都被const限制了，但我们在以前的编码过程中并没有注意这个问题，经常将非const类型的数据传递给const类型的形参，这样做从未引发任何副作用，原因就是上面讲到的，将非const类型转换为const类型是允许的。 ​ 下面是一个将const类型赋值给非const类型的例子： 12345678910#include &lt;stdio.h&gt;void func(char *str)&#123; &#125;int main()&#123; const char *str1 = "c.biancheng.net"; char *str2 = str1; func(str1); return 0;&#125; ​ 第7、8行代码分别通过赋值、传参（传参的本质也是赋值）将const类型的数据交给了非const类型的变量，编译器不会容忍这种行为，会给出警告，甚至直接报错。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之字节对齐]]></title>
    <url>%2F2018%2F02%2F20%2Fc%E8%AF%AD%E8%A8%804-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[C语言字节对齐不同系统的C语言类型长度 Data Type ILP32 ILP64 LP64 LLP64 char 8 8 8 8 short 16 16 16 16 int 32 64 32 32 long 32 64 64 32 long long 64 64 64 64 pointer 32 64 64 64 ​ 绝大部分64位的Unix，linux都是使用的LP64模型；32位Linux系统是ILP32模型；64位的Windows使用的是LLP64(long long and point 64)模型。 基本概念​ 许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K(通常是2，4或8)的倍数。这种对齐限制简化了形成处理器和存储器系统之间的接口的硬件设计。对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。比如在32位cpu下，假设一个整型变量的地址为0x00000004，那它就是自然对齐的。 为什么要字节对齐​ 需要字节对齐的根本原因在于CPU访问数据的效率问题。例如，假设一个处理器总是从存储器中取出8个字节，则地址必须为8的倍数。如果我们能保证将所有的double类型数据的地址对齐成8的倍数，那么就可以用一个存储器操作来读或者写值了。否则，我们可能需要执行两次存储器访问，因为对象可能被分放在两个8字节存储块中。 ​ 另外，假设一个整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据；如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。而如果变量在自然对齐位置上，则只要一次就可以取出数据。 ​ 各个硬件平台对存储空间的处理上有很大的不同，一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。比如sparc系统，如果取未对齐的数据会发生错误，举个例：123char ch[8];char *p = &amp;ch[1];int i = *(int *)p; 运行时会报segment error，而在x86上就不会出现错误，只是效率下降。 如何处理字节对齐​ 先让我们看编译器是按照什么样的原则进行对齐的 数据类型自身的对齐值：为指定平台上基本类型的长度。对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。 结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。 指定对齐值：#pragma pack (value)时的指定对齐值value。 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。 对于标准数据类型，它的地址只要是它的长度的整数倍就行了，而非标准数据类型按下面的原则对齐 数组 ：按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。 联合 ：按其包含的长度最大的数据类型对齐。 结构体： 结构体中每个数据类型都要对齐。 ​ 当数据类型为结构体时，编译器可能需要在结构体字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放（对于非对齐成员需要在其前面填充一些字节，保证其在对齐位置上），结构体本身也要根据自身的有效对齐值圆整(就是结构体总长度需要是结构体有效对齐值的整数倍)，此时可能需要在结构末尾填充一些空间，以满足结构体整体的对齐—-向结构体元素中最大的元素对齐。 ​ 通过上面的分析，对结构体进行字节对齐，我们需要知道四个值： 指定对齐值：代码中指定的对齐值，记为packLen； 默认对齐值：结构体中每个数据成员及结构体本身都有默认对齐值，记为defaultLen； 成员偏移量：即相对于结构体起始位置的长度，记为offset； 成员长度：结构体中每个数据成员的长度（注结构体成员为补齐之后的长度），记为memberLen。 及两个规则： 对齐规则： offset % vaildLen = 0，其中vaildLen为有效对齐值vaildLen = min(packLen, defaultLen)； 填充规则： 如成员变量不遵守对齐规则，则需要对其补齐；在其前面填充一些字节保证该成员对齐。需填充的字节数记为pad Linux和Windows的对齐方式Linux的对齐策略​ 在Linux中2字节数据类型(例如short)的地址必须是2的倍数，而较大的数据类型(例如int，int *，float和double)的地址必须是4的倍数。也就是说Linux下要么2字节对齐，要么4字节对齐，没有其他格式的对齐。 Windows的对齐策略​ 在Windows中对齐要求更严–任何K字节基本对象的地址都必须是K的倍数，K=2，4，或者8。特别地，double或者long long类型数据的地址应该是8的倍数。可以看出Windows的对齐策略和Linux还是不同的。 更改C编译器的缺省字节对齐方式​ 在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件： 使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。 使用伪指令#pragma pack ()，取消自定义字节对齐方式。 另外，还有如下的一种方式： __attribute__((aligned (n)))，让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。 __attribute__ ((packed))，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。 字节对齐的作用不仅是便于cpu快速访问，同时合理的利用字节对齐可以有效地节省存储空间。 ​ 对于32位机来说，4字节对齐能够使cpu访问速度提高，比如说一个long类型的变量，如果跨越了4字节边界存储，那么cpu要读取两次，这样效率就低了。但是在32位机中使用1字节或者2字节对齐，反而会使变量访问速度降低。所以这要考虑处理器类型，另外还得考虑编译器的类型。在vc中默认是4字节对齐的，GNU gcc也是默认4字节对齐。 结构体举例例子11234567891011121314151617181920212223/************************ &gt; File Name: struct_test.c &gt; Author:Marvin &gt; Created Time: Thu 22 Mar 2018 07:19:46 PM CST **********************/#include&lt;stdio.h&gt;int main()&#123; struct test &#123; char a; short b; int c; long d; &#125;; struct test t = &#123;'a',11,11,11&#125;; printf("size of struct t = %u\n", sizeof(t)); return 0;&#125; ​ 在64位centos上编译编译后结构struct test的布局如下: ​ 由于要保证结构体每个元素都要数据对齐，因此必须在a和b之间插入1字节的间隙使得后面的short元素2字节对齐int元素4字节对齐long元素8字节对齐，这样最终test结构大小为16字节。 ​ 运行程序结果为:1size of struct t = 16 例子2现在考虑这样一个结构体：123456struct test2 &#123; int a; long b; char c;&#125;;struct test2 t2 = &#123;11,11,'c'&#125;; 在64位centos上编译编译后结构struct test2的布局如下: ​ 结构体struct test2的自然对界条件为8字节，所以需要在最后的char型数据后面再填充7个字节使得结构体整体对齐。 ​ 运行程序结构为1size of struct test2 = 24 例子3​ 不妨将结构体struct test2里面成员的顺序重新排列一下：123456struct test3 &#123; char c; int a; long b;&#125;;struct test3 t3 = &#123;'c',11,11&#125;; ​ 在64位centos上编译编译后结构struct test2的布局如下: ​ 运行结果为：1size of struct test3 = 16 ​ 可见适当地编排结构体成员地顺序，可以在保存相同信息地情况下尽可能节约内存空间。 例子4123456struct B&#123; char b; int a; short c;&#125;; ​ 假设B从地址空间0x0000开始排放。该例子中没有定义指定对齐值，在笔者环境下，该值默认为4。 ​ 第一个成员变量b的自身对齐值是1，比指定或者默认指定对齐值4小，所以其有效对齐值为1，所以其存放地址0x0000符合0x0000%1=0。 ​ 第二个成员变量a，其自身对齐值为4，所以有效对齐值也为4，所以只能存放在起始地址为0x0004到0x0007这四个连续的字节空间中，复核0x0004%4=0，且紧靠第一个变量。 ​ 第三个变量c，自身对齐值为2，所以有效对齐值也是2，可以存放在0x0008到0x0009这两个字节空间中，符合0x0008%2=0。所以从0x0000到0x0009存放的都是B内容。 ​ 再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b）所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求，0x0009到0x0000等于10字节，（10＋2）％4＝0。所以0x0000A到0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节，sizeof(struct B)=12。 ​ 其实如果就这一个就来说它已将满足字节对齐了，因为它的起始地址是0，因此肯定是对齐的，之所以在后面补充2个字节，是因为编译器为了实现结构数组的存取效率，试想如果我们定义了一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢？按照数组的定义，数组中所有元素都是紧挨着的，如果我们不把结构的大小补充为4的整数倍，那么下一个结构的起始地址将是0x0000A，这显然不能满足结构的地址对齐了，因此我们要把结构补充成有效对齐大小的整数倍。 ​ 其实诸如，对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，这些已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知了，所以他们的自身对齐值也就已知了。 例子512345678910#pragma pack (2) /*指定按2字节对齐*/struct C&#123; char b; int a; short c;&#125;;#pragma pack () /*取消指定对齐，恢复缺省对齐*/` ​ 第一个变量b的自身对齐值为1，指定对齐值为2，所以，其有效对齐值为1，假设C从0x0000开始，那么b存放在0x0000，符合0x0000%1=0； ​ 第二个变量，自身对齐值为4，指定对齐值为2，所以有效对齐值为2，所以顺序存放在0x0002、0x0003、0x0004、0x0005四个连续字节中，符合0x0002%2=0。 ​ 第三个变量c的自身对齐值为2，所以有效对齐值为2，顺序存放在0x0006、0x0007中，符合0x0006%2=0。 ​ 所以从0x0000到0x00007共八字节存放的是C的变量。又C的自身对齐值为4，所以C的有效对齐值为2。又8%2=0，C只占用0x0000到0x0007的八个字节。所以sizeof(struct C)=8。 ​ 对于结构体嵌套地情况，结构体对齐算法思想：深度优先填充。12345678910padLen = getPadLen(offset , defaultLen);int getPadLen(int offsetLen, int defaultLen)&#123; int vaildLen = min(packLen,defaultLen); if(0 == vaildLen || 0 == offsetLen % vaildLen) &#123; return 0; &#125; return vaildLen - (offsetLen % vaildLen);&#125; ​ 先对齐内层结构体：对每个数据成员计算其defaultLen、memberLen和offset； ​ 再遍历每个数据成员时计算：对于基本数据类型成员defaultLen=memberLen；对于结构体成员defaultLen等于它的所有成员的最大的memberLen；遍历时对成员的memberLen进行累加，得到当前成员的offsetLen； ​ 运用对齐及填充规则：在当前结构体成员前填充padLen个字节； ​ 下面是结构体作为成员的例子：12345678910struct test1 &#123; int a; long b;&#125;;struct test4 &#123; char a; struct test1 b; int c;&#125;;struct test4 t4 = &#123;'a', &#123;11,11&#125;,11&#125; ​ test1的内存分布: ​ test4的内存分布: 字节对齐可能带来的隐患​ 代码中关于对齐的隐患，很多是隐式的。比如在强制类型转换的时候。例如：12345678unsigned int i = 0x12345678;unsigned char *p=NULL;unsigned short *p1=NULL;p=&amp;i;*p=0x00;p1=(unsigned short *)(p+1);*p1=0x0000; ​ 最后两句代码，从奇数边界去访问unsignedshort型变量，显然不符合对齐的规定。在x86上，类似的操作只会影响效率，但是在MIPS或者sparc上，可能就是一个error，因为它们要求必须字节对齐。 如何查找与字节对齐的问题如果出现对齐或者赋值问题首先查看 编译器的big little端设置。 看这种体系本身是否支持非对齐访问。 如果支持看设置了对齐与否，如果没有则看访问时需要加某些特殊的修饰来标志其特殊访问操作。 举例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;iostream&gt;using namespace std;//windows 64 位默认 结构体对齐系数为8，32位 结构体对齐系数为4//测试系统对齐系数// #pragma pack(8) my_struct_1 为16字节// #pragma pack(4) my_struct_1 为12字节// 不加#pragma pack(8) my_struct_1 为16字节//顾系统默认对齐系数为8struct my_struct_1&#123; char a; //1 double b; //之前补7 +8 8/8==1&#125;;#pragma pack(4)struct my_struct_2&#123; char a; //1 double b; //3+8 int c; //4 16/4=4&#125;;#pragma pack()#pragma pack(2)struct my_struct_3&#123; char a; //1 double b; //1+8 int c; //4 14/2&#125;;#pragma pack()#pragma pack(4)struct my_struct_4&#123; char a[5]; //5 double b; //3+8 16/4&#125;;#pragma pack()#pragma pack(2)struct my_struct_5&#123; char a[5]; //5 double b; //1+8 14/2&#125;;#pragma pack()#pragma pack(4)struct my_struct_6&#123; char a; //1 char b[3]; //3 char c; //1 1+3+1&#125;;#pragma pack()#pragma pack(4)struct my_struct_7&#123; char a; //1 char b[3]; //3 char c; //1 int d; //补齐 3 +4 &#125;;#pragma pack()#pragma pack(4)struct test&#123;char x1; //1short x2; //补齐1+ 2float x3; //4char x4; //1 补齐+3 &#125;;#pragma pack()int main()&#123; cout&lt;&lt;"char:"&lt;&lt;sizeof(char)&lt;&lt;endl; cout&lt;&lt;"short:"&lt;&lt;sizeof(short)&lt;&lt;endl; cout&lt;&lt;"int:"&lt;&lt;sizeof(int)&lt;&lt;endl; cout&lt;&lt;"long:"&lt;&lt;sizeof(long)&lt;&lt;endl; cout&lt;&lt;"float:"&lt;&lt;sizeof(float)&lt;&lt;endl; cout&lt;&lt;"double:"&lt;&lt;sizeof(double)&lt;&lt;endl; cout&lt;&lt;"long double:"&lt;&lt;sizeof(long double)&lt;&lt;endl; cout&lt;&lt;sizeof(my_struct_1)&lt;&lt;endl;//8 cout&lt;&lt;sizeof(my_struct_2)&lt;&lt;endl;//16 cout&lt;&lt;sizeof(my_struct_3)&lt;&lt;endl;//14 cout&lt;&lt;sizeof(my_struct_4)&lt;&lt;endl;//16 cout&lt;&lt;sizeof(my_struct_5)&lt;&lt;endl;//14 cout&lt;&lt;sizeof(my_struct_6)&lt;&lt;endl;//5 cout&lt;&lt;sizeof(my_struct_7)&lt;&lt;endl;//12 cout&lt;&lt;sizeof(test)&lt;&lt;endl;//12 system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之存储空间布局]]></title>
    <url>%2F2018%2F02%2F17%2Fc%E8%AF%AD%E8%A8%803-C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[虚拟地址空间在32位环境下的大小为4GB，在64位环境下的大小为256TB，那么，一个C语言程序的内存在整个地址空间中是如何分布的呢？ 内核空间和用户空间​ 对于32位环境，理论上程序可以拥有4GB 的虚拟地址空间，我们在C语言中使用到的变量、函数、字符串等都会对应内存中的一块区域。 ​ 但是，在这4GB的地址空间中，要拿出一部分给操作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间（Kernel Space）。 `Windows `在默认情况下会将高地址的` 2GB `空间分配给内核（也可以配置为`1GB`），而` Linux `默认情况下会将高地址的` 1GB `空间分配给内核。也就是说，应用程序只能使用剩下的` 2GB `或` 3GB `的地址空间，称为用户空间（`User Space`）。 Linux下32位环境的用户空间内存分布情况我们暂时不关心内核空间的内存分布情况，下图是Linux下32位环境的一种经典内存模型： 存储空间组成 代码区（text）加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的，具有只读特性和共享性。 未初始化数据区（BSS）加载的是可执行文件BSS 段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。 全局初始化数据区/静态数据区（data）加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。 栈区（stack）栈又称堆栈，是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等，也就是我们函数大括号”{}”中定义的变量(不包括static声明的变量)。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。由于栈的先进先出特性，所有栈特别方便用来保存/恢复调用现场。从这个意义上讲，把堆栈看成一个寄存、交换临时数据的内存区。 堆区（heap）堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上(堆被扩张)；当利用free等函数释放内存时，被释放的内存从堆上被剔除(堆被缩减)。 为了加深对内存布局的理解，请大家看下面一段代码： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;char *str1 = "c.biancheng.net"; //字符串在常量区，str1在全局数据区int n; //全局数据区char* func()&#123; char *str = "C语言中文网"; //字符串在常量区，str在栈区 return str;&#125;int main()&#123; int a; //栈区 char *str2 = "01234"; //字符串在常量区，str2在栈区 char arr[20] = "56789"; //字符串和arr都在栈区 char *pstr = func(); //栈区 int b; //栈区 printf("str1: %#X\npstr: %#X\nstr2: %#X\n", str1, pstr, str2); puts("--------------"); printf("&amp;str1: %#X\n &amp;n: %#X\n", &amp;str1, &amp;n); puts("--------------"); printf(" &amp;a: %#X\n arr: %#X\n &amp;b: %#X\n", &amp;a, arr, &amp;b); puts("--------------"); printf("n: %d\na :%d\nb: %d\n", n, a, b); puts("--------------"); printf("%s\n", pstr); return 0;&#125; 运行结果： 12345678910111213141516str1: 0X400710pstr: 0X400720str2: 0X400731--------------&amp;str1: 0X601040 &amp;n: 0X60104C-------------- &amp;a: 0X19D0728Carr: 0X19D07270 &amp;b: 0X19D0726C--------------n: 0a: -858993460b: -858993460--------------C语言中文网 对代码的说明： 1) 全局变量的内存在编译时就已经分配好了，它的默认初始值是0（它所占用的每一个字节都是0值），局部变量的内存在函数调用时分配，它默认初始值是不确定的，由编译器决定，一般是垃圾值。 2) 函数func()中的局部字符串常量&quot;C语言中文网&quot;也被存储到常量区，不会随着func()的运行结束而销毁，所以最后依然能够输出。 3) 字符数组arr[20]在栈区分配内存，字符串&quot;56789&quot;就保存在这块内存中，而不是在常量区，大家要注意区分。 详解数据段全局静态区​ 全局静态区分为全局区、静态区、常量区 全局区​ 处于该区域的数据属于外部链接，可以被其他文件使用。 静态区​ 静态区分为静态全局变量和静态局部变量 静态全局变量 由static修饰的全局变量，属于内部链接，只能在本文件中使用 静态局部变量 由static修饰的局部变量，当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。 常量区​ 常量区分为字符串常量和常变量 字符串常量 常变量 全局常变量存放在静态存储区，不可以间接修改。 局部常变量存放于栈，实际可间接通过指针或者引用进行修改。 1234567891011121314151617181920212223242526272829303132333435363738394041#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;int a = 10; //全局变量，在全局区,默认外部链接static int b = 20; //全局静态变量，在静态区,是内部链接//全局变量和全局静态变量有什么区别？//全局变量是外部链接//静态全局变量是内部链接//内部链接和外部链接有什么区别？//1. 如果变量是内部链接的话，那么此变量只能在当前文件内访问//2. 如果是变量是外部链接的话，那么此变量可以被其他文件使用//全局静态变量和局部静态变量有什么区别？//1. 全局静态变量和局部静态变量都存储在静态区，都是在程序运行期间都是合法有效//2. 局部静态变量符号的可见范围仅限于当前函数内部，全局静态变量可见范围从定义到文件结尾const int v1 = 20; //全局常变量，一旦初始化，不可修改void test01()&#123; static char arr[] = "hello world!"; //局部静态变量，在静态区存储可读可写 arr[2] = 'c'; const int v2 = 20; //局部常变量，可以通过指针或者引用进行间接修改 char* p = "hello world!"; //字符串"hello world!"在常量区，p局部变量：stack(栈) //p[2] = 'c'; //只读，不可修改 printf("%d\n",arr); printf("%d\n",p);&#125;int main()&#123; test01(); system("pause"); return EXIT_SUCCESS;&#125; 动态内存分配函数​ 堆（Heap）是唯一由程序员控制的内存区域，我们常说的动态内存分配也是在这个区域。在堆上分配和释放内存需要用到C语言标准库中的几个函数：malloc()、calloc()、realloc() 和free()。 ​ 这几个函数的具体用法在C标准库中已经进行了讲解（点击上面链接查看），这里不再赘述，仅作简单的对比，并给出一个综合示例。 1) malloc()​ 原型：void* malloc (size_t size); ​ 作用：在堆区分配size字节的内存空间。 ​ 返回值：成功返回分配的内存地址，失败则返回NULL。 ​ 注意：分配内存在动态存储区（堆区），手动分配，手动释放，申请时空间可能有也可能没有，需要自行判断，由于返回的是void*，建议手动强制类型转换。 2) calloc()原型：void* calloc(size_t n, size_t size); 功能：在堆区分配n*size字节的连续空间。 返回值：成功返回分配的内存地址，失败则返回NULL。 注意：calloc()函数是对malloc()函数的简单封装，参数不同，使用时务必小心，第一参数是第二参数的单元个数，第二参数是单位的字节数。 3) realloc()原型：void* realloc(void *ptr, size_t size); 功能：对ptr指向的内存重新分配size大小的空间，size可比原来的大或者小，还可以不变（如果你无聊的话）。 返回值：成功返回更改后的内存地址，失败则返回NULL。 4) free()原型：void free(void* ptr); 功能：释放由malloc()、calloc()、realloc()申请的内存空间。 几点注意1) 每个内存分配函数必须有相应的free函数，释放后不能再次使用被释放的内存。 2) 在分配内存时最好不要直接用数字指定内存空间的大小，这样不利于程序的移植。因为在不同的操作系统中，同一数据类型的长度可能不一样。为了解决这个问题，C语言提供了一个判断数据类型长度的操作符，就是sizeof。 3) free(p)并不能改变指针p的值，p依然指向以前的内存，为了防止再次使用该内存，建议将p的值手动置为NULL。 ​ sizeof是一个单目操作符，不是函数，用以获取数据类型的长度时必须加括号，例如sizeof(int)、sizeof(char) 等。 最后是一个综合的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N (5)#define N1 (7)#define N2 (3)int main()&#123; int *ip; int *large_ip; int *small_ip; if((ip = (int*)malloc(N * sizeof(int))) == NULL) &#123; printf("memory allocated failed!\n"); exit(1); &#125; int i; for(i = 0; i &lt; N; i++) &#123; ip[i] = i; printf("ip[%d] = %d\t", i, ip[i]); &#125; printf("\n"); if((large_ip = (int* )realloc(ip, N1 * sizeof(int))) == NULL) &#123; printf("memory allocated failed!\n"); exit(1); &#125; for(i = N; i &lt; N1; i++) large_ip[i] = 9; for(i = 0; i &lt; N1; i++) printf("large_ip[%d] = %d\t", i, large_ip[i]); printf("\n"); if((small_ip = (int*)realloc(large_ip, N2 * sizeof(int))) == NULL) &#123; printf("memory allocated failed!\n"); exit(1); &#125; for(i = 0; i &lt; N2; i++) printf("small_ip[%d] = %d\t", i, small_ip[i]); printf("\n"); free(small_ip); small_ip = NULL; system("pause"); return 0;&#125; 运行结果：ip[0] = 0 ip[1] = 1 ip[2] = 2 ip[3] = 3 ip[4] = 4large_ip[0] = 0 large_ip[1] = 1 large_ip[2] = 2 large_ip[3] = 3large_ip[4] = 4 large_ip[5] = 9 large_ip[6] = 9small_ip[0] = 0 small_ip[1] = 1 small_ip[2] = 2 代码说明： 1) 代码看似很长，其实较为简单，首先分配一个包含5个整型的内存区域，分别赋值0到4；再用realloc函数扩大内存区域以容纳7个整型数，对额外的两个整数赋值为9；最后再用realloc函数缩小内存区域，直接输出结果（因为realloc函数会自动复制数据）。 2) 这次把分配函数与验证返回值验证写在了一起，为的是书写方便，考虑到优先级问题添加了适当的括号，这种写法较为常用，注意学习使用。 3) 本例free函数只用释放small_ip指针即可，如函数介绍中注意里提到的，另外两个指针已被系统回收，不能再次使用。 Linux下64位环境的用户空间内存分布情况​ 在64位环境下，虚拟地址空间大小为256TB，Linux将高128TB的空间分配给内核使用，而将低128TB的空间分配给用户程序使用。如下图所示： ​ 在64位环境下，虚拟地址虽然占用64位，但只有最低48位有效。这里需要补充的一点是，任何虚拟地址的48位至63位必须与47位一致。 ​ 上图中，用户空间地址的47位是0，所以高16位也是0，换算成十六进制形式，最高的四个数都是0；内核空间地址的47位是1，所以高16位也是1，换算成十六进制形式，最高的四个数都是1。这样中间的一部分地址正好空出来，也就是图中的“未定义区域”，这部分内存无论如何也访问不到。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之栈区]]></title>
    <url>%2F2018%2F02%2F12%2Fc%E8%AF%AD%E8%A8%803-%E6%A0%88%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[程序的虚拟地址空间分为多个区域，栈（Stack）是其中地址较高的一个区域。栈（Stack）可以存放函数参数、局部变量、局部数组等作用范围在函数内部的数据，它的用途就是完成函数的调用。 ​ 栈内存由系统自动分配和释放：发生函数调用时就为函数运行时用到的数据分配内存，函数调用结束后就将之前分配的内存全部销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部。 栈的概念​ 在计算机中，栈可以理解为一个特殊的容器，用户可以将数据依次放入栈中，然后再将数据按照相反的顺序从栈中取出。也就是说，先放入的数据最后才能取出，而最后放入的数据必须先取出。这称为先进后出（First In Last Out）原则。 ​ 放入数据常称为入栈或压栈（Push），取出数据常称为出栈或弹出（Pop）。如下图所示： 图：数据的出栈和入栈 ​ 可以发现，栈底始终不动，出栈入栈只是在移动栈顶，当栈中没有数据时，栈顶和栈底重合。 ​ 从本质上来讲，栈是一段连续的内存，需要同时记录栈底和栈顶，才能对当前的栈进行定位。在现代计算机中，通常使用ebp寄存器指向栈底，而使用esp寄存器指向栈顶。随着数据的进栈出栈，esp的值会不断变化，进栈时esp的值减小，出栈时esp的值增大。 ​ ebp和esp都是CPU中的寄存器：ebp是Extend Base Pointer的缩写，通常用来指向栈底；esp是Extend Stack Pointer的缩写，通常用来指向栈顶。 如下图所示是一个栈的实例： 栈的大小以及栈溢出​ 对每个程序来说，栈能使用的内存是有限的，一般是1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。如果程序使用的栈内存超出最大值，就会发生栈溢出（Stack Overflow）错误。 ​ 一个程序可以包含多个线程，每个线程都有自己的栈，严格来说，栈的最大值是针对线程来说的，而不是针对程序。 ​ 栈内存的大小和编译器有关，编译器会为栈内存指定一个最大值，在VC/VS 下，默认是1M，在C-Free下，默认是2M，在Linux GCC下，默认是8M。 ​ 当然，我们也可以通过参数来修改栈内存的大小。以VS2010为例，在工程名处右击，会弹出一个菜单，选择“属性”，会出现一个对话框，如下图所示： ​ 该图中，我们将栈内存设置为4M。提示：栈也经常被称为堆栈，而堆依然称为堆，所以堆栈这个概念并不包含堆，大家要注意区分。 ​ 当程序使用的栈内存大于默认值（或者修改后的值）时，就会发生栈溢出（Stack Overflow）错误。使用VS2010 并切换到Debug模式，运行如下的代码： 1234int main()&#123; char str[1024*1024*2] = &#123;0&#125;; return 0;&#125; ​ 局部字符数组str存储在栈上，占用2M的内存，超出了默认值1M，所以会发生栈溢出错误，如下图所示： 栈帧/活动记录​ 当发生函数调用时，会将函数运行需要的信息全部压入栈中，这常常被称为栈帧（Stack Frame）或活动记录（Activate Record）。活动记录一般包括以下几个方面的内容： 1) 函数的返回地址，也就是函数执行完成后从哪里开始继续执行后面的代码。例如： 123int a, b, c;func(1, 2);c = a + b; ​ 站在C语言的角度看，func()函数执行完成后，会继续执行c=a+b;语句，那么返回地址就是该语句在内存中的位置。 ​ 注意：C语言代码最终会被编译为机器指令，确切地说，返回地址应该是下一条指令的地址，这里之所以说是下一条C语言语句的地址，仅仅是为了更加直观地说明问题。 2) 参数和局部变量。有些编译器，或者编译器在开启优化选项的情况下，会通过寄存器来传递参数，而不是将参数压入栈中，我们暂时不考虑这种情况。 3) 编译器自动生成的临时数据。例如，当函数返回值的长度较大（比如占用40个字节）时，会先将返回值压入栈中，然后再交给函数调用者。 ​ 当返回值的长度较小（char、int、long等）时，不会被压入栈中，而是先将返回值放入寄存器，再传递给函数调用者。 4) 一些需要保存的寄存器，例如ebp、ebx、esi、edi等。之所以要保存寄存器的值，是为了在函数退出时能够恢复到函数调用之前的场景，继续执行上层函数。 下图是一个函数调用的实例： 上图是在`Windows`下使用`VS2010 Debug`模式编译时一个函数所使用的栈内存，可以发现，理论上 `ebp `寄存器应该指向栈底，但在实际应用中，它却指向了`old ebp`。 在寄存器名字前面添加“old”，表示函数调用之前该寄存器的值。 当发生函数调用时： 实参、返回地址、ebp寄存器首先入栈； 然后再分配一块内存供局部变量、返回值等使用，这块内存一般比较大，足以容纳所有数据，并且会有冗余； 最后将其他寄存器的值压入栈中。 需要注意的是，不同编译器在不同编译模式下所产生的函数栈并不完全相同，例如在VS2010下选择Release模式，编译器会进行大量优化，函数栈的样貌荡然无存，不具有教学意义，所以本教程以VS2010 Debug模式为例进行分析。 关于数据的定位​ 由于esp的值会随着数据的入栈而不断变化，要想根据esp找到参数、局部变量等数据是比较困难的，所以在实现上是根据ebp来定位栈内数据的。ebp的值是固定的，数据相对ebp的偏移也是固定的，ebp的值加上偏移量就是数据的地址。 ​ 例如一个函数的定义如下： 12345void func(int a, int b)&#123; float f = 28.5; int n = 100; //TODO:&#125; ​ 调用形式为： 1func(15, 92); ​ 那么函数的活动记录如下图所示： ​ 这里我们假设两个局部变量挨着，并且第一个变量和old ebp也挨着（实际上它们之间有4个字节的空白），如此，第一个参数的地址是ebp+12，第二个参数的地址是ebp+8，第一个局部变量的地址是ebp-4，第二个局部变量的地址是ebp-8。 函数调用惯例​ 我们知道，一个C程序由若干个函数组成，C程序的执行实际上就是函数之间的相互调用。请看下面的代码： 12345678910111213141516#include &lt;stdio.h&gt;void funcA(int m, int n)&#123; printf("funcA被调用\n");&#125;void funcB(float a, float b)&#123; funcA(100, 200); printf("funcB被调用\n");&#125;int main()&#123; funcB(19.9, 28.5); printf("main被调用\n"); return 0;&#125; ​ main()调用了funcB()，funcB()又调用了funcA()。对于main()调用funcB()，我们称main()是调用方，funcB()是被调用方；同理，对于funcB()调用funcA()，funcB()是调用方，funcA()是被调用方。 ​ 函数的参数（实参）由调用方压入栈中供被调用方使用，它们之间要有一致的约定。例如，参数是从左到右入栈还是从右到左入栈，如果双方理解不一致，被调用方使用参数时就会出错。 ​ 以funcB()为例，假设main()函数先将 19.9入栈，后将28.5入栈，但是funcB()在使用这些实参时却认为28.5先入栈，19.9后入栈，那么就一定会产生混乱，误以为19.9是传递给b、28.5是传递给a的。 ​ 所以，函数调用方和被调用方必须遵守同样的约定，理解要一致，这称为调用惯例（Calling Convention）。 ​ 一个调用惯例一般规定以下两方面的内容： 1) 函数参数的传递方式，是通过栈传递还是通过寄存器传递（这里我们只讲解通过栈传递的情况）。 2) 函数参数的传递顺序，是从左到右入栈还是从右到左入栈。 3) 参数弹出方式。函数调用结束后需要将压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由调用方来完成，也可以由被调用方来完成。 4) 函数名修饰方式。函数名在编译时会被修改，调用惯例可以决定如何修改函数名。 ​ 在C语言中，存在多种调用惯例，可以在函数声明或函数定义时指定，例如： 1234567891011121314#include &lt;stdio.h&gt;int __cdecl max(int m, int n);int main()&#123; int a = max(10, 20); printf("a = %d\n", a); return 0;&#125;int __cdecl max(int m, int n)&#123; int max = m&gt;n ? m : n; return max;&#125; ​ 函数调用惯例在函数声明和函数定义时都可以指定，语法格式为： 返回值类型 调用惯例 函数名(函数参数) ​ 在函数声明处是为调用方指定调用惯例，而在函数定义处是为被调用方（也就是函数本身）指定调用惯例。 ​ __cdecl是C语言默认的调用惯例，在平时编程中，我们其实很少去指定调用惯例，这个时候就使用默认的__cdecl。 ​ 注意：__cdecl并不是标准关键字，上面的写法在VC/VS下有效，但是在GCC下，要使用__attribute__((cdecl))。 除了cdecl，还有其他调用惯例，请看下表： 调用惯例 参数传递方式 参数出栈方式 名字修饰 cdecl 按照从右到左的顺序入栈 调用方 下划线+函数名， 如函数max()的修饰名为_max stdcall 按照从右到左的顺序入栈 函数本身 （被调用方） 下划线+函数名+@+参数的字节数，如函数int max(int m, int n)的修饰名为_max_@8 fastcall 将部分参数放入寄存器，剩下的参数按照从右到左的顺序入栈 函数本身 （被调用方） @+函数名+@+参数的字节数 pascal 按照从左到右的顺序入栈 函数本身 （被调用方） 较为复杂，这里不再展开讨论 分析函数进出栈​ 前面我们只是讲解了一个函数的活动记录是什么样子的，相信大家对函数的详细调用过程的认识还不是太清晰，这节我们就以VS2010 Debug模式为例来深入分析一下。 请看下面的代码： 12345678void func(int a, int b)&#123; int p =12, q = 345;&#125;int main()&#123; func(90, 26); return 0;&#125; ​ 函数使用默认的调用惯例cdecl，即参数从右到左入栈，由调用方负责将参数出栈。函数的进栈出栈过程如下图所示： 函数进栈步骤①到⑥是函数进栈过程： 1) main()是主函数，也需要进栈，如步骤①所示。 2) 在步骤②中，执行语句func(90, 26);，先将实参90、26压入栈中，再将返回地址压入栈中，这些工作都由main()函数（调用方）完成。这个时候ebp的值并没有变，仅仅是改变esp的指向。 3) 到了步骤③，就开始执行func()的函数体了。首先将原来ebp寄存器的值压入栈中（也即图中的old ebp），并将esp的值赋给ebp，这样ebp就从main()函数的栈底指向了func()函数的栈底，完成了函数栈的切换。由于此时esp和ebp的值相等，所以它们也就指向了同一个位置。 4) 为局部变量、返回值等预留足够的内存，如步骤④所示。由于栈内存在函数调用之前就已经分配好了，所以这里并不是真的分配内存，而是将esp的值减去一个整数，例如esp - 0XC0，就是预留0XC0字节的内存。 5) 将ebp、esi、edi寄存器的值依次压入栈中。 6) 将局部变量的值放入预留好的内存中。注意，第一个变量和old ebp之间有4个字节的空白，变量之间也有若干字节的空白。 ​ 为什么要留出这么多的空白，岂不是浪费内存吗？这是因为我们使用Debug模式生成程序，留出多余的内存，方便加入调试信息；以Release模式生成程序时，内存将会变得更加紧凑，空白也被消除。 ​ 至此，func()函数的活动记录就构造完成了。可以发现，在函数的实际调用过程中，形参是不存在的，不会占用内存空间，内存中只有实参，而且是在执行函数体代码之前、由调用方压入栈中的。 未初始化的局部变量的值为什么是垃圾值​ 为局部变量分配内存时，仅仅是将esp的值减去一个整数，预留出足够的空白内存，不同的编译器在不同的模式下会对这片空白内存进行不同的处理，可能会初始化为一个固定的值，也可能不进行初始化。 ​ 例如在VS2010 Debug模式下，会将预留出来的内存初始化为0XCCCCCCCC，如果不对局部变量赋值，它们的内存就不会改变，输出时的结果就是0XCCCCCCCC，请看下面的代码： 12345678#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int m, n; printf("%#X, %#X\n", m, n); system("pause"); return 0;&#125; 运行结果： 0XCCCCCCCC, 0XCCCCCCCC ​ 虽然编译器对空白内存进行了初始化，但这个值对我们来说一般没有意义，所以我们可以认为它是垃圾值、是随机的。 函数出栈步骤⑦到⑨是函数func()出栈过程： 7) 函数func()执行完成后开始出栈，首先将edi、esi、ebx寄存器的值出栈。 8) 将局部变量、返回值等数据出栈时，直接将ebp的值赋给esp，这样ebp和esp就指向了同一个位置。 9) 接下来将 old ebp出栈，并赋值给现在的ebp，此时ebp就指向了func()调用之前的位置，即 main()活动记录的old ebp 位置，如步骤⑨所示。 ​ 这一步很关键，保证了还原到函数调用之前的情况，这也是每次调用函数时都必须将old ebp压入栈中的原因。 ​ 最后根据返回地址找到下一条指令的位置，并将返回地址和实参都出栈，此时esp就指向了main()活动记录的栈顶， 这意味着func()完全出栈了，栈被还原到了func()被调用之前的情况。 遗留的错误认知​ 经过上面的分析可以发现，函数出栈只是在增加esp寄存器的值，使它指向上一个数据，并没有销毁之前的数据。前面我们讲局部变量在函数运行结束后立即被销毁其实是错误的，这只是为了让大家更容易理解，对局部变量的作用范围有一个清晰的认识。 ​ 栈上的数据只有在后续函数继续入栈时才能被覆盖掉，这就意味着，只要时机合适，在函数外部依然能够取得局部变量的值。请看下面的代码： 12345678910111213141516#include &lt;stdio.h&gt;int *p;void func(int m, int n)&#123; int a = 18, b = 100; p = &amp;a;&#125;int main()&#123; int n; func(10, 20); n = *p; printf("n = %d\n", n); return 0;&#125; 运行结果：n = 18 ​ 在func()中，将局部变量a的地址赋给p，在main()函数中调用func()，函数刚刚调用结束，还没有其他函数入栈，局部变量a所在的内存没有被覆盖掉，所以通过语句n = *p;能够取得它的值。 栈溢出攻击的原理​ 我们先来看下面的一个例子： 1234567#include &lt;stdio.h&gt;int main()&#123; char str[10] = &#123;0&#125;; gets(str); printf("str: %s\n", str); return 0;&#125; ​ 在main()函数内部定义一个字符数组，并通过gets()为它赋值。 ​ 在VS2010 Debug模式下运行程序，当输入的字符不超过10个时，可以正确输出，但是当输入的字符过多时，就会出现运行时错误。例如输入&quot;12345678901234567890&quot;，就会出现下面的错误： ​ 这是为什么呢？我们不妨先来看一下main()函数的栈： ​ 局部数组也是在栈上分配内存，当输入&quot;12345678901234567890&quot;时，会发生数组溢出，占用“4字节空白内存”、“old ebp”和“返回地址”所在的内存，并将原有的数据覆盖掉，这样当main()函数执行完成后，会取得一个错误的返回地址，该地址上的指令是不确定的，或者根本就没有指令，所以程序在返回时出错。 ​ C语言不会对数组溢出做检测，这是一个典型的由于数组溢出导致覆盖了函数返回地址的例子，我们将这样的错误称为“栈溢出错误”。 ​ 注意：这里所说的“栈溢出”是指栈上的某个数据过大，覆盖了其他的数据。 ​ 局部数组在栈上分配内存，并且不对数组溢出做检测，这是导致栈溢出的根源。除了上面讲到的gets()函数，strcpy()、scanf()等能够向数组写入数据的函数都有导致栈溢出的风险。 ​ 下面是使用strcpy()函数导致栈溢出的例子： 123456789#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char *str1 = "这里是C语言中文网"; char str2[6] = &#123;0&#125;; strcpy(str2, str1); printf("str: %s\n", str2); return 0;&#125; ​ 将str1复制到str2，显然超出了str2的接受范围，会发生溢出，覆盖返回地址，导致main()函数返回时出错。 ​ 栈溢出一般不会产生严重的后果，但是如果有用户精心构造栈溢出，让返回地址指向恶意代码，那就比较危险了，这就是常说的栈溢出攻击。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之指针和数组]]></title>
    <url>%2F2018%2F02%2F05%2Fc%E8%AF%AD%E8%A8%802-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组和指针的不同​ 通过前面的讲解，相信很多读者都会认为数组和指针是等价的，数组名表示数组的首地址。不幸的是，这是一种非常危险的想法，并不完全正确，前面我们将数组和指针等价起来是为了方便大家理解（在大多数情况下数组名确实可以当做指针使用），不至于被指针难倒，这节请大家放弃这种观念，我将会颠覆你的认知。 ​ 数组和指针不等价的一个典型案例就是求数组的长度，这个时候只能使用数组名，不能使用数组指针。前面我们已经强调过了，这里不妨再来演示一下： 12345678910#include &lt;stdio.h&gt;int main()&#123; int a[6] = &#123;0, 1, 2, 3, 4, 5&#125;; int *p = a; int len_a = sizeof(a) / sizeof(int); int len_p = sizeof(p) / sizeof(int); printf("len_a = %d, len_p = %d\n", len_a, len_p); return 0;&#125; ​ 运行结果： len_a = 6, len_p = 1 ​ 数组是一系列数据的集合，没有开始和结束标志，p仅仅是一个指向int类型的指针，编译器不知道它指向的是一个整数还是一堆整数，对p使用sizeof求得的是指针变量本身的长度。也就是说，编译器并没有把p和数组关联起来，p仅仅是一个指针变量，不管它指向哪里，sizeof求得的永远是它本身所占用的字节数。 ​ 站在编译器的角度讲，变量名、数组名都是一种符号，它们最终都要和数据绑定起来。变量名用来指代一份数据，数组名用来指代一组数据（数据集合），它们都是有类型的，以便推断出所指代的数据的长度。 ​ 对，数组也有类型，这是很多读者没有意识到的，大部分C语言书籍对这一点也含糊其辞！我们可以将 int、float、char等理解为基本类型，将数组理解为由基本类型派生得到的稍微复杂一些的类型。sizeof就是根据符号的类型来计算长度的。 ​ 对于数组a，它的类型是int [6]，表示这是一个拥有6个int数据的集合，1个int的长度为4，6个int 的长度为4×6 = 24，sizeof很容易求得。 ​ 对于指针变量p，它的类型是int *，在32位环境下长度为4，在64位环境下长度为8。 ​ 归根结底，a和p这两个符号的类型不同，指代的数据也不同，它们不是一码事，sizeof是根据符号类型来求长度的，a和p的类型不同，求得的长度自然也不一样。 ​ 对于二维数组，也是类似的道理，例如int a[3][3]={1, 2, 3, 4, 5, 6, 7, 8, 9};，它的类型是int [3][3]，长度是4×3×3 = 36。 站在哲学的高度看问题​ 编程语言的目的是为了将计算机指令（机器语言）抽象成人类能够理解的自然语言，让程序员能够更加容易地管理和操作各种计算机资源，这些计算机资源最终表现为编程语言中的各种符号和语法规则。 ​ 整数、小数、数组、指针等不同类型的数据都是对内存的抽象，它们的名字用来指代不同的内存块，程序员在编码过程中不需要直接面对内存，使用这些名字将更加方便。 ​ 编译器在编译过程中会创建一张专门的表格用来保存名字以及名字对应的数据类型、地址、作用域等信息，sizeof是一个操作符，不是函数，使用sizeof时可以从这张表格中查询到符号的长度。 ​ 与普通变量名相比，数组名既有一般性也有特殊性：一般性表现在数组名也用来指代特定的内存块，也有类型和长度；特殊性表现在数组名有时候会转换为一个指针，而不是它所指代的数据本身的值。 数组什么时候转换为指针​ 数组名的本意是表示一组数据的集合，它和普通变量一样，都用来指代一块内存，但在使用过程中，数组名有时候会转换为指向数据集合的指针（地址），而不是表示数据集合本身，这在前面的例子中已经被多次证实。 ​ 数据集合包含了多份数据，直接使用一个集合没有明确的含义，将数组名转换为指向数组的指针后，可以很容易地访问其中的任何一份数据，使用时的语义更加明确。 ​ C语言标准规定，当数组名作为数组定义的标识符（也就是定义或声明数组时）、sizeof或&amp;的操作数时，它才表示整个数组本身，在其他的表达式中，数组名会被转换为指向第0个元素的指针（地址）。 ​ 数组和指针的关系颇像诗和词的关系，它们都是一种文学形式，有不少共同之处，但在实际的表现手法上又各有特色。 再谈数组下标[]​ C语言标准还规定，数组下标与指针的偏移量相同。通俗地理解，就是对数组下标的引用总是可以写成“一个指向数组的起始地址的指针加上偏移量”。假设现在有一个数组a和指针变量p，它们的定义形式为： 1int a = &#123;1, 2, 3, 4, 5&#125;, *p, i = 2; ​ 读者可以通过以下任何一种方式来访问a[i]：123p = a; p[i]; p = a; *(p + i); p = a + i; *p; ​ 对数组的引用a[i]在编译时总是被编译器改写成*(a+i)的形式，C语言标准也要求编译器必须具备这种行为。 ​ 取下标操作符[]是建立在指针的基础上，它的作用是使一个指针和一个整数相加，产生出一个新的指针，然后从这个新指针（新地址）上取得数据；假设指针的类型为T *，所产生的结果的类型就是T。 ​ 取下标操作符的两个操作数是可以交换的，它并不在意操作数的先后顺序，就像在加法中3+5和5+3并没有什么不一样。以上面的数组a为例，如果希望访问第3个元素，那么可以写作a[3]，也可以写作3[a]，这两种形式都是正确的，只不过后面的形式从不曾使用，它除了可以把初学者搞晕之外，实在没有什么实际的意义。 a[3]等价于*(a + 3)，3[a]等价于*(3 + a)，仅仅是把加法的两个操作数调换了位置。 ​ 使用下标时，编译器会自动把下标的步长调整到数组元素的大小。数组a中每个元素都是int类型，长度为4个字节，那么a[i+1]和a[i]在内存中的距离是4（而不是1）。 数组作函数参数​ C语言标准规定，作为“类型的数组”的形参应该调整为“类型的指针”。在函数形参定义这个特殊情况下，编译器必须把数组形式改写成指向数组第0个元素的指针形式。编译器只向函数传递数组的地址，而不是整个数组的拷贝。 ​ 这种隐式转换意味着下面三种形式的函数定义是完全等价的： 123void func(int *parr)&#123; ...... &#125;void func(int arr[])&#123; ...... &#125;void func(int arr[5])&#123; ...... &#125; ​ 在函数内部，arr会被转换成一个指针变量，编译器为arr分配4个字节的内存，用sizeof(arr)求得的是指针变量的长度，而不是数组长度。要想在函数内部获得数组长度必须额外增加一个参数，在调用函数之前求得数组长度。 ​ 参数传递是一次赋值的过程，赋值也是一个表达式，函数调用时不管传递的是数组名还是数组指针，效果都是一样的，相当于给一个指针变量赋值。 ​ 把作为形参的数组和指针等同起来是出于效率方面的考虑。数组是若干类型相同的数据的集合，数据的数目没有限制，可能只有几个，也可能成千上万，如果要传递整个数组，无论在时间还是内存空间上的开销都可能非常大。而且绝大部分情况下，我们其实并不需要整个数组的拷贝，我们只想告诉函数在那一时刻对哪个特定的数组感兴趣。 关于数组和指针可交换性的总结​ 1) 用a[i]这样的形式对数组进行访问总是会被编译器改写成（或者说解释为）像*(a+i)这样的指针形式。 ​ 2) 指针始终是指针，它绝不可以改写成数组。你可以用下标形式访问指针，一般都是指针作为函数参数时，而且你知道实际传递给函数的是一个数组。 ​ 3) 在特定的环境中，也就是数组作为函数形参，也只有这种情况，一个数组可以看做是一个指针。作为函数形参的数组始终会被编译器修改成指向数组第一个元素的指针。 ​ 4) 当希望向函数传递数组时，可以把函数参数定义为数组形式（可以指定长度也可以不指定长度），也可以定义为指针。不管哪种形式，在函数内部都要作为指针变量对待。 解析指针和数组​ 前面我们讲解了指针数组、二维数组指针、函数指针等几种较为复杂的指针，它们的定义形式分别是： 1234int *p1[6]; //指针数组int *(p2[6]); //指针数组，和上面的形式等价int (*p3)[6]; //二维数组指针int (*p4)(int, int); //函数指针 ​ 我相信大部分初学者对上面几种形式的指针都非常迷惑，不知道该从哪里入手去理解，为什么p1、p2是数组，而p3却是指针呢，它们仅仅是一个括号的区别。 ​ 指针是C语言中最强大最灵活的一部分，也是最难以理解的一部分，它是学习C语言的重点，没有学会指针就无从谈学会C语言。如果大家觉得上面几种形式的指针还能勉强接受，那么下面两个指针是不是让人抓狂呢？ 12char *(* c[10])(int **p);int (*(*(*pfunc)(int *))[5])(int *); ​ 只要找到了窍门，再复杂的指针也是可以理解的，这节我们就来戳破这层窗户纸！ ​ C语言标准规定，对于一个符号的定义，编译器总是从它的名字开始读取，然后按照优先级顺序依次解析。对，从名字开始，不是从开头也不是从末尾，这是理解复杂指针的关键！ ​ 对于初学者，有几种运算符的优先级非常容易混淆，它们的优先级从高到低依次是： 定义中被括号()括起来的那部分。 后缀操作符：括号()表示这是一个函数，方括号[]表示这是一个数组。 前缀操作符：星号*表示“指向xxx的指针”。 学会了“绝杀招式”，接下来我们就由浅入深，逐个击破上面的指针定义。 1)int *p1[6];​ 从p1开始理解，它的左边是*，右边是[]，[]的优先级高于*，所以编译器先解析p1[6]，p1首先是一个拥有6个元素的数组，然后再解析int *，它用来说明数组元素的类型。从整体上讲，p1是一个拥有6个int *元素的数组，也即指针数组。 2)int (*p3)[6];​ 从p3开始理解，()的优先级最高，编译器先解析(*p3)，p3首先是一个指针，剩下的int [6]是p3指向的数据的类型，它是一个拥有6个元素的一维数组。从整体上讲，p3是一个指向拥有6个int元素数组的指针，也即二维数组指针。 ​ 为了能够通过指针来遍历数组元素，在定义数组指针时需要进行降维处理，例如三维数组指针实际指向的数据类型是二维数组，二维数组指针实际指向的数据类型是一维数组，一维数组指针实际指向的是一个基本类型；在表达式中，数组名也会进行同样的转换（下降一维）。 3) int (*p4)(int, int);​ 从p4开始理解，()的优先级最高，编译器先解析(*p4)，p4首先是一个指针，它后边的()说明p4指向的是一个函数，括号中的int, int是参数列表，开头的int用来说明函数的返回值类型。整体来看，p4是一个指向原型为int func(int, int);的函数的指针。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之函数返回值]]></title>
    <url>%2F2018%2F01%2F23%2Fc%E8%AF%AD%E8%A8%802-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[问：那些临时变量是不能作为返回值的？ 返回局部变量​ 首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，已经可能被分配给其他变量了。所以在函数退出后，该内存可能已经被修改了，对于临时变量来说已经是没有意义的值了。 ​ C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit。 由此可见，函数调用结束后，**返回值被临时存储到寄存器中**，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中，与临时变量的生命周期没有关系。 ​ 如果我们需要返回值，一般使用赋值语句就可以了 1A a = func(); 综上，**函数是可以将临时变量的值作为返回值的。** 返回局部变量的指针​ 然而将一个指向局部变量的指针作为函数的返回值是有问题的。 ​ 由于指针指向局部变量，因此在函数返回时，临时变量被销毁，指针指向一块无意义的地址空间，所以一般不会有返回值。 ​ 如果得到正常的值，只能是幸运的，因为退出函数的时候，系统只是修改了栈顶的指针，并没有清内存；所以，是有可能正常访问到局部变量的内存的。但因为栈是系统自动管理的，所以该内存可能会可以被分配给其他函数，这样，该内存的内容就会被覆盖，不再是原来的值了。 ​ 常规程序中，函数返回的指针（函数指针，数组指针，结构体指针，联合体指针等）通常应该是： (1)、指向静态（static）变量； (2)、指向专门申请分配的（如用malloc）空间； (3)、指向常量区（如指向字符串&quot;hello&quot;）； (4)、指向全局变量； (5)、指向程序代码区（如指向函数的指针）。 ​ 对于结构体和联合体来说，在作为函数的参数和返回值时，表现与C语言的内置类型（int,float, char等）是一样的。当为临时变量的时候，作为返回值是有效的。这个也是与指针不同的地方。但是不要与结构体指针或者联合体指针弄混了，他们是指针，而不是自定义数据类型。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言-整数在内存的存储]]></title>
    <url>%2F2018%2F01%2F21%2Fc%E8%AF%AD%E8%A8%801-%E6%95%B4%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[​ 加法和减法是计算机中最基本的运算，计算机时时刻刻都离不开它们，所以它们由硬件直接支持。为了提高加减法的运算效率，硬件电路要设计得尽量简单。​ 对于有符号数，内存要区分符号位和数值位，对于人脑来说，很容易辨别，但是对于计算机来说，就要设计专门的电路，这无疑增加了硬件的复杂性，增加了计算的时间。要是能把符号位和数值位等同起来，让它们一起参与运算，不再加以区分，这样硬件电路就变得简单了。 整数在内存的存储​ 另外，加法和减法也可以合并为一种运算，就是加法运算，因为减去一个数相当于加上这个数的相反数，例如，5 - 3等价于 5 + (-3)，10 - (-9)等价于10 + 9。 相反数是指数值相同，符号不同的两个数，例如，10和-10就是一对相反数，-98和98也是一对相反数。 ​ 如果能够实现上面的两个目标，那么只要设计一种简单的、不用区分符号位和数值位的加法电路，就能同时实现加法和减法运算，并且非常高效。实际上，这两个目标都已经实现了，真正的计算机硬件电路就是如此简单。 ​ 然而，简化硬件电路是有代价的，这个代价就是有符号数在存储和读取时都要进行转化。那么，这个转换过程究竟是怎样的呢？接下来我们就详细地讲解一下。 ​ 首先，请读者先记住下面的几个概念。 原码​ 将一个整数转换成二进制形式，就是其原码。例如short a = 6;，a的原码就是0000 0000 0000 0110；更改a的值a = -18;，此时a的原码就是1000 0000 0001 0010。 ​ 通俗的理解，原码就是一个整数本来的二进制形式。 反码​ 谈到反码，正数和负数要区别对待，因为它们的反码不一样。 ​ 对于正数，它的反码就是其原码（原码和反码相同）；负数的反码是将原码中除符号位以外的所有位（数值位）取反，也就是0变成1，1变成0。例如short a = 6;，a的原码和反码都是0000 0000 0000 0110；更改a的值a = -18;，此时a的反码是1111 1111 1110 1101。 补码​ 正数和负数的补码也不一样，也要区别对待。 ​ 对于正数，它的补码就是其原码（原码、反码、补码都相同）；负数的补码是其反码加1。例如short a = 6;，a的原码、反码、补码都是0000 0000 0000 0110；更改a的值a = -18;，此时a的补码是1111 1111 1110 1110。 ​ 可以认为，补码是在反码的基础上打了一个补丁，进行了一下修正，所以叫“补码”。 ​ 原码、反码、补码的概念只对负数有实际意义，对于正数，它们都一样。 ​ 最后我们总结一下6和-18从原码到补码的转换过程： ​ 在计算机内存中，整数一律采用补码的形式来存储。这意味着，当读取整数时还要采用逆向的转换，也就是将补码转换为原码。 ​ 将补码转换为原码也很简单：先减去1，再将数值位取反即可。 补码如何简化硬件电路​ 假设6和18都是short类型的，现在我们要计算6 - 18的结果，根据运算规则，它等价于6 + (-18)。 ​ 如果采用原码计算，那么运算过程为：12346 - 18 = 6 + (-18)= [0000 0000 0000 0110]原 + [1000 0000 0001 0010]原= [1000 0000 0001 1000]原= -24 ​ 直接用原码表示整数，让符号位也参与运算，对于类似上面的减法来说，结果显然是不正确的。 ​ 于是人们开始继续探索，不断试错，后来设计出了反码。下面就演示了反码运算的过程：123456 - 18 = 6 + (-18)= [0000 0000 0000 0110]反 + [1111 1111 1110 1101]反= [1111 1111 1111 0011]反= [1000 0000 0000 1100]原= -12 ​ 这样一来，计算结果就正确了。 ​ 然而，这样还不算万事大吉，我们不妨将减数和被减数交换一下位置，也就是计算18 - 6 的结果：12345618 - 6 = 18 + (-6)= [0000 0000 0001 0010]反 + [1111 1111 1111 1001]反= [1 0000 0000 0000 1011]反= [0000 0000 0000 1011]反= [0000 0000 0000 1011]原= 11 ​ 按照反码计算的结果是11，而真实的结果应该是12才对，它们相差了1。 蓝色的 1 是加法运算过程中的进位，它溢出了，内存容纳不了了，所以直接截掉。 ​ 6 - 18 的结果正确，18 - 6 的结果就不正确，相差1。按照反码来计算，是不是小数减去大数正确，大数减去小数就不对了，始终相差1呢？我们不妨再看两个例子，分别是 5 - 13 和 13 - 5。 ​ 5 - 13的运算过程为：1234565 - 13 = 5 + (-13)= [0000 0000 0000 0101]原 + [1000 0000 0000 1101]原= [0000 0000 0000 0101]反 + [1111 1111 1111 0010]反= [1111 1111 1111 0111]反= [1000 0000 0000 1000]原= -8 13 - 5的运算过程为： 123456713 - 5 = 13 + (-5)= [0000 0000 0000 1101]原 + [1000 0000 0000 0101]原= [0000 0000 0000 1101]反 + [1111 1111 1111 1010]反= [1 0000 0000 0000 0111]反 = [0000 0000 0000 0111]反= [0000 0000 0000 0111]原= 7 ​ 这足以证明，刚才的猜想是正确的：小数减去大数不会有问题，而大数减去小数的就不对了，结果始终相差1。 ​ 相差的这个1要进行纠正，但是又不能影响小数减去大数，怎么办呢？于是人们又绞尽脑汁设计出了补码，给反码打了一个“补丁”，终于把相差的1给纠正过来了。 ​ 下面演示了按照补码计算的过程：12345678910111213141516171819202122232425262728296 - 18 = 6 + (-18)= [0000 0000 0000 0110]补 + [1111 1111 1110 1110]补= [1111 1111 1111 0100]补= [1111 1111 1111 0011]反= [1000 0000 0000 1100]原= -12 18 - 6 = 18 + (-6)= [0000 0000 0001 0010]补 + [1111 1111 1111 1010]补= [1 0000 0000 0000 1100]补= [0000 0000 0000 1100]补= [0000 0000 0000 1100]反= [0000 0000 0000 1100]原= 12 5 - 13 = 5 + (-13)= [0000 0000 0000 0101]补 + [1111 1111 1111 0011]补= [1111 1111 1111 1000]补= [1000 1111 1111 0111]反= [1000 0000 0000 1000]原= -8 13 - 5 = 13 + (-5)= [0000 0000 0000 1101]补 + [1111 1111 1111 1011]补= [1 0000 0000 0000 1000]补 = [0000 0000 0000 1000]补= [0000 0000 0000 1000]反= [0000 0000 0000 1000]原= 8 ​ 你看，采用补码的形式正好把相差的1纠正过来，也没有影响到小数减去大数，这个“补丁”真是巧妙。 ​ 小数减去大数，结果为负数，之前（负数从反码转换为补码要加1）加上的1，后来（负数从补码转换为反码要减1）还要减去，正好抵消掉，所以不会受影响。 ​ 而大数减去小数，结果为正数，之前（负数从反码转换为补码要加1）加上的1，后来（正数的补码和反码相同，从补码转换为反码不用减1）就没有再减去，不能抵消掉，这就相当于给计算结果多加了一个1。 ​ 补码这种天才般的设计，一举达成了本文开头提到的两个目标，简化了硬件电路。 实例分析​ 上一节我们还留下了一个谜团，就是有符号数以无符号的形式输出，或者无符号数以有符号的形式输出时，会得到一个奇怪的值，请看下面的代码： 1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; short a = 0100; //八进制 int b = -0x1; //十六进制 long c = 720; //十进制 unsigned short m = 0xffff; //十六进制 unsigned int n = 0x80000000; //十六进制 unsigned long p = 100; //十进制 //以无符号的形式输出有符号数 printf("a=%#ho, b=%#x, c=%#ld\n", a, b, c); //以有符号数的形式输出无符号类型（只能以十进制形式输出） printf("m=%hd, n=%d, p=%ld\n", m, n, p); return 0;&#125; ​ 运行结果：123a=0100, b=0xffffffff, c=720m=-1, n=-2147483648, p=100 ​ 其中，b、m、n的输出结果看起来非常奇怪。 ​ b是有符号数，它在内存中的存储形式（也就是补码）为：12345b = -0x1= [1000 0000 …… 0000 0001]原= [1111 1111 …… 1111 1110]反= [1111 1111 …… 1111 1111]补= [0xffffffff]补 ​ %#x表示以无符号的形式输出，而无符号数的补码和原码相同，所以不用转换了，直接输出 0xffffffff 即可。 ​ m 和n 是无符号数，它们在内存中的存储形式为：12345m = 0xffff= [1111 1111 1111 1111]补 n = 0x80000000= [1000 0000 …… 0000 0000]补 ​ %hd和%d表示以有符号的形式输出，所以还要经过一个逆向的转换过程： 12345678[1111 1111 1111 1111]补= [1111 1111 1111 1110]反= [1000 0000 0000 0001]原= -1 [1000 0000 …… 0000 0000]补= -231= -2147483648 由此可见，-1 和-2147483648才是最终的输出值。 注意，[1000 0000 …… 0000 0000]补是一个特殊的补码，无法按照本节讲到的方法转换为原码，所以计算机直接规定这个补码对应的值就是-231，至于为什么，下节我们会详细分析。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言-小数在内存的存储]]></title>
    <url>%2F2018%2F01%2F20%2Fc%E8%AF%AD%E8%A8%801-%E5%B0%8F%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[小数在内存中是以浮点数的形式存储的。浮点数并不是一种数值分类，它和整数、小数、实数等不是一个层面的概念。 ​ 浮点数是数字（或者说数值）在内存中的一种存储格式，它和定点数是相对的。 小数在内存的存储​ C语言使用定点数格式来存储short、int、long类型的整数，使用浮点数格式来存储float、double类型的小数。整数和小数在内存中的存储格式不一样。 ​ 我们在学习C语言时，通常认为浮点数和小数是等价的，并没有严格区分它们的概念，这也并没有影响到我们的学习，原因就是浮点数和小数是绑定在一起的，只有小数才使用浮点格式来存储。 ​ 其实，整数和小数可以都使用定点格式来存储，也可以都使用浮点格式来存储，但实际情况却是，C语言使用定点格式存储整数，使用浮点格式存储小数，这是在“数值范围”和“数值精度”两项重要指标之间追求平衡的结果，稍后我会给大家带来深入的剖析。 计算机的设计是一门艺术，很多实用技术都是权衡和妥协的结果。 ​ 浮点数和定点数中的“点”指的就是小数点！ ​ 对于整数，可以认为小数点后面都是零，小数部分是否存在并不影响整个数字的值，所以干脆将小数部分省略，只保留整数部分。 定点数​ 所谓定点数，就是指小数点的位置是固定的，不会向前或者向后移动。 ​ 假设我们用4个字节（32位）来存储无符号的定点数，并且约定，前16位表示整数部分，后16位表示小数部分，如下图所示： ​ 如此一来，小数点就永远在第16位之后，整数部分和小数部分一目了然，不管什么时候，整数部分始终占用16位（不足16位前置补0），小数部分也始终占用16位（不足16位后置补0）。例如，在内存中存储了 10101111 00110001 01011100 11000011，那么对应的小数就是 10101111 00110001 . 01011100 11000011，非常直观。 精度​ 小数部分的最后一位可能是精确数字，也可能是近似数字（由四舍五入、向零舍入等不同方式得到）；除此以外，剩余的31位都是精确数字。从二进制的角度看，这种定点格式的小数，最多有32位有效数字，但是能保证的是31位；也就是说，整体的精度为31~32位。 数值范围​ 将内存中的所有位（Bit）都置为1，小数的值最大，为 $2^{16}$ - $2^{-16}$，极其接近$2^{16}$，换算成十进制为 65 536。将内存中最后一位（第32位）置1，其它位都置0，小数的值最小，为$2^{-16}$。 这里所说的最小值不是0值，而是最接近0的那个值。 综述​ 用定点格式来存储小数，优点是精度高，因为所有的位都用来存储有效数字了，缺点是取值范围太小，不能表示很大或者很小的数字。 反面例子​ 在科学计算中，小数的取值范围很大，最大值和最小值的差距有上百个数量级，使用定点数来存储将变得非常困难。 ​ 例如，电子的质量为：10000000000000000000000000000.9 克 = 9 × 10^(-28) 克 ​ 太阳的质量为：12000000000000000000000000000000000 克 = 2 × 10^33 克 ​ 如果使用定点数，那么只能按照=前面的格式来存储，这将需要很大的一块内存，大到需要几十个字节。更加科学的方案是按照=后面的指数形式来存储，这样不但节省内存，也非常直观。这种以指数的形式来存储小数的解决方案就叫做浮点数。 ​ 浮点数是对定点数的升级和优化，克服了定点数取值范围太小的缺点。 浮点数​ C语言标准规定，小数在内存中以科学计数法的形式来存储，具体形式为：1flt = (-1)sign × mantissa × baseexponent ​ 对各个部分的说明： flt是要表示的小数。 sign用来表示flt的正负号，它的取值只能是0或1：取值为0表示flt是正数，取值为1表示flt是负数。 base是基数，或者说进制，它的取值大于等于2（例如，2表示二进制、10表示十进制、16表示十六进制……）。数学中常见的科学计数法是基于十进制的，例如6.93 × 1013；计算机中的科学计数法可以基于其它进制，例如1.001 × 27就是基于二进制的，它等价于1001 0000。 mantissa为尾数，或者说精度，是base进制的小数，并且1 ≤ mantissa ＜ base，这意味着，小数点前面只能有一位数字； exponent为指数，是一个整数，可正可负，并且为了直观一般采用十进制表示。 下面我们以19.625为例来演示如何将小数转换为浮点格式。 ​ 当base取值为10时，19.625的浮点形式为：119.625 = 1.9625 × 101 ​ 当base取值为2时，将19.625转换成二进制为10011.101，用浮点形式来表示为：119.625 = 10011.101 = 1.0011101×2^4 19.625整数部分的二进制形式为： 19 = 1×24 + 0×23 + 0×22 + 1×21 + 1×20 = 10011 小数部分的二进制形式为： 0.625 = 1×2-1 + 0×2-2 + 1×2-3 = 101 将整数部分和小数部分合并在一起： 19.625 = 10011.101 可以看出，当基数（进制）base确定以后，指数exponent实际上就成了小数点的移动位数： exponent大于零，mantissa中的小数点右移exponent位即可还原小数的值； exponent小于零，mantissa中的小数点左移exponent位即可还原小数的值。 ​ 换句话说，将小数转换成浮点格式后，小数点的位置发生了浮动（移动），并且浮动的位数和方向由 exponent决定，所以我们将这种表示小数的方式称为浮点数。 二进制形式的浮点数的存储​ 虽然C语言标准没有规定base使用哪种进制，但是在实际应用中，各种编译器都将base实现为二进制，这样不仅贴近计算机硬件（任何数据在计算机底层都以二进制形式表示），还能减少转换次数。 ​ 接下来我们就讨论一下如何将二进制形式的浮点数放入内存中。 ​ 原则上讲，上面的科学计数法公式中，符号sign、尾数mantissa、基数base和指数exponent都是不确定因素，都需要在内存中体现出来。但是现在基数base已经确定是二进制了，就不用在内存中体现出来了，这样只需要在内存中存储符号sign、尾数mantissa、指数exponent这三个不确定的元素就可以了。 ​ 仍然以19.625为例，将它转换成二进制形式的浮点数格式：119.625 = 1.0011101×2^4 ​ 此时符号sign为0，尾数mantissa为1.0011101，指数exponent为4。 1) 符号的存储​ 符号的存储很容易，就像存储short、int等普通整数一样，单独分配出一个位（Bit）来，用0表示正数，用1表示负数。对于19.625，这一位的值是0。 2) 尾数的存储​ 当采用二进制形式后，尾数部分的取值范围为1 ≤ mantissa ＜ 2，这意味着：尾数的整数部分一定为1，是一个恒定的值，这样就无需在内存中提现出来，可以将其直接截掉，只要把小数点后面的二进制数字放入内存中即可。对于1.0011101，就是把0011101放入内存。 ​ 我们不妨将真实的尾数命名为mantissa，将内存中存储的尾数命名为mant，那么它们之间的关系为：1mantissa = 1.mant ​ 如果base采用其它进制，那么尾数的整数部分就不是固定的，它有多种取值的可能，以十进制为例，尾数的整数部分可能是1~9之间的任何一个值，这样一来尾数的整数部分就不能省略了，必须在内存中体现出来。而将base设置为二进制就可以节省掉一个位（Bit）的内存，这也算是采用二进制的一点点优势。 3) 指数的存储​ 指数是一个整数，并且有正负之分，不但需要存储它的值，还得能区分出正负号来。 ​ short、int、long等类型的整数在内存中的存储采用的是补码加符号位的形式，数值在写入内存之前必须先进行转换，读取以后还要再转换一次。但是为了提高效率，避免繁琐的转换，指数的存储并没有采用补码加符号位的形式，而是设计了一套巧妙的解决方案，稍等我会为您解开谜团。 为二进制浮点数分配内存​ C语言中常用的浮点数类型为float和double；float始终占用4个字节，double始终占用8个字节。 ​ 下图演示了float和double的存储格式： ​ 浮点数的内存被分成了三部分，分别用来存储符号sign、尾数mantissa和指数exponent，当浮点数的类型确定后，每一部分的位数就是固定的。 ​ 符号sign可以不加修改直接放入内存中，尾数mantissa只需要将小数部分放入内存中，最让人疑惑的是指数exponent如何放入内存中，这也是我们在前面留下的一个谜团，下面我们以float为例来揭开谜底。 ​ float的指数部分占用8 Bits，能表示从0~255的值，取其中间值127，指数在写入内存前先加上127，读取时再减去127，正数负数就显而易见了。19.625转换后的指数为4，4+127 = 131，131换算成二进制为1000 0011，这就是19.626的指数部分在float中的最终存储形式。 ​ 先确定内存中指数部分的取值范围，得到一个中间值，写入指数时加上这个中间值，读取指数时减去这个中间值，这样符号和值就都能确定下来了。 ​ 中间值的求取有固定的公式。设中间值为median，指数部分占用的内存为n位，那么中间值为：1median = 2^(n-1) - 1 ​ 对于float，中间值为 $2^{8-1}$ - 1 = 127；对于double，中间值为 $2^{11-1}$ -1 = 1023。 ​ 我们不妨将真实的指数命名为exponent，将内存中存储的指数命名为exp，那么它们之间的关系为：1exponent = exp - median ​ 也可以写作：1exp = exponent + median 为了方便后续文章的编写，这里我强调一下命名： mantissa表示真实的尾数，包括整数部分和小数部分；mant表示内存中存储的尾数，只有小数部分，省略了整数部分。 exponent表示真实的指数，exp表示内存中存储的指数，exponent和exp并不相等，exponent加上中间数median才等于exp。 用代码验证float的存储​ 19.625转换成二进制的指数形式为：119.625 = 1.0011101×2^4 ​ 此时符号为0；尾数为1.0011101，截掉整数部分后为0011101，补齐到23 Bits后为 001 1101 0000 0000 0000 0000；指数为 4，4+127 = 131，131 换算成二进制为 1000 0011。 ​ 综上所述，float类型的 19.625 在内存中的值为：0 - 10000011 - 001 1101 0000 0000 0000 0000。 ​ 下面我们通过代码来验证一下： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//浮点数结构体typedef struct &#123; unsigned int nMant : 23; //尾数部分 unsigned int nExp : 8; //指数部分 unsigned int nSign : 1; //符号位&#125; FP_SINGLE;int main()&#123; char strBin[33] = &#123; 0 &#125;; float f = 19.625; FP_SINGLE *p = (FP_SINGLE*)&amp;f; itoa(p-&gt;nSign, strBin, 2); printf("sign: %s\n", strBin); itoa(p-&gt;nExp, strBin, 2); printf("exp: %s\n", strBin); itoa(p-&gt;nMant, strBin, 2); printf("mant: %s\n", strBin); return 0;&#125; ​ 运行结果：123sign: 0exp: 10000011mant: 111010000000000000000 mant的位数不足，在前面补齐两个0即可。 printf()不能直接输出二进制形式，这里我们借助itoa()函数将十进制数转换成二进制的字符串，再使用%s输出。itoa()虽然不是标准函数，但是大部分编译器都支持。不过itoa()在C99标准中已经被指定为不可用函数，在一些严格遵循C99标准的编译器下会失效，甚至会引发错误，例如在Xcode（使用LLVM编译器）下就会编译失败。如果itoa()无效，请使用%X输出十六进制形式，十六进制能够很方便地转换成二进制。 精度问题​ 对于十进制小数，整数部分转换成二进制使用“展除法”（就是不断除以2，直到余数为0），一个有限位数的整数一定能转换成有限位数的二进制。但是小数部分就不一定了，小数部分转换成二进制使用“乘二取整法”（就是不断乘以2，直到小数部分为0），一个有限位数的小数并不一定能转换成有限位数的二进制，只有末位是5的小数才有可能转换成有限位数的二进制，其它的小数都不行。 ​ float和double的尾数部分是有限的，固然不能容纳无限的二进制；即使小数能够转换成有限的二进制，也有可能会超出尾数部分的长度，此时也不能容纳。这样就必须“四舍五入”，将多余的二进制“处理掉”，只保留有效长度的二进制，这就涉及到了精度的问题。 ​ 也就是说，浮点数不一定能保存真实的小数，很有可能保存的是一个近似值。 ​ 对于float，尾数部分有23位，再加上一个隐含的整数1，一共是24位。最后一位可能是精确数字，也可能是近似数字（由四舍五入、向零舍入等不同方式得到）；除此以外，剩余的23位都是精确数字。从二进制的角度看，这种浮点格式的小数，最多有24位有效数字，但是能保证的是23位；也就是说，整体的精度为23~24位。如果转换成十进制，$2^{24}$ = 16 777 216，一共8位；也就是说，最多有8 位有效数字，但是能保证的是7位，从而得出整体精度为7~8位。 ​ 对于double，同理可得，二进制形式的精度为52~53位，十进制形式的精度为15~16位。 IEEE 754标准​ 浮点数的存储以及加减乘除运算是一个比较复杂的问题，很多小的处理器在硬件指令方面甚至不支持浮点运算，其他的则需要一个独立的协处理器来处理这种运算，只有最复杂的处理器才会在硬件指令集中支持浮点运算。省略浮点运算，可以将处理器的复杂度减半！如果硬件不支持浮点运算，那么只能通过软件来实现，代价就是需要容忍不良的性能。 PC和智能手机上的处理器就是最复杂的处理器了，它们都能很好地支持浮点运算。 ​ 在六七十年代，计算机界对浮点数的处理比较混乱，各家厂商都有自己的一套规则，缺少统一的业界标准，这给数据交换、计算机协同工作带来了很大不便。 ​ 作为处理器行业的老大，Intel早就意识到了这个问题，并打算一统浮点数的世界。Intel 在研发 8087 浮点数协处理器时，聘请到加州大学伯克利分校的William Kahan教授（最优秀的数值分析专家之一）以及他的两个伙伴，来为8087协处理器设计浮点数格式，他们的工作完成地如此出色，设计的浮点数格式具有足够的合理性和先进性，被 IEEE 组织采用为浮点数的业界标准，并于1985年正式发布，这就是IEEE 754标准，它等同于国际标准ISO/IEC/IEEE 60559。 IEEE是Institute of Electrical and Electronics Engineers的简写，中文意思是“电气和电子工程师协会”。 ​ IEEE 754简直是天才一般的设计，William Kahan教授也因此获得了1987年的图灵奖。图灵奖是计算机界的“诺贝尔奖”。 ​ 目前，几乎所有的计算机都支持IEEE 754标准，大大改善了科学应用程序的可移植性，C语言编译器在实现浮点数时也采用了该标准。 ​ 不过，IEEE 754标准的出现晚于C语言标准（最早的ANSI C标准于1983年发布），C语言标准并没有强制编译器采用IEEE 754格式，只是说要使用科学计数法的形式来表示浮点数，但是编译器在实现浮点数时，都采用了IEEE 754格式，这既符合C语言标准，又符合IEEE标准，何乐而不为。 特殊值​ IEEE 754标准规定，当指数exp的所有位都为1时，不再作为“正常”的浮点数对待，而是作为特殊值处理： 如果此时尾数mant的二进制位都为0，则表示无穷大： 如果符号sign为1，则表示负无穷大； 如果符号sign为0，则表示正无穷大。 如果此时尾数mant的二进制位不全为0，则表示NaN（Not a Number），也即这是一个无效的数字，或者该数字未经初始化。 非规格化浮点数​ 当指数exp的所有二进制位都为0时，情况也比较特殊。 ​ 对于“正常”的浮点数，尾数mant隐含的整数部分为1，并且在读取浮点数时，内存中的指数exp要减去中间值median才能还原真实的指数exponent，也即：12mantissa = 1.mantexponent = exp - median ​ 但是当指数exp的所有二进制位都为0时，一切都变了！尾数mant隐含的整数部分变成了0，并且用1减去内存中的指数exp才能还原真实的指数exponent，也即：12mantissa = 0.mantexponent = 1 - exp ​ 对于float，exponent = 1 - 127 = -126，指数exponent的值恒为-126；对于double，exponent = 1 - 1023 = -1022，指数exponent的值恒为-1022。 ​ 当指数exp的所有二进制位都是0时，我们将这样的浮点数称为“非规格化浮点数”；当指数exp的所有二进制位既不全为0也不全为1时，我们称之为“规格化浮点数”；当指数exp的所有二进制位都是1时，作为特殊值对待。 ​ 也就是说，究竟是规格化浮点数，还是非规格化浮点数，还是特殊值，完全看指数exp。 +0和-0的表示​ 对于非规格化浮点数，当尾数mant的所有二进制位都为0时，整个浮点数的值就为0： 如果符号sign为0，则表示+0； 如果符号sign为1，则表示-0。 IEEE 754为什么增加非规格化浮点数​ 我们以float类型为例来说明。 ​ 对于规格化浮点数，当尾数mant的所有位都为0、指数exp的最低位为1时，浮点数的绝对值最小（符号sign的取值不影响绝对值），为 1.0 × $2^{-126}$，也即 $2^{-126}$。 ​ 对于一般的计算，这个值已经很小了，非常接近0值了，但是对于科学计算，它或许还不够小，距离0值还不够近，非规格化浮点数就是来弥补这一缺点的：非规格化浮点数可以让最小值更小，更加接近0值。 ​ 对于非规格化浮点数，当尾数的最低位为1时，浮点数的绝对值最小，为 $2^{-23}$ × $2^{-126}$ = $2^{-149}$，这个值比 $2^{-126}$小了23个数量级，更加即接近0值。 ​ 上表演示了正数时的情形，负数与此类似。请读者注意观察最大非规格化数和最小规格化数，它们是连在一起的，是平滑过渡的。 舍入模式​ 浮点数的尾数部分mant所包含的二进制位有限，不可能表示太长的数字，如果尾数部分过长，在放入内存时就必须将多余的位丢掉，取一个近似值。究竟该如何来取这个近似值，IEEE 754列出了四种不同的舍入模式。 1) 舍入到最接近的值​ 就是将结果舍入为最接近且可以表示的值，这是默认的舍入模式。最近舍入模式和我们平时所见的“四舍五入”非常类似，但有一个细节不同。 ​ 对于最近舍入模式，IEEE 754规定，当有两个最接近的可表示的值时首选“偶数”值；而对于四舍五入模式，当有两个最接近的可表示的值时要选较大的值。以十进制为例，就是对.5的舍入上采用偶数的方式，请看下面的例子。 最近舍入模式：Round(0.5) = 0、Round(1.5) = 2、Round(2.5) = 2 四舍五入模式：Round(0.5) = 1、Round(1.5) = 2、Round(2.5) = 3 2) 向+∞方向舍入（向上舍入）​ 会将结果朝正无穷大的方向舍入。标准库函数ceil()使用的就是这种舍入模式，例如，ceil(1.324) = 2，Ceil(-1.324) = -1。 3) 向-∞方向舍入（向下舍入）​ 会将结果朝负无穷大的方向舍入。标准库函数floor()使用的就是这种舍入模式，例如，floor(1.324) = 1，floor(-1.324) = -2。 4) 向0舍入（直接截断）​ 会将结果朝接近0的方向舍入，也就是将多余的位数直接丢掉。C语言中的类型转换使用的就是这种舍入模式，例如，(int)1.324 = 1，(int) -1.324 = -1。 总结​ 与定点数相比，浮点数在精度方面损失不小，但是在取值范围方面增大很多。牺牲精度，换来取值范围，这就是浮点数的整体思想。 ​ IEEE 754标准其实还规定了浮点数的加减乘除运算，不过本文的重点是讲解浮点数的存储，所以对于浮点数的运算不再展开讨论。 答疑解惑​ 上节我们还留下了一个疑问，就是用%f输出128.101时得到的是一个近似值，而不是一个精确值，这是因为，128.101转换为浮点格式后，尾数部分过长，被丢掉了，不能“真实”地存储了。 ​ 128.101转换成二进制为：110000000.0001100111011011001000101101……（无限循环） ​ 向左移动7位后为：11.00000000001100111011011001000101101…… ​ 由此可见，尾数部分为：1000 0000 0001 1001 1101 1011 001000101101…… ​ 将多出的二进制丢掉后为：1000 0000 0001 1001 1101 1011 ​ 使用printf输出时，还需要进行还原，还原后的二进制为：110000000.0001100111011011 ​ 转换成十进制为128.1009979248046875，按照四舍五入的原则取6位小数，就是128.100998]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之位运算]]></title>
    <url>%2F2018%2F01%2F17%2Fc%E8%AF%AD%E8%A8%801-%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[位运算小结​ 位运算不管是在C语言中，或者其他语言，都是经常会用到的，所以本文也就不固定以某种语言来举例子了，原始点就从0、1开始。位运算主要包括按位与(&amp;)、按位或(|)、按位异或(^)、取反(~)、左移(&lt;&lt;)、右移(&gt;&gt;)这几种，其中除了取反(~)以外，其他的都是二目运算符，即要求运算符左右两侧均有一个运算量。 补码 在总结按位运算前，有必要先介绍下补码的知识，我们知道当将一个十进制正整数转换为二进制数的时候，只需要通过除2取余的方法即可，但是怎么将一个十进制的负整数转换为二进制数呢？其实，负数是以补码的形式表示，其转换方式，简单的一句话就是：先按正数转换，然后取反加1。 12345678要将十进制的-10用二进制表示，先将10用二进制表示：0000 0000 0000 1010取反：1111 1111 1111 0101加1：1111 1111 1111 0110所以，-10的二进制表示就是：1111 1111 1111 0110 按位与(&amp;)​ 参加运算的两个数，换算为二进制(0、1)后，进行与运算。只有当相应位上的数都是1时，该位才取1，否则该为为0。 1234567将10与-10进行按位与(&amp;)运算：0000 0000 0000 10101111 1111 1111 0110-----------------------0000 0000 0000 0010所以：10 &amp; -10 = 0000 0000 0000 0010` 按位或(|)​ 参加运算的两个数，换算为二进制(0、1)后，进行或运算。只要相应位上存在1，那么该位就取1，均不为1，即为0。 1234567将10与-10进行按位或(|)运算：0000 0000 0000 10101111 1111 1111 0110-----------------------1111 1111 1111 1110所以：10 | -10 = 1111 1111 1111 1110` 按位异或(^)​ 参加运算的两个数，换算为二进制(0、1)后，进行异或运算。只有当相应位上的数字不相同时，该为才取1，若相同，即为0。 1234567将10与-10进行按位异或(^)运算：0000 0000 0000 10101111 1111 1111 0110-----------------------1111 1111 1111 1100所以：10 ^ -10 = 1111 1111 1111 1100` ​ 可以看出，任何数与0异或，结果都是其本身。利用异或还可以实现一个很好的交换算法，用于交换两个数，算法如下： 123a = a ^ b;b = b ^ a;a = a ^ b; 取反(~)​ 参加运算的两个数，换算为二进制(0、1)后，进行取反运算。每个位上都取相反值，1变成0，0变成1。 123456对10进行取反(~)运算：0000 0000 0000 1010---------------------1111 1111 1111 0101所以：~10 = 1111 1111 1111 0101` 左移(&lt;&lt;)​ 参加运算的两个数，换算为二进制(0、1)后，进行左移运算，用来将一个数各二进制位全部向左移动若干位。 123456对10左移2位(就相当于在右边加2个0)：0000 0000 0000 1010--------------------0000 0000 0010 1000所以：10 &lt;&lt; 2 = 0000 0000 0010 1000 = 40 注意，观察可以发现，左移一位的结果就是原值乘2，左移两位的结果就是原值乘4。 右移(&gt;&gt;)​ 参加运算的两个数，换算为二进制(0、1)后，进行右移运算，用来将一个数各二进制位全部向右移动若干位。 123456对10右移2位(就相当于在左边加2个0)：0000 0000 0000 1010--------------------0000 0000 0000 0010所以：10 &gt;&gt; 2 = 0000 0000 0000 0010 = 2 ​ 注意，观察可以发现，右移一位的结果就是原值除2，左移两位的结果就是原值除4，注意哦，除了以后没有小数位的，都是取整。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之位段]]></title>
    <url>%2F2018%2F01%2F15%2Fc%E8%AF%AD%E8%A8%801-%E4%BD%8D%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用0和1表示足以，也就是用一个二进位。正是基于这种考虑，C语言又提供了一种叫做位域的数据结构。 ​ 在结构体定义时，我们可以指定某个成员变量所占用的二进制位数（Bit），这就是位域。请看下面的例子： 12345struct bs&#123; unsigned m; unsigned n: 4; unsigned char ch: 6;&#125;; ​ :后面的数字用来限定成员变量占用的位数。成员m没有限制，根据数据类型即可推算出它占用4个字节（Byte）的内存。成员n、ch被:后面的数字限制，不能再根据数据类型计算长度，它们分别占用4、6位（Bit）的内存。 ​ n、ch的取值范围非常有限，数据稍微大些就会发生溢出，请看下面的例子： 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; struct bs&#123; unsigned m; unsigned n: 4; unsigned char ch: 6; &#125; a = &#123; 0xad, 0xE, '$'&#125;; //第一次输出 printf("%#x, %#x, %c\n", a.m, a.n, a.ch); //更改值后再次输出 a.m = 0xb8901c; a.n = 0x2d; a.ch = 'z'; printf("%#x, %#x, %c\n", a.m, a.n, a.ch); return 0;&#125; 运行结果：0xad, 0xe, $0xb8901c, 0xd, : ​ 对于n和ch，第一次输出的数据是完整的，第二次输出的数据是残缺的。 ​ 第一次输出时，n、ch的值分别是0xE、0x24（&#39;$&#39;对应的ASCII码为0x24），换算成二进制是1110、10 0100，都没有超出限定的位数，能够正常输出。 ​ 第二次输出时，n、ch的值变为0x2d、0x7a（&#39;z&#39;对应的ASCII码为0x7a），换算成二进制分别是10 1101、111 1010，都超出了限定的位数。超出部分被直接截去，剩下1101、11 1010，换算成十六进制为0xd、0x3a（0x3a对应的字符是:）。 ​ C语言标准规定，位域的宽度不能超过它所依附的数据类型的长度。通俗地讲，成员变量都是有类型的，这个类型限制了成员变量的最大长度，:后面的数字不能超过这个长度。 ​ 例如上面的bs，n的类型是unsigned int，长度为4个字节，共计32位，那么n后面的数字就不能超过32；ch 的类型是unsigned char，长度为1个字节，共计8位，那么ch后面的数字就不能超过8。 ​ 我们可以这样认为，位域技术就是在成员变量所占用的内存中选出一部分位宽来存储数据。 ​ C语言标准还规定，只有有限的几种数据类型可以用于位域。在ANSI C中，这几种数据类型是int、signed int和unsigned int（int默认就是signed int）。 ​ 但编译器在具体实现时都进行了扩展，额外支持了char、signed char、unsigned char以及enum类型，所以上面的代码虽然不符合C语言标准，但它依然能够被编译器支持。 位域的存储​ C语言标准并没有规定位域的具体存储方式，不同的编译器有不同的实现，但它们都尽量压缩存储空间。 ​ 位域的具体存储规则如下：​ 1) 当相邻成员的类型相同时，如果它们的位宽之和小于类型的sizeof大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；如果它们的位宽之和大于类型的sizeof大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。 ​ 以下面的位域bs为例： 123456789101112#include &lt;stdio.h&gt;int main()&#123; struct bs&#123; unsigned m: 6; unsigned n: 12; unsigned p: 4; &#125;; printf("%d\n", sizeof(struct bs)); return 0;&#125; 运行结果：4 ​ m、n、p的类型都是unsigned int，sizeof的结果为4个字节（Byte），也即32个位（Bit）。m、n、p的位宽之和为6+12+4 = 22，小于32，所以它们会挨着存储，中间没有缝隙。 sizeof(struct bs)的大小之所以为4，而不是3，是因为要将内存对齐到4个字节，以便提高存取效率。 ​ 如果将成员m的位宽改为22，那么输出结果将会是8，因为22+12 = 34，大于32，n会从新的位置开始存储，相对m的偏移量是sizeof(unsigned int)，也即4个字节。 ​ 如果再将成员p的位宽也改为22，那么输出结果将会是12，三个成员都不会挨着存储。 ​ 2) 当相邻成员的类型不同时，不同的编译器有不同的实现方案，GCC会压缩存储，而VC/VS不会。 ​ 请看下面的位域bs： 123456789101112#include &lt;stdio.h&gt;int main()&#123; struct bs&#123; unsigned m: 12; unsigned char ch: 4; unsigned p: 4; &#125;; printf("%d\n", sizeof(struct bs)); return 0;&#125; ​ 在GCC下的运行结果为4，三个成员挨着存储；在VC/VS下的运行结果为12，三个成员按照各自的类型存储（与不指定位宽时的存储方式相同）。 m 、ch、p的长度分别是4、1、4个字节，共计占用9个字节内存。 ​ 3) 如果成员之间穿插着非位域成员，那么不会进行压缩。例如对于下面的bs： 12345struct bs&#123; unsigned m: 12; unsigned ch; unsigned p: 4;&#125;; ​ 在各个编译器下sizeof的结果都是12。 ​ 通过上面的分析，我们发现位域成员往往不占用完整的字节，有时候也不处于字节的开头位置，因此使用&amp;获取位域成员的地址是没有意义的，C语言也禁止这样做。地址是字节（Byte）的编号，而不是位（Bit）的编号。 无名位域​ 位域成员可以没有名称，只给出数据类型和位宽，如下所示： 12345struct bs&#123; int m: 12; int : 20; //该位域成员不能使用 int n: 4;&#125;; ​ 无名位域一般用来作填充或者调整成员位置。因为没有名称，无名位域不能使用。 ​ 上面的例子中，如果没有位宽为20的无名成员，m、n将会挨着存储，sizeof(struct bs)的结果为4；有了这20位作为填充，m、n将分开存储，sizeof(struct bs)的结果为8。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之基础数据类型]]></title>
    <url>%2F2018%2F01%2F13%2Fc%E8%AF%AD%E8%A8%801-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型位数标准基础类型12345678910111213141516171819202122232416位平台 char 1个字节8位 short 2个字节16位 int 2个字节16位 long 4个字节32位 指针 2个字节16位 ---------------------------32位平台 char 1个字节8位 short 2个字节16位 int 4个字节32位 long 4个字节32位 long long 8个字节64位 指针 4个字节32位 ---------------------------64位平台 char 1个字节8位 short 2个字节16位 int 4个字节32位 long 8个字节64位 long long 8个字节64位 指针 8个字节64位 int_t同类​ int_t 为一个结构的标注，可以理解为type/typedef的缩写，表示它是通过typedef定义的，而不是一种新的数据类型。因为跨平台，不同的平台会有不同的字长，所以利用预编译和typedef可以最有效的维护代码 int8_t : typedef signed char; uint8_t : typedef unsigned char; int16_t : typedef signed short ; uint16_t : typedef unsigned short ; int32_t : typedef signed int; uint32_t : typedef unsigned int; int64_t : typedef signed long long; uint64_t : typedef unsigned long long; Specifier Common Equivalent Signing Bits Bytes Minimum Value Maximum Value int8_t signed char Signed 8 1 -128 127 uint8_t unsigned char Unsigned 8 1 0 255 int16_t short Signed 16 2 -32,768 32,767 uint16_t unsigned short Unsigned 16 2 0 65,535 int32_t int Signed 32 4 -2,147,483,648 2,147,483,647 uint32_t unsigned int Unsigned 32 4 0 4,294,967,295 int64_t long long Signed 64 8 -9,223,372,036,854,775,808 9,223,372,036,854,775,807 uint64_t unsigned long long Unsigned 64 8 0 18,446,744,073,709,551,615]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之大端和小端]]></title>
    <url>%2F2018%2F01%2F08%2Fc%E8%AF%AD%E8%A8%801-%E5%A4%A7%E7%AB%AF%E5%92%8C%E5%B0%8F%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[大端和小端是指数据在内存中的存储模式，它由CPU决定： ​ 1) 大端模式（Big-endian）是指将数据的低位（比如1234 中的34就是低位）放在内存的高地址上，而数据的高位（比如1234中的12就是高位）放在内存的低地址上。这种存储模式有点儿类似于把数据当作字符串顺序处理，地址由小到大增加，而数据从高位往低位存放。 ​ 2) 小端模式（Little-endian）是指将数据的低位放在内存的低地址上，而数据的高位放在内存的高地址上。这种存储模式将地址的高低和数据的大小结合起来，高地址存放数值较大的部分，低地址存放数值较小的部分，这和我们的思维习惯是一致，比较容易理解。 为什么有大小端模式之分​ 计算机中的数据是以字节（Byte）为单位存储的，每个字节都有不同的地址。现代CPU的位数（可以理解为一次能处理的数据的位数）都超过了8位（一个字节），PC机、服务器的CPU基本都是64位的，嵌入式系统或单片机系统仍然在使用32位和16位的CPU。 ​ 对于一次能处理多个字节的CPU，必然存在着如何安排多个字节的问题，也就是大端和小端模式。以int类型的0x12345678为例，它占用4 个字节，如果是小端模式（Little-endian），那么在内存中的分布情况为（假设从地址0x4000开始存放）： 内存地址 0x4000 0x4001 0x4002 0x4003 存放内容 0x78 0x56 0x34 0x12 如果是大端模式（Big-endian），那么分布情况正好相反： 内存地址 0x4000 0x4001 0x4002 0x4003 存放内容 0x12 0x34 0x56 0x78 ​ 我们的PC机上使用的是X86结构的CPU，它是小端模式；51单片机是大端模式；很多ARM、DSP也是小端模式（部分ARM处理器还可以由硬件来选择是大端模式还是小端模式）。 ​ 借助共用体，我们可以检测CPU是大端模式还是小端模式，请看代码： 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; union&#123; int n; char ch; &#125; data; data.n = 0x00000001; //也可以直接写作 data.n = 1; if(data.ch == 1)&#123; printf("Little-endian\n"); &#125;else&#123; printf("Big-endian\n"); &#125; return 0;&#125; 在PC机上的运行结果：Little-endian ​ 共用体的各个成员是共用一段内存的。1是数据的低位，如果1被存储在data的低字节，就是小端模式，这个时候data.ch的值也是1。如果1被存储在data的高字节，就是大端模式，这个时候data.ch的值就是0。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之指针]]></title>
    <url>%2F2018%2F01%2F01%2Fc%E8%AF%AD%E8%A8%802-%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[指针详解​ 这段时间在看Linux内核，深觉C语言功底不扎实，很多代码都看不太懂，深入学习巩固C语言的知识很有必要。先从指针开始。 什么是指针​ C语言里，变量存放在内存中，而内存其实就是一组有序字节组成的数组，每个字节有唯一的内存地址。CPU通过内存寻址对存储在内存中的某个指定数据对象的地址进行定位。这里，数据对象是指存储在内存中的一个指定数据类型的数值或字符串，它们都有一个自己的地址，而指针便是保存这个地址的变量。也就是说：指针是一种保存变量地址的变量。 ​ 前面已经提到内存其实就是一组有序字节组成的数组，数组中，每个字节大大小固定，都是 8bit。对这些连续的字节从0开始进行编号，每个字节都有唯一的一个编号，这个编号就是内存地址。示意如下图： ​ 这是一个 4GB 的内存，可以存放 2^32 个字节的数据。左侧的连续的十六进制编号就是内存地址，每个内存地址对应一个字节的内存空间。而指针变量保存的就是这个编号，也即内存地址。 为什么要使用指针​ 在C语言中，指针的使用非常广泛，因为使用指针往往可以生成更高效、更紧凑的代码。总的来说，使用指针有如下好处： 1）指针的使用使得不同区域的代码可以轻易的共享内存数据，这样可以使程序更为快速高效； 2）C语言中一些复杂的数据结构往往需要使用指针来构建，如链表、二叉树等； 3）C语言是传值调用，而有些操作传值调用是无法完成的，如通过被调函数修改调用函数的对象，但是这种操作可以由指针来完成，而且并不违背传值调用。 如何声明一个指针声明并初始化一个指针​ 指针其实就是一个变量，指针的声明方式与一般的变量声明方式没太大区别： 12345int *p; // 声明一个 int 类型的指针 pchar *p // 声明一个 char 类型的指针 pint *arr[10] // 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向 int 类型对象的指针int (*arr)[10] // 声明一个数组指针，该指针指向一个 int 类型的一维数组int **p; // 声明一个指针 p ，该指针指向一个 int 类型的指针 ​ 指针的声明比普通变量的声明多了一个一元运算符 “*”。运算符 “*” 是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。在上述的声明中：p 是一个指针，保存着一个地址，该地址指向内存中的一个变量； *p则会访问这个地址所指向的变量。 ​ 声明一个指针变量并不会自动分配任何内存。在对指针进行间接访问之前，指针必须进行初始化：或是使他指向现有的内存，或者给他动态分配内存，否则我们并不知道指针指向哪儿，这将是一个很严重的问题，稍后会讨论这个问题。初始化操作如下： 123456789/* 方法1：使指针指向现有的内存 */int x = 1;int *p = &amp;x; // 指针 p 被初始化，指向变量 x ，其中取地址符 &amp; 用于产生操作数内存地址/* 方法2：动态分配内存给指针 */int *p;p = (int *)malloc(sizeof(int) * 10); // malloc 函数用于动态分配内存free(p); // free 函数用于释放一块已经分配的内存，常与 malloc 函数一起使用，要使用这两个函数需要头文件 stdlib.h ​ 指针的初始化实际上就是给指针一个合法的地址，让程序能够清楚地知道指针指向哪儿。 未初始化和非法的指针​ 如果一个指针没有被初始化，那么程序就不知道它指向哪里。它可能指向一个非法地址，这时，程序会报错，在Linux上，错误类型是Segmentation fault（core dumped），提醒我们段违例或内存错误。它也可能指向一个合法地址，实际上，这种情况更严重，你的程序或许能正常运行，但是这个没有被初始化的指针所指向的那个位置的值将会被修改，而你并无意去修改它。用一个例子简单的演示一下： 123456789#include "stdio.h"int main()&#123; int *p; *p = 1; printf("%d\n",*p); return 0; &#125; ​ 这个程序可以编译通过，但是运行的话会报错，报错信息如下： 1234[root@hly_centos learn]# gcc -o point point.c [root@hly_centos learn]# ./point Segmentation fault[root@hly_centos learn]# ​ 要想使这个程序运行起来，需要先对指针p进行初始化： 1234567891011#include "stdio.h"int main()&#123; int x = 1; int *p = &amp;x; printf("%d\n",*p); *p = 2; printf("%d\n",*p); return 0; &#125; ​ 这段代码的输出结果如下： 1234[root@hly_centos learn]# gcc -o point point.c [root@hly_centos learn]# ./point 12 ​ 可以看到，对指针进行初始化后，便可以正常对指针进行赋值了。 NULL指针​ NULL指针是一个特殊的指针变量，表示不指向任何东西。可以通过给一个指针赋一个零值来生成一个NULL指针。 12345678910111213#include "stdio.h"int main()&#123; int *p = NULL; printf("p的地址为%d\n",p); return 0;&#125;/*************** * 程序输出： * p的地址为0***************/ ​ 可以看到指针指向内存地址0。在大多数的操作系统上，程序不允许访问地址为0的内存，因为该内存是为操作系统保留的。但是，内存地址0有一个特别重要的意义，它表明该指针指向一个不可访问的内存位置。 指针的运算​ C指针的算术运算只限于两种形式： 指针+/-整数 ：​ 可以对指针变量p进行p++、p--、p + i等操作，所得结果也是一个指针，只是指针所指向的内存地址相比于p所指的内存地址前进或者后退了i个操作数。用一张图来说明一下： ​ 在上图中，10000000等是内存地址的十六进制表示（数值是假定的），p是一个int类型的指针，指向内存地址 0x10000008 处。则p++将指向与p相邻的下一个内存地址，由于int型数据占4个字节，因此p++所指的内存地址为 1000000b。其余类推。不过要注意的是，这种运算并不会改变指针变量p自身的地址，只是改变了它所指向的地址。 指针-指针​ 只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。两个指针相减的结果的类型是 ptrdiff_t，它是一种有符号整数类型。减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位，而不是以字节为单位），因为减法运算的结果将除以数组元素类型的长度。举个例子： 12345678910111213#include "stdio.h"int main()&#123; int a[10] = &#123;1,2,3,4,5,6,7,8,9,0&#125;; int sub; int *p1 = &amp;a[2]; int *p2 = &amp;a[8]; sub = p2-p1; printf("%d\n",sub); // 输出结果为 6 return 0;&#125; 指针与数组​ 在C语言中，指针与数组之间的关系十分密切。实际上，许多可以用数组完成的工作都可以使用指针来完成。一般来说，用指针编写的程序比用数组编写的程序执行速度快，但另一方面，用指针实现的程序理解起来稍微困难一些。 指针与数组的关系​ 我们先声明一个数组： 1int a[10]; // 声明一个int类型的数组，这个数组有10个元素 ​ 我们可以用a[0]、a[1]、...、a[9]来表示这个数组中的10个元素，这10个元素是存储在一段连续相邻的内存区域中的。 ​ 接下来，我们再声明一个指针： 1int *p; // 声明一个int类型的指针变量 ​ p是一个指针变量，指向内存中的一个区域。如果我们对指针p做如下的初始化： 1p = &amp;a[0]; // 对指针进行初始化，p将指向数组 a 的第 1 个元素 a[0] ​ 我们知道，对指针进行自增操作会让指针指向与当前元素相邻的下一个元素，即*(p + 1)将指向 a[1] ；同样的，*(p + i)将指向a[i]。因此，我们可以使用该指针来遍历数组a[10]的所有元素。可以看到，数组下标与指针运算之间的关系是一一对应的。而根据定义，数组类型的变量或表达式的值是该数组第1个元素的地址，且数组名所代表的的就是该数组第1个元素的地址，故，上述赋值语句可以直接写成： 1p = a; // a 为数组名，代表该数组最开始的一个元素的地址 ​ 很显然，一个通过数组和下标实现的表达式可以等价地通过指针及其偏移量来实现，这就是数组和指针的互通之处。但有一点要明确的是，数组和指针并不是完全等价，指针是一个变量，而数组名不是变量，它数组中第1个元素的地址，数组可以看做是一个用于保存变量的容器。更直接的方法，我们可以直接看二者的地址，并不一样： 12345678910111213#include "stdio.h" int main()&#123; int x[10] = &#123;1,2,3,4,5,6,7,8,9,0&#125;; int *p = x; printf("x的地址为：%p\n",x); printf("x[0]的地址为：%p\n",&amp;x[0]); printf("p的地址为：%p\n",&amp;p); // 打印指针 p 的地址，并不是指针所指向的地方的地址 p += 2; printf("*(p+2)的值为：%d\n",*p); // 输出结果为 3，*(p+2)指向了 x[2] return 0;&#125; ​ 结果如下： 123456[root@hly_centos learn]# gcc -o point point.c [root@hly_centos learn]# ./point x的地址为：0x7ffe02b98a60x[0]的地址为：0x7ffe02b98a60p的地址为：0x7ffe02b98a58*(p+2)的值为：3 ​ 可以看到，x的值与x[0]的地址是一样的，也就是说数组名即为数组中第1个元素的地址。实际上，打印&amp;x后发现，x的地址也是这个值。而x的地址与指针变量p的地址是不一样的。故而数组和指针并不能完全等价。 （笔者注：上述输出结果是在 centos7 64bit 的环境下使用 gcc 编译器得到的，可以看到地址是一个12位的十六进制数，转换成二进制是48位，也就是说寻址空间有 256TB，但是笔者的电脑只有 8GB 内存，猜测是不是由于 linux 系统开启了内存分页机制，这里寻址的是虚拟地址？另外，在Windows下使用 vs2015编译运行的话，则输出结果是一个8位的十六进制数，也就是32位二进制，寻址空间为 4GB） 指针数组​ 指针是一个变量，而数组是用于存储变量的容器，因此，指针也可以像其他变量一样存储在数组中，也就是指针数组。 指针数组是一个数组，数组中的每一个元素都是指针。声明一个指针数组的方法如下： 1int *p[10]; // 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向int类型的指针 ​ 在上述声明中，由于[]的优先级比*高，故p先与[]结合，成为一个数组p[]；再由int *指明这是一个int类型的指针数组，数组中的元素都是int类型的指针。数组的第i个元素是*p[i]，而 p[i]是一个指针。由于指针数组中存放着多个指针，操作灵活，在一些需要操作大量数据的程序中使用，可以使程序更灵活快速。 数组指针​ 数组指针是一个指针，它指向一个数组。声明一个数组指针的方法如下： 1int (*p)[10]; // 声明一个数组指针 p ，该指针指向一个数组 ​ 由于()的优先级最高，所以p是一个指针，指向一个int类型的一维数组，这个一维数组的长度是10，这也是指针p的步长。也就是说，执行p+1时，p要跨过1个int型数据的长度。数组指针与二维数组联系密切，可以用数组指针来指向一个二维数组，如下： 12345678910111213#include "stdio.h"int main()&#123; int arr[2][3] = &#123;1,2,3,4,5,6&#125;; // 定义一个二维数组并初始化 int (*p)[3]; // 定义一个数组指针，指针指向一个含有3个元素的一维数组 p = arr; // 将二维数组的首地址赋给 p，此时 p 指向 arr[0] 或 &amp;arr[0][0] printf("%d\n",(*p)[0]); // 输出结果为 1 p++; // 对 p 进行算术运算，此时 p 将指向二维数组的下一行的首地址，即 &amp;arr[1][0] printf("%d\n",(*p)[1]); // 输出结果为5 return 0; &#125; 指针与结构简单介绍一下结构​ 结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。由于结构将一组相关的变量看做一个单元而不是各自独立的实体，因此结构有助于组织复杂的数据，特别是在大型的程序中。声明一个结构的方式如下： 12345678910111213141516struct message&#123; // 声明一个结构 message char name[10]; // 成员 int age; int score; &#125;;typedef struct message s_message; // 类型定义符 typedefs_message mess = &#123;"tongye",23,83&#125;; // 声明一个 struct message 类型的变量 mess,并对其进行初始化 ----------------------------------------------------------------------------------/* 另一种更简便的声明方法 */typedef struct&#123; char name[10]; int age; int score;&#125;message; ​ 可以使用 结构名.成员 的方式来访问结构中的成员，如下： 12345678#include "stdio.h"int main()&#123; printf("%s\n",mess.name); // 输出结果：tongye printf("%d\n",mess.age); // 输出结果：23 return 0;&#125; 结构指针​ 结构指针是指向结构的指针，以上面的结构为例，可以这样定义一个结构指针： 12s_message *p; // 声明一个结构指针 p ，该指针指向一个 s_message 类型的结构p = &amp;mess; // 对结构指针的初始化与普通指针一样，也是使用取地址符 &amp; ​ C语言中使用-&gt;操作符来访问结构指针的成员，举个例子： 1234567891011121314151617#include "stdio.h"typedef struct&#123; char name[10]; int age; int score; &#125;message;int main()&#123; message mess = &#123;"tongye",23,83&#125;; message *p = &amp;mess; printf("%s\n",p-&gt;mess); // 输出结果为：tongye printf("%d\n",p-&gt;score); // 输出结果为：83 return 0;&#125; 指针与函数​ C语言的所有参数均是以“传值调用”的方式进行传递的，这意味着函数将获得参数值的一份拷贝。这样，函数可以放心修改这个拷贝值，而不必担心会修改调用程序实际传递给它的参数。 指针作为函数的参数​ 传值调用的好处是是被调函数不会改变调用函数传过来的值，可以放心修改。但是有时候需要被调函数回传一个值给调用函数，这样的话，传值调用就无法做到。为了解决这个问题，可以使用传指针调用。指针参数使得被调函数能够访问和修改主调函数中对象的值。用一个例子来说明： 12345678910111213141516171819202122232425262728#include "stdio.h"void swap1(int a,int b) // 参数为普通的 int 变量&#123; int temp; temp = a; a = b; b = temp;&#125;void swap2(int *a,int *b) // 参数为指针，接受调用函数传递过来的变量地址作为参数，对所指地址处的内容进行操作&#123; int temp; // 最终结果是，地址本身并没有改变，但是这一地址所对应的内存段中的内容发生了变化，即x,y的值发生了变化 temp = *a; *a = *b; *b = temp;&#125;int main()&#123; int x = 1,y = 2; swap1(x,y); // 将 x,y 的值本身作为参数传递给了被调函数 printf("%d %5d\n",x,y); // 输出结果为：1 2 swap(&amp;x,&amp;y); // 将 x,y 的地址作为参数传递给了被调函数，传递过去的也是一个值，与传值调用不冲突 printf("%d %5d\n",x,y); // 输出结果为：2 1 return 0;&#125; 指针函数​ 指针函数： 顾名思义，它的本质是一个函数，不过它的返回值是一个指针。其声明的形式如下所示：1ret *func(args, ...); ​ 其中，func是一个函数，args是形参列表，ret *作为一个整体，是 func函数的返回值，是一个指针的形式。​ 下面举一个具体的实例来做说明： 123456789101112131415161718192021222324252627282930文件：pointer_func.c# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;int * func_sum(int n)&#123; if (n &lt; 0) &#123; printf("error:n must be &gt; 0\n"); exit(-1); &#125; static int sum = 0; int *p = &amp;sum; for (int i = 0; i &lt; n; i++) &#123; sum += i; &#125; return p;&#125;int main(void)&#123; int num = 0; printf("please input one number:"); scanf("%d", &amp;num); int *p = func_sum(num); printf("sum:%d\n", *p); return 0;&#125; ​ 上例就是一个指针函数的例子，其中，int * func_sum(int n)就是一个指针函数， 其功能十分简单，是根据传入的参数n，来计算从0到n的所有自然数的和，其结果通过指针的形式返回给调用方。​ 以上代码的运行结果如下所示： 1234[root@hly_centos learn]# gcc -o point_func point_func.c [root@hly_centos learn]# ./point_func please input one number:100sum:4950 ​ 如果上述代码使用普通的局部变量来实现，也是可以的，如下所示： 123456789101112131415161718192021222324252627282930文件：pointer_func2.c# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;int func_sum2(int n)&#123; if (n &lt; 0) &#123; printf("error:n must be &gt; 0\n"); exit(-1); &#125; int sum = 0; int i = 0; for (i = 0; i &lt; n; i++) &#123; sum += i; &#125; return sum;&#125;int main(void)&#123; int num = 0; printf("please input one number:"); scanf("%d", &amp;num); int ret = func_sum2(num); printf("sum2:%d\n", ret); return 0;&#125; ​ 本案例中，func_sum2函数的功能与指针函数所实现的功能完全一样。 1234[root@hly_centos learn]# gcc -o point_func point_func.c [root@hly_centos learn]# ./point_func please input one number:100sum:4950 ​ 不过在使用指针函数时，需要注意一点，相信细心地读者已经发现了，对比func_sum和func_sum2函数，除了返回值不一样之外，还有一个不同的地方在于，在func_sum中，变量sum使用的是静态局部变量，而func_sum2函数中，变量sum使用的则是普通的变量。​ 如果我们把指针函数的sum定义为普通的局部变量，会是什么结果呢？不妨来试验一下： 123456789101112131415161718192021222324252627282930文件：pointer_func3.c# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;int * func_sum(int n)&#123; if (n &lt; 0) &#123; printf("error:n must be &gt; 0\n"); exit(-1); &#125; int sum = 0; int *p = &amp;sum; for (int i = 0; i &lt; n; i++) &#123; sum += i; &#125; return p;&#125;int main(void)&#123; int num = 0; printf("please input one number:"); scanf("%d", &amp;num); int *p = func_sum(num); printf("sum:%d\n", *p); return 0;&#125; ​ 执行以上程序，发现仍然能得到正确的结果： 1234[root@hly_centos learn]# gcc -o point_func point_func.c [root@hly_centos learn]# ./point_func please input one number:100sum:4950 ​ 可如果我们把main函数里面稍微改动一下： 12345678910int main(void)&#123; int num = 0; printf("please input one number:"); scanf("%d", &amp;num); int *p = func_sum(num); printf("wait for a while...\n"); //此处加一句打印 printf("sum:%d\n", *p); return 0;&#125; ​ 我们在输出sum之前打印一句话，这时看到得到的结果完全不是我们预先想象的样子，得到的并不是我们想要的答案。 12345[root@hly_centos learn]# gcc -o point_func point_func.c [root@hly_centos learn]# ./point_func please input one number:100wait for a while...sum:0 ​ 为什么会出现上面的结果呢？​ 其实原因在于，一般的局部变量是存放于栈区的，当函数结束，栈区的变量就会释放掉，如果我们在函数内部定义一个变量，在使用一个指针去指向这个变量，当函数调用结束时，这个变量的空间就已经被释放，这时就算返回了该地址的指针，也不一定会得到正确的值。上面的示例中，在返回该指针后，立即访问，的确是得到了正确的结果，但这只是十分巧合的情况，如果我们等待一会儿再去访问该地址，很有可能该地址已经被其他的变量所占用，这时候得到的就不是我们想要的结果。甚至更严重的是，如果因此访问到了不可访问的内容，很有可能造成段错误等程序崩溃的情况。​ 因此，在使用指针函数的时候，一定要避免出现返回局部变量指针的情况。​ 那么为什么用了static就可以避免这个问题呢？​ 原因是一旦使用了static去修饰变量，那么该变量就变成了静态变量。而静态变量是存放在数据段的，它的生命周期存在于整个程序运行期间，只要程序没有结束，该变量就会一直存在，所以该指针就能一直访问到该变量。​ 因此，还有一种解决方案是使用全局变量，因为全局变量也是放在数据段的，但是并不推荐使用全局变量。 函数指针​ 与指针函数不同，函数指针的本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。​ 我们知道，函数的定义是存在于代码段，因此，每个函数在代码段中，也有着自己的入口地址，函数指针就是指向代码段中函数入口地址的指针。​ 其声明形式如下所示： 1ret (*p)(args, ...); ​ 其中，ret为返回值，*p作为一个整体，代表的是指向该函数的指针，args为形参列表。其中p被称为函数指针变量 。​ 关于函数指针的初始化与数组类似，在数组中，数组名即代表着该数组的首地址，函数也是一样，函数名即是该数组的入口地址，因此，函数名就是该函数的函数指针。​ 因此，我们可以采用如下的初始化方式： 1函数指针变量 = 函数名; ​ 下面还是以一个简单的例子来具体说明一下函数指针的应用：123456789101112131415161718192021222324文件：func_pointer.c#include &lt;stdio.h&gt;int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;int main(void)&#123; int (*p)(int, int); //函数指针的定义 //int (*p)(); //函数指针的另一种定义方式，不过不建议使用 //int (*p)(int a, int b); //也可以使用这种方式定义函数指针 p = max; //函数指针初始化 int ret = p(10, 15); //函数指针的调用 //int ret = (*max)(10,15); //int ret = (*p)(10,15); //以上两种写法与第一种写法是等价的，不过建议使用第一种方式 printf("max = %d \n", ret); return 0;&#125; ​ 上面这个函数的功能也十分简单，就是求两个数中较大的一个数。值得注意的是通过函数指针调用的方式。​ 首先代码里提供了3种函数指针定义的方式，这三种方式都是正确的，比较推荐第一种和第三种定义方式。然后对函数指针进行初始化，前面已经提到过了，直接将函数名赋值给函数指针变量名即可。​ 上述代码运行的结果如下： 123[root@hly_centos learn]# gcc -o func_point func_point.c [root@hly_centos learn]# ./func_point max = 15 ​ 调用的时候，既可以直接使用函数指针调用，也可以通过函数指针所指向的值去调用。(*p)所代表的就是函数指针所指向的值，也就是函数本身，这样调用自然不会有问题。​ 为什么要使用函数指针？ ​ 那么，有不少人就觉得，本来很简单的函数调用，搞那么复杂干什么？其实在这样比较简单的代码实现中不容易看出来，当项目比较大，代码变得复杂了以后，函数指针就体现出了其优越性。​ 举个例子，如果我们要实现数组的排序，我们知道，常用的数组排序方法有很多种，比如快排，插入排序，冒泡排序，选择排序等，如果不管内部实现，你会发现，除了函数名不一样之外，返回值，包括函数入参都是相同的，这时候如果要调用不同的排序方法，就可以使用指针函数来实现，我们只需要修改函数指针初始化的地方，而不需要去修改每个调用的地方（特别是当调用特别频繁的时候）。 回调函数​ 函数指针的一个非常典型的应用就是回调函数。​ 什么是回调函数？​ 回调函数就是一个通过指针函数调用的函数。其将函数指针作为一个参数，传递给另一个函数。​ 回调函数并不是由实现方直接调用，而是在特定的事件或条件发生时由另外一方来调用的。同样我们来看一个回调函数的例子： 1234567891011121314151617181920212223242526272829303132333435文件：callback.c#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//函数功能：实现累加求和int func_sum(int n)&#123; int sum = 0; if (n &lt; 0) &#123; printf("n must be &gt; 0\n"); exit(-1); &#125; for (int i = 0; i &lt; n; i++) &#123; sum += i; &#125; return sum;&#125;//这个函数是回调函数，其中第二个参数为一个函数指针，通过该函数指针来调用求和函数，并把结果返回给主调函数int callback(int n, int (*p)(int))&#123; return p(n);&#125;int main(void)&#123; int n = 0; printf("please input number:"); scanf("%d", &amp;n); printf("the sum from 0 to %d is %d\n", n, callback(n, func_sum)); //此处直接调用回调函数，而不是直接调用func_sum函数 return 0;&#125; ​ 上面这个简单的demo就是一个比较典型的回调函数的例子。在这个程序中，回调函数callback无需关心func_sum是怎么实现的，只需要去调用即可。 ​ 这样的好处就是，如果以后对求和函数有优化，比如新写了个func_sum2函数的实现，我们只需要在调用回调函数的地方将函数指针指向func_sum2即可，而无需去修改callback函数内部。​ 以上代码的输出结果如下： 1234[root@hly_centos learn]# gcc -o call_back call_back.c [root@hly_centos learn]# ./call_back please input number:10the sum from 0 to 10 is 45 ​ 回调函数广泛用于开发场景中，比如信号函数、线程函数等，都使用到了回调函数的知识。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
</search>
