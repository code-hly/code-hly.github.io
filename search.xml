<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ceph部署难题</title>
      <link href="/2019/05/08/ceph-%E9%83%A8%E7%BD%B2%E9%9A%BE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/05/08/ceph-%E9%83%A8%E7%BD%B2%E9%9A%BE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本章总结了搭建ceph集群过程中遇到的各种问题，以及相应的原理过程</p><a id="more"></a><h3 id="Q1-环境预准备"><a href="#Q1-环境预准备" class="headerlink" title="Q1. 环境预准备**"></a>Q1. 环境预准备**</h3><p>​        绝大多数MON创建的失败都是由于防火墙没有关导致的，亦或是SeLinux没关闭导致的。一定一定一定要关闭每个每个每个节点的防火墙(执行一次就好，没安装报错就忽视)：</p><p><strong>CentOS</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/SELINUX=.*/SELINUX=disabled/'</span> /etc/selinux/config</span><br><span class="line">setenforce <span class="number">0</span></span><br><span class="line">systemctl stop firewalld </span><br><span class="line">systemctl disable firewalld</span><br><span class="line"># iptables -F</span><br><span class="line">service iptables stop</span><br></pre></td></tr></table></figure><h3 id="Q2-清理环境"><a href="#Q2-清理环境" class="headerlink" title="Q2. 清理环境"></a><strong>Q2. 清理环境</strong></h3><p>​        MON部署不上的第二大问题就是在旧的节点部署MON，或者在这个节点部署MON失败了，然后重新<code>new</code>再<code>mon create-initial</code>，请查看要部署MON的节点上的<code>/var/lib/ceph/mon/</code>目录下是否为空，如果不为空，说明已经在这个目录部署过MON，再次部署会检测子目录下的<code>done</code>文件，由于有了这个文件，就不会再建立新的MON数据库，并且不会覆盖之，导致了部署时的各种异常，这里就不赘述了，直接给出万能清理大法：</p><p><strong>对于任何需要新部署MON的节点，请到这个节点下执行如下指令，确保环境已经清理干净：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep ceph |awk <span class="string">'&#123;print $2&#125;'</span>|xargs kill <span class="number">-9</span></span><br><span class="line">ps -ef|grep ceph</span><br><span class="line">#确保此时所有ceph进程都已经关闭！！！如果没有关闭，多执行几次。</span><br><span class="line">rm -rf /<span class="keyword">var</span>/lib/ceph/mon<span class="comment">/*</span></span><br><span class="line"><span class="comment">rm -rf /var/lib/ceph/bootstrap-mds/*</span></span><br><span class="line"><span class="comment">rm -rf /var/lib/ceph/bootstrap-osd/*</span></span><br><span class="line"><span class="comment">rm -rf /var/lib/ceph/bootstrap-rgw/*</span></span><br><span class="line"><span class="comment">rm -rf /etc/ceph/*</span></span><br><span class="line"><span class="comment">rm -rf /var/run/ceph/*</span></span><br></pre></td></tr></table></figure><p>请直接复制粘贴，遇到过好些个自己打错打漏删了目录的。</p><h3 id="Q3-部署前最后的确认"><a href="#Q3-部署前最后的确认" class="headerlink" title="Q3. 部署前最后的确认"></a><strong>Q3. 部署前最后的确认</strong></h3><p>这里介绍的都是个案，不过还是需要提一下：</p><ul><li>确保每个节点的<code>hostname</code>都设置正确，并且添加至<code>/etc/hosts</code>文件中，然后同步到所有节点下。克隆出来的虚拟机或者批量建的虚拟机有可能发生此情形。</li><li>确保以下目录在各个节点都存在：</li><li><code>/var/lib/ceph/</code></li><li><code>/var/lib/ceph/mon/</code></li><li><code>/var/lib/ceph/osd/</code></li><li><code>/etc/ceph/</code></li><li><code>/var/run/ceph/</code></li><li>上面的目录，如果Ceph版本大于等于<code>jewel</code>,请确认权限均为<code>ceph:ceph</code>，如果是<code>root:root</code>，请自行<code>chown</code>。</li></ul><h3 id="Q4-安装Ceph"><a href="#Q4-安装Ceph" class="headerlink" title="Q4. 安装Ceph"></a><strong>Q4. 安装Ceph</strong></h3><p>​        官网指导方法是使用<code>ceph-deploy install nodeX</code>,但是因为是国外的源，速度慢得令人发指，所以我们换到阿里的源，并且使用<code>yum install</code>的方式安装，没差啦其实，这样反而还快点，毕竟多个节点一起装。</p><p><strong>很多安装失败的都是因为没有添加epel源请在每个存储节点都执行以下指令，来安装Ceph:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">rm -rf /etc/yum.repos.d<span class="comment">/*.repo</span></span><br><span class="line"><span class="comment">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"><span class="comment">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span></span><br><span class="line"><span class="comment">sed -i '/aliyuncs/d' /etc/yum.repos.d/CentOS-Base.repo</span></span><br><span class="line"><span class="comment">sed -i '/aliyuncs/d' /etc/yum.repos.d/epel.repo</span></span><br><span class="line"><span class="comment">sed -i 's/$releasever/7.2.1511/g' /etc/yum.repos.d/CentOS-Base.repo</span></span><br><span class="line"><span class="comment">echo "</span></span><br><span class="line"><span class="comment">[ceph]</span></span><br><span class="line"><span class="comment">name=ceph</span></span><br><span class="line"><span class="comment">baseurl=http://mirrors.aliyun.com/ceph/rpm-hammer/el7/x86_64/</span></span><br><span class="line"><span class="comment">gpgcheck=0</span></span><br><span class="line"><span class="comment">[ceph-noarch]</span></span><br><span class="line"><span class="comment">name=cephnoarch</span></span><br><span class="line"><span class="comment">baseurl=http://mirrors.aliyun.com/ceph/rpm-hammer/el7/noarch/</span></span><br><span class="line"><span class="comment">gpgcheck=0</span></span><br><span class="line"><span class="comment">" &gt; /etc/yum.repos.d/ceph.repo</span></span><br><span class="line"><span class="comment">yum install ceph ceph-radosgw -y</span></span><br></pre></td></tr></table></figure><p>这里是安装的<code>hammer</code>版本的Ceph，如果需要安装<code>jewel</code>版本的，请执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/hammer/jewel/'</span> /etc/yum.repos.d/ceph.repo</span><br><span class="line">yum install ceph ceph-radosgw -y</span><br></pre></td></tr></table></figure><p>如果安装了<code>jewel</code>版本的Ceph，想要换回<code>hammer</code>版本的Ceph，可以执行下面的指令：</p><p><strong>卸载Ceph客户端</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa |grep <span class="string">`ceph -v |awk '&#123;print $3&#125;'`</span> |xargs rpm -e --nodeps</span><br></pre></td></tr></table></figure><p><strong>更改ceph.repo里面的Ceph版本</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/jewel/hammer/'</span> /etc/yum.repos.d/ceph.repo</span><br><span class="line">yum install ceph ceph-radosgw -y</span><br></pre></td></tr></table></figure><h3 id="Q5-ceph-deploy"><a href="#Q5-ceph-deploy" class="headerlink" title="Q5. ceph-deploy"></a><strong>Q5. ceph-deploy</strong></h3><p>这里我要开启话唠模式：</p><p><strong>① Ceph-deploy 是什么？</strong></p><p>​        Ceph-deploy是Ceph官方给出的用于<strong>部署Ceph</strong>的一个工具，这个工具几乎全部是Python写的脚本，其代码位于<code>/usr/lib/python2.7/site-packages/ceph_deploy</code>目录下(<code>1.5.36</code>版本)。最主要的功能就是用几个简单的指令部署好一个集群，而不是手动部署操碎了心，敲错一个地方就可能失败。所以对于新人来说，或者说以我的经验，接触Ceph少于一个月的，又或者说，集群规模不上PB的，都没有必要手动部署，Ceph-deploy完全足够了。</p><p><strong>② Ceph-deploy怎么装?</strong></p><p>​        这个包在ceph的源里面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ceph-deploy -y</span><br></pre></td></tr></table></figure><p><strong>③Ceph-deploy装在哪？</strong></p><p>​        既然Ceph-deploy只是个部署Ceph的脚本工具而已，那么这个工具随便装在哪个节点都可以，<strong>并不需要单独为了装这个工具再搞个节点</strong>，我一般习惯放在第一个节点，以后好找部署目录。</p><p><strong>④Ceph-deploy怎么用？</strong></p><p>​        详细的指令暂时不介绍，下面会有，在安装好后，需要在这个节点新建一个目录，用作<code>部署目录</code>，这里是强烈建议建一个单独的目录的，比如我习惯在集群的第一个节点下建一个<code>/root/cluster</code>目录，为了以后好找。<strong>Ceph-deploy的所有的指令都需要在这个目录下执行</strong>。包括<code>new,mon,osd</code>等等一切ceph-deploy的指令都需要在这个部署目录下执行！最后一遍，所有的<code>ceph-deploy</code>的指令都要在部署目录下执行！否则就会报下面的错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ceph_deploy][ERROR ] ConfigError: Cannot load config: [Errno <span class="number">2</span>] No such file or directory: <span class="string">'ceph.conf'</span>; has ceph-deploy <span class="keyword">new</span> been run <span class="keyword">in</span> <span class="keyword">this</span> directory?</span><br></pre></td></tr></table></figure><p><strong>⑤ Ceph-deploy怎么部署集群?</strong></p><p>​        我们暂且把<strong>部署目录</strong>所在的节点叫做<strong>部署节点</strong>。Ceph-deploy通过SSH到各个节点，然后再在各个节点执行本机的Ceph指令来创建MON或者OSD等。所以在部署之前，你需要从<code>部署节点ssh-copy-id</code>到各个集群节点，使其可以免秘钥登陆。</p><p><strong>⑥Ceph-deploy部署的日志在哪里?</strong></p><p>​        就在部署目录下面的<code>ceph-deploy-ceph.log</code>文件，部署过程中产生的所有的日志都会保存在里面，比如你大半年前敲的创建OSD的指令。在哪个目录下执行ceph-deploy指令，就会在这个目录下生成log，如果你跑到别的目录下执行，就会在执行目录里生成log再记下第四点的错。当然，这个LOG最有用的地方还是里面记录的部署指令，你可以通过<code>cat ceph-deploy-ceph.log |grep &quot;Running command&quot;</code>查看到创建一个集群所需的所有指令，这对你手动建立集群或者创建秘钥等等等等有着很大的帮助！！！</p><p><strong>⑦ Ceph-deploy版本</strong></p><p>​        写这段时的最新的版本号为<code>1.5.36</code>，下载链接为ceph-deploy-1.5.36-0.noarch.rpm， 之前的<code>1.5.35</code>里面有点bug在这个版本被修复了，如果使用<code>1.5.25</code>部署遇到了问题，可以更新至这个版本，会绕过一些坑。更新到<code>1.5.36</code>之后，腰也不酸了,退了不疼了，Ceph也能部署上了。</p><h3 id="Q6-ceph-deploy-new-做了什么"><a href="#Q6-ceph-deploy-new-做了什么" class="headerlink" title="Q6. ceph-deploy new 做了什么"></a><strong>Q6. ceph-deploy new 做了什么</strong></h3><p>​        <strong>进入部署目录</strong>，执行<code>ceph-deploy new node1 node2 node3</code>，会生成两个文件（第三个是<code>ceph-deploy-ceph.log</code>，忽视之）:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@blog cluster]# ls</span><br><span class="line">ceph.conf  ceph-deploy-ceph.log  ceph.mon.keyring</span><br></pre></td></tr></table></figure><p>​        <code>new</code>后面跟的是你即将部署MON的节点的<code>hostname</code>，推荐三个就够了，需要是奇数个MON节点。不要因为只有两个节点就搞两个MON，两个节点请用一个MON，因为两个MON挂掉一个，集群也就挂了，和一个MON挂掉一个效果是一样的。生成的<code>ceph.conf</code>默认情况下长成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@blog cluster]# cat ceph.conf </span><br><span class="line">[global]</span><br><span class="line">fsid = <span class="number">13</span>b5d863<span class="number">-75</span>aa<span class="number">-479</span>d<span class="number">-84</span>ba<span class="number">-9e5</span>edd881ec9</span><br><span class="line">mon_initial_members = blog</span><br><span class="line">mon_host = <span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span></span><br><span class="line">auth_cluster_required = cephx</span><br><span class="line">auth_service_required = cephx</span><br><span class="line">auth_client_required = cephx</span><br></pre></td></tr></table></figure><p>​        会调用<code>uuidgen</code>生成一个<code>fsid</code>，用作集群的唯一ID，再将<code>new</code>后面的主机加入到<code>mon_initial_members</code>和<code>mon_host</code>里面，剩下的三行大家都是一样的，默认开启CephX认证。下面有一节会专门介绍这个，需要注意的是，<strong>部署的时候，千万不要动这三行</strong> 下面会有一节介绍之。还有一个文件<code>ceph.mon.keyring</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@blog cluster]# cat ceph.mon.keyring </span><br><span class="line">[mon.]</span><br><span class="line">key = AQB1yWRYAAAAABAAhMoAcadfCdy9VtAaY79+Sw==</span><br><span class="line">caps mon = allow *</span><br></pre></td></tr></table></figure><p>​        除了<code>key</code>的内容不一样，剩下的都会是一样的。因为是开启了CephX认证了，所以MON直接的通讯是需要一个秘钥的，<code>key</code>的内容就是秘钥。是不是对Ceph里面的明文认证感到吃惊，有总比没有强。如果，你再次执行<code>new</code>，会生成新的<code>ceph.conf</code>和新的<code>ceph.mon.keyring</code>，并将之前的这两个文件给覆盖掉，新旧文件唯一不同的就是<code>fsid</code>和<code>key</code>的内容，但是对Ceph来说，这就是两个集群了。这里说一下我个人非常非常非常反感的一个问题，有的朋友喜欢在<code>/etc/ceph/</code>目录下面执行ceph-deploy的命令，这么做和在<strong>部署目录</strong>下面做一般是没有差别的，因为这两个目录下面都有<code>ceph.conf</code>和<code>ceph.client.admin.keyring</code>，但是我还是强烈推荐创建独立的<strong>部署目录</strong>，因为<code>/etc/ceph</code>目录是Ceph节点的运行目录，为了体现各自的功能性，也为了安全性，<strong>请不要在</strong><code>**/etc/ceph**</code><strong>目录下部署集群！！！</strong></p><h3 id="Q7-为ceph-deploy添加参数"><a href="#Q7-为ceph-deploy添加参数" class="headerlink" title="Q7. 为ceph-deploy添加参数"></a><strong>Q7. 为ceph-deploy添加参数</strong></h3><p>​        Ceph-deploy的log还是很有看头的，查看<code>ceph-deploy new blog</code>(blog是我的一台主机)的log：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@blog cluster]# ceph-deploy new blog</span><br><span class="line">[ceph_deploy.conf][DEBUG ] found configuration file at: <span class="regexp">/root/</span>.cephdeploy.conf</span><br><span class="line">[ceph_deploy.cli][INFO  ] Invoked (<span class="number">1.5</span><span class="number">.36</span>): <span class="regexp">/usr/</span>bin/ceph-deploy <span class="keyword">new</span> blog</span><br><span class="line">[ceph_deploy.cli][INFO  ] ceph-deploy options:</span><br><span class="line">[ceph_deploy.cli][INFO  ]  username                      : None</span><br><span class="line">[ceph_deploy.cli][INFO  ]  func                          : <span class="xml"><span class="tag">&lt;<span class="name">function</span> <span class="attr">new</span> <span class="attr">at</span> <span class="attr">0x288e2a8</span>&gt;</span></span></span><br><span class="line"><span class="xml">[ceph_deploy.cli][INFO  ]  verbose                       : False</span></span><br><span class="line"><span class="xml">[ceph_deploy.cli][INFO  ]  overwrite_conf                : False</span></span><br><span class="line"><span class="xml">[ceph_deploy.cli][INFO  ]  quiet                         : False</span></span><br><span class="line">[ceph_deploy.cli][INFO  ]  cd_conf                       : &lt;ceph_deploy.conf.cephdeploy.Conf instance at 0x28eccf8&gt;</span><br><span class="line">[ceph_deploy.cli][INFO  ]  cluster                       : ceph</span><br><span class="line">[ceph_deploy.cli][INFO  ]  ssh_copykey                   : True</span><br><span class="line">[ceph_deploy.cli][INFO  ]  mon                           : ['blog']</span><br><span class="line">[ceph_deploy.cli][INFO  ]  public_network                : None</span><br><span class="line">[ceph_deploy.cli][INFO  ]  ceph_conf                     : None</span><br><span class="line">[ceph_deploy.cli][INFO  ]  cluster_network               : None</span><br><span class="line">[ceph_deploy.cli][INFO  ]  default_release               : False</span><br><span class="line">[ceph_deploy.cli][INFO  ]   fsid                          : None</span><br><span class="line">[ceph_deploy.new][DEBUG ] Creating new cluster named ceph</span><br></pre></td></tr></table></figure><p>​        可以看到有很多的参数被列出来了，比如：<code>mon : [&#39;blog&#39;]</code>，也有很多参数是False或者None， 这些参数能否被设置呢? 因为这里我们可以看到有<code>fsid : None</code> 这个参数，难道集群的<code>fsid</code>可以被指定吗？抱着这些疑惑，我就去看完了ceph-deploy的所有代码，答案是：可以设置。所有上面的参数都可以使用参数的形式进行设置，只需要在前面加上两个<code>--</code>，比如对于<code>fsid</code>可以执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy  <span class="keyword">new</span> blog --fsid xx-xx-xx-xxxx</span><br></pre></td></tr></table></figure><p>​        如果想要查看每个执行可指定的参数，可以<code>-h</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@blog cluster]# ceph-deploy new -h</span><br><span class="line">usage: ceph-deploy <span class="keyword">new</span> [-h] [--no-ssh-copykey] [--fsid FSID]</span><br><span class="line">                      [--cluster-network CLUSTER_NETWORK]</span><br><span class="line">                      [--public-network PUBLIC_NETWORK]</span><br><span class="line">                      MON [MON ...]</span><br><span class="line">...</span><br><span class="line">optional <span class="built_in">arguments</span>:</span><br><span class="line">  -h, --help            show <span class="keyword">this</span> help message and exit</span><br><span class="line">  --no-ssh-copykey      <span class="keyword">do</span> not attempt to copy SSH keys</span><br><span class="line">  --fsid FSID           provide an alternate FSID <span class="keyword">for</span> ceph.conf generation</span><br><span class="line">  --cluster-network CLUSTER_NETWORK</span><br><span class="line">                        specify the (internal) cluster network</span><br><span class="line">  --public-network PUBLIC_NETWORK</span><br><span class="line">                        specify the public network <span class="keyword">for</span> a cluster</span><br></pre></td></tr></table></figure><p>​        这里就可以看到可以指定<code>--cluster-network</code>，<code>--public-network</code>，等等，如果<code>optional arguments</code>里面没有介绍这个参数，可以直接使用<code>--xxarg</code>的方式指定，比如<code>--overwrite-conf</code>，<code>--verbose</code>等等，能不能设置这些参数，自己动手试一下就知道了。需要注意的是，参数的位置根据指令而异，比如<code>--overwrite-conf</code>参数是跟在<code>ceph-deploy</code>后面的，而<code>--public-network</code>是跟在<code>new</code>后面的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy --overwrite-conf --verbose <span class="keyword">new</span> blog --fsid a-a-a-a</span><br><span class="line">[root@blog cluster]# cat ceph.conf |grep fsid</span><br><span class="line">fsid = a-a-a-a</span><br></pre></td></tr></table></figure><h3 id="Q8-Public-VS-Cluster"><a href="#Q8-Public-VS-Cluster" class="headerlink" title="Q8. Public VS Cluster"></a><strong>Q8. Public VS Cluster</strong></h3><p>​        如果非要在刚刚生成的ceph.conf里面添加什么的话，那么可能就要加public_network或者cluster_network了。那么这两个配置项有什么用呢？这里简单得介绍下Ceph的Public(外网或者叫公网或者前端网)和Cluster(内网或者叫集群网或者叫后端网)这两个网络，在Ceph中，存在以下三种主要的网络通讯关系：</p><ul><li>client-&gt; mon =&gt;public : 也就是客户端获取集群状态，或者叫客户端与MON通讯走的网络，是走的外网。</li><li>client-&gt; osd =&gt; public : 也就是客户端向OSD直接写入数据走的也是外网。</li><li>osd<-> osd =&gt; cluster ：也就是OSD之间的数据克隆，恢复走的是内网，客户端写第一份数据时通过外网写，对于三副本剩下的两个副本OSD之间通过内网完成数据复制。当OSD挂掉之后产生的recover,走的也是内网。</-></li></ul><p>通常，我们会将外网配置为千兆网，而内网配置成万兆网，这是有一定原因的：</p><ul><li>客户端可能由成百上千的计算节点组成，外网配成万兆成本太高。</li><li>存储节点一般只有几个到几十个节点，配置了万兆内网可以大大加快故障恢复速度，而且剩余的两副本写速度会大大加快，万兆网的性价比极高。举个例子，集群坏掉一个OSD千兆需要一小时，那么万兆网只需要五六分钟，一定程度上增加了集群的安全性。</li></ul><p>借用官网的这张图来说明集群的网络走势：再假设你的节点有两个网段172.23.0.1和3.3.4.1，还记得我们上一节<code>ceph-deploy new</code>的时候是可以指定<code>public_network</code>和<code>cluster_network</code>的吗！如果不指定这两个参数，那么ceph-deploy怎么知道用哪个IP作为这个节点的<code>mon_host</code>的IP呢，其实他是随便选的，如果它选了172网段但是你想使用3.3网段作为这个节点的<code>mon_host</code>的IP，那么只需要指定<code>--public-network 172.23.0.0/24</code> 就可以了，其中的<code>/24</code>就相当于一个掩码，表示前面的IP的前24位，也就是<code>172.23.0.XXX</code>，只要你的主机上有一个处于这个范围内的IP，那么就会选择这个IP作为公网IP。类似的，<code>/16</code>表示范围：<code>172.23.XXX.XXX</code>。 如果想指定内网IP，那么只要指定<code>--cluster-network 3.3.4.1/24</code>就可以了。</p><p>​        <strong>一般情况下，会在new生成的ceph.conf文件里加入public_network配置项以指定公网IP。当然你的MON主机上需要有至少一个IP在公网范围内。</strong>除了在生成的<code>ceph.conf</code>文件中加入公网IP的方式，我们还可以使用参数的方式来指定公网IP：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-1 cluster]# ceph-deploy new ceph-1 --public-network 172.23.0.0/24</span><br><span class="line">[ceph_deploy.cli][INFO  ] Invoked (<span class="number">1.5</span><span class="number">.36</span>): <span class="regexp">/usr/</span>bin/ceph-deploy <span class="keyword">new</span> ceph<span class="number">-1</span> --public-network <span class="number">172.23</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">24</span></span><br><span class="line">[ceph_deploy.cli][INFO  ] ceph-deploy options:</span><br><span class="line">...</span><br><span class="line">[ceph_deploy.cli][INFO  ]  public_network                : <span class="number">172.23</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">24</span></span><br><span class="line">...</span><br><span class="line">[ceph<span class="number">-1</span>][DEBUG ] IP addresses found: [u<span class="string">'172.23.0.101'</span>, u<span class="string">'10.0.2.15'</span>]</span><br><span class="line">[ceph_deploy.new][DEBUG ] Resolving host ceph<span class="number">-1</span></span><br><span class="line">[ceph_deploy.new][DEBUG ] Monitor ceph<span class="number">-1</span> at <span class="number">172.23</span><span class="number">.0</span><span class="number">.101</span></span><br><span class="line">[ceph_deploy.new][DEBUG ] Monitor initial members are [<span class="string">'ceph-1'</span>]</span><br><span class="line">[ceph_deploy.new][DEBUG ] Monitor addrs are [u<span class="string">'172.23.0.101'</span>]</span><br><span class="line">[ceph_deploy.new][DEBUG ] Writing monitor keyring to ceph.mon.keyring...</span><br><span class="line">[ceph_deploy.new][DEBUG ] Writing initial config to ceph.conf...</span><br><span class="line">[root@ceph-1 cluster]# cat ceph.conf </span><br><span class="line">[global]</span><br><span class="line">fsid = d2a2bccc-b215<span class="number">-4</span>f3e<span class="number">-922</span>b-cf6019068e76</span><br><span class="line">public_network = <span class="number">172.23</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">24</span></span><br><span class="line">mon_initial_members = ceph<span class="number">-1</span></span><br><span class="line">mon_host = <span class="number">172.23</span><span class="number">.0</span><span class="number">.101</span></span><br><span class="line">auth_cluster_required = cephx</span><br><span class="line">auth_service_required = cephx</span><br><span class="line">auth_client_required = cephx</span><br></pre></td></tr></table></figure><p>​        查看部署log可以发现参数配置已经生效，而这个节点有两个IP，<code>public_nwtwork</code>这个参数限定了公网IP的搜索范围，生成的ceph.conf文件内也包含了<code>public_network</code>这个参数。</p><h3 id="Q9-参数是下划线还是空格分隔"><a href="#Q9-参数是下划线还是空格分隔" class="headerlink" title="Q9. 参数是下划线还是空格分隔"></a><strong>Q9. 参数是下划线还是空格分隔</strong></h3><p>​        这里只是简单的提一下这个小困惑，对于以下的两个参数书写方式，哪种会有问题呢：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public_network = <span class="number">172.23</span><span class="number">.0</span><span class="number">.1</span>/<span class="number">24</span></span><br><span class="line">public network = <span class="number">172.23</span><span class="number">.0</span><span class="number">.1</span>/<span class="number">24</span></span><br><span class="line">osd_journal_size = <span class="number">128</span></span><br><span class="line">osd journal size = <span class="number">128</span></span><br></pre></td></tr></table></figure><p>​        这两种参数的书写方式其实都是正确的，说到底是因为底层调用的是Python的<code>argparse</code>模块。这两种方式都是等效的，所以不需要担心。</p><h3 id="Q10-ceph-deploy-mon-create-initial如何一次性通过"><a href="#Q10-ceph-deploy-mon-create-initial如何一次性通过" class="headerlink" title="Q10. ceph-deploy mon create-initial如何一次性通过"></a><strong>Q10. ceph-deploy mon create-initial如何一次性通过</strong></h3><p>​        这一步坑哭了多少迫切加入Ceph世界的新人，看到的最多的就是5s，10s，10s, 15s，20s。。。然后报了错。再执行，再报错。所以这里给出以下的预检清单，如果被报错失败所烦恼，请认真执行各个子项，尤其是失败后要执行清理环境：</p><ol><li>请确保所有节点都安装了Ceph。</li><li>请确保所有节点的防火墙等都关闭了。参考<strong>环境预准备</strong>一节</li><li>请前往各个MON节点清理干净，不论你是否相信这个节点是干净的。参考<strong>清理环境</strong>一节。</li><li>请确保各个MON节点下存在以下目录，并且对于Jewel版本及之后的请确保目录权限为<code>ceph:ceph</code>。参考<strong>部署前最后的确认</strong>一节。</li><li>请在<code>ceph-deploy new</code>生成的<code>ceph.conf</code>内添加<code>public_network</code>配置项，参考<strong>Public VS Cluster</strong>一节。</li></ol><p>这些总结来之不易，我帮过上百个人解决过部署问题和集群故障。我相信在<strong>认真确认</strong>过之后是肯定可以通过的(反正前三点如果有问题一般是不会建好MON的，为什么不认真确认下呢)，我遇到过绝大多数都是因为防火墙没关，或者手动删除了一些目录，或者没有修改权限导致的问题。</p><p>​        相对来说，新环境只要关了防火墙就可以一次性通过，旧环境或者失败的环境只要清理环境就可以通过了。</p><p><strong>Q11. mon create-initial 做了什么</strong></p><p>简单介绍下流程：</p><ul><li><p>ceph-deploy读取配置文件中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mon_initial_members</span><br></pre></td></tr></table></figure><p>的各个主机，然后依次SSH前往各个主机：</p><ol><li>将<strong>部署目录</strong>下的ceph.conf推送到新节点的<code>/etc/ceph/</code>目录下。</li><li>创建<code>/var/lib/ceph/mon/$cluster-$hostname/</code>目录。</li><li>检查MON目录下是否有<code>done</code>文件，如果有则直接跳到第6步。</li><li>将<code>ceph.mon.keyring</code>拷贝到新节点，并利用该秘钥在MON目录下建立MON数据库。</li><li>在MON目录下建立done文件，防止重新建立MON。</li><li>启动MON进程。</li><li>查看<code>/var/run/ceph/$cluster-mon.$hostname.asok</code>SOCKET文件，这个是由MON进程启动后生成的，输出MON状态。</li></ol></li><li><p>在所有的MON都建立好后，再次前往各个主机，查看所有主机是否运行并且到达法定人群(quorum)。如果有没到到的，直接结束报错。如果都到达了，执行下一步。</p></li><li><p>调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth get-or-create</span><br></pre></td></tr></table></figure><p>方法创建(如果不存在)或者拉取(已经存在)MON节点上的以下几个keyring到</p><p>部署目录</p><p>中：</p><ul><li><code>ceph.bootstrap-mds.keyring</code></li><li><code>ceph.bootstrap-osd.keyring</code></li><li><code>ceph.bootstrap-rgw.keyring</code></li><li><code>ceph.client.admin.keyring</code></li></ul></li><li><p>指令结束。</p></li></ul><h3 id="Q12-mon-create-initial-为什么会失败"><a href="#Q12-mon-create-initial-为什么会失败" class="headerlink" title="Q12. mon create-initial 为什么会失败"></a><strong>Q12. mon create-initial 为什么会失败</strong></h3><p>​        我不喜欢讲怎么做，我愿意花很大的篇幅介绍为什么会造成各种各样的问题，如果知道了原因，你自然知道该怎么做，所以才会理解Ceph，而不是机械的去敲指令。</p><p>综合上面的所有小节，我来总结下这一步失败的基本上所有可能的原因：</p><ul><li>所谓MON的quorum，相当于多个MON形成的一个群体，它们之间需要通过网络发送数据包来通讯达成某种协议，如果打开了防火墙，会阻断数据交流。所以不能构成群体，一直等待(5s-&gt;10s-&gt;10s-&gt;15s-&gt;20s)其他MON的数据包，既然被阻断了这样的等待是没有意义的，等了30s还没有正常，就可以直接<code>ctrl+z</code>去检查了。</li><li>我在配置文件里面添加了<code>pubilc_network</code>，但是有个主机的所有IP都不在公网IP段内，那么这个MON是建不好的，因为没有IP用作MON使用，<code>public_network</code>相当于一个<strong>过滤器</strong>。</li><li>搭好了一台虚拟机后，直接克隆了两台，没有修改主机名，导致socket文件路径名识别错误，报了异常，不过这很少发生。</li><li>如果在旧的MON节点上再次部署新的MON，再又没有清理环境，之前的MON数据库会保留着<code>done</code>文件，MON数据库里面还是记录着之前fsid，keyring等等，和新集群是两套完全不同的，所以这个节点的MON自然到达不了MON群体。</li><li>即使你单单删除了<code>/var/lib/ceph/mon</code>下的东西，而没有清理那些keyring，也有可能会因为收集了旧集群的秘钥而发生稀奇古怪的问题。</li><li>对于Jewel，你一不小心删除了<code>/var/lib/ceph/mon</code>目录，或者其他的OSD目录或者<code>/var/run/ceph</code>目录，然后又重建了目录，依然部署不上，是因为Jewel的所有Ceph指定都是运行在<code>ceph:ceph</code>用户下的，自然不能在root权限目录下建立任何文件，修改权限即可。</li><li>Ceph生成MON数据库是依照主机的<code>hostname</code>来命名至目录<code>/var/lib/ceph/mon/${cluster}-${hostname}</code>的，而检测SOCKET文件则是用<code>ceph.conf</code>里面的<code>mon_initial_members</code>里面的名字来检测的 ，如果<code>mon_initial_members</code>里面的名字和真是的主机名不一致，就会报错。</li></ul><p>​      一旦你运行了<code>ceph-deploy mon create-initial</code>指令，并且失败了，有极大的可能性已经在某些节点建立好了MON的数据库，再次执行可能会因为旧的环境导致再次失败，所以如果失败了，执行一下第二节中的<code>清理环境</code>即可。清理完毕后，再执行<code>ceph-deploy mon create-initial</code>。</p><h3 id="Q13-ceph-s-的全称以及报错原因"><a href="#Q13-ceph-s-的全称以及报错原因" class="headerlink" title="Q13. ceph -s 的全称以及报错原因**"></a>Q13. ceph -s 的全称以及报错原因**</h3><p>​        开开心心过了<code>mon create-initial</code>，这个时候执行<code>ceph -s</code>，如果你恰好在monitor节点执行，那就会显示正常的信息，但是如果你在别的节点执行<code>ceph -s</code>，很有可能会报下面的错，但是有的节点又不会，所以这里花一点篇幅介绍<code>ceph -s</code>到底是怎么工作的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@root cluster]# ceph -s</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-17</span> <span class="number">13</span>:<span class="number">47</span>:<span class="number">34.190226</span> <span class="number">7</span>f446ccde700 <span class="number">-1</span> auth: unable to find a keyring on /etc/ceph/ceph.client.admin.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin: (<span class="number">2</span>) No such file or directory</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-17</span> <span class="number">13</span>:<span class="number">47</span>:<span class="number">34.190393</span> <span class="number">7</span>f446ccde700 <span class="number">-1</span> monclient(hunting): ERROR: missing keyring, cannot use cephx <span class="keyword">for</span> authentication</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-17</span> <span class="number">13</span>:<span class="number">47</span>:<span class="number">34.190443</span> <span class="number">7</span>f446ccde700  <span class="number">0</span> librados: client.admin initialization error (<span class="number">2</span>) No such file or directory</span><br></pre></td></tr></table></figure><p>​        首先，如果你要执行<code>ceph</code>开头的任何指令，你当然要安装好Ceph客户端！（<code>yum install ceph</code>）而<code>ceph -s</code>的全称是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ceph \</span><br><span class="line">--name client.admin \</span><br><span class="line">--keyring /etc/ceph/ceph.client.admin.keyring \</span><br><span class="line">--conf /etc/ceph/ceph.conf</span><br><span class="line">--cluster ceph \</span><br><span class="line">-s</span><br></pre></td></tr></table></figure><p>​        上面两个参数很好理解，Ceph内部自身使用<code>CephX</code>进行认证，和普通的认证没什么区别，同样需要用户名和密码进行认证，那么这里默认的用户名就叫做<code>client.admin</code>，而默认的秘钥保存位置就位于以下几个位置任一：</p><ul><li>/etc/ceph/ceph.client.admin.keyring</li><li>/etc/ceph/ceph.keyring</li><li>/etc/ceph/keyring</li><li>/etc/ceph/keyring.bin</li></ul><p>一般我们选择第一个，因为秘钥的命名规则采用<code>/etc/ceph/$cluster.$name.keyring</code>也就是集群名加上用户名再加上keyring的后缀组成。所以在我们执行<code>ceph -s</code>的时候，默认使用的是<code>client.admin</code>用户，同时会去那四个默认位置搜索该用户的秘钥，如果和集群保存的认证信息一致，那么就会显示出集群的状态。如果在那四个位置下面无法找到秘钥文件，就会报上面的<code>unable to find a keyring</code>这样的错误，解决方法后面再说。如果这个位置下面的秘钥文件保存了错误的秘钥值，就会报下面的错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-17</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">07.625018</span> <span class="number">7</span>f8757577700  <span class="number">0</span> librados: client.admin authentication error (<span class="number">1</span>) Operation not permitted</span><br><span class="line"><span class="built_in">Error</span> connecting to cluster: PermissionError</span><br></pre></td></tr></table></figure><p>​        翻译过来很简单，就是认证不通过，就好比你使用了错误的密码，去登陆系统不通过一样。这可能是由于这个节点保存了旧的集群的秘钥信息导致的。</p><p>​        那么正确的秘钥信息保存在哪里呢？还记得部署目录吗，在<code>mon create-initial</code>正确通过后，就会自动收集所有的秘钥，并保存在部署目录下面，眼疾手快的把部署目录的<code>ceph.client.admin.keyring</code>拷贝到<code>/etc/ceph</code>下面就会发现<code>ceph -s</code>正常显示了，不过，这不是<strong>授权</strong>的正确的姿势。</p><p>如果我们想要给一个节点admin权限，也就是执行所有Ceph指令的权限，我们可以前往部署目录，然后调用下面的指令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy admin xxNode</span><br></pre></td></tr></table></figure><p>​        这样就会把部署目录下的<code>ceph.client.admin.keyring</code>和<code>ceph.conf</code>拷贝到xxNode的<code>/etc/ceph</code>目录下，并覆盖掉原先的秘钥文件，虽然实际上也就是scp了这两个文件，但是管理Ceph遵循一定的规则是一个很好的习惯。所以，想要得到<code>ceph -s</code>的正确输出，你需要确认在<code>/etc/ceph</code>目录下有<code>ceph.conf</code>和<code>ceph.client.admin.keyring</code>这两个文件，并且和集群认证信息相同即可。如果认证失败，可以前往部署目录<strong>授权</strong>该节点。</p><h3 id="Q14-ceph-s-卡住了"><a href="#Q14-ceph-s-卡住了" class="headerlink" title="Q14. ceph -s 卡住了"></a><strong>Q14. ceph -s 卡住了</strong></h3><p>简单介绍下<code>ceph -s</code>的流程:</p><ul><li>每当你敲下一个Ceph指令时，相当于建立了一个Ceph的客户端进程去连接集群。</li><li>连接集群需要知道MON的IP地址，这个地址从<code>/etc/ceph/ceph.conf</code>里面的<code>mon_host</code>读取。</li><li>有了IP客户端就拿着自己用户名和秘钥向MON进行认证，认证通过执行指令返回输出。</li></ul><p>如果你只有一个MON，然后这个MON挂掉了，那么执行指令会返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@blog ceph]# ceph -s</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-19</span> <span class="number">17</span>:<span class="number">49</span>:<span class="number">45.437748</span> <span class="number">7</span>f02f44e1700  <span class="number">0</span> -- :<span class="regexp">/1314350745 &gt;&gt; 139.224.0.251:6789/</span><span class="number">0</span> pipe(<span class="number">0x7f02f0063e80</span> sd=<span class="number">3</span> :<span class="number">0</span> s=<span class="number">1</span> pgs=<span class="number">0</span> cs=<span class="number">0</span> l=<span class="number">1</span> c=<span class="number">0x7f02f005c4f0</span>).fault</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-19</span> <span class="number">17</span>:<span class="number">49</span>:<span class="number">48.442946</span> <span class="number">7</span>f02f43e0700  <span class="number">0</span> -- :<span class="regexp">/1314350745 &gt;&gt; 139.224.0.251:6789/</span><span class="number">0</span> pipe(<span class="number">0x7f02e4000c80</span> sd=<span class="number">3</span> :<span class="number">0</span> s=<span class="number">1</span> pgs=<span class="number">0</span> cs=<span class="number">0</span> l=<span class="number">1</span> c=<span class="number">0x7f02e4001f90</span>).fault</span><br></pre></td></tr></table></figure><p><strong>Tips: MON的端口号为6789，所以一般看到IP:6789时，就可以判断这个IP的MON可能挂了，或者MON的防火墙开开了。</strong>上面的报错还好处理， 前往MON节点，检查<code>ceph-mon</code>进程是否正常运行，正确启动MON进程就可以了。</p><p>​        如果你有两个MON，挂了一个，指令会返回和上面一样的信息，所以，两个MON只能坏一个，一般MON个数都是<strong>奇数个</strong>。如果你有三个MON，挂了一个，那么会返回下面信息，集群还是会有输出的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@st001 ~]# ceph -s</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-19</span> <span class="number">17</span>:<span class="number">59</span>:<span class="number">40.753370</span> <span class="number">7</span>f72ac31c700  <span class="number">0</span> -- :<span class="regexp">/4173548806 &gt;&gt; 10.8.0.101:6789/</span><span class="number">0</span> pipe(<span class="number">0x7f72a805e9d0</span> sd=<span class="number">3</span> :<span class="number">0</span> s=<span class="number">1</span> pgs=<span class="number">0</span> cs=<span class="number">0</span> l=<span class="number">1</span> c=<span class="number">0x7f72a805fce0</span>).fault</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-19</span> <span class="number">17</span>:<span class="number">59</span>:<span class="number">49.754198</span> <span class="number">7</span>f72ac21b700  <span class="number">0</span> -- <span class="number">10.8</span><span class="number">.0</span><span class="number">.101</span>:<span class="number">0</span>/<span class="number">4173548806</span> &gt;&gt; <span class="number">10.8</span><span class="number">.0</span><span class="number">.101</span>:<span class="number">6789</span>/<span class="number">0</span> pipe(<span class="number">0x7f729c000b90</span> sd=<span class="number">4</span> :<span class="number">0</span> s=<span class="number">1</span> pgs=<span class="number">0</span> cs=<span class="number">0</span> l=<span class="number">1</span> c=<span class="number">0x7f729c0041e0</span>).fault</span><br><span class="line">    cluster <span class="number">810</span>eaecb<span class="number">-2</span>b15<span class="number">-4</span>a97<span class="number">-84</span>ad<span class="number">-7340e6</span>cbe969</span><br><span class="line">    health HEALTH_WARN</span><br><span class="line">            <span class="number">1</span> mons down, quorum <span class="number">1</span>,<span class="number">2</span> st002,st003</span><br><span class="line">    monmap e1: <span class="number">3</span> mons at &#123;st001=<span class="number">10.8</span><span class="number">.0</span><span class="number">.101</span>:<span class="number">6789</span>/<span class="number">0</span>,st002=<span class="number">10.8</span><span class="number">.0</span><span class="number">.102</span>:<span class="number">6789</span>/<span class="number">0</span>,st003=<span class="number">10.8</span><span class="number">.0</span><span class="number">.103</span>:<span class="number">6789</span>/<span class="number">0</span>&#125;</span><br><span class="line">            election epoch <span class="number">18</span>, quorum <span class="number">1</span>,<span class="number">2</span> st002,st003</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>​        客户端会去连挂掉的MON，如果过一秒钟左右连不上，就会连接剩下的MON，剩下的还有两个在运行，就连到了运行中的MON，一切输出照旧，就是多了那个连不上的MON报错输出。</p><p>​        而<code>ceph -s</code>卡住有一种可能是：对于有三个MON的集群，挂掉了两个MON之后 ，手动去<code>/etc/ceph/ceph.conf</code>里面把挂掉的MON的IP给删除了， 只留下一个，这时候<code>ceph -s</code>的指令就会一直卡在那里，查看MON的log可以发现，那个活着的MON一直处于<code>probing</code>状态，这样的MON是不会给客户端返回信息的，所以会卡在那里。有一点需要知道的是，MON的删除比较复杂，不能仅仅通过修改配置文件里面的IP值修改MON，所以，这里正确的做法就是，将删除的IP加回去，然后<code>ceph -s</code>就会报出6789之类的错误，然后再去对应的IP的MON去启动MON服务。</p><p>​        那么一个集群能坏多少MON呢 ，简单的计算法法就是：</p><p>​        <strong>(mon个数 -1 )/ 2 取整数位</strong></p><p>​        也就是说三个能坏一个，两个和一个不能坏，四个坏一个，五个坏两个等等等。当你坏的MON个数大于可以坏的个数，那么所有的指令是不能返回的。</p><h3 id="Q15-Monitor-clock-skew-detected"><a href="#Q15-Monitor-clock-skew-detected" class="headerlink" title="Q15. Monitor clock skew detected"></a><strong>Q15. Monitor clock skew detected</strong></h3><p>​        如果你部署了多个monitor，比如三个MON，而这三个MON的时间不是严格相同的，那么就会报这个错，而Ceph需要MON节点之间的时间差在0.05秒之内，所以一般会选择配置一个内部的NTP server。剩余节点指向该Server节点。</p><p>​        千万一定不要小看了时间对其这个问题，如果各个节点时间不对其的话，有可能会导致某些OSD无法启动，而校准后，OSD立马就启动成功了，亦或导致OSD异常挂掉等等一系列的奇怪现象，十分不利于故障排查。</p><p>​        然而，简单的增加<code>mon_clock_drift_allowed</code>的时间偏移大小，是治标不治本的方法，并且OSD节点的时间偏移并不会报告在<code>ceph -s</code>里面，所以根本的节点方法还是配置NTP，具体方法请参考我之前写的配置NTP一段，这里就不重复了。</p><h3 id="Q16-CephX是什么，以及CephX的开启与关闭"><a href="#Q16-CephX是什么，以及CephX的开启与关闭" class="headerlink" title="Q16. CephX是什么，以及CephX的开启与关闭"></a><strong>Q16. CephX是什么，以及CephX的开启与关闭</strong></h3><p>在默认生成的<code>ceph.conf</code>里面有三行包含CephX的配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auth_cluster_required = cephx</span><br><span class="line">auth_service_required = cephx</span><br><span class="line">auth_client_required = cephx</span><br></pre></td></tr></table></figure><p>Ceph提供认证功能，想要连接集群，是需要提供用户名和密码的，这三个配置的值只有两种：</p><ul><li><code>cephx</code>: 开启CephX，即需要提供用户名和密码才能连接集群。</li><li><code>none</code>: 关闭CephX，即不需要提供，任何人都可以连接集群。</li></ul><p><strong>注意</strong>：如果关闭了CephX，那么任何一个客户端只要拥有了MON的IP和集群的fsid，就可以连接到集群中，然后执行所有的Ceph的指令，这是相当危险的，所以对于一个非局域网的集群，是需要开启的。</p><p>之所以写这一节，是因为见过好几个在部署集群时就关闭了CephX而遇到了奇怪的现象的情形，他们一般的操作步骤是：</p><ol><li><code>ceph-deploy new node1 node2 node3</code></li><li>将生成的<code>ceph.conf</code>中的三个<code>cephx</code>改成了<code>none</code></li><li><code>ceph-deploy mon create-initial</code> 这一步报错如下:</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ceph_deploy.mon][INFO  ] mon.blog monitor has reached quorum!</span><br><span class="line">[ceph_deploy.mon][INFO  ] all initial monitors are running and have formed quorum</span><br><span class="line">[ceph_deploy.mon][INFO  ] Running gatherkeys...</span><br><span class="line">.......</span><br><span class="line">[blog][DEBUG ] fetch remote file</span><br><span class="line">[ceph_deploy.gatherkeys][WARNIN] No mon key found <span class="keyword">in</span> host: blog</span><br><span class="line">[ceph_deploy.gatherkeys][ERROR ] Failed to connect to host:blog</span><br><span class="line">[ceph_deploy.gatherkeys][INFO  ] Destroy temp directory /tmp/tmpyGDe4r</span><br><span class="line">[ceph_deploy][ERROR ] RuntimeError: Failed to connect any mon</span><br></pre></td></tr></table></figure><p>​        先介绍下这里报错的原因，在Ceph中，除了需要使用Ceph的普通用户之外，Ceph的基本组件：MON，OSD，MDS再到RGW等都可以看做一个用户，而在使用<code>ceph-deploy</code>部署的时候，会默认为这些用户生成秘钥文件，在<code>ceph-deploy new</code>的时候，除了生成了<code>ceph.conf</code>，还生成了<code>ceph.mon.keyring</code>，顾名思义这个就是为MON用户生成的秘钥文件。查看该文件的内容可以看到如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mon.]</span><br><span class="line">key = AQCUXIRYAAAAABAAOi6Cxnvm+zFzd5gi+hrt+A==</span><br><span class="line">caps mon = allow *</span><br></pre></td></tr></table></figure><p>一个秘钥文件一般由三部分组成：</p><ul><li><code>[mon.]</code> ： 也就是用户名，在方括号里面的就是用户名，这里为<code>mon.</code>，注意是有个<strong>点号</strong>的。</li><li><code>key = AQCUXIRYAAAAABAAOi6Cxnvm+zFzd5gi+hrt+A==</code> : 顾名思义，这就是<code>mon.</code>用户的密码。</li><li><code>caps</code> ： 后面的就是权限，这里可以简单理解成，该用户可以对所有的MON进行所有操作。</li></ul><p>也就是说，Ceph中的Monitor也会像一个用户一样，拥有自己的用户名和秘钥以及操作MON的权限。简单理解了CephX之后，我们再来看上面修改了<code>none</code>之后报的错。</p><p>​        在<code>ceph-deploy mon create-initial</code>执行的时候，它会去读取<code>ceph.conf</code>里面的<code>auth_cluster_required</code>配置，当被修改为<code>none</code>之后， 就不会在创建MON的时候，为其生成对应的<code>keyring</code>，但是有一点要注意的是，尽管没有为MON生成秘钥文件，但是，MON是正确生成的，这时候执行<code>ceph -s</code>是可以得到集群状态的，说明MON已经正确建立。但是在所有的MON建立成功之后，<code>mon create-initial</code>指令内部会执行<code>gatherkeys</code>指令，这个指令会首先去MON的目录下面查找<code>/var/lib/ceph/mon/ceph-$HOSTNAME/keyring</code>文件，由于关闭了CephX，在创建MON的时候不会为其生成该文件，所以<code>gatherkeys</code>指令报错：<code>No mon key found in host: blog</code>。这里只要清理下MON环境然后开启CephX重新部署MON就可以通过了。所以在我们<strong>部署集群</strong>的时候，<strong>强烈建议开启CephX</strong>，这样除了可以正确通过<code>mon create-initial</code>，还可以在后续的添加OSD时，为每个OSD生成对应的秘钥。在<strong>集群部署完毕后</strong>，可以关闭CephX认证，具体方法如下：</p><ul><li>修改部署目录内<code>ceph.conf</code>的<code>cephx-&gt;none</code>,将配置推送到所有节点。</li><li>重启所有的MON和OSD。如果只重启MON，过一段时间(几个小时)，所有的OSD就会挂掉。。。</li></ul><p>在<code>ceph-deploy mon create-initial</code>正确通过之后，我们可以在部署目录下面看到多出了几个文件，都是以<code>keyring</code>结尾：</p><ul><li><code>ceph.client.admin.keyring</code>： 这个是超级用户<code>client.admin</code>的秘钥文件，查看其对应的权限，可以发现全部都是<code>allow *</code>，所以有了这个秘钥之后，相当于有了Linux系统的<code>root</code>用户，可以为所欲为了。</li><li><code>ceph.bootstrap-osd.keyring</code>: 类似的还有两个<code>mds</code>和<code>rgw</code>，<code>bootstrap</code>的意思是引导，查看其权限<code>mon = &quot;allow profile bootstrap-osd&quot;</code>，简单解释就是，这个用户可以用于创建OSD(or MDS or RGW)用户。也就是说，后续的OSD的用户的生成是由该用户引导生成的。</li></ul><p>最后再说一点，对于秘钥文件，其实我们只需要提供<code>key= xxxxxxxx</code>和用户名<code>[xxx]</code>就好了，不需要提供权限部分，因为权限已经在Ceph集群中保存了，秘钥文件说了不算的。具体权限可以通过<code>ceph auth list</code>来查看。</p><h3 id="Q17-–overwrite-conf参数"><a href="#Q17-–overwrite-conf参数" class="headerlink" title="Q17. –overwrite-conf参数"></a><strong>Q17. –overwrite-conf参数</strong></h3><p>这是个经常会遇到的问题，修改配置文件内的某些参数后，再执行<code>ceph-deploy</code>指令，会报如下的错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[blog][DEBUG ] write cluster configuration to /etc/ceph/&#123;cluster&#125;.conf</span><br><span class="line">[ceph_deploy.mon][ERROR ] RuntimeError: config file /etc/ceph/ceph.conf exists <span class="keyword">with</span> different content; use --overwrite-conf to overwrite</span><br><span class="line">[ceph_deploy][ERROR ] GenericError: Failed to create <span class="number">1</span> monitors</span><br></pre></td></tr></table></figure><p>​        报错信息提示得很明确，部署目录内的<code>ceph.conf</code>和集群的配置文件<code>/etc/ceph/ceph.conf</code>内容不一致，使用<code>--overwrite-conf</code>参数来覆盖集群的配置文件，也就是用部署目录的<code>ceph.conf</code>覆盖之。使用<code>ceph-deploy --overwrite-conf xxxCMD</code>来达到这一效果，当然，你也可以直接<code>cp</code>覆盖之。但是这不是一个好习惯。</p><p>正确的修改集群配置文件的姿势应该是：</p><ul><li>修改<strong>部署目录下的<code>ceph.conf</code></strong>。</li><li><code>ceph-deploy --overwrite-conf config push NodeA NodeB ... NodeZ</code>将部署目录下的配置文件推送到各个节点。</li><li><strong>强烈建议使用上面的方法</strong></li></ul><p>有的朋友可能喜欢直接去某个节点下的<code>/etc/ceph/ceph.conf</code>去改配置文件，这样有很多坏处：</p><ul><li>过了一周你可能忘了你改过这个节点的配置文件。</li><li>这个节点的配置和集群其他节点的配置不一样，会带来一些安全隐患。</li><li>如果再来一个不知情的同事，他使用了正确的姿势推送配置文件，你改过的参数很容易被覆盖掉。</li></ul><p>所以，从一开始，大家都使用同样的方式去修改集群的配置，是一个很好的习惯，对集群对同事有利无害。</p><p>​        如果你觉得可以接受这种推送配置的方式，但是又不喜欢每次都敲<code>--overwrite-conf</code>这么长的参数，你可以修改<code>~/.cephdeploy.conf</code>这个文件，增加一行<code>overwrite_conf = true</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy configuration file</span><br><span class="line">[ceph-deploy-global]</span><br><span class="line"># Overrides for some of ceph-deploy's global flags, like verbosity or cluster</span><br><span class="line"># name</span><br><span class="line">overwrite_conf = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>​        打开文件你就会发现，这个是<code>ceph-deploy</code>的配置文件，里面的配置项是对<code>ceph-deploy</code>生效的，在加了那一行之后，我们再去执行<code>ceph-deploy</code>的任何指令，都会默认带上了<code>--overwrite-conf</code>参数，这样就可以不打这个参数还能覆盖节点的配置文件。好处是少打了一些参数，坏处是你可能会不知不觉就覆盖了配置文件，各中利弊自行取舍。</p><p>​        <code>~/.cephdeploy.conf</code>这个文件的用处是很大的，可以为不同的<code>ceph-deploy xxxCMD</code>添加参数，刚刚添加在<code>[ceph-deploy-global]</code>下的参数对全局都会生效，如果你希望只对<code>xxxCMD</code>比如<code>new</code>，<code>osd</code>，<code>mon</code>指定对应的参数，可以添加<code>[ceph-deploy-xxxCMD]</code>域，同时在对应的域下添加对应的参数。</p><p>​        比如给<code>ceph-deploy osd 添加参数--zap-disk</code>，可以在<code>~/.cephdeploy.conf</code>中添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ceph-deploy-osd]</span><br><span class="line">zap_disk = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="Q18-PG卡在creating状态"><a href="#Q18-PG卡在creating状态" class="headerlink" title="Q18. PG卡在creating状态"></a><strong>Q18. PG卡在creating状态</strong></h3><p>​        这时候，Monitor已经建好了，可以执行<code>ceph -s</code>的指令了，然而我们看到集群的健康状态却是：<code>health HEALTH_ERR</code>。之所以是ERROR状态，是因为目前还没有建立OSD，PG处于creating状态，在建好了OSD之后，自然会解决这一问题。然而我要说的重点是<code>creating</code>这个状态的几个产生原因。</p><p>​        <code>creating</code>字面意思很好理解，正在创建，那么怎么理解PG正在创建呢？ 用最简单的方式解释PG就是： <strong>PG等于目录</strong>。如果我们使用磁盘做OSD的话，那么这个OSD上的PG就相当于，在这个磁盘上建立的目录。那么现在的问题就可以简化成，我们尚未添加任何磁盘，那么需要落盘的目录无处可建，所以就会长时间处于<code>creating</code>状态。在添加了一些OSD后，PG就可以建立了。</p><p>​        还有一种可能的原因是，刚入门的同学在配置文件中加了<code>osd_crush_update_on_start = false</code> 参数，这个参数的具体意义会有专门的小节介绍，这个参数的默认值是<code>true</code>，在使用这个参数后不论创建多少OSD，PG都依旧卡在<code>creating</code>状态。原因是所添加的OSD均不在默认的<code>root=default</code>根节点下。CRUSH在<code>default</code>下无法找到OSD，所以效果就和没有创建OSD一样，再解释就过于深入了，这里只简单介绍下解决方法：</p><ul><li>将部署目录里的<code>ceph.conf</code>的<code>osd_crush_update_on_start = false</code>去掉，或者将false改为true。</li><li>将配置文件推送到各个节点。</li><li>重启所有的OSD。</li></ul><p>这样OSD在启动时，就会自动加到对应的主机名下的host下方，并将主机名加到<code>default</code>下方。这样CRUSH就可以找到OSD了。当然，对于新入门的同学，一点建议就是，不知道意义的参数都不用加上，Ceph有自己一套默认参数，而这些参数不用修改就可以正常运行集群。如果添加了某些参数，最好知道其作用再使用。</p><h3 id="Q19-osd-crush-update-on-start-参数的使用和注意点"><a href="#Q19-osd-crush-update-on-start-参数的使用和注意点" class="headerlink" title="Q19. osd_crush_update_on_start 参数的使用和注意点"></a><strong>Q19. osd_crush_update_on_start 参数的使用和注意点</strong></h3><p>​        这是一个很有趣的参数，使用得当会省去很多事情，使用不当可能会造成灾难(亲身体验)。这个参数在<code>ceph --show-config</code>中并不能查询到，所以这并不是Ceph进程的一个配置项。实际上，这个配置相当于一个启动配置项。也就是说在OSD启动的时候会加载这个参数。由于Jewel将OSD的启动方式做了修改，所以针对Hammer及其之前和Jewel两种启动方式，分别在下面的两个文件使用到了这个参数，实际上，加载的方式还是一样的，只是启动文件有所变化：</p><ul><li>Hammer 及其之前 : <code>0.94.9 -&gt; /etc/init.d/ceph -&gt; line 370 -&gt; get_conf update_crush &quot;&quot; &quot;osd crush update on start&quot;</code></li><li>Jewel : <code>10.2.3 -&gt;/usr/lib/ceph/ceph-osd-prestart.sh -&gt; line 23 -&gt; update=&quot;$(ceph-conf --cluster=${cluster:-ceph} --name=osd.$id --lookup osd_crush_update_on_start || :)&quot;</code></li></ul><p>在OSD启动的时候，都会去配置文件中读取<code>osd_crush_update_on_start</code>。然后启动脚本根据是否存在以及配置值来决定是否将该OSD按照一定的方式(CRUSH位置，OSD的ID，OSD的weight)将这个OSD添加到CRUSH中。</p><p>​        简单点说，如果这个值为false，那么OSD在启动的时候不会去修改你的CRUSH树，也就是说OSD不会自动填加到对应的主机名下再自己添加到<code>root=default</code>下。</p><p>​        如果这个值为true，或者不添加该配置项(也就是说，默认为true)，OSD在启动时(任何一次启动)都会将自己添加到CRUSH树下。默认的位置为：<code>/usr/bin/ceph-crush-location -&gt; line 86 -&gt; host=$(hostname -s) root=default</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Ceph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建博客教程</title>
      <link href="/2019/05/08/hexo%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/05/08/hexo%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>​        现在越来越多的人喜欢利用Github搭建静态网站，原因不外乎简单省钱。本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。</p><a id="more"></a><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>下载<code>node.js</code>并安装（官网下载安装），默认会安装<code>npm</code>。</li><li>下载安装<code>git</code>（官网下载安装）</li><li>下载安装<code>hexo</code>。方法：打开<code>cmd</code> 运行<code>*npm install -g hexo</code>*（要翻墙） </li></ul><h3 id="本地搭建hexo静态博客"><a href="#本地搭建hexo静态博客" class="headerlink" title="本地搭建hexo静态博客"></a>本地搭建hexo静态博客</h3><ul><li>新建一个文件夹，如<code>MyBlog</code></li><li>进入该文件夹内，右击运行<code>git</code>，输入：<code>*hexo init</code>*（生成hexo模板，可能要翻墙）</li><li>生成完模板，运行<code>*npm install</code>*（目前貌似不用运行这一步）</li><li>最后运行：<em><code>hexo server</code></em> （运行程序，访问本地localhost:4000可以看到博客已经搭建成功）</li></ul><h3 id="创建一个新仓库"><a href="#创建一个新仓库" class="headerlink" title="创建一个新仓库"></a>创建一个新仓库</h3><p>​       新建一个名为你的<code>github用户名.github.io</code>的仓库，比如说，如果你的github用户名是code-hly(这个是我的用户名)，那么你就新建<code>code-hly.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="https://code-hly.github.io" target="_blank" rel="noopener">https://code-hly.github.io</a> 了，是不是很方便</p><p>​     由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库，所以访问的地址也是唯一的，方便github服务器管理。</p><h3 id="设置仓库的参数"><a href="#设置仓库的参数" class="headerlink" title="设置仓库的参数"></a>设置仓库的参数</h3><p>​       相信大多数人都知道，要想使用git命令来和github进行提交部署等操作，需要进行一些配置，大概就是下面一些命令，如不明白请自行搜索.  </p><ul><li>右键鼠标选择<code>git Base here</code>,输入如下命令：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email xxx@qq.com   </span><br><span class="line">git config --global user.name xxx  </span><br><span class="line">ssh-keygen -t rsa -C xxx@qq.com(邮箱地址)  <span class="comment">// 生成ssh</span></span><br></pre></td></tr></table></figure><p>​       <strong>注：<code>email</code>和<code>name</code>分别为注册<code>github</code>时的邮箱和用户名，生成ssh时会提示让你选择存储地址，可直接按enter下一步存储为默认地址。</strong></p><ul><li><p>找到<code>.ssh</code>文件夹，找到<code>id_rsa.pub</code>文件打开复制<code>SSH</code></p></li><li><p>登陆<code>github</code>，<code>settings</code>-&gt;<code>Deploy keys</code>-&gt;<code>add deploy key</code>（把复制的SSH添加进去即可）</p></li></ul><h3 id="将博客与Github关联"><a href="#将博客与Github关联" class="headerlink" title="将博客与Github关联"></a>将博客与<code>Github</code>关联</h3><ul><li>打开本地的<code>MyBlog</code>文件夹项目内的<code>_config.yml</code>配置文件，将其中的type设置为git</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:code-hly/code-hly.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><strong>repository为对应仓库的地址。注意仓库地址有两种形式。一种是<code>https</code>，一种是<code>SSH</code>。此处应该使用SSH形式的地址。</strong>   </p><ul><li>运行：<em><code>npm install hexo-deployer-git –save</code></em></li><li>运行：<em><code>hexo g</code></em>（本地生成静态文件）</li><li>运行：<em><code>hexo d</code></em>（将本地静态文件推送至Github）</li></ul><p>此时，打开浏览器，访问<em><a href="https://code-hly.github.io" target="_blank" rel="noopener">https://code-hly.github.io</a></em></p><h4 id="可能问题"><a href="#可能问题" class="headerlink" title="可能问题"></a>可能问题</h4><blockquote><p>错误提示：FATAL bad indentation of a mapping entry at line 72, column 7:</p></blockquote><p>可以hexo g 但是不可以hexo d<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">错误提示：</span><br><span class="line">You should configure deployment settings in _config.yml first!</span><br><span class="line">Available deployer plugins:</span><br><span class="line">  git</span><br><span class="line">For more help, you can check the online docs: http://hexo.io/</span><br></pre></td></tr></table></figure></p><p>天真的我，被他俩坑死了。</p><p>​        问题一：(上图)type: git这里的分号后面没有空格（纳尼，手动黑人问号脸）。所有的配置项目分号（你输入的<code>http:</code>这个分号不用）后面有参数的都要有一个空格</p><p>​        问题二：(上图)deploy和下面的那几项我从网上复制了一下，（不知为啥我的配置里没生成<code>repo</code>和<code>branch</code>）结果就因为后三个没有缩进，我又白白躺了几个小时</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>　　因为<code>Hexo</code>个人博客是托管在<code>github</code>之上，每次访问都要使用<a href="http://penglei.top" target="_blank" rel="noopener">githubname.github.io</a>这么一个长串的域名来访问，会显得非常繁琐。这个时候我们可以购买一个域名，设置<code>DNS</code>跳转，以达到通过域名即可访问我们的个人博客，我就是在阿里的万网购买的域名。</p><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><ul><li>点击对应域名的”解析”</li></ul><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1557307304760.png" alt></p><ul><li><p>点击添加解析，记录类型选<code>A</code>或<code>CNAME</code></p><blockquote><p><code>A</code>记录的记录值就是<code>ip</code>地址，<code>github</code>(官方文档)提供了两个IP地址，<code>192.30.252.153和192.30.252.154</code>，这两个<code>IP</code>地址为<code>github</code>的服务器地址，两个都要填上，解析记录设置两个<code>@</code>，线路就默认就行了，<br><code>CNAME</code>记录值填你的<code>github</code>博客网址。如我的是<code>code-hly.github.io</code></p></blockquote></li></ul><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1557307617094.png" alt></p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1557307781856.png" alt></p><p>​        这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建<code>CNAME</code>文件，不带任何后缀，里面添加你的域名信息，如：<code>penglei.com</code>。实践证明如果此时你填写的是<code>www.penglei.top</code> 那么以后你只能用<code>www.penglei.top</code> 访问，而如果你填写的是<code>penglei.top</code>。那么用<code>www.penglei.top</code> 和 <code>penglei.top</code> 访问都是可以的。重新清理hexo,并发布即可用新的域名访问。</p><ul><li><p>运行：<em>hexo g</em></p></li><li><p>运行：<em>hexo d</em></p></li></ul><h3 id="更新博客内容"><a href="#更新博客内容" class="headerlink" title="更新博客内容"></a>更新博客内容</h3><p>　　至此博客已经搭建完毕，域名也已经正常解析，那么剩下的问题就是更新内容了。</p><h4 id="更新文章"><a href="#更新文章" class="headerlink" title="更新文章"></a>更新文章</h4><ul><li>在<code>MyBlog</code>目录下执行：<em><code>hexo new “我的第一篇文章”</code></em>，会在<code>source-&gt;_posts</code>文件夹内生成一个.md文件。</li><li>编辑该文件（遵循Markdown规则）</li><li>修改起始字段<ul><li>title    文章的标题  </li><li>date    创建日期    （文件的创建日期 ）</li><li>updated    修改日期   （ 文件的修改日期）   </li><li>comments    是否开启评论    true  </li><li>tags    标签   </li><li>categories    分类   </li><li>permalink    url中的名字（文件名）</li></ul></li><li>编写正文内容（MakeDown）</li><li><code>hexo clean</code> 删除本地静态文件（Public目录），可不执行。</li><li><code>hexo g</code> 生成本地静态文件（Public目录）</li><li><code>hexo deploy</code> 将本地静态文件推送至github（hexo d）</li></ul><h4 id="添加菜单"><a href="#添加菜单" class="headerlink" title="添加菜单"></a>添加菜单</h4><p>进入<code>theme</code>目录，编辑<code>_config_yml</code>文件，找到<code>menu:</code>字段，在该字段下添加一个字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  about: /about</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>然后找到<code>lanhuages</code>目录，编辑<code>zh-Hans.yml</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  about: 关于作者</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>更新页面显示的中文字符，最后进入<code>theme</code>目录下的<code>Source</code>目录，新增一个<code>about</code>目录，里面写一个<code>index.html</code>文件。</p><h4 id="文章内插入图片"><a href="#文章内插入图片" class="headerlink" title="文章内插入图片"></a>文章内插入图片</h4><p>在文章中写入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](/upload_image/1.jpg)</span><br></pre></td></tr></table></figure><p>　　然后进入<code>themes-主题名-source-upload_image</code>目录下(自己创建)，将图片放到这个目录下，就可以了。</p><p>说明：当执行<code>hexo g</code>命令时，会自动把图片复制到 <code>public</code>文件的<code>upload_image</code>目录下。</p><h3 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h3><h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><p>　　在根目录下的<code>_config.yml</code>文件中，可以修改标题，作者等信息。打开编辑该文件，注意：每一个值的冒号后面都有一个半角空格！</p><ul><li>未生效的写法：<code>title:nMask</code>的博客</li><li>能生效的写法：<code>title:[空格]nMask</code>的博客</li></ul><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>访问<a href="http://www.zhihu.com/question/24422335" target="_blank" rel="noopener">主题列表</a>，获取主题代码。</p><p>进入themes目录，进入以下操作：</p><ul><li><p>下载主题 (以next主题为例)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/iissnan/hexo-theme-next.git（主题的地址）</span></span><br></pre></td></tr></table></figure></li><li><p>打开<code>__config.yml</code>文件，将<code>themes</code>修改为<code>next</code>（下载到的主题文件夹的名字）</p></li><li><p><code>hexo g</code></p></li><li><p><code>hexo d</code></p></li></ul><p>关于hexo-next主题下的一些个性化配置，参考：<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next主题配置</a></p><h3 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h3><h4 id="文章中添加居中模块"><a href="#文章中添加居中模块" class="headerlink" title="文章中添加居中模块"></a>文章中添加居中模块</h4><p>文章Markdown中填写如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;blockquote <span class="class"><span class="keyword">class</span></span>=<span class="string">"blockquote-center"</span>&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;<span class="regexp">/blockquote&gt;</span></span><br></pre></td></tr></table></figure><h4 id="在文章底部增加版权信息"><a href="#在文章底部增加版权信息" class="headerlink" title="在文章底部增加版权信息"></a>在文章底部增加版权信息</h4><ul><li>在目录<code>next/layout/_macro/</code>下添加<code>my-copyright.swig</code>：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> page.copyright %&#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"my_post_copyright"</span>&gt;</span><br><span class="line">  &lt;script src=<span class="string">"//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  &lt;!-- JS库 sweetalert 可修改路径 --&gt;</span><br><span class="line">  &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;script src=<span class="string">"http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"</span>&gt;</span><br><span class="line">  &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>本文标题:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(page.path) &#125;&#125;"</span>&gt;</span>&#123;&#123; page.title &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>文章作者:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span> <span class="attr">title</span>=<span class="string">"访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"</span>&gt;</span>&#123;&#123; theme.author &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>发布时间:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#123;&#123; page.date.format(<span class="string">"YYYY年MM月DD日 - HH:MM"</span>) &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;&lt;span&gt;最后更新:&lt;/</span>span&gt;&#123;&#123; page.updated.format(<span class="string">"YYYY年MM月DD日 - HH:MM"</span>) &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;&lt;span&gt;原始链接:&lt;/</span>span&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(page.path) &#125;&#125;"</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; page.title &#125;&#125;"</span>&gt;</span>&#123;&#123; page.permalink &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"copy-path"</span>  title=<span class="string">"点击复制文章链接"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-clipboard"</span> <span class="attr">data-clipboard-text</span>=<span class="string">"&#123;&#123; page.permalink &#125;&#125;"</span>  <span class="attr">aria-label</span>=<span class="string">"复制成功！"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;&lt;span&gt;许可协议:&lt;/</span>span&gt;<span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-creative-commons"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">rel</span>=<span class="string">"license"</span> <span class="attr">href</span>=<span class="string">"https://creativecommons.org/licenses/by-nc-nd/4.0/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">title</span>=<span class="string">"Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"</span>&gt;</span>署名-非商业性使用-禁止演绎 4.0 国际<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span> 转载请保留原文链接及作者。&lt;<span class="regexp">/p&gt;  </span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;script&gt; </span><br><span class="line">    <span class="keyword">var</span> clipboard = <span class="keyword">new</span> Clipboard(<span class="string">'.fa-clipboard'</span>);</span><br><span class="line">    clipboard.on(<span class="string">'success'</span>, $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      $(<span class="string">".fa-clipboard"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        swal(&#123;   </span><br><span class="line">          title: <span class="string">""</span>,   </span><br><span class="line">          text: <span class="string">'复制成功'</span>,   </span><br><span class="line">          html: <span class="literal">false</span>,</span><br><span class="line">          timer: <span class="number">500</span>,   </span><br><span class="line">          showConfirmButton: <span class="literal">false</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));  </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure><ul><li>在目录<code>next/source/css/_common/components/post/</code>下添加<code>my-post-copyright.styl</code>：</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.my_post_copyright</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">85%</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">45em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2.8em</span> auto <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1.0em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d3d3d3</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.93rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.6em</span>;</span><br><span class="line">  <span class="attribute">word-break</span>: break-all;</span><br><span class="line">  <span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> p&#123;<span class="attribute">margin</span>:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5.2em</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#b5b5b5</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-class">.raw</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#808080</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-tag">a</span>:hover &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#a3d2a3</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span>:hover <span class="selector-class">.fa-clipboard</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-class">.post-url</span>:hover &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-class">.copy-path</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  +mobile()&#123;<span class="attribute">display</span>:none;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-class">.copy-path</span>:hover &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#808080</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改<code>next/layout/_macro/post.swig</code>，在代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">      &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &#123;% include <span class="string">'wechat-subscriber.swig'</span> %&#125;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><ul><li>之前添加增加如下代码：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">      &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &#123;% include <span class="string">'my-copyright.swig'</span> %&#125;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><ul><li>修改<code>next/source/css/_common/components/post/post.styl</code>文件，在最后一行增加代码：</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import <span class="string">"my-post-copyright"</span></span><br></pre></td></tr></table></figure><ul><li>如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加<code>copyright: true</code>的设置，类似：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">tags: </span><br><span class="line">categories: </span><br><span class="line">copyright: <span class="literal">true</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="自定义hexo-new生成md文件的选项"><a href="#自定义hexo-new生成md文件的选项" class="headerlink" title="自定义hexo new生成md文件的选项"></a>自定义hexo new生成md文件的选项</h4><p>在<code>/scaffolds/post.md</code>文件中添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories: </span><br><span class="line">copyright: <span class="literal">true</span></span><br><span class="line">permalink: <span class="number">01</span></span><br><span class="line">top: <span class="number">0</span></span><br><span class="line">password:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="隐藏网页底部powered-By-Hexo-强力驱动"><a href="#隐藏网页底部powered-By-Hexo-强力驱动" class="headerlink" title="隐藏网页底部powered By Hexo / 强力驱动"></a>隐藏网页底部powered By Hexo / 强力驱动</h4><p>打开<code>themes/next/layout/_partials/footer.swig</code>,使用””隐藏之间的代码即可，或者直接删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"powered-by"</span>&gt;</span><br><span class="line">  &#123;&#123; __(<span class="string">'footer.powered'</span>, <span class="string">'&lt;a class="theme-link" rel="external nofollow" href="https://hexo.io"&gt;Hexo&lt;/a&gt;'</span>) &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;div class="theme-info"&gt;</span></span><br><span class="line"><span class="regexp">  &#123;&#123; __('footer.theme') &#125;&#125; -</span></span><br><span class="line"><span class="regexp">  &lt;a class="theme-link" rel="external nofollow" href="https:/</span><span class="regexp">/github.com/ii</span>ssnan/hexo-theme-next<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    NexT.&#123;&#123; theme.scheme &#125;&#125;</span></span><br><span class="line"><span class="string">  &lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="文章加密访问"><a href="#文章加密访问" class="headerlink" title="文章加密访问"></a>文章加密访问</h4><p>打开<code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code>文件,在<code>meta</code>标签后面插入这样一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">'&#123;&#123; page.password &#125;&#125;'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (prompt(<span class="string">'请输入文章密码'</span>) !== <span class="string">'&#123;&#123; page.password &#125;&#125;'</span>)&#123;</span><br><span class="line">                alert(<span class="string">'密码错误！'</span>);</span><br><span class="line">                history.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>然后文章中添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password: nmask</span><br></pre></td></tr></table></figure><p>如果<code>password</code>后面为空，则表示不用密码。</p><h4 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h4><p>修改 <code>hero-generator-index</code> 插件，把文件：<code>node_modules/hexo-generator-index/lib/generator.js</code> 内的代码替换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">            <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top; <span class="comment">// 否则按照top值降序排</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">  <span class="keyword">return</span> pagination(<span class="string">''</span>, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在文章中添加 <code>top</code> 值，数值越大文章越靠前，如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">......</span><br><span class="line">copyright: <span class="literal">true</span></span><br><span class="line">top: <span class="number">100</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>默认不设置则为0，数值相同时按时间排序。</p><h4 id="添加顶部加载条"><a href="#添加顶部加载条" class="headerlink" title="添加顶部加载条"></a>添加顶部加载条</h4><p>打开<code>/themes/next/layout/_partials/head.swig</code>文件，在<code>maximum-scale=1”/&gt;</code>后添加如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"//cdn.bootcss.com/pace/1.0.2/pace.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;link href=<span class="string">"//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br></pre></td></tr></table></figure><p>但是，默认的是粉色的，要改变颜色可以在<code>/themes/next/layout/_partials/head.swig</code>文件中添加如下代码（接在刚才link的后面）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .pace .pace-progress &#123;</span><br><span class="line">        background: #1E92FB; /*进度条颜色*/</span><br><span class="line">        height: <span class="number">3</span>px;</span><br><span class="line">    &#125;</span><br><span class="line">    .pace .pace-progress-inner &#123;</span><br><span class="line">         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/</span><br><span class="line">    &#125;</span><br><span class="line">    .pace .pace-activity &#123;</span><br><span class="line">        border-top-color: #1E92FB;    /*上边框颜色*/</span><br><span class="line">        border-left-color: #1E92FB;    /*左边框颜色*/</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><h4 id="添加热度"><a href="#添加热度" class="headerlink" title="添加热度"></a>添加热度</h4><p>next主题集成<code>leanCloud</code>，打开<code>/themes/next/layout/_macro/post.swig</code><br>在<code>”leancloud-visitors-count”&gt;</code>标签后面添加<code>℃</code>。<br>然后打开，<code>/themes/next/languages/zh-Hans.yml</code>，将<code>visitors</code>内容改为<em><code>热度</code></em>即可。</p><h4 id="主页文章添加阴影效果"><a href="#主页文章添加阴影效果" class="headerlink" title="主页文章添加阴影效果"></a>主页文章添加阴影效果</h4><p>打开<code>\themes\next\source\css_custom\custom.styl</code>,向里面加入：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主页文章添加阴影效果</span></span><br><span class="line"> <span class="selector-class">.post</span> &#123;</span><br><span class="line">   <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="修改文章底部的那个带-号的标签"><a href="#修改文章底部的那个带-号的标签" class="headerlink" title="修改文章底部的那个带#号的标签"></a>修改文章底部的那个带#号的标签</h4><p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=”tag”&gt;#</code>，将 <code>#</code> 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p><h4 id="鼠标点击小红心的设置"><a href="#鼠标点击小红心的设置" class="headerlink" title="鼠标点击小红心的设置"></a>鼠标点击小红心的设置</h4><p>将 <a href="https://github.com/Neveryu/Neveryu.github.io/blob/master/js/src/love.js" target="_blank" rel="noopener">love.js</a> 文件添加到 <code>\themes\next\source\js\src</code> 文件目录下。<br>找到 <code>\themes\next\layout_layout.swing</code> 文件， 在文件的后面， 标签之前 添加以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/love.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="背景的设置"><a href="#背景的设置" class="headerlink" title="背景的设置"></a>背景的设置</h4><p>将 <a href="https://github.com/Neveryu/Neveryu.github.io/blob/master/js/src/particle.js" target="_blank" rel="noopener">particle.js</a> 文件添加到 <code>\themes\next\source\js\src</code> 文件目录下。<br>找到 <code>\themes\next\layout_layout.swing</code> 文件， 在文件的后面，标签之前 添加以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 背景动画 --&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/particle.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h4><p>将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。<br>找到文件 <code>themes\next\source\css\_custom\custom.styl</code> ，添加如下 <code>css</code> 样式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0477ab</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="博文压缩"><a href="#博文压缩" class="headerlink" title="博文压缩"></a>博文压缩</h4><p>在站点的根目录下执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install gulp -g</span><br><span class="line"><span class="meta">$</span> npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save</span><br></pre></td></tr></table></figure><p>在博客根目录下新建 <code>gulpfile.js</code> ，并填入以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"><span class="comment">// 压缩 public 目录 css</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩 public 目录 html</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">    .pipe(htmlclean())</span><br><span class="line">    .pipe(htmlmin(&#123;</span><br><span class="line">         removeComments: <span class="literal">true</span>,</span><br><span class="line">         minifyJS: <span class="literal">true</span>,</span><br><span class="line">         minifyCSS: <span class="literal">true</span>,</span><br><span class="line">         minifyURLs: <span class="literal">true</span>,</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩 public/js 目录 js</span></span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [</span><br><span class="line">    <span class="string">'minify-html'</span>,<span class="string">'minify-css'</span>,<span class="string">'minify-js'</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>生成博文是执行 <code>hexo g &amp;&amp; gulp</code> 就会根据 <code>gulpfile.js</code> 中的配置，对 <code>public</code> 目录中的静态资源文件进行压缩。</p><h4 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h4><p>安装 <code>hexo-generator-searchdb</code>，在站点的根目录下执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>编辑 站点配置文件，新增以下内容到任意位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: <span class="number">10000</span></span><br></pre></td></tr></table></figure><h4 id="增加阅读排行统计页面"><a href="#增加阅读排行统计页面" class="headerlink" title="增加阅读排行统计页面"></a>增加阅读排行统计页面</h4><p>首先我们可以使用<code>leancloud</code>来统计页面阅读数量，以及储存这些信息，然后通过<code>leancloud</code>提供的<code>api</code>编写<code>js</code>脚本来获取阅读数量信息，并展示在页面上。<br>首先新建一个<code>page</code>页面，<code>hexo new page “”</code>,然后编辑此<code>.md</code>文件，写下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;AV.initialize(<span class="string">""</span>, <span class="string">""</span>);<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> <span class="comment">//需要写上leancloud的key</span></span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="keyword">var</span> time=<span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> title=<span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> url=<span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(<span class="string">'Counter'</span>);<span class="comment">//表名</span></span><br><span class="line">  query.notEqualTo(<span class="string">'id'</span>,<span class="number">0</span>); <span class="comment">//id不为0的结果</span></span><br><span class="line">  query.descending(<span class="string">'time'</span>); <span class="comment">//结果按阅读次数降序排序</span></span><br><span class="line">  query.limit(<span class="number">20</span>);  <span class="comment">//最终只返回10条结果</span></span><br><span class="line">  query.find().then(<span class="function"><span class="keyword">function</span> (<span class="params">todo</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123; </span><br><span class="line">      <span class="keyword">var</span> result=todo[i].attributes;</span><br><span class="line">      time=result.time;  <span class="comment">//阅读次数</span></span><br><span class="line">      title=result.title; <span class="comment">//文章标题</span></span><br><span class="line">      url=result.url;     <span class="comment">//文章url</span></span><br><span class="line">      <span class="keyword">var</span> content=<span class="string">"&lt;p&gt;"</span>+<span class="string">"&lt;font color='#0477ab'&gt;"</span>+<span class="string">"【阅读次数:"</span>+time+<span class="string">"】"</span>+<span class="string">"&lt;a href='"</span>+<span class="string">"http://thief.one"</span>+url+<span class="string">"'&gt;"</span>+title+<span class="string">"&lt;/font&gt;"</span>+<span class="string">"&lt;/a&gt;"</span>+<span class="string">"&lt;/p&gt;"</span>;</span><br><span class="line">      <span class="comment">// document.write("&lt;a href='"+"http://thief.one/"+url+"'&gt;"+title+"&lt;/a&gt;"+"    Readtimes:"+time+"&lt;br&gt;");</span></span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">"heheda"</span>).innerHTML+=content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>最终的效果查看：<a href="http://thief.one/count" target="_blank" rel="noopener">http://thief.one/count</a></p><h4 id="多说替换成来必力评论"><a href="#多说替换成来必力评论" class="headerlink" title="多说替换成来必力评论"></a>多说替换成来必力评论</h4><p>更新于@2017年5月18日<br>多说已经宣布下线了，因此我找了个来必力评论系统来替换，以下是替换的教程，教程内容来自：<a href="https://blog.smoker.cc/web/add-comments-livere-for-hexo-theme-next.html" target="_blank" rel="noopener">https://blog.smoker.cc/web/add-comments-livere-for-hexo-theme-next.html</a></p><p>来必力评价<br>优点：界面美观<br>缺点：不支持数据导入，加载慢</p><p>首先在 <code>_config.yml</code> 文件中添加如下配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">livere_uid: your uid</span><br></pre></td></tr></table></figure><p>其中 <code>livere_uid</code> 即注册来必力获取到的 <code>uid</code>。<br>在 <code>layout/_scripts/third-party/comments/</code> 目录中添加 <code>livere.swig</code>，文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125;</span><br><span class="line">  &#123;% <span class="keyword">if</span> theme.livere_uid %&#125;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params">d, s</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> j, e = d.getElementsByTagName(s)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> LivereTower === <span class="string">'function'</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        j = d.createElement(s);</span><br><span class="line">        j.src = <span class="string">'https://cdn-city.livere.com/js/embed.dist.js'</span>;</span><br><span class="line">        j.async = <span class="literal">true</span>;</span><br><span class="line">        e.parentNode.insertBefore(j, e);</span><br><span class="line">      &#125;)(<span class="built_in">document</span>, <span class="string">'script'</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &#123;% endif %&#125;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure><p>​        优先使用其他评论插件，如果其他评论插件没有开启，且<code>LiveRe</code>评论插件配置开启了，则使用<code>LiveRe</code>。其中脚本代码为上一步管理页面中获取到的。在<code>layout/_scripts/third-party/comments.swig</code>文件中追加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include <span class="string">'./comments/livere.swig'</span> %&#125;</span><br></pre></td></tr></table></figure><p>引入 <code>LiveRe</code> 评论插件。<br>最后，在 <code>layout/_partials/comments.swig</code> 文件中条件最后追加<code>LiveRe</code>插件是否引用的判断逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.livere_uid %&#125;</span><br><span class="line">      &lt;div id=<span class="string">"lv-container"</span> data-id=<span class="string">"city"</span> data-uid=<span class="string">"&#123;&#123; theme.livere_uid &#125;&#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>最后打开博客瞧瞧吧！</p><h4 id="多说替换成网易云跟贴"><a href="#多说替换成网易云跟贴" class="headerlink" title="多说替换成网易云跟贴"></a>多说替换成网易云跟贴</h4><p>最好的方法就是更新next主题，因为最新版本的主题已经支持这几种评论。<br>如果不想更新主题，则往下看：</p><p>网易云跟贴评价：<br>性能稳定，功能中规中矩，支持数据导入</p><p>首先在 <code>_config.yml</code> 文件中添加如下配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gentie_productKey: #your-gentie-product-key</span><br></pre></td></tr></table></figure><p>其中 <code>gentie_productKey</code> 即注册网易云跟贴获取到的<code>key</code>。<br>在 <code>layout/_scripts/third-party/comments/</code> 目录中添加 <code>gentie.swig</code>，文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% <span class="keyword">if</span> theme.gentie_productKey %&#125;</span><br><span class="line">    &#123;% <span class="keyword">set</span> gentie_productKey = theme.gentie_productKey %&#125;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      var cloudTieConfig = &#123;</span><br><span class="line">        url: <span class="built_in">document</span>.location.href, </span><br><span class="line">        sourceId: <span class="string">""</span>,</span><br><span class="line">        productKey: <span class="string">"&#123;&#123;gentie_productKey&#125;&#125;"</span>,</span><br><span class="line">        target: <span class="string">"cloud-tie-wrapper"</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script src="https:/</span><span class="regexp">/img1.ws.126.net/</span>f2e/tie/yun/sdk/loader.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">  &#123;% endif %&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure><p>在<code>layout/_scripts/third-party/comments.swig</code>文件中追加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include <span class="string">'./comments/gentie.swig'</span> %&#125;</span><br></pre></td></tr></table></figure><p>最后，在 <code>layout/_partials/comments.swig</code> 文件中条件最后追加网易云跟帖插件引用的判断逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.gentie_productKey %&#125;</span><br><span class="line">      &lt;div id=<span class="string">"cloud-tie-wrapper"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cloud-tie-wrapper"</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><h3 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h3><h4 id="（一）Deployer-not-found-git"><a href="#（一）Deployer-not-found-git" class="headerlink" title="（一）Deployer not found: git"></a>（一）Deployer not found: git</h4><p>当编辑<code>__config.yml</code>文件，将<code>type: git</code>设置完成后，运行<code>hexo g</code> 报错：<em><code>git not found</code></em><br>解决方案：可以在<code>MyBlog</code>目录下运行: <em><code>npm install hexo-deployer-git –save</code></em>。</p><h4 id="（二）permission-denied"><a href="#（二）permission-denied" class="headerlink" title="（二）permission denied"></a>（二）permission denied</h4><p>当执行: <code>hexo  deploy</code> 报错时，把<code>__config.yml</code>中的<code>github</code>连接形式从<code>ssh</code>改成<code>http</code>。</p><h4 id="（三）当在themes目录下载主题时，报错。"><a href="#（三）当在themes目录下载主题时，报错。" class="headerlink" title="（三）当在themes目录下载主题时，报错。"></a>（三）当在themes目录下载主题时，报错。</h4><p>将该目录只读属性取消。</p><h4 id="（四）genrnate-报错"><a href="#（四）genrnate-报错" class="headerlink" title="（四）genrnate 报错"></a>（四）genrnate 报错</h4><p>检查<code>_config.yml</code>配置中，键值对冒号后面是否已经预留了一个半角空格。</p><h4 id="（五）ERROR-Plugin-load-failed-hexo-generator-feed"><a href="#（五）ERROR-Plugin-load-failed-hexo-generator-feed" class="headerlink" title="（五）ERROR Plugin load failed: hexo-generator-feed"></a>（五）ERROR Plugin load failed: hexo-generator-feed</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><h4 id="（六）fatal-The-remote-end-hung-up-unexpectedly"><a href="#（六）fatal-The-remote-end-hung-up-unexpectedly" class="headerlink" title="（六）fatal: The remote end hung up unexpectedly"></a>（六）fatal: The remote end hung up unexpectedly</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config https.postBuffer 524288000</span><br><span class="line"><span class="meta">$</span> git config http.postBuffer 524288000</span><br><span class="line"><span class="meta">$</span> git config ssh.postBuffer 524288000</span><br></pre></td></tr></table></figure><h4 id="（七）hero-d推送的内容有问题"><a href="#（七）hero-d推送的内容有问题" class="headerlink" title="（七）hero d推送的内容有问题"></a>（七）hero d推送的内容有问题</h4><p>　　首先检查下<code>.deploy_git</code>文件夹下的<code>.git</code>文件是否存在，此<code>.git</code>文件指定了<code>hexo d</code>时推送public文件夹，而不是所有的内容。如果此<code>.git</code>文件不存在，则会出现推送内容错误。<br>　　用<code>npm  install hexo-deployer-git  –save</code>生成的<code>.deploy_git</code>不包含.git文件，因此正确的做法是<code>.deploy_git</code>文件夹也需要备份，然后再用<code>npm install  hexo-deployer-git –save</code>更新一下其内容即可。<br>　　如果已经出现这个错误，则删除<code>.deploy_git</code>，重新<code>hexo d</code>。</p><h4 id="（八）hexo-s报错"><a href="#（八）hexo-s报错" class="headerlink" title="（八）hexo s报错"></a>（八）hexo s报错</h4><p>在新版本的mac上，安装运行<code>hexo</code>会报此错误，但不影响使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">Error</span>: Cannot find <span class="built_in">module</span></span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --no-optional</span><br></pre></td></tr></table></figure><h3 id="Local-Search错误"><a href="#Local-Search错误" class="headerlink" title="Local Search错误"></a>Local Search错误</h3><p>　　最近发现Local Search搜索出来的连接有错误，到不是说连接不对，而是当我在/aaa/目录下搜索一个页面时，跳转到了/aaa/正确的连接/，这样明显是正确的，应该是跟目录+跳转的目录。<br>　　网上搜索了下，没有类似的案例，那么自己动手修改吧，打开<code>node_modules/hexo-generator-searchdb/templates</code>下的<code>xml.ejs</code>文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;url&gt;<span class="xml"><span class="tag">&lt;<span class="name">%-</span> ("<span class="attr">..</span>/<span class="attr">..</span>/<span class="attr">..</span>/<span class="attr">..</span>/<span class="attr">..</span>/<span class="attr">..</span>/<span class="attr">..</span>/<span class="attr">..</span>/"+<span class="attr">post.path</span>) %&gt;</span><span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>说明：将这个文件的两处url都改成这样就可以了。</p><h3 id="异地同步博客内容"><a href="#异地同步博客内容" class="headerlink" title="异地同步博客内容"></a>异地同步博客内容</h3><p>　　现在电脑已经很普及了，因为一般来说我们都是公司一台电脑，家里一台电脑，那么如何将两台电脑上博客的内容同步内，即两台电脑上都可以编辑更新博客？<br>要解决这个问题，首先我们要清楚我们博客文件的组成：</p><ul><li>node_modules</li><li>public</li><li>scaffolds</li><li>source</li><li>themes</li><li>_config_yml</li><li>db.json</li><li>package.json</li><li>.deploy_git</li></ul><p>　　以上为利用hexo生成的博客全部内容，那么当我们执行hexo d时，正真被推送到github上的又有哪些内容呢？<br>　　我们可以看下github上的<code>code-hly.github.io</code>项目，发现里面只有<code>Public</code>目录下的内容。也就是说，我们博客上呈现的内容，其实就是<code>public</code>下的文件内容。那么这个Pulic目录是怎么生成的呢？<br>　　一开始<code>hexo  init</code>的时候是没有<code>public</code>目录的，而当我们运行<code>hexo g</code>命令时，<code>public`</code>目录被生成了，换句话说hexo  g<code>命令就是用来生成博客文件的（会根据</code>_config.yml<code>，</code>source<code>目录文件以及</code>themes<code>目录下文件生成）。同样当我们运行</code>hexo  clean<code>命令时，</code>public<code>目录被删除了。　　好了，既然我们知道了决定博客显示内容的只有一个</code>Public<code>目录，而</code>public<code>目录又是可以动态生成的，那么其实我们只要在不同电脑上同步可以生成</code>Public`目录的文件即可。</p><p>以下文件以及目录是必须要同步的：</p><ul><li>source</li><li>themes</li><li>_config.yml</li><li>db.json</li><li>package.json</li><li>.deploy_git</li></ul><p>　　同步的方式有很多种，可以每次更新后都备份到一个地址。我采用<code>github</code>去备份，也就是新建一个项目用来存放以上文件，每次更新后推送到github上，用作备份同步。<br>　　同步完必须的文件后，怎么再其他电脑上也可以更新博客呢？<br>　　前提假设我们现在配置了一台新电脑，里面没有安装任何有关博客的东西，那么我们开始吧：</p><ul><li>下载<code>node.js</code>并安装（官网下载安装），默认会安装npm。</li><li>下载安装<code>git</code>（官网下载安装）</li><li>下载安装<code>hexo</code>。方法：打开<code>cmd</code> 运行<em><code>npm install -g hexo</code></em>（要翻墙） </li><li>新建一个文件夹，如<code>MyBlog</code></li><li>进入该文件夹内，右击运行<code>git</code>，输入：<em><code>hexo init</code></em>（生成hexo模板，可能要翻墙)</li></ul><p>　　我们重复了一开始搭建博客的步骤，重新生成了一个新的模板，这个模板中包含了hexo生成的一些文件。</p><ul><li><code>git clone</code> 我们备份的项目，生成一个文件夹，如：<code>MyBlogData</code></li><li>将<code>MyBlog</code>里面的<code>node_modules</code>、<code>scaffolds</code>文件夹复制到<code>MyBlogData</code>里面。</li></ul><p>　　做完这些，从表面上看，两台电脑上MyBlogData目录下的文件应该都是一样的了。那么我们运行hexo g<br>hexo d试试，如果会报错，则往下看。</p><ul><li>这是因为<code>.deploy_git</code>没有同步，在<code>MyBlogData</code>目录内运行:<em><code>npm install hexo-deployer-git –save</code></em>后再次推送即可</li></ul><p>　　总结流程：当我们每次更新<code>MyBlog</code>内容后，先利用<code>hexo</code>将<code>public</code>推送到<code>github</code>，然后再将其余必须同步的文件利用<code>git</code>推送到<code>github</code>。</p><h3 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h3><p>seo优化对于网站是否能被搜索引擎快速收录有很大帮助，因此适当做一些seo还是有必要的，以下内容参考：<a href="https://lancelot_lewis.coding.me/2016/08/16/blog/Hexo-NexT-SEO/" target="_blank" rel="noopener">https://lancelot_lewis.coding.me/2016/08/16/blog/Hexo-NexT-SEO/</a></p><h4 id="添加sitemap文件"><a href="#添加sitemap文件" class="headerlink" title="添加sitemap文件"></a>添加sitemap文件</h4><p>安装以下2个插件，然后重启<code>hexo</code>后，网站根目录（source）下会生成<code>sitemap.xml</code>与<code>baidusitemap.xml</code>文件，搜索引擎在爬取时会参照文件中的url去收录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save-dev</span><br><span class="line">hexo d -g</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save-dev</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><h4 id="添加robots-txt"><a href="#添加robots-txt" class="headerlink" title="添加robots.txt"></a>添加robots.txt</h4><p>新建<code>robots.txt</code>文件，添加以下文件内容，把<code>robots.txt</code>放在<code>hexo</code>站点的<code>source</code>文件下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">User-agent: * Allow: <span class="regexp">/</span></span><br><span class="line"><span class="regexp">Allow: /</span>archives/</span><br><span class="line">Disallow: <span class="regexp">/vendors/</span></span><br><span class="line">Disallow: <span class="regexp">/js/</span></span><br><span class="line">Disallow: <span class="regexp">/css/</span></span><br><span class="line">Disallow: <span class="regexp">/fonts/</span></span><br><span class="line">Disallow: <span class="regexp">/vendors/</span></span><br><span class="line">Disallow: <span class="regexp">/fancybox/</span></span><br><span class="line"></span><br><span class="line">Sitemap: http:<span class="comment">//thief.one/sitemap.xml</span></span><br><span class="line">Sitemap: http:<span class="comment">//thief.one/baidusitemap.xml</span></span><br></pre></td></tr></table></figure><h4 id="首页title的优化"><a href="#首页title的优化" class="headerlink" title="首页title的优化"></a>首页title的优化</h4><p>更改<code>index.swig</code>文件，文件路径是<code>your-hexo-site\themes\next\layout</code>，将下面代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block title %&#125;  &#123;&#123; config.title &#125;&#125;  &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block title %&#125;  &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125;  &#123;% endblock</span><br></pre></td></tr></table></figure><p>观察首页title就是标题+描述了。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo腾讯云COS部署+Markdown图床</title>
      <link href="/2019/05/08/hexo%E8%85%BE%E8%AE%AF%E4%BA%91cos%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/05/08/hexo%E8%85%BE%E8%AE%AF%E4%BA%91cos%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>静态博客网站的需求就是一片足够大的空间，而腾讯云COS提供免费50G的存储空间，无疑是一个不错的选择。</p><p>同时也可以用腾讯云cos制作Markdown的图床，这样网站访问速度会比较快</p><a id="more"></a><h2 id="hexo部署腾讯云cos"><a href="#hexo部署腾讯云cos" class="headerlink" title="hexo部署腾讯云cos"></a>hexo部署腾讯云cos</h2><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>​        域名注册与备案</p><blockquote><p>注意：腾讯云cos绑定cdn域名加速时需要备案域名，而域名的备案需要购买腾讯云的服务器。这点比较坑！</p><p>根据个人情况选择，也可以选择上篇博文，采用<code>hexo双站点部署</code></p></blockquote><h3 id="创建存储桶-Bucket"><a href="#创建存储桶-Bucket" class="headerlink" title="创建存储桶(Bucket)"></a>创建存储桶(Bucket)</h3><ul><li><strong>创建存储桶</strong> <a href="http://console.cloud.tencent.com/cos5/bucket" target="_blank" rel="noopener">COS地址</a></li></ul><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-141726@2x.png" alt></p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-141825@2x.png" alt></p><p>填写名称后，选择权限为<strong>公有读私有写</strong>。</p><h3 id="配置存储桶"><a href="#配置存储桶" class="headerlink" title="配置存储桶"></a>配置存储桶</h3><ul><li><p><strong>选择基础配置</strong><br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-141924@2x.png" alt></p></li><li><p><strong>编辑静态网站</strong><br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-141947@2x.png" alt></p></li><li><p><strong>打开设置</strong><br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-142142@2x.png" alt></p></li></ul><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><ul><li>域名管理，添加域名，选择<strong>静态网站源站</strong><br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-142336@2x.png" alt></li></ul><ul><li>域名解析，添加记录<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-142950@2x.png" alt></li></ul><ul><li>第一个框为<strong>二级域名</strong>，第二个框为<strong>记录值</strong>。<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-143210@2x.png" alt></li></ul><h3 id="上传文件测试"><a href="#上传文件测试" class="headerlink" title="上传文件测试"></a>上传文件测试</h3><ul><li>在test存储桶上传<code>CNAME</code>文件和<code>index.html</code>进行测试。</li><li><p>CANME文件的内容为（域名换成自己的域名）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.fiftykg.com</span><br></pre></td></tr></table></figure></li><li><p><code>index.html</code>的内容为：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>测试主页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">测试主页内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在浏览器中查看结果：<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-183101@2x.png" alt></li></ul><h3 id="刷新CDN缓存"><a href="#刷新CDN缓存" class="headerlink" title="刷新CDN缓存"></a>刷新CDN缓存</h3><ul><li><p>上图的效果是不能立刻看到的，大部分时候需要等待。</p><p>有可能你会看到以下的效果：<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-182126@2x.png" alt></p></li></ul><ul><li>首先请确认你的网站类型为<code>静态网站源站</code>。如果设置正确，那么可能需要手动刷新以下cdn的缓存：</li></ul><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-182852@2x.png" alt></p><h3 id="hexo部署"><a href="#hexo部署" class="headerlink" title="hexo部署"></a>hexo部署</h3><p>安装cos部署插件：</p><p><code>npm install hexo-deployer-cos --save</code></p><ul><li>在根目录的<code>_config.yml</code>配置：<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-184622@2x.png" alt></li></ul><ul><li><p>region等参数可以在下图位置查看：<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-184118@2x.png" alt></p><p>秘钥可以在<code>访问管理</code>中<code>云API秘密钥</code>中找到。</p></li></ul><h2 id="Markdown图床"><a href="#Markdown图床" class="headerlink" title="Markdown图床"></a>Markdown图床</h2><h3 id="创建存储桶-Bucket-1"><a href="#创建存储桶-Bucket-1" class="headerlink" title="创建存储桶(Bucket)"></a>创建存储桶(Bucket)</h3><ul><li><strong>创建存储桶</strong> <a href="http://console.cloud.tencent.com/cos5/bucket" target="_blank" rel="noopener">COS地址</a></li></ul><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1557315247262.png" alt></p><p>填写名称后，选择权限为<strong>公有读写</strong>。</p><h3 id="PicGo-客户端配置"><a href="#PicGo-客户端配置" class="headerlink" title="PicGo 客户端配置"></a>PicGo 客户端配置</h3><h4 id="下载-amp-安装"><a href="#下载-amp-安装" class="headerlink" title="下载&amp;安装"></a>下载&amp;安装</h4><p>​    PicGo （目前 2.0.4）是一个开源的图床工具，非常优秀。可以到 git 上下载，但下载速度太慢，所以我放了一个百度云的链接，速度快很多。</p><ul><li>git的地址：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo</a></li><li>Win版下载链接：<a href="https://pan.baidu.com/s/1sr7DKuP7p0WQ1WNBK3Zkow" target="_blank" rel="noopener">https://pan.baidu.com/s/1sr7DKuP7p0WQ1WNBK3Zkow</a>  提取码：d4cx</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1557315547061.png" alt></p><ul><li><p>存储空间名：所存储图片的桶名称</p></li><li><p>存储路径：选择的地区，例如：<code>ap-guangzhou</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo双站点部署github和coding</title>
      <link href="/2019/05/08/hexo%E5%8F%8C%E7%AB%99%E7%82%B9%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/05/08/hexo%E5%8F%8C%E7%AB%99%E7%82%B9%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>​        这是搭建博客系列的第二篇，至于为什么要托管到<code>coding</code>上，原因大家也应该能猜到，就是<code>github</code>访问速度偏慢，体验不是很好。</p><a id="more"></a><h3 id="注册coding-net账号并创建项目"><a href="#注册coding-net账号并创建项目" class="headerlink" title="注册coding.net账号并创建项目"></a>注册<code>coding.net</code>账号并创建项目</h3><p>项目名最好跟用户名一样<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/QQ截图20190508182436.png" alt></p><h3 id="设置coding-SSH-KEY"><a href="#设置coding-SSH-KEY" class="headerlink" title="设置coding SSH KEY"></a>设置<code>coding SSH KEY</code></h3><p>这个就用当时设置<code>github</code>的一样就行了<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/QQ截图20190508182512.png" alt></p><h3 id="config-yml配置"><a href="#config-yml配置" class="headerlink" title="_config.yml配置"></a><code>_config.yml</code>配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: </span><br><span class="line">        github: git@github.com:code-hly/code-hly.github.io.git,master</span><br><span class="line">        coding: git@git.coding.net:huliaoyuan/huliaoyuan.git,master</span><br></pre></td></tr></table></figure><blockquote><p>替换你的项目名，注意空格，我这儿用的是<code>ssh</code>，而不是<code>https</code></p></blockquote><h3 id="部署项目到coding上"><a href="#部署项目到coding上" class="headerlink" title="部署项目到coding上"></a>部署项目到<code>coding</code>上</h3><ul><li><p>进入<code>myblog</code>根目录下，先敲如下命令。为了使用<code>hexo d</code>来部署到<code>git</code>上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用部署命令就能把博客同步到<code>coding</code>上面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy -g</span><br></pre></td></tr></table></figure></li></ul><h3 id="pages服务方式部署"><a href="#pages服务方式部署" class="headerlink" title="pages服务方式部署"></a><code>pages</code>服务方式部署</h3><p>​        部署博客方式有两种，第一种就是<code>pages</code>服务的方式，也推荐这种方式，因为可以绑定域名，而第二种演示的方式必须升级会员才能绑定自定义域名。<code>pages</code>方式也很简单就是在<code>source/</code>需要创建一个空白文件，至于原因，是因为<code>coding.net</code>需要这个文件来作为以静态文件部署的标志。就是说看到这个<code>Staticfile</code>就知道按照静态文件来发布。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd source/</span><br><span class="line">touch Staticfile  #名字必须是Staticfile</span><br></pre></td></tr></table></figure><h3 id="个人域名绑定"><a href="#个人域名绑定" class="headerlink" title="个人域名绑定"></a>个人域名绑定</h3><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/QQ截图20190508183145.png" alt></p><blockquote><p>注意<code>github</code>绑定需要在 <code>myblog/source</code>目录下建一 <code>CNAME</code> 文件，并写上你购买的域名，域名我是在阿里万网买的</p><p>我当时按照别人的做法写的默认和海外，这样发现只能访问<code>coding</code>上的博客而不能访问 <code>github</code> 上的博客了</p></blockquote><h3 id="coding绑定私有域名"><a href="#coding绑定私有域名" class="headerlink" title="coding绑定私有域名"></a><code>coding</code>绑定私有域名</h3><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/QQ截图20190508183721.png" alt></p><h3 id="发布博客新文章后直接部署到github和coding"><a href="#发布博客新文章后直接部署到github和coding" class="headerlink" title="发布博客新文章后直接部署到github和coding"></a>发布博客新文章后直接部署到<code>github</code>和<code>coding</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ceph存储引擎之bluestore</title>
      <link href="/2019/05/07/Ceph-bluestore%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/05/07/Ceph-bluestore%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>​        ceph后端支持多种存储引擎，以插件式的方式来进行管理使用，目前支持filestore，kvstore，memstore以及最新的bluestore，本文介绍的是bluestore的存储方法。</p><a id="more"></a><p>​        目前ceph10版本默认使用的filestore，但是因为filestore在写数据前需要先写journal，会有一倍的写放大，并且filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑，因此诞生的bluestore初衷就是为了减少写放大，并针对ssd做优化，而且直接管理裸盘，从理论上进一步减少文件系统如ext4/xfs等部分的开销，目前bluestore还处于开发优化阶段，在jewel版本还是试用版本，并且最新的master相比jewel已经做了大的重构，预期会在后续的大版本中稳定下来成为默认的存储引擎。本文基于master分支对bluestore存储引擎进行分析。</p><h4 id="bluestore整体架构"><a href="#bluestore整体架构" class="headerlink" title="bluestore整体架构"></a>bluestore整体架构</h4><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEB8.tmp.jpg" alt></p><p>​        bluestore直接管理裸设备，抛弃了ext4/xfs等本地文件系统，BlockDevice实现在用户态下使用linux aio直接对裸设备进行I/O操作。既然是直接管理裸设备就必然需要进行裸设备的空间管理，对应的就是<strong>Allocator</strong>，目前支持<strong>StupidAllocator</strong>和<strong>BitmapAllocator</strong>两种分配器。</p><p>​        相关的元数据以kv的形式保存到<strong>kv数据库</strong>里，默认使用的是rocksdb，由于rocksdb本身是基于文件系统的，不是直接操作裸设备，但是rocksdb也比较灵活，将系统相关的处理抽象成Env，用户可用实现相应的接口，rocksdb默认的Env是<strong>PosixEnv</strong>，直接对接本地文件系统，为此，bluestore实现了一个BlueRocksEnv，继承自EnvWrapper，来为rocksdb提供底层系统的封装，为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口，在系统启动mount这个文件系统的时候将所有的元数据都加载到内存中，BluesFS的数据和日志文件都通过BlockDevice保存到裸设备上，BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备。</p><h4 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h4><p>​        <strong>RocksDB</strong>： 存储预写式日志、数据对象元数据、Ceph的omap数据信息、以及分配器的元数据（分配器负责决定真正的数据应在什么地方存储）<br>​        <strong>BlueRocksEnv</strong>： 与RocksDB交互的接口<br>​        <strong>BlueFS</strong>： 小的文件系统，解决元数据、文件空间及磁盘空间的分配和管理，并实现了rocksdb::Env 接口(存储RocksDB日志和sst文件)。因为rocksdb常规来说是运行在文件系统的顶层，下面是BlueFS。 它是数据存储后端层，RocksDB的数据和BlueStore中的真正数据被存储在同一个块物理设备<br>​        <strong>HDD/SSD</strong>： 物理块设备，存储实际的数据</p><p>​        rocksdb本身是基于文件系统的，不是直接操作裸设备。它将系统相关的处理抽象成Env，用户可用实现相应的接口（rocksdb默认的Env是PosixEnv，直接对接本地文件系统）。BlueRocksEnv是bluestore实现的一个类，继承自rocksdb::EnvWrapper，来为rocksdb提供底层系统的封装。</p><p>​        为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口。所有的元数据的修改都记录在BlueFS的日志中，也就是对于BlueFS，元数据的持久化保存在日志中。在系统启动mount这个文件系统时，只需replay日志，就可将所有的元数据都加载到内存中。BluesFS的数据和日志文件都通过块设备保存到裸设备上（BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备）。</p><p>​        bluestore不使用本地文件系统，直接接管裸设备，并且只使用一个原始分区，HDD/SSD所在的物理块设备实现在用户态下使用linux aio直接对裸设备进行I/O操作。由于操作系统支持的aio操作只支持directIO，所以对BlockDevice的写操作直接写入磁盘，并且需要按照page对齐。其内部有一个aio_thread 线程，用来检查aio是否完成。其完成后，通过回调函数aio_callback 通知调用方。</p><h4 id="wal-amp-db"><a href="#wal-amp-db" class="headerlink" title="wal &amp; db"></a>wal &amp; db</h4><p>BlueFs将整个BlueStore的存储空间分为三个层次 ：</p><ul><li><p><strong>慢速(Slow)空间</strong> </p><p>主要用于存储对象数据，可由普通大容量机械盘提供，由BlueStore自行管理</p></li><li><p><strong>高速(DB)空间</strong> </p><p>存储BlueStore内部产生的元数据，可由普通SSD提供，需求小于（慢速空间）。</p></li><li><p><strong>超高速(WAL)空间</strong> </p><p>主要存储RocksDB内部产生的.log文件，可由ＳＳＤ或者ＮＶＲＡＭ等时延相较普通ＳＳＤ更小的设备充当。容量需求和（高速空间）相当，同样由ＢｌｕｅＦｓ直接管理。</p></li></ul><h5 id="wal-amp-db-的大小问题"><a href="#wal-amp-db-的大小问题" class="headerlink" title="wal &amp; db 的大小问题"></a>wal &amp; db 的大小问题</h5><p>​        在 ceph bluestore 的情况下，wal 是 RocksDB 的 write-ahead log, 相当于之前的 journal  数据，db 是 RocksDB 的 metadata 信息。在磁盘选择原则是 block.wal &gt; block.db &gt;  block。当然所有的数据也可以放到同一块盘上。</p><p>​        默认情况下， wal 和 db 的大小分别是 512 MB 和 1GB, 现在没有一个好的理论值，好像和 ceph 本身承载的数据类型有关系。</p><p>​        值得注意的是，如果所有的数据都在单块盘上，那是没有必要指定 wal &amp; db 的大小的。如果 wal &amp; db  是在不同的盘上，由于 wal/db 一般都会分的比较小，是有满的可能性的。如果满了，这些数据会迁移到下一个快的盘上(wal - db -  main)。所以最少不会因为数据满了，而造成无法写入。</p><h4 id="bluestore元数据"><a href="#bluestore元数据" class="headerlink" title="bluestore元数据"></a>bluestore元数据</h4><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEB9.tmp.jpg" alt></p><p>​        在之前的存储引擎filestore里，对象的表现形式是对应到文件系统里的文件，默认4MB大小的文件，但是在bluestore里，已经没有传统的文件系统，而是自己管理裸盘，因此需要有元数据来管理对象，对应的就是Onode，Onode是常驻内存的数据结构，持久化的时候会以kv的形式存到rocksdb里。</p><p>​        在onode里又分为lextent，表示逻辑的数据块，用一个map来记录，一个onode里会存在多个lextent，lextent通过blob的id对应到blob（bluestore_blob_t ），blob里通过pextent对应到实际物理盘上的区域（pextent里就是offset和length来定位物理盘的位置区域）。一个onode里的多个lextent可能在同一个blob里，而一个blob也可能对应到多个pextent。</p><p>​        另外还有Bnode这个元数据，它是用来表示多个object可能共享extent，目前在做了快照后写I/O触发的cow进行clone的时候会用到。</p><h4 id="I-O读写映射逻辑"><a href="#I-O读写映射逻辑" class="headerlink" title="I/O读写映射逻辑"></a>I/O读写映射逻辑</h4><h5 id="写I-O处理"><a href="#写I-O处理" class="headerlink" title="写I/O处理"></a>写I/O处理</h5><p>​        到达bluestore的I/O的offset和length都是对象内（onode）的，offset是相对于这个对象起始位置的偏移，在_do_write里首先就会根据最小分配单位min_alloc_size进行判断，从而将I/O分为对齐和非对齐的。如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEBA.tmp.png" alt></p><p>​        当一个写请求按照min_alloc_size进行拆分后，就会分为对齐写，对应到do_write_big，非对齐写（即落到某一个min_alloc_size区间的写I/O（对应到do_write_small）。</p><h6 id="do-write-big"><a href="#do-write-big" class="headerlink" title="do_write_big"></a>do_write_big</h6><p>​        对齐到min_alloc_size的写请求处理起来比较简单，有可能是多个min_alloc_size的大小，在处理时会根据实际大小新生成lextent和blob，这个lextent跨越的区域是min_alloc_size的整数倍，如果这段区间是之前写过的，会将之前的lextent记录下来便于后续的空间回收。</p><h6 id="do-write-small"><a href="#do-write-small" class="headerlink" title="do_write_small"></a>do_write_small</h6><p>​        在处理落到某个min_alloc_size区间的写请求时，会首先根据offset去查找有没有可以复用的blob，因为最小分配单元是min_alloc_size，默认64KB，如果一个4KB的写I/O就只会用到blob的一部分，blob里剩余的还能放其他的。</p><h6 id="1）没有找到可以复用的blob，新生成blob"><a href="#1）没有找到可以复用的blob，新生成blob" class="headerlink" title="1）没有找到可以复用的blob，新生成blob"></a>1）没有找到可以复用的blob，新生成blob</h6><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCECB.tmp.jpg" alt></p><p>​        在处理还还需要根据offset和len是否对齐到block_size（默认是4KB）进行补零对齐的操作，之所以需要补齐是与后续的写盘操作有关，真正写盘时有两种方式，一种是Direct I/O的方式，这种要求偏移和缓冲区都对齐的，另外一种非Direct I/O，即Buffered I/O，这种可以不对齐，但是是写到cache里，然后再sync刷到磁盘上，比如只写了100字节，在内核里是需要先从设备上读出来补齐成一个完整的扇区，然后再刷的，这样反而降低了效率。因此在bluestore里直接处理好对齐，对于后面的写盘来说比较有利，这里对齐到block_size，是个可配置的参数。</p><p>​        进行对齐补零时就是按照如上图那样把前后对齐到block_size，然后再把对齐后的offset和len作为lextent，进而放到blob里。</p><h6 id="2）找到可以复用的blob"><a href="#2）找到可以复用的blob" class="headerlink" title="2）找到可以复用的blob"></a>2）找到可以复用的blob</h6><p>​        对于可以复用的blob，也是先按照block_size进行对齐补零的动作，然后再判断是否可以直接使用blob里空闲的空间进行区分做不同的处理。</p><h6 id="a）直接写在blob未使用的空间上"><a href="#a）直接写在blob未使用的空间上" class="headerlink" title="a）直接写在blob未使用的空间上"></a>a）直接写在blob未使用的空间上</h6><p>​        这种情况下直接新生成lextent放到blob里。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCECC.tmp.png" alt></p><h6 id="b）覆盖写的情况"><a href="#b）覆盖写的情况" class="headerlink" title="b）覆盖写的情况"></a>b）覆盖写的情况</h6><p>​        比如下面的这种情况，写I/O会覆盖部分已经写过的数据。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCECD.tmp.jpg" alt></p><p>​        对于这种情况的处理如下图：也是需要先处理对齐补零的情况，如果覆盖的区域刚好是已经对齐到block_size，那么就不需要从磁盘读数据，但是如果覆盖的区域没有对齐到block_size，那么就需要把不对齐的那部分读出来，拼成一个对齐的buffer，然后新生成lextent，并且会对原来那个lextent进行调整，会记录需要回收的那部分区域。对于覆盖写的情况，都不是直接写盘，而是通过wal写到rocksdb。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEDD.tmp.jpg" alt></p><h6 id="整体写I-O的逻辑"><a href="#整体写I-O的逻辑" class="headerlink" title="整体写I/O的逻辑"></a>整体写I/O的逻辑</h6><p>​        之前组内同事画过一个流程图，这里借用一下算是一个简单的总结。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEDE.tmp.png" alt></p><h5 id="读I-O的处理"><a href="#读I-O的处理" class="headerlink" title="读I/O的处理"></a>读I/O的处理</h5><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEEF.tmp.jpg" alt></p><p>​        读I/O请求的处理时也是通过寻找相关联的lextent，可能会存在空洞的情况，即读到未写过的数据，这部分就直接补零。</p><h4 id="clone及extent共享"><a href="#clone及extent共享" class="headerlink" title="clone及extent共享"></a>clone及extent共享</h4><p>前面说到Bnode就是用来记录共享的lextent，目前是在做完快照后对原卷进行写I/O会触发cow，从而产生clone操作。clone时就是将原对象的blob从onode-&gt;blob_map移到onode-&gt;bnode-&gt;blob_map，并且将blob id置为负的，并设置共享标记，然后将新的快照对象的onode-&gt;bnode指向原对象的onode-&gt;bnode，并且用原onode里的lextents里的值赋给新的onode的lextents，从而达到共享extent的目的，图示仅供参考。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEF0.tmp.jpg" alt></p><p>​        在clone完之后，继续对原对象进行写I/O操作时，当碰到共享的blob时就需要跳过，新生成blob，并且取消对原来那部分lextent的引用，在后续的空间释放时的判断依据就是否还有引用。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEF1.tmp.png" alt></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>​        从BlueStore 的设计和实现上看，可以将其理解为用户态下的一个文件系统，同时使用RocksDB来实现BlueStore所有元数据的管理，简化实现。</p><p>​        对于整块数据的写入，数据直接以aio的方式写入磁盘，再更新RocksDB中数据对象的元数据，避免了filestore的先写日志，后apply到实际磁盘的两次写盘。同时避免了日志元数据的冗余存储占用，因为传统文件系统有他们自己内部的日志和元数据管理机制。</p><p>​        对于随机IO，直接WAL的形式，写入RocksDB 高性能的KV存储中。</p><p>​        本文总体上介绍了bluestore的架构、相关元数据及内部I/O映射的逻辑，这还只是bluestore的冰山一角，后续会陆续对bluestore的处理流程、空间分配器、缓存管理、压缩等实现进行分析。</p>]]></content>
      
      
      <categories>
          
          <category> Ceph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ceph存储引擎之bluestore</title>
      <link href="/2019/05/07/Ceph-bluestore/"/>
      <url>/2019/05/07/Ceph-bluestore/</url>
      
        <content type="html"><![CDATA[<p>​        ceph后端支持多种存储引擎，以插件式的方式来进行管理使用，目前支持filestore，kvstore，memstore以及最新的bluestore，本文介绍的是bluestore的存储方法。</p><a id="more"></a><p>​        目前ceph10版本默认使用的filestore，但是因为filestore在写数据前需要先写journal，会有一倍的写放大，并且filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑，因此诞生的bluestore初衷就是为了减少写放大，并针对ssd做优化，而且直接管理裸盘，从理论上进一步减少文件系统如ext4/xfs等部分的开销，目前bluestore还处于开发优化阶段，在jewel版本还是试用版本，并且最新的master相比jewel已经做了大的重构，预期会在后续的大版本中稳定下来成为默认的存储引擎。本文基于master分支对bluestore存储引擎进行分析。</p><h4 id="bluestore整体架构"><a href="#bluestore整体架构" class="headerlink" title="bluestore整体架构"></a>bluestore整体架构</h4><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEB8.tmp.jpg" alt></p><p>​        bluestore直接管理裸设备，抛弃了ext4/xfs等本地文件系统，BlockDevice实现在用户态下使用linux aio直接对裸设备进行I/O操作。既然是直接管理裸设备就必然需要进行裸设备的空间管理，对应的就是<strong>Allocator</strong>，目前支持<strong>StupidAllocator</strong>和<strong>BitmapAllocator</strong>两种分配器。</p><p>​        相关的元数据以kv的形式保存到<strong>kv数据库</strong>里，默认使用的是rocksdb，由于rocksdb本身是基于文件系统的，不是直接操作裸设备，但是rocksdb也比较灵活，将系统相关的处理抽象成Env，用户可用实现相应的接口，rocksdb默认的Env是<strong>PosixEnv</strong>，直接对接本地文件系统，为此，bluestore实现了一个BlueRocksEnv，继承自EnvWrapper，来为rocksdb提供底层系统的封装，为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口，在系统启动mount这个文件系统的时候将所有的元数据都加载到内存中，BluesFS的数据和日志文件都通过BlockDevice保存到裸设备上，BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备。</p><h4 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h4><p>​        <strong>RocksDB</strong>： 存储预写式日志、数据对象元数据、Ceph的omap数据信息、以及分配器的元数据（分配器负责决定真正的数据应在什么地方存储）<br>​        <strong>BlueRocksEnv</strong>： 与RocksDB交互的接口<br>​        <strong>BlueFS</strong>： 小的文件系统，解决元数据、文件空间及磁盘空间的分配和管理，并实现了rocksdb::Env 接口(存储RocksDB日志和sst文件)。因为rocksdb常规来说是运行在文件系统的顶层，下面是BlueFS。 它是数据存储后端层，RocksDB的数据和BlueStore中的真正数据被存储在同一个块物理设备<br>​        <strong>HDD/SSD</strong>： 物理块设备，存储实际的数据</p><p>​        rocksdb本身是基于文件系统的，不是直接操作裸设备。它将系统相关的处理抽象成Env，用户可用实现相应的接口（rocksdb默认的Env是PosixEnv，直接对接本地文件系统）。BlueRocksEnv是bluestore实现的一个类，继承自rocksdb::EnvWrapper，来为rocksdb提供底层系统的封装。</p><p>​        为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口。所有的元数据的修改都记录在BlueFS的日志中，也就是对于BlueFS，元数据的持久化保存在日志中。在系统启动mount这个文件系统时，只需replay日志，就可将所有的元数据都加载到内存中。BluesFS的数据和日志文件都通过块设备保存到裸设备上（BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备）。</p><p>​        bluestore不使用本地文件系统，直接接管裸设备，并且只使用一个原始分区，HDD/SSD所在的物理块设备实现在用户态下使用linux aio直接对裸设备进行I/O操作。由于操作系统支持的aio操作只支持directIO，所以对BlockDevice的写操作直接写入磁盘，并且需要按照page对齐。其内部有一个aio_thread 线程，用来检查aio是否完成。其完成后，通过回调函数aio_callback 通知调用方。</p><h4 id="wal-amp-db"><a href="#wal-amp-db" class="headerlink" title="wal &amp; db"></a>wal &amp; db</h4><p>BlueFs将整个BlueStore的存储空间分为三个层次 ：</p><ul><li><p><strong>慢速(Slow)空间</strong> </p><p>主要用于存储对象数据，可由普通大容量机械盘提供，由BlueStore自行管理</p></li><li><p><strong>高速(DB)空间</strong> </p><p>存储BlueStore内部产生的元数据，可由普通SSD提供，需求小于（慢速空间）。</p></li><li><p><strong>超高速(WAL)空间</strong> </p><p>主要存储RocksDB内部产生的.log文件，可由ＳＳＤ或者ＮＶＲＡＭ等时延相较普通ＳＳＤ更小的设备充当。容量需求和（高速空间）相当，同样由ＢｌｕｅＦｓ直接管理。</p></li></ul><h5 id="wal-amp-db-的大小问题"><a href="#wal-amp-db-的大小问题" class="headerlink" title="wal &amp; db 的大小问题"></a>wal &amp; db 的大小问题</h5><p>​        在 ceph bluestore 的情况下，wal 是 RocksDB 的 write-ahead log, 相当于之前的 journal  数据，db 是 RocksDB 的 metadata 信息。在磁盘选择原则是 block.wal &gt; block.db &gt;  block。当然所有的数据也可以放到同一块盘上。</p><p>​        默认情况下， wal 和 db 的大小分别是 512 MB 和 1GB, 现在没有一个好的理论值，好像和 ceph 本身承载的数据类型有关系。</p><p>​        值得注意的是，如果所有的数据都在单块盘上，那是没有必要指定 wal &amp; db 的大小的。如果 wal &amp; db  是在不同的盘上，由于 wal/db 一般都会分的比较小，是有满的可能性的。如果满了，这些数据会迁移到下一个快的盘上(wal - db -  main)。所以最少不会因为数据满了，而造成无法写入。</p><h4 id="bluestore元数据"><a href="#bluestore元数据" class="headerlink" title="bluestore元数据"></a>bluestore元数据</h4><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEB9.tmp.jpg" alt></p><p>​        在之前的存储引擎filestore里，对象的表现形式是对应到文件系统里的文件，默认4MB大小的文件，但是在bluestore里，已经没有传统的文件系统，而是自己管理裸盘，因此需要有元数据来管理对象，对应的就是Onode，Onode是常驻内存的数据结构，持久化的时候会以kv的形式存到rocksdb里。</p><p>​        在onode里又分为lextent，表示逻辑的数据块，用一个map来记录，一个onode里会存在多个lextent，lextent通过blob的id对应到blob（bluestore_blob_t ），blob里通过pextent对应到实际物理盘上的区域（pextent里就是offset和length来定位物理盘的位置区域）。一个onode里的多个lextent可能在同一个blob里，而一个blob也可能对应到多个pextent。</p><p>​        另外还有Bnode这个元数据，它是用来表示多个object可能共享extent，目前在做了快照后写I/O触发的cow进行clone的时候会用到。</p><h4 id="I-O读写映射逻辑"><a href="#I-O读写映射逻辑" class="headerlink" title="I/O读写映射逻辑"></a>I/O读写映射逻辑</h4><h5 id="写I-O处理"><a href="#写I-O处理" class="headerlink" title="写I/O处理"></a>写I/O处理</h5><p>​        到达bluestore的I/O的offset和length都是对象内（onode）的，offset是相对于这个对象起始位置的偏移，在_do_write里首先就会根据最小分配单位min_alloc_size进行判断，从而将I/O分为对齐和非对齐的。如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEBA.tmp.png" alt></p><p>​        当一个写请求按照min_alloc_size进行拆分后，就会分为对齐写，对应到do_write_big，非对齐写（即落到某一个min_alloc_size区间的写I/O（对应到do_write_small）。</p><h6 id="do-write-big"><a href="#do-write-big" class="headerlink" title="do_write_big"></a>do_write_big</h6><p>​        对齐到min_alloc_size的写请求处理起来比较简单，有可能是多个min_alloc_size的大小，在处理时会根据实际大小新生成lextent和blob，这个lextent跨越的区域是min_alloc_size的整数倍，如果这段区间是之前写过的，会将之前的lextent记录下来便于后续的空间回收。</p><h6 id="do-write-small"><a href="#do-write-small" class="headerlink" title="do_write_small"></a>do_write_small</h6><p>​        在处理落到某个min_alloc_size区间的写请求时，会首先根据offset去查找有没有可以复用的blob，因为最小分配单元是min_alloc_size，默认64KB，如果一个4KB的写I/O就只会用到blob的一部分，blob里剩余的还能放其他的。</p><h6 id="1）没有找到可以复用的blob，新生成blob"><a href="#1）没有找到可以复用的blob，新生成blob" class="headerlink" title="1）没有找到可以复用的blob，新生成blob"></a>1）没有找到可以复用的blob，新生成blob</h6><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCECB.tmp.jpg" alt></p><p>​        在处理还还需要根据offset和len是否对齐到block_size（默认是4KB）进行补零对齐的操作，之所以需要补齐是与后续的写盘操作有关，真正写盘时有两种方式，一种是Direct I/O的方式，这种要求偏移和缓冲区都对齐的，另外一种非Direct I/O，即Buffered I/O，这种可以不对齐，但是是写到cache里，然后再sync刷到磁盘上，比如只写了100字节，在内核里是需要先从设备上读出来补齐成一个完整的扇区，然后再刷的，这样反而降低了效率。因此在bluestore里直接处理好对齐，对于后面的写盘来说比较有利，这里对齐到block_size，是个可配置的参数。</p><p>​        进行对齐补零时就是按照如上图那样把前后对齐到block_size，然后再把对齐后的offset和len作为lextent，进而放到blob里。</p><h6 id="2）找到可以复用的blob"><a href="#2）找到可以复用的blob" class="headerlink" title="2）找到可以复用的blob"></a>2）找到可以复用的blob</h6><p>​        对于可以复用的blob，也是先按照block_size进行对齐补零的动作，然后再判断是否可以直接使用blob里空闲的空间进行区分做不同的处理。</p><h6 id="a）直接写在blob未使用的空间上"><a href="#a）直接写在blob未使用的空间上" class="headerlink" title="a）直接写在blob未使用的空间上"></a>a）直接写在blob未使用的空间上</h6><p>​        这种情况下直接新生成lextent放到blob里。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCECC.tmp.png" alt></p><h6 id="b）覆盖写的情况"><a href="#b）覆盖写的情况" class="headerlink" title="b）覆盖写的情况"></a>b）覆盖写的情况</h6><p>​        比如下面的这种情况，写I/O会覆盖部分已经写过的数据。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCECD.tmp.jpg" alt></p><p>​        对于这种情况的处理如下图：也是需要先处理对齐补零的情况，如果覆盖的区域刚好是已经对齐到block_size，那么就不需要从磁盘读数据，但是如果覆盖的区域没有对齐到block_size，那么就需要把不对齐的那部分读出来，拼成一个对齐的buffer，然后新生成lextent，并且会对原来那个lextent进行调整，会记录需要回收的那部分区域。对于覆盖写的情况，都不是直接写盘，而是通过wal写到rocksdb。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEDD.tmp.jpg" alt></p><h6 id="整体写I-O的逻辑"><a href="#整体写I-O的逻辑" class="headerlink" title="整体写I/O的逻辑"></a>整体写I/O的逻辑</h6><p>​        之前组内同事画过一个流程图，这里借用一下算是一个简单的总结。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEDE.tmp.png" alt></p><h5 id="读I-O的处理"><a href="#读I-O的处理" class="headerlink" title="读I/O的处理"></a>读I/O的处理</h5><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEEF.tmp.jpg" alt></p><p>​        读I/O请求的处理时也是通过寻找相关联的lextent，可能会存在空洞的情况，即读到未写过的数据，这部分就直接补零。</p><h4 id="clone及extent共享"><a href="#clone及extent共享" class="headerlink" title="clone及extent共享"></a>clone及extent共享</h4><p>前面说到Bnode就是用来记录共享的lextent，目前是在做完快照后对原卷进行写I/O会触发cow，从而产生clone操作。clone时就是将原对象的blob从onode-&gt;blob_map移到onode-&gt;bnode-&gt;blob_map，并且将blob id置为负的，并设置共享标记，然后将新的快照对象的onode-&gt;bnode指向原对象的onode-&gt;bnode，并且用原onode里的lextents里的值赋给新的onode的lextents，从而达到共享extent的目的，图示仅供参考。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEF0.tmp.jpg" alt></p><p>​        在clone完之后，继续对原对象进行写I/O操作时，当碰到共享的blob时就需要跳过，新生成blob，并且取消对原来那部分lextent的引用，在后续的空间释放时的判断依据就是否还有引用。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEF1.tmp.png" alt></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>​        从BlueStore 的设计和实现上看，可以将其理解为用户态下的一个文件系统，同时使用RocksDB来实现BlueStore所有元数据的管理，简化实现。</p><p>​        对于整块数据的写入，数据直接以aio的方式写入磁盘，再更新RocksDB中数据对象的元数据，避免了filestore的先写日志，后apply到实际磁盘的两次写盘。同时避免了日志元数据的冗余存储占用，因为传统文件系统有他们自己内部的日志和元数据管理机制。</p><p>​        对于随机IO，直接WAL的形式，写入RocksDB 高性能的KV存储中。</p><p>​        本文总体上介绍了bluestore的架构、相关元数据及内部I/O映射的逻辑，这还只是bluestore的冰山一角，后续会陆续对bluestore的处理流程、空间分配器、缓存管理、压缩等实现进行分析。</p>]]></content>
      
      
      <categories>
          
          <category> Ceph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ceph-deploy部署ceph12集群</title>
      <link href="/2019/05/07/ceph-12%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/05/07/ceph-12%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h1><h2 id="1-1-硬件"><a href="#1-1-硬件" class="headerlink" title="1.1 硬件"></a>1.1 硬件</h2><p>4台 Linux虚拟机： server0, server1, server2, server3<br> 每台有两块磁盘 ： /dev/vdb, /dev/vdc<br> 每台有两块网卡 ：eth0, ens9</p><h2 id="1-2-软件"><a href="#1-2-软件" class="headerlink" title="1.2 软件"></a>1.2 软件</h2><p>linux版本： CentOS 7.2.1511<br> 内核版本 ：  3.10.0-327.el7.x86_64<br> ceph版本：  12.2.12<br> ceph-deploy版本： 2.0.0</p><a id="more"></a><h1 id="2-准备工作-所有server"><a href="#2-准备工作-所有server" class="headerlink" title="2. 准备工作(所有server)"></a>2. 准备工作(所有server)</h1><h2 id="2-1-配置静态IP"><a href="#2-1-配置静态IP" class="headerlink" title="2.1 配置静态IP"></a>2.1 配置静态IP</h2><p>每台server有两个interface, 分别配置在如下两个网段：</p><ul><li>192.168.122.0/24</li><li>192.168.100.0/24</li></ul><p>具体如下表：</p><table><thead><tr><th>Server</th><th>Interface</th><th>IPADDR</th></tr></thead><tbody><tr><td>server0</td><td>eth0</td><td>192.168.122.160</td></tr><tr><td>server0</td><td>ens9</td><td>192.168.100.160</td></tr><tr><td>server1</td><td>eth0</td><td>192.168.122.161</td></tr><tr><td>server1</td><td>ens9</td><td>192.168.100.161</td></tr><tr><td>server2</td><td>eth0</td><td>192.168.122.162</td></tr><tr><td>server2</td><td>ens9</td><td>192.168.100.162</td></tr><tr><td>server3</td><td>eth0</td><td>192.168.122.163</td></tr><tr><td>server3</td><td>ens9</td><td>192.168.100.163</td></tr></tbody></table><h2 id="2-2-生成ssh-key"><a href="#2-2-生成ssh-key" class="headerlink" title="2.2 生成ssh key"></a>2.2 生成ssh key</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ssh-keygen</span><br></pre></td></tr></table></figure><h2 id="2-3-配置主机名解析"><a href="#2-3-配置主机名解析" class="headerlink" title="2.3 配置主机名解析"></a>2.3 配置主机名解析</h2><p>把如下内容追加到/etc/hosts:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.100.160 server0</span><br><span class="line">192.168.100.161 server1</span><br><span class="line">192.168.100.162 server2</span><br><span class="line">192.168.100.163 server3</span><br></pre></td></tr></table></figure><h2 id="2-4-配置ntp"><a href="#2-4-配置ntp" class="headerlink" title="2.4 配置ntp"></a>2.4 配置ntp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># yum install  -y  ntp ntpdate ntp-doc</span><br><span class="line"># vim /etc/ntp.conf  （一般不需要修改）</span><br><span class="line"># systemctl start ntpd.service</span><br><span class="line"># systemctl enable ntpd.service</span><br></pre></td></tr></table></figure><h2 id="2-5-关闭防火墙"><a href="#2-5-关闭防火墙" class="headerlink" title="2.5 关闭防火墙"></a>2.5 关闭防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl stop firewalld</span><br><span class="line"># systemctl disable firewalld</span><br></pre></td></tr></table></figure><h2 id="2-6-安装yum源epel"><a href="#2-6-安装yum源epel" class="headerlink" title="2.6 安装yum源epel"></a>2.6 安装yum源epel</h2><p>为了方便yum安装一些常用的软件包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br></pre></td></tr></table></figure><h1 id="3-安装ceph软件包"><a href="#3-安装ceph软件包" class="headerlink" title="3. 安装ceph软件包"></a>3. 安装ceph软件包</h1><h2 id="3-1-添加yum源-所有server"><a href="#3-1-添加yum源-所有server" class="headerlink" title="3.1 添加yum源(所有server)"></a>3.1 添加yum源(所有server)</h2><p>在<strong>所有server</strong>上添加ceph.repo，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/yum.repos.d/ceph.repo </span><br><span class="line">[Ceph]</span><br><span class="line">name=Ceph packages for $basearch</span><br><span class="line">baseurl=http://mirrors.163.com/ceph/rpm-luminous/el7/$basearch</span><br><span class="line">enabled=1</span><br><span class="line">priority=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://download.ceph.com/keys/release.asc</span><br><span class="line"></span><br><span class="line">[Ceph-noarch]</span><br><span class="line">name=Ceph noarch packages</span><br><span class="line">baseurl=http://mirrors.163.com/ceph/rpm-luminous/el7/noarch</span><br><span class="line">enabled=1</span><br><span class="line">priority=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://download.ceph.com/keys/release.asc</span><br><span class="line"></span><br><span class="line">[ceph-source]</span><br><span class="line">name=Ceph source packages</span><br><span class="line">baseurl=http://mirrors.163.com/ceph/rpm-luminous/el7/SRPMS</span><br><span class="line">enabled=0</span><br><span class="line">priority=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://download.ceph.com/keys/release.asc</span><br></pre></td></tr></table></figure><p><strong>[Ceph]</strong>： ceph软件包的yum源，所有server都需要添加。<br><strong>[Ceph-noarch]</strong>：ceph-deploy的yum源。admin server (见3.2节)  需要安装ceph-deploy，所以它需要这个yum源。admin  server控制其他server的时候，也需要被控server添加这个yum源。最终，所有server都需要添加。<br><strong>[ceph-source]</strong>： admin server控制其他server的时候，也需要被控server添加这个yum源。所以，所有server都需要添加。</p><h2 id="3-2-选择admin-server"><a href="#3-2-选择admin-server" class="headerlink" title="3.2 选择admin server"></a>3.2 选择admin server</h2><p>选择server0作为admin server。官网上建议admin server使用一个单独的user来进行ceph-deploy操作，这里避免麻烦，还用root账户。<br> admin server需要免密登录所有server（包括自己），所以在admin server上配置免密登录（其他server不必配置）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ssh-copy-id root@server0</span><br><span class="line"># ssh-copy-id root@server1</span><br><span class="line"># ssh-copy-id root@server2</span><br><span class="line"># ssh-copy-id root@server3</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># for i in &#123;0..3&#125; ; do ssh server$i hostname ; done </span><br><span class="line">server0</span><br><span class="line">server1</span><br><span class="line">server2</span><br><span class="line">server3</span><br></pre></td></tr></table></figure><h2 id="3-3-安装ceph-deploy-在admin-server上"><a href="#3-3-安装ceph-deploy-在admin-server上" class="headerlink" title="3.3 安装ceph-deploy(在admin server上)"></a>3.3 安装ceph-deploy(在admin server上)</h2><p>在3.1节已经添加了ceph-deploy的yum源，这里直接通过yum安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install ceph-deploy</span><br></pre></td></tr></table></figure><p>然后测试一下，发现报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy --version</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/bin/ceph-deploy&quot;, line 18, in &lt;module&gt;</span><br><span class="line">    from ceph_deploy.cli import main</span><br><span class="line">  File &quot;/usr/lib/python2.7/site-packages/ceph_deploy/cli.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    import pkg_resources</span><br><span class="line">ImportError: No module named pkg_resources</span><br></pre></td></tr></table></figure><p>原因是缺python-setuptools，安装它即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># yum install python-setuptools</span><br><span class="line"></span><br><span class="line"># ceph-deploy --version</span><br><span class="line">2.0.0</span><br></pre></td></tr></table></figure><h2 id="3-4-安装ceph包-在admin-server上执行"><a href="#3-4-安装ceph包-在admin-server上执行" class="headerlink" title="3.4 安装ceph包(在admin server上执行)"></a>3.4 安装ceph包(在admin server上执行)</h2><p>这一步的目标是：admin server通过远程控制在所有server上安装ceph包。它需要在所有server上添加yum源：[Ceph], [Ceph-noarch]和[ceph-source]，见3.1节。</p><p>另外注意：在所有server上安装deltarpm (yum install -y deltarpm)， 否则会报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[server0][DEBUG ] Delta RPMs disabled because /usr/bin/applydeltarpm not installed.</span><br><span class="line">[server0][WARNIN] No data was received after 300 seconds, disconnecting...</span><br><span class="line">[server0][INFO  ] Running command: ceph --version</span><br><span class="line">[server0][ERROR ] Traceback (most recent call last):</span><br><span class="line">[server0][ERROR ]   File &quot;/usr/lib/python2.7/site-packages/ceph_deploy</span><br></pre></td></tr></table></figure><p>下面就是安装了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy install --release=luminous server0 server1 server2 server3</span><br></pre></td></tr></table></figure><p>成功之后，每台server都安装了ceph包，在任意sever上检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># ceph -v</span><br><span class="line">ceph version 12.2.5 (cad919881333ac92274171586c827e01f554a70a) luminous (stable)</span><br><span class="line"></span><br><span class="line"># ceph -v</span><br><span class="line">ceph version 12.2.5 (cad919881333ac92274171586c827e01f554a70a) luminous (stable)</span><br><span class="line">[root@server1 ~]# rpm -qa | grep ceph</span><br><span class="line">ceph-common-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-mds-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-release-1-1.el7.noarch</span><br><span class="line">libcephfs2-12.2.5-0.el7.x86_64</span><br><span class="line">python-cephfs-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-base-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-mon-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-osd-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-mgr-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-radosgw-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-selinux-12.2.5-0.el7.x86_64</span><br></pre></td></tr></table></figure><h1 id="4-部署ceph集群（在admin-server上执行）"><a href="#4-部署ceph集群（在admin-server上执行）" class="headerlink" title="4. 部署ceph集群（在admin server上执行）"></a>4. 部署ceph集群（在admin server上执行）</h1><p>为了演示，我们</p><ol><li>创建一个集群：1 mon + 1 mgr。这个是initial monitor。</li><li>添加 osd</li><li>添加 2 mon + 2 mgr</li><li>创建一个mds</li></ol><p>实际上，我们完全可以在第1步中直接创建 3 mon + 3 mgr的集群 (3个都是initial monitor)，然后添加osd就行了。这里分作1和3两步，是为了演示添加mon和mgr。</p><p>另外，ceph-deploy在部署集群的过程中，会产生一些文件(log，keyring，ceph.conf等)，所以，我们在一个新目录下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir test-ceph-deploy</span><br><span class="line"># cd test-ceph-deploy/</span><br></pre></td></tr></table></figure><p>若部署出现错误，需要重头开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy purge server0 server1 server2 server3</span><br><span class="line">ceph-deploy purgedata server0 server1 server2 server3</span><br><span class="line">ceph-deploy forgetkeys</span><br><span class="line">rm ceph.*</span><br></pre></td></tr></table></figure><h2 id="4-1-创建集群：1-mon-1-mgr"><a href="#4-1-创建集群：1-mon-1-mgr" class="headerlink" title="4.1 创建集群：1 mon + 1 mgr"></a>4.1 创建集群：1 mon + 1 mgr</h2><p><strong>A. 以server2为initial monitor创建集群</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy new server2</span><br></pre></td></tr></table></figure><p>这里指定server2作为initial monitor。这一步完成之后，在当前目录下会产生如下文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph.conf               </span><br><span class="line">ceph.mon.keyring        </span><br><span class="line">ceph-deploy-ceph.log</span><br></pre></td></tr></table></figure><p>ceph.conf是ceph的配置文件。它将会被分发到所有server的/etc/ceph/目录下。在后续的ceph运维中，若需要做某些配置，可以在所有server上修改/etc/ceph/ceph.conf。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># cat ceph.conf </span><br><span class="line">[global]</span><br><span class="line">fsid = 744f59b7-c403-48e6-a1c6-2c74901a4d0b</span><br><span class="line">mon_initial_members = server2</span><br><span class="line">mon_host = 192.168.100.162</span><br><span class="line">auth_cluster_required = cephx</span><br><span class="line">auth_service_required = cephx</span><br><span class="line">auth_client_required = cephx</span><br></pre></td></tr></table></figure><p>ceph.mon.keyring是monitor的keyring，它定义了monitor的key，以及monitor有什么权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cat ceph.mon.keyring </span><br><span class="line">[mon.]</span><br><span class="line">key = AQDf7O9aAAAAABAAX4qmBiNsPhvK43wnpNCtLA==</span><br><span class="line">caps mon = allow *</span><br></pre></td></tr></table></figure><p><strong>B. 配置ceph网络</strong></p><p>ceph集群使用两个网络：public network和cluster network。前者用于服务client；后者用于集群内部通信，例如osd之间迁移数据。另外，两个网络上都有heartbeat。</p><p>注意：若只有一个网络，也可以部署ceph。这个网络同时担任public network和cluster network。<strong>这种情况下，跳过本小节</strong>。</p><p>我们有两个网络（见第2.1节），所以在ceph.conf中，增加如下两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vim ceph.conf</span><br><span class="line">......</span><br><span class="line">public network  = 192.168.100.0/24</span><br><span class="line">cluster network = 192.168.122.0/24</span><br></pre></td></tr></table></figure><p>注意以下两点：</p><ul><li>在2.3节，我们配置主机名解析的时候，把主机名解析为public  network的地址。这是因为，ceph-deploy是作为client (见下文D小节：client.admin,  client.bootstrap-mds,client.bootstrap-mgr,client.bootstrap-osd,client.bootstrap-rgw)来操作集群的，ceph集群通过public  network服务于client。</li><li>monitor是运行于public network上的。这也很容易理解，ceph的client都需要访问monitor，若monitor运行于cluster network上，client无法访问。</li></ul><p><strong>C. 部署initial monitor</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy mon create server2</span><br></pre></td></tr></table></figure><p>这时候，server2上，monitor已经运行起来了。可以到server2上检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server2 ~]# ps -ef | grep ceph</span><br><span class="line">ceph       18240       1  1 14:24 ?        00:00:00 /usr/bin/ceph-mon -f --cluster ceph --id server2 --setuser ceph --setgroup ceph</span><br></pre></td></tr></table></figure><p>如前文B小节所述，monitor运行于public network之上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server2 ~]# netstat -anpl | grep 6789 | grep LISTEN</span><br><span class="line">tcp        0      0 192.168.100.162:6789    0.0.0.0:*               LISTEN      18240/ceph-mon</span><br></pre></td></tr></table></figure><p><strong>D. 创建ceph keyring</strong></p><p>经过前一步，server2上的monitor已经运行起来了。但这时候ceph -s失败，因为ceph -s是admin的命令，我们还没有admin的权限信息呢。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> ceph -c ceph.conf -s </span><br><span class="line">2018-05-07 14:25:46.127163 7f76e1834700 -1 auth: unable to find a keyring on /etc/ceph/ceph.client.admin.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin,: (2) No such file or directory</span><br><span class="line">2018-05-07 14:25:46.127199 7f76e1834700 -1 monclient: ERROR: missing keyring, cannot use cephx for authentication</span><br><span class="line">2018-05-07 14:25:46.127201 7f76e1834700  0 librados: client.admin initialization error (2) No such file or directory</span><br></pre></td></tr></table></figure><p>下面使用gatherkeys来创建各个角色（包括admin）的权限信息。gatherkeys 依次对角色 admin,  bootstrap-mds, bootstrap-mgr, bootstrap-osd,  bootstrap-rgw作如下操作（问题：为什么没有bootstrap-rbd？）：</p><ol><li>使用 ceph auth get 来获取角色的key和权限；</li><li>若不存在，则使用auth get-or-create {角色} {权限}来创建角色的key和权限；</li><li>把角色的key保存到 {角色}.keyring文件；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy gatherkeys server2</span><br><span class="line">[ceph_deploy.conf][DEBUG ] found configuration file at: /root/.cephdeploy.conf</span><br><span class="line">[ceph_deploy.cli][INFO  ] Invoked (2.0.0): /usr/bin/ceph-deploy gatherkeys server2</span><br><span class="line">......</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.admin</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.admin osd allow * mds allow * mon allow * mgr allow *</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.bootstrap-mds</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.bootstrap-mds mon allow profile bootstrap-mds</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.bootstrap-mgr</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.bootstrap-mgr mon allow profile bootstrap-mgr</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.bootstrap-osd</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.bootstrap-osd mon allow profile bootstrap-osd</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.bootstrap-rgw</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.bootstrap-rgw mon allow profile bootstrap-rgw</span><br><span class="line">[ceph_deploy.gatherkeys][INFO  ] Storing ceph.client.admin.keyring</span><br><span class="line">[ceph_deploy.gatherkeys][INFO  ] Storing ceph.bootstrap-mds.keyring</span><br><span class="line">[ceph_deploy.gatherkeys][INFO  ] Storing ceph.bootstrap-mgr.keyring</span><br><span class="line">[ceph_deploy.gatherkeys][INFO  ] keyring &apos;ceph.mon.keyring&apos; already exists</span><br><span class="line">[ceph_deploy.gatherkeys][INFO  ] Storing ceph.bootstrap-osd.keyring</span><br><span class="line">[ceph_deploy.gatherkeys][INFO  ] Storing ceph.bootstrap-rgw.keyring</span><br><span class="line">[ceph_deploy.gatherkeys][INFO  ] Destroy temp directory /tmp/tmpCHsfbU</span><br></pre></td></tr></table></figure><p>创建之后，各个角色的key和权限就存在于集群中了。某个角色（例如admin）要对集群的某个组件（例如osd）进行读写操作时，要提供自己的key；集群根据它的key找到它的权限，然后鉴定它是否能够对这个组件进行读写操作。</p><p>上面gatherkeys在生成各个角色的key+权限的同时，把角色的key保存成keyring文件，供各个角色读写集群组件时使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># ll</span><br><span class="line">total 120</span><br><span class="line">-rw-------. 1 root root    71 May  7 14:28 ceph.bootstrap-mds.keyring</span><br><span class="line">-rw-------. 1 root root    71 May  7 14:28 ceph.bootstrap-mgr.keyring</span><br><span class="line">-rw-------. 1 root root    71 May  7 14:28 ceph.bootstrap-osd.keyring</span><br><span class="line">-rw-------. 1 root root    71 May  7 14:28 ceph.bootstrap-rgw.keyring</span><br><span class="line">-rw-------. 1 root root    63 May  7 14:28 ceph.client.admin.keyring</span><br><span class="line"></span><br><span class="line"># cat ceph.client.admin.keyring </span><br><span class="line">[client.admin]</span><br><span class="line">    key = AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==</span><br><span class="line"></span><br><span class="line"># cat ceph.bootstrap-osd.keyring </span><br><span class="line">[client.bootstrap-osd]</span><br><span class="line">    key = AQD+8e9aFC9+LxAApTnB/DImy5ZjoRbQhYoiVA==</span><br></pre></td></tr></table></figure><p>现在就可以执行ceph的admin命令了（admin的key保存在ceph.client.admin.keyring文件里，通过–keyring提供）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># ceph --keyring ceph.client.admin.keyring -c ceph.conf -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     744f59b7-c403-48e6-a1c6-2c74901a4d0b</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 1 daemons, quorum server2</span><br><span class="line">    mgr: no daemons active</span><br><span class="line">    osd: 0 osds: 0 up, 0 in</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   0 pools, 0 pgs</span><br><span class="line">    objects: 0 objects, 0 bytes</span><br><span class="line">    usage:   0 kB used, 0 kB / 0 kB avail</span><br><span class="line">    pgs:     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ceph --keyring ceph.client.admin.keyring -c ceph.conf auth get client.admin</span><br><span class="line">exported keyring for client.admin</span><br><span class="line">[client.admin]</span><br><span class="line">    key = AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==</span><br><span class="line">    caps mds = &quot;allow *&quot;</span><br><span class="line">    caps mgr = &quot;allow *&quot;</span><br><span class="line">    caps mon = &quot;allow *&quot;</span><br><span class="line">    caps osd = &quot;allow *&quot;</span><br></pre></td></tr></table></figure><p><strong>E. 分发keyring</strong></p><p>如前所示，我们执行admin的命令，要提供admin的key（–keyring  ceph.client.admin.keyring）以及配置文件(-c  ceph.conf)。在后续的运维中，我们经常需要在某个server上执行admin命令。每次都提供这些参数比较麻烦。实际上，ceph会默认地从/etc/ceph/中找keyring和ceph.conf。因此，我们可以把ceph.client.admin.keyring和ceph.conf放到每个server的/etc/ceph/。ceph-deploy可以帮我做这些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy admin server0 server1 server2 server3</span><br></pre></td></tr></table></figure><p>检查每个server，发现/etc/ceph/下都多了ceph.client.admin.keyring和ceph.conf这两个文件。现在就不用提供那些参数了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line"># ceph auth get client.admin</span><br></pre></td></tr></table></figure><p><strong>F. 创建mgr</strong></p><p>从ceph 12（luminous）开始，需要为每个monitor创建一个mgr（其功能待研究，之前的版本都没有这个组件）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy mgr create server2</span><br><span class="line"></span><br><span class="line"># ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     744f59b7-c403-48e6-a1c6-2c74901a4d0b</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 1 daemons, quorum server2</span><br><span class="line">    mgr: server2(active)    ----------------------新加的mgr</span><br><span class="line">    osd: 0 osds: 0 up, 0 in</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   0 pools, 0 pgs</span><br><span class="line">    objects: 0 objects, 0 bytes</span><br><span class="line">    usage:   0 kB used, 0 kB / 0 kB avail</span><br><span class="line">    pgs:</span><br></pre></td></tr></table></figure><h2 id="4-2-添加OSD"><a href="#4-2-添加OSD" class="headerlink" title="4.2 添加OSD"></a>4.2 添加OSD</h2><p>ceph-deploy osd create通过调用ceph-volume来创建OSD。使用bluestore时(默认)，需要指定3个device：</p><table><thead><tr><th>device</th><th>如何指定</th><th>说明</th></tr></thead><tbody><tr><td>block</td><td>–data</td><td>主要存储，必选。可以是磁盘，分区或者lv</td></tr><tr><td>block.db</td><td>–block-db</td><td>可选。若不指定，则对应内容存储于block。可以是分区或者lv</td></tr><tr><td>block.wal</td><td>–block-wal</td><td>可选。若不指定，则对应内容存储于block。可以是分区或者lv</td></tr></tbody></table><p>注意： </p><ol><li>不可以使用磁盘作为block.db或者block.wal，否则会报错：blkid could not detect a PARTUUID for device； </li><li>若使用磁盘或者分区作block，则ceph-volume会在其上创建lv来使用。若使用分区作block.db或block.wal，则直接使用分区而不创建lv。</li></ol><p>在使用磁盘之前，我们先把磁盘清空。若已经创建了volume group，需要先删掉（vgremove），然后通过ceph-deploy的disk zap进行清空。ceph-deploy disk zap会发生如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy disk zap server0 /dev/vdb</span><br><span class="line">[ceph_deploy.conf][DEBUG ] found configuration file at: /root/.cephdeploy.conf</span><br><span class="line">[ceph_deploy.cli][INFO  ] Invoked (2.0.0): /usr/bin/ceph-deploy disk zap </span><br><span class="line">[ceph_deploy.osd][DEBUG ] zapping /dev/vdb on server0</span><br><span class="line">......</span><br><span class="line">[server0][DEBUG ] find the location of an executable</span><br><span class="line">[ceph_deploy][ERROR ] Traceback (most recent call last):</span><br><span class="line">[ceph_deploy][ERROR ]   File &quot;/usr/lib/python2.7/site-packages/ceph_deploy/util/decorators.py&quot;, line 69, in newfunc</span><br><span class="line">[ceph_deploy][ERROR ]     return f(*a, **kw)</span><br><span class="line">[ceph_deploy][ERROR ]   File &quot;/usr/lib/python2.7/site-packages/ceph_deploy/cli.py&quot;, line 164, in _main</span><br><span class="line">[ceph_deploy][ERROR ]     return args.func(args)</span><br><span class="line">[ceph_deploy][ERROR ]   File &quot;/usr/lib/python2.7/site-packages/ceph_deploy/osd.py&quot;, line 438, in disk</span><br><span class="line">[ceph_deploy][ERROR ]     disk_zap(args)</span><br></pre></td></tr></table></figure><p>修改ceph-deploy的 osd.py的disk_zap函数，即可成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vim /usr/lib/python2.7/site-packages/ceph_deploy/osd.py</span><br><span class="line">ceph_volume_executable = system.executable_path(distro.conn, &apos;ceph-volume&apos;)</span><br><span class="line">#if args.debug:</span><br><span class="line">if False:</span><br></pre></td></tr></table></figure><p><strong>A. 添加osd.0（磁盘作block，无block.db，无block.wal）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy osd create server0 --data /dev/vdb</span><br><span class="line"></span><br><span class="line"># ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     744f59b7-c403-48e6-a1c6-2c74901a4d0b</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 1 daemons, quorum server2</span><br><span class="line">    mgr: server2(active)</span><br><span class="line">    osd: 1 osds: 1 up, 1 in</span><br><span class="line"></span><br><span class="line"># mount | grep ceph</span><br><span class="line">tmpfs on /var/lib/ceph/osd/ceph-0 type tmpfs (rw,relatime,seclabel)</span><br><span class="line"></span><br><span class="line"># ll /var/lib/ceph/osd/ceph-0  </span><br><span class="line">total 48</span><br><span class="line">-rw-r--r--. 1 ceph ceph 189 May  7 15:19 activate.monmap</span><br><span class="line">lrwxrwxrwx. 1 ceph ceph  93 May  7 15:19 block -&gt; /dev/ceph-012c2043-33ef-4219-af69-34c7ed389d41/osd-block-5beb22d5-891c-4d6e-affe-87eb4bc083b2</span><br><span class="line">-rw-r--r--. 1 ceph ceph   2 May  7 15:19 bluefs</span><br><span class="line">-rw-r--r--. 1 ceph ceph  37 May  7 15:19 ceph_fsid</span><br><span class="line">-rw-r--r--. 1 ceph ceph  37 May  7 15:19 fsid</span><br><span class="line">-rw-------. 1 ceph ceph  55 May  7 15:19 keyring</span><br><span class="line">-rw-r--r--. 1 ceph ceph   8 May  7 15:19 kv_backend</span><br><span class="line">-rw-r--r--. 1 ceph ceph  21 May  7 15:19 magic</span><br><span class="line">-rw-r--r--. 1 ceph ceph   4 May  7 15:19 mkfs_done</span><br><span class="line">-rw-r--r--. 1 ceph ceph  41 May  7 15:19 osd_key</span><br><span class="line">-rw-r--r--. 1 ceph ceph   6 May  7 15:19 ready</span><br><span class="line">-rw-r--r--. 1 ceph ceph  10 May  7 15:19 type</span><br><span class="line">-rw-r--r--. 1 ceph ceph   2 May  7 15:19 whoami</span><br></pre></td></tr></table></figure><p>可见： </p><ol><li>使用磁盘vdb创建lv供block使用；  </li><li>osd是mount到tmpfs的（bluefs, ceph_fsid, fsid, keyring等等都存于集群中）；</li></ol><p><strong>B. 添加osd.1（分区作block，分区作block.db，无block.wal）</strong></p><p>把server0的vdc分成两个分区（分区过程省略，注意，要是有gpt分区格式）：vdc1作block.db，vdc2作block。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy osd create server0 --data /dev/vdc2 --block-db /dev/vdc1</span><br><span class="line"></span><br><span class="line"># ll  /var/lib/ceph/osd/ceph-1 </span><br><span class="line">total 52</span><br><span class="line">-rw-r--r--. 1 ceph ceph 189 May  7 15:25 activate.monmap</span><br><span class="line">lrwxrwxrwx. 1 ceph ceph  93 May  7 15:25 block -&gt; /dev/ceph-ae408599-db16-4028-914d-4006594c5cd8/osd-block-1edeced4-e5e9-45ac-a5d3-ddd238d720d4</span><br><span class="line">lrwxrwxrwx. 1 root root   9 May  7 15:25 block.db -&gt; /dev/vdc1</span><br><span class="line">-rw-r--r--. 1 ceph ceph   2 May  7 15:25 bluefs</span><br><span class="line">-rw-r--r--. 1 ceph ceph  37 May  7 15:25 ceph_fsid</span><br><span class="line">-rw-r--r--. 1 ceph ceph  37 May  7 15:25 fsid</span><br><span class="line">-rw-------. 1 ceph ceph  55 May  7 15:25 keyring</span><br><span class="line">-rw-r--r--. 1 ceph ceph   8 May  7 15:25 kv_backend</span><br><span class="line">-rw-r--r--. 1 ceph ceph  21 May  7 15:25 magic</span><br><span class="line">-rw-r--r--. 1 ceph ceph   4 May  7 15:25 mkfs_done</span><br><span class="line">-rw-r--r--. 1 ceph ceph  41 May  7 15:25 osd_key</span><br><span class="line">-rw-r--r--. 1 ceph ceph  10 May  7 15:25 path_block.db</span><br><span class="line">-rw-r--r--. 1 ceph ceph   6 May  7 15:25 ready</span><br><span class="line">-rw-r--r--. 1 ceph ceph  10 May  7 15:25 type</span><br><span class="line">-rw-r--r--. 1 ceph ceph   2 May  7 15:25 whoami</span><br></pre></td></tr></table></figure><p>可见，使用分区vdc2创建lv供block使用； block.db直接使用vdc1;</p><p><strong>C. 添加osd.2（分区作block，分区作block.db，分区作block.wal）</strong></p><p>把serve1的vdb分成3个分区：vdb3作block，vdb2作block.db，vdb1作block-wal：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy osd create server1 --data /dev/vdb3 --block-db /dev/vdb2 --block-wal /dev/vdb1</span><br></pre></td></tr></table></figure><p>到server1上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># ll /var/lib/ceph/osd/ceph-2 </span><br><span class="line">total 56</span><br><span class="line">-rw-r--r--. 1 ceph ceph 189 May  7 15:34 activate.monmap</span><br><span class="line">lrwxrwxrwx. 1 ceph ceph  93 May  7 15:34 block -&gt; /dev/ceph-c2f66dc2-076b-46cd-a1cd-e3ef9511a38a/osd-block-7bf0f953-2feb-4064-8d19-873495cae7f5</span><br><span class="line">lrwxrwxrwx. 1 root root   9 May  7 15:34 block.db -&gt; /dev/vdb2</span><br><span class="line">lrwxrwxrwx. 1 root root   9 May  7 15:34 block.wal -&gt; /dev/vdb1</span><br><span class="line">-rw-r--r--. 1 ceph ceph   2 May  7 15:34 bluefs</span><br><span class="line">-rw-r--r--. 1 ceph ceph  37 May  7 15:34 ceph_fsid</span><br><span class="line">-rw-r--r--. 1 ceph ceph  37 May  7 15:34 fsid</span><br><span class="line">-rw-------. 1 ceph ceph  55 May  7 15:34 keyring</span><br><span class="line">-rw-r--r--. 1 ceph ceph   8 May  7 15:34 kv_backend</span><br><span class="line">-rw-r--r--. 1 ceph ceph  21 May  7 15:34 magic</span><br><span class="line">-rw-r--r--. 1 ceph ceph   4 May  7 15:34 mkfs_done</span><br><span class="line">-rw-r--r--. 1 ceph ceph  41 May  7 15:34 osd_key</span><br><span class="line">-rw-r--r--. 1 ceph ceph  10 May  7 15:34 path_block.db</span><br><span class="line">-rw-r--r--. 1 ceph ceph  10 May  7 15:34 path_block.wal</span><br><span class="line">-rw-r--r--. 1 ceph ceph   6 May  7 15:34 ready</span><br><span class="line">-rw-r--r--. 1 ceph ceph  10 May  7 15:34 type</span><br><span class="line">-rw-r--r--. 1 ceph ceph   2 May  7 15:34 whoami</span><br></pre></td></tr></table></figure><p><strong>D. 添加osd.3（lv作block，lv作block.db，lv作block.wal）</strong></p><p>首先，在server1上，使用vdc创建出3个lv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># pvcreate /dev/vdc</span><br><span class="line">  Physical volume &quot;/dev/vdc&quot; successfully created</span><br><span class="line"></span><br><span class="line"># vgcreate myvg /dev/vdc   </span><br><span class="line">  Volume group &quot;myvg&quot; successfully created</span><br><span class="line"></span><br><span class="line"># lvcreate -n block-lv -L 30G myvg  </span><br><span class="line">  Logical volume &quot;block-lv&quot; created.</span><br><span class="line"></span><br><span class="line"># lvcreate -n db-lv -L 10G myvg</span><br><span class="line">  Logical volume &quot;db-lv&quot; created.</span><br><span class="line"></span><br><span class="line"># lvcreate -n wal-lv -L 10G myvg</span><br><span class="line">  Logical volume &quot;wal-lv&quot; created.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ls /dev/myvg/</span><br><span class="line">block-lv  db-lv  wal-lv</span><br></pre></td></tr></table></figure><p>然后，在admin server上创建osd.3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy osd create server1 --data myvg/block-lv --block-db myvg/db-lv  --block-wal myvg/wal-lv</span><br></pre></td></tr></table></figure><p>到server1上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># ll /var/lib/ceph/osd/ceph-3  </span><br><span class="line">total 56</span><br><span class="line">-rw-r--r--. 1 ceph ceph 189 May  7 15:47 activate.monmap</span><br><span class="line">lrwxrwxrwx. 1 ceph ceph  18 May  7 15:47 block -&gt; /dev/myvg/block-lv</span><br><span class="line">lrwxrwxrwx. 1 root root  15 May  7 15:47 block.db -&gt; /dev/myvg/db-lv</span><br><span class="line">lrwxrwxrwx. 1 root root  16 May  7 15:47 block.wal -&gt; /dev/myvg/wal-lv</span><br><span class="line">-rw-r--r--. 1 ceph ceph   2 May  7 15:47 bluefs</span><br><span class="line">-rw-r--r--. 1 ceph ceph  37 May  7 15:47 ceph_fsid</span><br><span class="line">-rw-r--r--. 1 ceph ceph  37 May  7 15:47 fsid</span><br><span class="line">-rw-------. 1 ceph ceph  55 May  7 15:47 keyring</span><br><span class="line">-rw-r--r--. 1 ceph ceph   8 May  7 15:47 kv_backend</span><br><span class="line">-rw-r--r--. 1 ceph ceph  21 May  7 15:47 magic</span><br><span class="line">-rw-r--r--. 1 ceph ceph   4 May  7 15:47 mkfs_done</span><br><span class="line">-rw-r--r--. 1 ceph ceph  41 May  7 15:47 osd_key</span><br><span class="line">-rw-r--r--. 1 ceph ceph  16 May  7 15:47 path_block.db</span><br><span class="line">-rw-r--r--. 1 ceph ceph  17 May  7 15:47 path_block.wal</span><br><span class="line">-rw-r--r--. 1 ceph ceph   6 May  7 15:47 ready</span><br><span class="line">-rw-r--r--. 1 ceph ceph  10 May  7 15:47 type</span><br><span class="line">-rw-r--r--. 1 ceph ceph   2 May  7 15:47 whoami</span><br></pre></td></tr></table></figure><p>注意： lv应写作 myvg/xx-lv，而不是/dev/myvg/xx-lv。否则会报错。</p><p><strong>E. 添加其他osd</strong></p><p>为了方便，block, block.db和block.wal都使用分区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy osd create server3 --data /dev/vdb3  --block-db /dev/vdb2  --block-wal /dev/vdb1</span><br><span class="line"># ceph-deploy osd create server3 --data /dev/vdc3  --block-db /dev/vdc2  --block-wal /dev/vdc1</span><br><span class="line"># ceph-deploy osd create server2 --data /dev/vdb3  --block-db /dev/vdb2  --block-wal /dev/vdb1</span><br><span class="line"># ceph-deploy osd create server2 --data /dev/vdc3  --block-db /dev/vdc2  --block-wal /dev/vdc1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     744f59b7-c403-48e6-a1c6-2c74901a4d0b</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 1 daemons, quorum server2</span><br><span class="line">    mgr: server2(active)</span><br><span class="line">    osd: 8 osds: 8 up, 8 in    &lt;-------- 8 个 osd</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   0 pools, 0 pgs</span><br><span class="line">    objects: 0 objects, 0 bytes</span><br><span class="line">    usage:   8226 MB used, 339 GB / 347 GB avail</span><br><span class="line">    pgs:</span><br></pre></td></tr></table></figure><h2 id="4-3-添加-2-mon-2-mgr"><a href="#4-3-添加-2-mon-2-mgr" class="headerlink" title="4.3 添加 2 mon + 2 mgr"></a>4.3 添加 2 mon + 2 mgr</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy mon add server0</span><br><span class="line"># ceph-deploy mgr create server0</span><br><span class="line"># ceph-deploy mon add server1</span><br><span class="line"># ceph-deploy mgr create server1</span><br></pre></td></tr></table></figure><p>注意：貌似新版的ceph-deploy一次只能增加一个mon.</p><p>现在集群就有3个mon和3个mgr了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     744f59b7-c403-48e6-a1c6-2c74901a4d0b</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 3 daemons, quorum server0,server1,server2</span><br><span class="line">    mgr: server2(active), standbys: server0, server1</span><br><span class="line">    osd: 8 osds: 8 up, 8 in</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   0 pools, 0 pgs</span><br><span class="line">    objects: 0 objects, 0 bytes</span><br><span class="line">    usage:   8230 MB used, 339 GB / 347 GB avail</span><br><span class="line">    pgs:</span><br></pre></td></tr></table></figure><h2 id="4-4-创建一个mds"><a href="#4-4-创建一个mds" class="headerlink" title="4.4 创建一个mds"></a>4.4 创建一个mds</h2><p>为了支持cephfs，我们在server2上创建一个mds：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy mds create server2</span><br></pre></td></tr></table></figure><p>成功之后，到server2上可以看见mds进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server2 ~]# ps -ef | grep ceph-mds</span><br><span class="line">ceph       19995       1  0 16:35 ?        00:00:00 /usr/bin/ceph-mds -f --cluster ceph --id server2 --setuser ceph --setgroup ceph</span><br></pre></td></tr></table></figure><p>但这个时候，mds并没有active，如下，我们通过ceph -s看不到mds服务。直到创建ceph filesystem的时候，mds才进入active状态（见6.1节）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     744f59b7-c403-48e6-a1c6-2c74901a4d0b</span><br><span class="line">    health: HEALTH_WARN</span><br><span class="line">            too few PGs per OSD (12 &lt; min 30)</span><br><span class="line"></span><br><span class="line">  services:    -----------------&gt; 看不到mds</span><br><span class="line">    mon: 3 daemons, quorum server0,server1,server2</span><br><span class="line">    mgr: server2(active), standbys: server0, server1</span><br><span class="line">    osd: 8 osds: 8 up, 8 in</span><br><span class="line">    rgw: 2 daemons active</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   4 pools, 32 pgs</span><br><span class="line">    objects: 187 objects, 1113 bytes</span><br><span class="line">    usage:   8239 MB used, 339 GB / 347 GB avail</span><br><span class="line">    pgs:     32 active+clean</span><br></pre></td></tr></table></figure><p>至此，ceph集群就完全部署起来了。下面，我们为ceph集群增加一些client。</p><h1 id="5-增加rgw-（在admin-server上操作）"><a href="#5-增加rgw-（在admin-server上操作）" class="headerlink" title="5. 增加rgw （在admin server上操作）"></a>5. 增加rgw （在admin server上操作）</h1><p>我们可以使用ceph集群之外的server来部署rgw。部署之前，需要保证默认端口（7480）没有被防火墙禁止。并且需要安装ceph-radosgw包机器依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy install --rgw &lt;client-node&gt; [&lt;client-node&gt; ...]</span><br></pre></td></tr></table></figure><p>为了方便起见，我们复用集群内的server1和server3来部署rgw。由于ceph-radosgw已经安装（见3.4节），并且防火墙已经被停掉（见2.5节），所以，直接部署即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy rgw create server1 server3</span><br></pre></td></tr></table></figure><p>成功之后，在server1和server3上rgw进程就运行起来了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@server1 ~]# ps -ef | grep ceph</span><br><span class="line">......</span><br><span class="line">ceph       15884       1  2 16:23 ?        00:00:00 /usr/bin/radosgw -f --cluster ceph --name client.rgw.server1 --setuser ceph --setgroup ceph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@server3 ~]# ps -ef | grep ceph</span><br><span class="line">......</span><br><span class="line">ceph       14107       1  2 16:23 ?        00:00:00 /usr/bin/radosgw -f --cluster ceph --name client.rgw.server3 --setuser ceph --setgroup ceph</span><br></pre></td></tr></table></figure><p>并且我们可以通过http来访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># curl server1:7480</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;ListAllMyBucketsResult xmlns=&quot;http://s3.amazonaws.com/doc/2006-03-01/&quot;&gt;</span><br><span class="line">&lt;Owner&gt;</span><br><span class="line">    &lt;ID&gt;anonymous&lt;/ID&gt;</span><br><span class="line">    &lt;DisplayName&gt;&lt;/DisplayName&gt;</span><br><span class="line">&lt;/Owner&gt;</span><br><span class="line">&lt;Buckets&gt;&lt;/Buckets&gt;</span><br><span class="line">&lt;/ListAllMyBucketsResult&gt;</span><br></pre></td></tr></table></figure><h1 id="6-增加cephfs"><a href="#6-增加cephfs" class="headerlink" title="6. 增加cephfs"></a>6. 增加cephfs</h1><p>ceph filesystem需要mds（我们在4.4节已经部署）。并且，有两种方式来挂载：ceph fuse和ceph kernel driver。在这一节，我们:</p><ol><li>创建一个ceph filesystem</li><li>通过ceph fuse挂载</li><li>通过ceph kernel driver挂载</li></ol><h2 id="6-1-创建ceph-filesystem（在集群内任意server上）"><a href="#6-1-创建ceph-filesystem（在集群内任意server上）" class="headerlink" title="6.1 创建ceph filesystem（在集群内任意server上）"></a>6.1 创建ceph filesystem（在集群内任意server上）</h2><p><strong>A. 创建所需的pool</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd pool create cephfs_data 80</span><br><span class="line">pool &apos;cephfs_data&apos; created</span><br><span class="line"># ceph osd pool create cephfs_metadata 40</span><br><span class="line">pool &apos;cephfs_metadata&apos; created</span><br></pre></td></tr></table></figure><p><strong>B. 创建filesystem</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph fs new mycephfs cephfs_metadata cephfs_data</span><br><span class="line">new fs with metadata pool 6 and data pool 5</span><br></pre></td></tr></table></figure><p>如第4.4节所示，在没有创建filesystem之前，mds没有active。现在mds就进入active状态了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     744f59b7-c403-48e6-a1c6-2c74901a4d0b</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 3 daemons, quorum server0,server1,server2</span><br><span class="line">    mgr: server2(active), standbys: server0, server1</span><br><span class="line">    mds: mycephfs-1/1/1 up  &#123;0=server2=up:active&#125;  ---------&gt;mds已经active</span><br><span class="line">    osd: 8 osds: 8 up, 8 in</span><br><span class="line">    rgw: 2 daemons active</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   6 pools, 152 pgs</span><br><span class="line">    objects: 208 objects, 3359 bytes</span><br><span class="line">    usage:   8248 MB used, 339 GB / 347 GB avail</span><br><span class="line">    pgs:     152 active+clean</span><br></pre></td></tr></table></figure><h2 id="6-2-通过ceph-fuse挂载（在server2上）"><a href="#6-2-通过ceph-fuse挂载（在server2上）" class="headerlink" title="6.2 通过ceph fuse挂载（在server2上）"></a>6.2 通过ceph fuse挂载（在server2上）</h2><p>和rgw一样，原则上我们在ceph集群之外的某台server上挂载ceph filesystem。但为了方便起见，我们还是在server2上挂载。</p><p>首先，要在server2上安装ceph-fuse（<strong>若使用ceph集群外的server，也只需这一个包</strong>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y ceph-fuse.x86_64</span><br></pre></td></tr></table></figure><p>然后，创建一个挂载点，就可以挂载了。注意，ceph-fuse挂载使用的是admin的权限，所以，通过-k选项传入admin的key。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /mnt/cephfs</span><br><span class="line"></span><br><span class="line"># ceph-fuse -k /etc/ceph/ceph.client.admin.keyring -m server0:6789 /mnt/cephfs</span><br><span class="line">2018-05-07 17:27:07.205147 7f501e11f040 -1 init, newargv = 0x7f502968cb80 newargc=9</span><br><span class="line">ceph-fuse[20080]: starting ceph client</span><br><span class="line">ceph-fuse[20080]: starting fuse</span><br></pre></td></tr></table></figure><p>这时候，一个全新的ceph filesystem就可以使用了。注意：这时cephfs_data是空的，但cephfs_metadata不空：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ceph df</span><br><span class="line">GLOBAL:</span><br><span class="line">    SIZE     AVAIL     RAW USED     %RAW USED </span><br><span class="line">    347G      339G        8248M          2.32 </span><br><span class="line">POOLS:</span><br><span class="line">    NAME                    ID     USED     %USED     MAX AVAIL     OBJECTS </span><br><span class="line">    ......</span><br><span class="line">    cephfs_data             5         0         0          106G           0 </span><br><span class="line">    cephfs_metadata         6      2624         0          106G          21</span><br></pre></td></tr></table></figure><p>往里拷贝一些东西，就会发现cephfs_data也不空了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># cp /boot/vmlinuz-3.10.0-327.el7.x86_64  /mnt/cephfs/</span><br><span class="line"></span><br><span class="line"># ls /mnt/cephfs/</span><br><span class="line">vmlinuz-3.10.0-327.el7.x86_64</span><br><span class="line"></span><br><span class="line"># ceph df</span><br><span class="line">GLOBAL:</span><br><span class="line">    SIZE     AVAIL     RAW USED     %RAW USED </span><br><span class="line">    347G      339G        8263M          2.32 </span><br><span class="line">POOLS:</span><br><span class="line">    NAME                    ID     USED      %USED     MAX AVAIL     OBJECTS </span><br><span class="line">    ......</span><br><span class="line">    cephfs_data             5      5035k         0          106G           2 </span><br><span class="line">    cephfs_metadata         6       7541         0          106G          21</span><br></pre></td></tr></table></figure><h2 id="6-3-通过ceph-kernel-driver挂载"><a href="#6-3-通过ceph-kernel-driver挂载" class="headerlink" title="6.3 通过ceph kernel driver挂载"></a>6.3 通过ceph kernel driver挂载</h2><p>首先，我们尝试在server3上测试ceph kernel driver挂载。</p><p>和ceph-fuse一样，通过ceph kernel driver挂载也需要admin的权限。不同的是，不需要admin的keyring文件，而是直接需要admin的key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server3 ~]# mkdir /mnt/kcephfs</span><br><span class="line">[root@server3 ~]# mount -t ceph server0:6789:/ /mnt/kcephfs/  -o name=admin,secret=AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==</span><br></pre></td></tr></table></figure><p>这个命令卡了一段时间后，报出如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount error 5 = Input/output error</span><br></pre></td></tr></table></figure><p>在/var/log/messages中，有如下错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server3 ~]# tail /var/log/messages</span><br><span class="line">May  7 17:41:29 server3 kernel: libceph: mon0 192.168.100.160:6789 feature set mismatch, my 103b84a842aca &lt; server&apos;s 40103b84a842aca, missing 400000000000000</span><br><span class="line">May  7 17:41:29 server3 kernel: libceph: mon0 192.168.100.160:6789 missing required protocol features</span><br></pre></td></tr></table></figure><p>就是说：ceph集群需要的feature set，我们的ceph kernel driver没能够全部提供，缺失的是400000000000000。</p><p>从<a href="http://cephnotes.ksperis.com/blog/2014/01/21/feature-set-mismatch-error-on-ceph-kernel-client" target="_blank" rel="noopener">CephNotes</a>里，我们可以看到，缺失有些feature，可以通过两种办法解决：</p><ol><li>升级内核  （从客户端入手解决）</li><li>对集群做某些设置 （从server端入手解决）</li></ol><p>例如：</p><ul><li>missing 2040000 (CEPH_FEATURE_CRUSH_TUNABLES 和CEPH_FEATURE_CRUSH_TUNABLES2 )： <pre><code>把客户server（cephfs挂载机）的内核升到3.9（或以上） ； 把tunables设置为legacy : ceph osd crush tunables legacy；</code></pre></li><li>missing 40000000 (CEPH_FEATURE_OSDHASHPSPOOL)： <pre><code>把客户server（rbd客户机？）的内核升到3.9（或以上） ； ceph osd pool set rbd hashpspool false</code></pre></li><li>missing 800000000 (CEPH_FEATURE_OSD_CACHEPOOL)： <pre><code>把客户server的内核升到3.14（或以上） ； 删除cache pool并reload monitors；</code></pre></li></ul><p>悲剧的是，我们缺失的400000000000000 (CEPH_FEATURE_NEW_OSDOPREPLY_ENCODING)，无法通过设置集群来解决，也就是说必须升级内核（到4.5以上）。</p><p>参考：<a href="http://cephnotes.ksperis.com/blog/2014/01/21/feature-set-mismatch-error-on-ceph-kernel-client" target="_blank" rel="noopener">http://cephnotes.ksperis.com/blog/2014/01/21/feature-set-mismatch-error-on-ceph-kernel-client</a></p><p>刚好，我有个开发server（devbuild：192.168.100.150），已经编译安装过内核  4.14.39。去试试。如4.1.B节所述，monitor运行于public  network上（192.168.100.0/24），devbuild能够访问这个网络。这就足够了。<strong>注意：这个server不需安装任何ceph包</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># ping 192.168.100.160</span><br><span class="line">PING 192.168.100.160 (192.168.100.160) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.100.160: icmp_seq=1 ttl=64 time=4.12 ms</span><br><span class="line">64 bytes from 192.168.100.160: icmp_seq=2 ttl=64 time=0.557 ms</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[root@devbuild ~]# uname -a</span><br><span class="line">Linux devbuild 4.14.39.hyg.20180503  ......</span><br><span class="line"></span><br><span class="line">[root@devbuild ~]# mkdir /mnt/kcephfs</span><br><span class="line"></span><br><span class="line">[root@devbuild ~]# mount -t ceph 192.168.100.162:6789:/ /mnt/kcephfs/  -o name=admin,secret=AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==</span><br><span class="line"></span><br><span class="line">[root@devbuild ~]# ls /mnt/kcephfs/</span><br><span class="line">vmlinuz-3.10.0-327.el7.x86_64</span><br></pre></td></tr></table></figure><p>已经mount成功，并且能看到第6.2节拷贝过去的文件。再测试拷贝一个文件，可见读写正常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@devbuild ~]# cp linux-4.14.39.tar.xz /mnt/kcephfs/</span><br><span class="line"></span><br><span class="line">[root@devbuild ~]# ll /mnt/kcephfs/</span><br><span class="line">total 103560</span><br><span class="line">-rw-r--r-- 1 root root 100888428 May  7 18:27 linux-4.14.39.tar.xz</span><br><span class="line">-rwxr-xr-x 1 root root   5156528 May  7 17:30 vmlinuz-3.10.0-327.el7.x86_64</span><br></pre></td></tr></table></figure><p>另外，根据官方文档，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount -t ceph 192.168.100.162:6789:/ /mnt/kcephfs/  -o name=admin,secret=AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==</span><br></pre></td></tr></table></figure><p>也可以换做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cat admin.secret </span><br><span class="line">AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==</span><br><span class="line"></span><br><span class="line"># mount -t ceph 192.168.100.162:6789:/ /mnt/kcephfs/  -o name=admin,secretfile=admin.secret</span><br></pre></td></tr></table></figure><p>但是，我这样尝试，一直报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@devbuild ~]# cat admin.secret</span><br><span class="line">AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==</span><br><span class="line">[root@devbuild ~]# mount -t ceph 192.168.100.162:6789:/ /mnt/kcephfs/  -o name=admin,secretfile=admin.secret</span><br><span class="line">mount: wrong fs type, bad option, bad superblock on 192.168.100.162:6789:/,</span><br><span class="line">       missing codepage or helper program, or other error</span><br><span class="line"></span><br><span class="line">       In some cases useful info is found in syslog - try</span><br><span class="line">       dmesg | tail or so.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@devbuild ~]# dmesg | tail   </span><br><span class="line">[   66.850589] random: 7 urandom warning(s) missed due to ratelimiting</span><br><span class="line">[  140.953833] Key type dns_resolver registered</span><br><span class="line">[  141.096210] Key type ceph registered</span><br><span class="line">[  141.097950] libceph: loaded (mon/osd proto 15/24)</span><br><span class="line">[  141.160712] ceph: loaded (mds proto 32)</span><br><span class="line">[  141.163762] libceph: bad option at &apos;secretfile=admin.secret&apos;</span><br></pre></td></tr></table></figure><p>原因是，我的这个server没有安装任何ceph包，所以没有/usr/sbin/mount.ceph这个文件。解决办法：<br> \1. 从别的server拷贝这个文件;<br> \2. 安装ceph-common；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y ceph-common-12.2.5-0.el7.x86_64</span><br></pre></td></tr></table></figure><p>前文说过，devbuild server不需安装任何ceph包，但若使用secretfile的方式，还是安装这个ceph-common为好。</p><h1 id="7-增加rbd"><a href="#7-增加rbd" class="headerlink" title="7. 增加rbd"></a>7. 增加rbd</h1><h2 id="7-1-准备rbd-pool"><a href="#7-1-准备rbd-pool" class="headerlink" title="7.1 准备rbd pool"></a>7.1 准备rbd pool</h2><p>在集群内的任意server上创建一个pool，并init：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd pool create rbd_pool 100 100</span><br><span class="line">pool &apos;rbd_pool&apos; created</span><br><span class="line"></span><br><span class="line"># rbd pool init rbd_pool</span><br></pre></td></tr></table></figure><h2 id="7-2-创建块设备"><a href="#7-2-创建块设备" class="headerlink" title="7.2 创建块设备"></a>7.2 创建块设备</h2><p>首先我们尝试在集群内的一个server（server0）上创建块设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># rbd create foo --size 4096 --image-feature layering -m 192.168.100.160  -K admin.secret -p rbd_pool</span><br><span class="line"># rbd map foo --name client.admin -m 192.168.100.160 -K admin.secret -p rbd_pool</span><br><span class="line"></span><br><span class="line">rbd: sysfs write failed</span><br><span class="line">rbd: error opening default pool &apos;rbd&apos;</span><br><span class="line">Ensure that the default pool has been created or specify an alternate pool name.</span><br><span class="line">In some cases useful info is found in syslog - try &quot;dmesg | tail&quot;.</span><br><span class="line">rbd: map failed: (5) Input/output error</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># dmesg | tail </span><br><span class="line">......</span><br><span class="line">[527394.031762] libceph: mon0 192.168.100.160:6789 feature set mismatch, my 102b84a842a42 &lt; server&apos;s 40102b84a842a42, missing 400000000000000</span><br><span class="line">[527394.034677] libceph: mon0 192.168.100.160:6789 missing required protocol features</span><br></pre></td></tr></table></figure><p>和6.3节遇到的问题一样，内核版本低，缺feature 400000000000000。还是到devbuild这个server上创建吧，要求：</p><ul><li>devbuild server能够访问monitor (public network)；</li><li>安装ceph-common；</li><li>admin.secret；</li></ul><p>如6.3节所述，都已满足。可以创建块设备了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># rbd create foo --size 4096 --image-feature layering -m 192.168.100.160  -K admin.secret -p rbd_pool</span><br><span class="line"></span><br><span class="line"># rbd map foo --name client.admin -m 192.168.100.160  -K admin.secret -p rbd_pool</span><br></pre></td></tr></table></figure><p>选项-K admin.secret也可以换成-k ceph.client.admin.keyring。成功之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ll /dev/rbd0</span><br><span class="line">brw-rw----. 1 root disk 251, 0 May 10 16:31 /dev/rbd0</span><br><span class="line"></span><br><span class="line"># ls /dev/rbd/</span><br><span class="line">rbd_pool</span><br><span class="line"></span><br><span class="line"># ls /dev/rbd/rbd_pool</span><br><span class="line">foo</span><br></pre></td></tr></table></figure><p>这时候，我们可以使用/dev/rbd0了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkfs.ext4  /dev/rbd0 </span><br><span class="line"># mount  /dev/rbd0 /mnt/rbd/</span><br></pre></td></tr></table></figure><h1 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h1><p>本文实践了使用ceph-deploy安装部署ceph集群的过程，给集群添加了三种类型的客户端，并且解决了一些部署中常见的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Ceph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ceph存储引擎之FileStore</title>
      <link href="/2019/05/07/Ceph-FileStore%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/05/07/Ceph-FileStore%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>​        Ceph作为一个高可用和强一致性的软件定义存储实现，去使用它非常重要的就是了解其内部的IO路径和存储实现。这篇文章主要介绍在IO路径中最底层的ObjectStore的实现之一FileStore。</p><a id="more"></a><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/图片1.png" alt></p><h2 id="ObjectStore"><a href="#ObjectStore" class="headerlink" title="ObjectStore"></a>ObjectStore</h2><p>​        ObjectStore是Ceph OSD中最重要的概念之一，它封装了所有对底层存储的IO操作。从上图中可以看到所有IO请求在Clieng端发出，在Message层统一解析后会被OSD层分发到各个PG，每个PG都拥有一个队列，一个线程池会对每个队列进行处理。</p><p>​        当一个在PG队列里的IO被提出后，该IO请求会被根据类型和相关附带参数进行处理。如果是读请求会通过ObjectStore提供的API获得相应的内容，如果是写请求也会利用ObjectStore提供的事务API将所有写操作组合成一个原子事务提交给ObjectStore。ObjectStore通过接口对上层提供不同的隔离级别，目前PG层只采用了Serializable级别,保证读写的顺序性。</p><p>​        ObjectStore主要接口分为三部分，第一部分是Object的读写操作，类似于POSIX的部分接口，第二部分是Object的属性(xattr)读写操作，这类操作的特征是kv对并且与某一个Object关联。第三部分是关联Object的kv操作(在Ceph中称为omap)，这个其实与第二部分非常类似，但是在实现上可能会有所变化。</p><p>​        目前ObjectStore的主要实现是FileStore，也就是利用文件系统的POSIX接口实现ObjectStore  API。每个Object在FileStore层会被看成是一个文件，Object的属性(xattr)会利用文件的xattr属性存取，因为有些文件系统(如Ext4)对xattr的长度有限制，因此超出长度的Metadata会被存储在DBObjectMap里。而Object的omap则直接利用DBObjectMap实现。因此，可以看出xattr和omap操作是互通的，在用户角度来说，前者可以看作是受限的长度，后者更宽泛(API没有对这些做出硬性要求)。</p><h2 id="FileJournal"><a href="#FileJournal" class="headerlink" title="FileJournal"></a>FileJournal</h2><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/图片2.png" alt></p><p>为了缩小写事务的处理时间，提高写事务的处理能力并且实现事务的原子性，FileStore引入了FileJournal，所有写事务在被FileJournal处理以后都会立即返回(上图中的第二步)。FileJournal类似于数据库的writeahead日志，使用O_DIRECT和O_DSYNC每次同步写入到journal文件，完成后该事务会被塞到FileStore的op  queue。事务通常有若干个写操作组成，当在中间过程进程crash时，journal会OSD  recover提供了完备的输入。FileStore会存在多个thread从op  queue里获取op，然后真正apply到文件系统上对应的Object(Buffer  IO)。当FileStore将事务落到disk上之后，后续的该Object的读请求才会继续(上图中的第五步)。当FileStore完成一个op后，对应的Journal可以丢弃这部分日志。</p><p>​        实际上并不是所有的文件系统都按照这个顺序，一般来说如Ceph推荐的Ext4和XFS文件系统会先写入Journal，然后再写入Filesystem，而COW(Copy  on Write)文件系统如Btrfs和ZFS会同时写入Journal和FileSystem。</p><h2 id="DBObjectMap"><a href="#DBObjectMap" class="headerlink" title="DBObjectMap"></a>DBObjectMap</h2><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/图片3.png" alt></p><p>​        DBObjectMap是FileStore的一部分，利用KeyValue数据库实现了ObjectStore的第三部分API，DBObjectMap主要复杂在其实现了clone操作的no-copy。因为ObjectStore提供了clone   API，提供对一个Object的完全clone(包括Object的属性和omap)。DBObjectMap对每一个Object有一个Header，每个Object联系的omap(kv   pairs)对会与该Header联系，当clone时，会产生两个新的Header，原来的Header作为这两个新Header的parent，这时候无论是原来的Object还是cloned  Object在查询或者写操作时都会查询parent的情况，并且实现copy-on-write。那么Header如何与omap(kv  pairs)联系呢，首先每个Header有一个唯一的seq，然后所有属于该Header的omap的key里面都会包含该seq，因此，利用KeyValueDB的提供的有序prefix检索来实现对omap的遍历。</p><p>​        上面提到FileStore会将每个Object作为一个文件，那么Object的一些属性会与Object  Name一起作为文件名，Object  所属的PG会作为文件目录，当一个PG内所包含的文件超过一定程度时(在目录内文件太多会造成文件系统的lookup性能损耗)，PG会被分裂成两个PG。</p>]]></content>
      
      
      <categories>
          
          <category> Ceph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数进阶</title>
      <link href="/2019/04/22/python-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"/>
      <url>/2019/04/22/python-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>函数参数和返回值的作用</li><li>函数的返回值 进阶</li><li>函数的参数 进阶</li><li>递归函数<a id="more"></a><h2 id="01-函数参数和返回值的作用"><a href="#01-函数参数和返回值的作用" class="headerlink" title="01. 函数参数和返回值的作用"></a>01. 函数参数和返回值的作用</h2></li></ul><p>函数根据 <strong>有没有参数</strong> 以及 <strong>有没有返回值</strong>，可以 <strong>相互组合</strong>，一共有 <strong>4 种</strong> 组合形式</p><ol><li>无参数，无返回值</li><li>无参数，有返回值</li><li>有参数，无返回值</li><li>有参数，有返回值</li></ol><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/001_函数参数和返回值.png" alt></p><blockquote><p>定义函数时，<strong>是否接收参数，或者是否返回结果</strong>，是根据 <strong>实际的功能需求</strong> 来决定的！</p></blockquote><ol><li>如果函数 <strong>内部处理的数据不确定</strong>，就可以将外界的数据以参数传递到函数内部</li><li>如果希望一个函数 <strong>执行完成后，向外界汇报执行结果</strong>，就可以增加函数的返回值</li></ol><h3 id="1-1-无参数，无返回值"><a href="#1-1-无参数，无返回值" class="headerlink" title="1.1 无参数，无返回值"></a>1.1 无参数，无返回值</h3><p>此类函数，不接收参数，也没有返回值，应用场景如下：</p><ol><li><strong>只是单纯地做一件事情</strong>，例如 <strong>显示菜单</strong></li><li>在函数内部 <strong>针对全局变量进行操作</strong>，例如：<strong>新建名片</strong>，最终结果 <strong>记录在全局变量</strong> 中</li></ol><blockquote><p>注意：</p></blockquote><ul><li>如果全局变量的数据类型是一个 <strong>可变类型</strong>，在函数内部可以使用 <strong>方法</strong> 修改全局变量的内容 —— <strong>变量的引用不会改变</strong></li><li>在函数内部，<strong>使用赋值语句</strong> 才会 <strong>修改变量的引用</strong></li></ul><h3 id="1-2-无参数，有返回值"><a href="#1-2-无参数，有返回值" class="headerlink" title="1.2 无参数，有返回值"></a>1.2 无参数，有返回值</h3><p>此类函数，不接收参数，但是有返回值，应用场景如下：</p><ul><li>采集数据，例如 <strong>温度计</strong>，返回结果就是当前的温度，而不需要传递任何的参数</li></ul><h3 id="1-3-有参数，无返回值"><a href="#1-3-有参数，无返回值" class="headerlink" title="1.3 有参数，无返回值"></a>1.3 有参数，无返回值</h3><p>此类函数，接收参数，没有返回值，应用场景如下：</p><ul><li>函数内部的代码保持不变，针对 <strong>不同的参数 处理 不同的数据</strong></li><li>例如 <strong>名片管理系统</strong> 针对 <strong>找到的名片</strong> 做 <strong>修改</strong>、<strong>删除</strong> 操作</li></ul><h3 id="1-4-有参数，有返回值"><a href="#1-4-有参数，有返回值" class="headerlink" title="1.4 有参数，有返回值"></a>1.4 有参数，有返回值</h3><p>此类函数，接收参数，同时有返回值，应用场景如下：</p><ul><li>函数内部的代码保持不变，针对 <strong>不同的参数 处理 不同的数据</strong>，并且 <strong>返回期望的处理结果</strong></li><li>例如 <strong>名片管理系统</strong> 使用 <strong>字典默认值</strong> 和 <strong>提示信息</strong> 提示用户输入内容<ul><li>如果输入，返回输入内容</li><li>如果没有输入，返回字典默认值</li></ul></li></ul><h2 id="02-函数的返回值-进阶"><a href="#02-函数的返回值-进阶" class="headerlink" title="02. 函数的返回值 进阶"></a>02. 函数的返回值 进阶</h2><ul><li>在程序开发中，有时候，会希望 <strong>一个函数执行结束后，告诉调用者一个结果</strong>，以便调用者针对具体的结果做后续的处理</li><li><strong>返回值</strong> 是函数 <strong>完成工作</strong>后，<strong>最后</strong> 给调用者的 <strong>一个结果</strong></li><li>在函数中使用 <code>return</code> 关键字可以返回结果</li><li>调用函数一方，可以 <strong>使用变量</strong> 来 <strong>接收</strong> 函数的返回结果</li></ul><blockquote><p>问题：一个函数执行后能否返回多个结果？</p></blockquote><h3 id="示例-——-温度和湿度测量"><a href="#示例-——-温度和湿度测量" class="headerlink" title="示例 —— 温度和湿度测量"></a>示例 —— 温度和湿度测量</h3><ul><li>假设要开发一个函数能够同时返回当前的温度和湿度</li><li><strong>先完成返回温度</strong>的功能如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">measure</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""返回当前的温度"""</span></span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"开始测量..."</span>)</span><br><span class="line">    temp = <span class="number">39</span></span><br><span class="line">    print(<span class="string">"测量结束..."</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line">result = measure()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><ul><li>在利用 <strong>元组</strong> 在返回温度的同时，也能够返回 <strong>湿度</strong></li><li>改造如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">measure</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""返回当前的温度"""</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"开始测量..."</span>)</span><br><span class="line">    temp = <span class="number">39</span></span><br><span class="line">    wetness = <span class="number">10</span></span><br><span class="line">    print(<span class="string">"测量结束..."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (temp, wetness)</span><br></pre></td></tr></table></figure><blockquote><p>提示：如果一个函数返回的是元组，括号可以省略</p></blockquote><p><strong>技巧</strong> </p><ul><li>在 <code>Python</code> 中，可以 <strong>将一个元组</strong> 使用 <strong>赋值语句</strong> 同时赋值给 <strong>多个变量</strong></li><li>注意：变量的数量需要和元组中的元素数量保持一致</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = temp, wetness = measure()</span><br></pre></td></tr></table></figure><h2 id="03-函数的参数-进阶"><a href="#03-函数的参数-进阶" class="headerlink" title="03. 函数的参数 进阶"></a>03. 函数的参数 进阶</h2><h3 id="3-1-不可变和可变的参数"><a href="#3-1-不可变和可变的参数" class="headerlink" title="3.1. 不可变和可变的参数"></a>3.1. 不可变和可变的参数</h3><blockquote><p>问题 1：在函数内部，针对参数使用 <strong>赋值语句</strong>，会不会影响调用函数时传递的 <strong>实参变量</strong>？ —— 不会！</p></blockquote><ul><li>无论传递的参数是 <strong>可变</strong> 还是 <strong>不可变</strong> <ul><li>只要 <strong>针对参数</strong> 使用 <strong>赋值语句</strong>，会在 <strong>函数内部</strong> 修改 <strong>局部变量的引用</strong>，<strong>不会影响到 外部变量的引用</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(num, num_list)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"函数内部"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 赋值语句</span></span><br><span class="line">    num = <span class="number">200</span></span><br><span class="line">    num_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line">    print(num_list)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"函数代码完成"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gl_num = <span class="number">99</span></span><br><span class="line">gl_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">demo(gl_num, gl_list)</span><br><span class="line">print(gl_num)</span><br><span class="line">print(gl_list)</span><br></pre></td></tr></table></figure><blockquote><p>问题 2：如果传递的参数是 <strong>可变类型</strong>，在函数内部，使用 <strong>方法</strong> 修改了数据的内容，<strong>同样会影响到外部的数据</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mutable</span><span class="params">(num_list)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># num_list = [1, 2, 3]</span></span><br><span class="line">    num_list.extend([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    </span><br><span class="line">    print(num_list)</span><br><span class="line"></span><br><span class="line">gl_list = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">mutable(gl_list)</span><br><span class="line">print(gl_list)</span><br></pre></td></tr></table></figure><ul><li>在 <code>python</code> 中，列表变量调用 <code>+=</code> 本质上是在执行列表变量的 <code>extend</code> 方法，不会修改变量的引用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(num, num_list)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"函数内部代码"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># num = num + num</span></span><br><span class="line">    num += num</span><br><span class="line">    <span class="comment"># num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用</span></span><br><span class="line">    <span class="comment"># 函数执行结束后，外部数据同样会发生变化</span></span><br><span class="line">    num_list += num_list</span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line">    print(num_list)</span><br><span class="line">    print(<span class="string">"函数代码完成"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gl_num = <span class="number">9</span></span><br><span class="line">gl_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">demo(gl_num, gl_list)</span><br><span class="line">print(gl_num)</span><br><span class="line">print(gl_list)</span><br></pre></td></tr></table></figure><h3 id="3-2-缺省参数"><a href="#3-2-缺省参数" class="headerlink" title="3.2 缺省参数"></a>3.2 缺省参数</h3><ul><li>定义函数时，可以给 <strong>某个参数</strong> 指定一个<strong>默认值</strong>，具有默认值的参数就叫做 <strong>缺省参数</strong></li><li>调用函数时，如果没有传入 <strong>缺省参数</strong> 的值，则在函数内部使用定义函数时指定的 <strong>参数默认值</strong></li><li>函数的缺省参数，<strong>将常见的值设置为参数的缺省值</strong>，从而 <strong>简化函数的调用</strong></li><li>例如：对列表排序的方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gl_num_list = [<span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认就是升序排序，因为这种应用需求更多</span></span><br><span class="line">gl_num_list.sort()</span><br><span class="line">print(gl_num_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有当需要降序排序时，才需要传递 `reverse` 参数</span></span><br><span class="line">gl_num_list.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">print(gl_num_list)</span><br></pre></td></tr></table></figure><h4 id="指定函数的缺省参数"><a href="#指定函数的缺省参数" class="headerlink" title="指定函数的缺省参数"></a>指定函数的缺省参数</h4><ul><li>在参数后使用赋值语句，可以指定参数的缺省值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_info</span><span class="params">(name, gender=True)</span>:</span></span><br><span class="line"></span><br><span class="line">    gender_text = <span class="string">"男生"</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> gender:</span><br><span class="line">        gender_text = <span class="string">"女生"</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"%s 是 %s"</span> % (name, gender_text))</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><ol><li>缺省参数，需要使用 <strong>最常见的值</strong> 作为默认值！</li><li>如果一个参数的值 <strong>不能确定</strong>，则不应该设置默认值，具体的数值在调用函数时，由外界传递！</li></ol><h4 id="缺省参数的注意事项"><a href="#缺省参数的注意事项" class="headerlink" title="缺省参数的注意事项"></a>缺省参数的注意事项</h4><h5 id="1-缺省参数的定义位置"><a href="#1-缺省参数的定义位置" class="headerlink" title="1) 缺省参数的定义位置"></a>1) 缺省参数的定义位置</h5><ul><li><strong>必须保证</strong> <strong>带有默认值的缺省参数</strong> <strong>在参数列表末尾</strong></li><li>所以，以下定义是错误的！</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_info</span><span class="params">(name, gender=True, title)</span>:</span></span><br></pre></td></tr></table></figure><h5 id="2-调用带有多个缺省参数的函数"><a href="#2-调用带有多个缺省参数的函数" class="headerlink" title="2) 调用带有多个缺省参数的函数"></a>2) 调用带有多个缺省参数的函数</h5><ul><li>在 <strong>调用函数时</strong>，如果有 <strong>多个缺省参数</strong>，<strong>需要指定参数名</strong>，这样解释器才能够知道参数的对应关系！</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_info</span><span class="params">(name, title=<span class="string">""</span>, gender=True)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param title: 职位</span></span><br><span class="line"><span class="string">    :param name: 班上同学的姓名</span></span><br><span class="line"><span class="string">    :param gender: True 男生 False 女生</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    gender_text = <span class="string">"男生"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> gender:</span><br><span class="line">        gender_text = <span class="string">"女生"</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"%s%s 是 %s"</span> % (title, name, gender_text))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！</span></span><br><span class="line">print_info(<span class="string">"小明"</span>)</span><br><span class="line">print_info(<span class="string">"老王"</span>, title=<span class="string">"班长"</span>)</span><br><span class="line">print_info(<span class="string">"小美"</span>, gender=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="3-3-多值参数"><a href="#3-3-多值参数" class="headerlink" title="3.3 多值参数"></a>3.3 多值参数</h3><h4 id="定义支持多值参数的函数"><a href="#定义支持多值参数的函数" class="headerlink" title="定义支持多值参数的函数"></a>定义支持多值参数的函数</h4><ul><li>有时可能需要 <strong>一个函数</strong> 能够处理的参数 <strong>个数</strong> 是不确定的，这个时候，就可以使用 <strong>多值参数</strong></li><li><code>python</code> 中有 <strong>两种</strong> 多值参数：<ul><li>参数名前增加 <strong>一个</strong> <code>*</code> 可以接收 <strong>元组</strong></li><li>参数名前增加 <strong>两个</strong> <code>*</code> 可以接收 <strong>字典</strong></li></ul></li><li><p>一般在给多值参数命名时，<strong>习惯</strong>使用以下两个名字</p><ul><li><code>*args</code> —— 存放 <strong>元组</strong> 参数，前面有一个 <code>*</code></li><li><code>**kwargs</code> —— 存放 <strong>字典</strong> 参数，前面有两个 <code>*</code></li></ul></li><li><p><code>args</code> 是 <code>arguments</code> 的缩写，有变量的含义</p></li><li><code>kw</code> 是 <code>keyword</code> 的缩写，<code>kwargs</code> 可以记忆 <strong>键值对参数</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(num, *args, **kwargs)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, name=<span class="string">"小明"</span>, age=<span class="number">18</span>, gender=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><blockquote><p>提示：<strong>多值参数</strong> 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，<strong>有利于我们能够读懂大牛的代码</strong></p></blockquote><h4 id="多值参数案例-——-计算任意多个数字的和"><a href="#多值参数案例-——-计算任意多个数字的和" class="headerlink" title="多值参数案例 —— 计算任意多个数字的和"></a>多值参数案例 —— 计算任意多个数字的和</h4><p><strong>需求</strong></p><ol><li>定义一个函数 <code>sum_numbers</code>，可以接收的 <strong>任意多个整数</strong></li><li>功能要求：将传递的 <strong>所有数字累加</strong> 并且返回累加结果</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_numbers</span><span class="params">(*args)</span>:</span></span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 遍历 args 元组顺序求和</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">        num += n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">print(sum_numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><h4 id="元组和字典的拆包（知道）"><a href="#元组和字典的拆包（知道）" class="headerlink" title="元组和字典的拆包（知道）"></a>元组和字典的拆包（知道）</h4><ul><li>在调用带有多值参数的函数时，如果希望：<ul><li>将一个 <strong>元组变量</strong>，直接传递给 <code>args</code></li><li>将一个 <strong>字典变量</strong>，直接传递给 <code>kwargs</code></li></ul></li><li>就可以使用 <strong>拆包</strong>，简化参数的传递，<strong>拆包</strong> 的方式是：<ul><li>在 <strong>元组变量前</strong>，增加 <strong>一个</strong> <code>*</code></li><li>在 <strong>字典变量前</strong>，增加 <strong>两个</strong> <code>*</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要将一个元组变量/字典变量传递给函数对应的参数</span></span><br><span class="line">gl_nums = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">gl_xiaoming = &#123;<span class="string">"name"</span>: <span class="string">"小明"</span>, <span class="string">"age"</span>: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># demo(gl_nums, gl_xiaoming)--&gt;会把 num_tuple 和 xiaoming 作为元组传递个 args</span></span><br><span class="line">demo(*gl_nums, **gl_xiaoming)</span><br></pre></td></tr></table></figure><h2 id="04-函数的递归"><a href="#04-函数的递归" class="headerlink" title="04. 函数的递归"></a>04. 函数的递归</h2><blockquote><p>函数调用自身的 <strong>编程技巧</strong> 称为递归</p></blockquote><h3 id="4-1-递归函数的特点"><a href="#4-1-递归函数的特点" class="headerlink" title="4.1 递归函数的特点"></a>4.1 递归函数的特点</h3><p><strong>特点</strong></p><ul><li><strong>一个函数</strong> <strong>内部</strong> <strong>调用自己</strong><ul><li>函数内部可以调用其他函数，当然在函数内部也可以调用自己</li></ul></li></ul><p><strong>代码特点</strong></p><ol><li>函数内部的 <strong>代码</strong> 是相同的，只是针对 <strong>参数</strong> 不同，<strong>处理的结果不同</strong></li><li>当 <strong>参数满足一个条件</strong> 时，函数不再执行<ul><li><strong>这个非常重要</strong>，通常被称为递归的出口，否则 <strong>会出现死循环</strong>！</li></ul></li></ol><p>示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_numbers</span><span class="params">(num)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归的出口很重要，否则会出现死循环</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    sum_numbers(num - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">sum_numbers(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/002_递归调用示意图I.png" alt></p><h3 id="4-2-递归案例-——-计算数字累加"><a href="#4-2-递归案例-——-计算数字累加" class="headerlink" title="4.2 递归案例 —— 计算数字累加"></a>4.2 递归案例 —— 计算数字累加</h3><p><strong>需求</strong></p><ol><li>定义一个函数 <code>sum_numbers</code></li><li>能够接收一个 <code>num</code> 的整数参数</li><li>计算 1 + 2 + … num 的结果</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_numbers</span><span class="params">(num)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 假设 sum_numbers 能够完成 num - 1 的累加</span></span><br><span class="line">    temp = sum_numbers(num - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 函数内部的核心算法就是 两个数字的相加</span></span><br><span class="line">    <span class="keyword">return</span> num + temp</span><br><span class="line"></span><br><span class="line">print(sum_numbers(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/002_递归调用示意图.png" alt></p><blockquote><p>提示：递归是一个 <strong>编程技巧</strong>，初次接触递归会感觉有些吃力！在处理 <strong>不确定的循环条件时</strong>，格外的有用，例如：<strong>遍历整个文件目录的结构</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级变量类型</title>
      <link href="/2019/04/22/python-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/04/22/python-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>列表</li><li>元组</li><li>字典</li><li>字符串</li><li>公共方法</li><li><p>变量高级</p><a id="more"></a><h3 id="知识点回顾"><a href="#知识点回顾" class="headerlink" title="知识点回顾"></a>知识点回顾</h3></li><li><p>Python 中数据类型可以分为 <strong>数字型</strong> 和 <strong>非数字型</strong></p></li><li>数字型<ul><li>整型 (<code>int</code>)</li><li>浮点型（<code>float</code>）</li><li>布尔型（<code>bool</code>） <ul><li>真 <code>True</code> <code>非 0 数</code> —— <strong>非零即真</strong></li><li>假 <code>False</code> <code>0</code></li></ul></li><li>复数型 (<code>complex</code>)<ul><li>主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题</li></ul></li></ul></li><li><p>非数字型</p><ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li></ul></li><li><p>在 <code>Python</code> 中，所有 <strong>非数字型变量</strong> 都支持以下特点：</p><ol><li>都是一个 <strong>序列</strong> <code>sequence</code>，也可以理解为 <strong>容器</strong></li><li><strong>取值</strong> <code>[]</code></li><li><strong>遍历</strong> <code>for in</code></li><li><strong>计算长度</strong>、<strong>最大/最小值</strong>、<strong>比较</strong>、<strong>删除</strong></li><li><strong>链接</strong> <code>+</code> 和 <strong>重复</strong> <code>*</code></li><li><strong>切片</strong></li></ol></li></ul><h2 id="1-列表"><a href="#1-列表" class="headerlink" title="1. 列表"></a>1. 列表</h2><h3 id="1-1-列表的定义"><a href="#1-1-列表的定义" class="headerlink" title="1.1 列表的定义"></a>1.1 列表的定义</h3><ul><li><code>List</code>（列表） 是 <code>Python</code> 中使用 <strong>最频繁</strong> 的数据类型，在其他语言中通常叫做 <strong>数组</strong></li><li>专门用于存储 <strong>一串 信息</strong></li><li>列表用 <code>[]</code> 定义，<strong>数据</strong> 之间使用 <code>,</code> 分隔</li><li>列表的 <strong>索引</strong> 从 <code>0</code> 开始<ul><li><strong>索引</strong> 就是数据在 <strong>列表</strong> 中的位置编号，<strong>索引</strong> 又可以被称为 <strong>下标</strong></li></ul></li></ul><blockquote><p>注意：从列表中取值时，如果 <strong>超出索引范围</strong>，程序会报错</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name_list = [<span class="string">"zhangsan"</span>, <span class="string">"lisi"</span>, <span class="string">"wangwu"</span>]</span><br></pre></td></tr></table></figure><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/001_列表示意图.png" alt></p><h3 id="1-2-列表常用操作"><a href="#1-2-列表常用操作" class="headerlink" title="1.2 列表常用操作"></a>1.2 列表常用操作</h3><ul><li>在 <code>ipython3</code> 中定义一个 <strong>列表</strong>，例如：<code>name_list = []</code></li><li>输入 <code>name_list.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>列表</strong> 能够使用的 <strong>方法</strong> 如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: name_list.</span><br><span class="line">name_list.append   name_list.count    name_list.insert   name_list.reverse</span><br><span class="line">name_list.clear    name_list.extend   name_list.pop      name_list.sort</span><br><span class="line">name_list.copy     name_list.index    name_list.remove</span><br></pre></td></tr></table></figure><h4 id="del-关键字（科普）"><a href="#del-关键字（科普）" class="headerlink" title="del 关键字（科普）"></a>del 关键字（科普）</h4><ul><li>使用 <code>del</code> 关键字(<code>delete</code>) 同样可以删除列表中元素</li><li><code>del</code> 关键字本质上是用来 <strong>将一个变量从内存中删除的</strong></li><li>如果使用 <code>del</code> 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> name_list[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>在日常开发中，要从列表删除数据，建议 <strong>使用列表提供的方法</strong></p></blockquote><h4 id="关键字、函数和方法（科普）"><a href="#关键字、函数和方法（科普）" class="headerlink" title="关键字、函数和方法（科普）"></a>关键字、函数和方法（科普）</h4><ul><li><strong>关键字</strong> 是 Python 内置的、具有特殊意义的标识符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> keyword</span><br><span class="line">In [<span class="number">2</span>]: print(keyword.kwlist)</span><br><span class="line">In [<span class="number">3</span>]: print(len(keyword.kwlist))</span><br></pre></td></tr></table></figure><blockquote><p>关键字后面不需要使用括号</p></blockquote><ul><li><strong>函数</strong> 封装了独立功能，可以直接调用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(参数)</span><br></pre></td></tr></table></figure><blockquote><p>函数需要死记硬背</p></blockquote><ul><li><strong>方法</strong> 和函数类似，同样是封装了独立的功能</li><li><strong>方法</strong> 需要通过 <strong>对象</strong> 来调用，表示针对这个 <strong>对象</strong> 要做的操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.方法名(参数)</span><br></pre></td></tr></table></figure><blockquote><p>在变量后面输入 <code>.</code>，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多</p></blockquote><h3 id="1-3-循环遍历"><a href="#1-3-循环遍历" class="headerlink" title="1.3 循环遍历"></a>1.3 循环遍历</h3><ul><li><p><strong>遍历</strong> 就是 <strong>从头到尾</strong> <strong>依次</strong> 从 <strong>列表</strong> 中获取数据</p><ul><li>在 <strong>循环体内部</strong> 针对 <strong>每一个元素</strong>，执行相同的操作</li></ul></li><li><p>在 <code>Python</code> 中为了提高列表的遍历效率，专门提供的 <strong>迭代 iteration 遍历</strong></p></li><li>使用 <code>for</code> 就能够实现迭代遍历</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for 循环内部使用的变量 in 列表</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> name_list:</span><br><span class="line"></span><br><span class="line">    循环内部针对列表元素进行操作</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/002_forin循环流程图.png" alt></p><h3 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 <strong>应用场景</strong></h3><ul><li>尽管 <code>Python</code> 的 <strong>列表</strong> 中可以 <strong>存储不同类型的数据</strong></li><li>但是在开发中，更多的应用场景是<ol><li><strong>列表</strong> 存储相同类型的数据</li><li>通过 <strong>迭代遍历</strong>，在循环体内部，针对列表中的每一项元素，执行相同的操作</li></ol></li></ul><h2 id="2-元组"><a href="#2-元组" class="headerlink" title="2. 元组"></a>2. 元组</h2><h3 id="2-1-元组的定义"><a href="#2-1-元组的定义" class="headerlink" title="2.1 元组的定义"></a>2.1 元组的定义</h3><ul><li><code>Tuple</code>（元组）与列表类似，不同之处在于元组的 <strong>元素不能修改</strong><ul><li><strong>元组</strong> 表示多个元素组成的序列</li><li><strong>元组</strong> 在 <code>Python</code> 开发中，有特定的应用场景</li></ul></li><li>用于存储 <strong>一串 信息</strong>，<strong>数据</strong> 之间使用 <code>,</code> 分隔</li><li>元组用 <code>()</code> 定义</li><li>元组的 <strong>索引</strong> 从 <code>0</code> 开始<ul><li><strong>索引</strong> 就是数据在 <strong>元组</strong> 中的位置编号</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_tuple = (<span class="string">"zhangsan"</span>, <span class="number">18</span>, <span class="number">1.75</span>)</span><br></pre></td></tr></table></figure><h4 id="创建空元组"><a href="#创建空元组" class="headerlink" title="创建空元组"></a>创建空元组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_tuple = ()</span><br></pre></td></tr></table></figure><h4 id="元组中-只包含一个元素-时，需要-在元素后面添加逗号"><a href="#元组中-只包含一个元素-时，需要-在元素后面添加逗号" class="headerlink" title="元组中 只包含一个元素 时，需要 在元素后面添加逗号"></a>元组中 <strong>只包含一个元素</strong> 时，需要 <strong>在元素后面添加逗号</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_tuple = (<span class="number">50</span>, )</span><br></pre></td></tr></table></figure><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/003_元组示意图.png" alt></p><h3 id="2-2-元组常用操作"><a href="#2-2-元组常用操作" class="headerlink" title="2.2 元组常用操作"></a>2.2 元组常用操作</h3><ul><li>在 <code>ipython3</code> 中定义一个 <strong>元组</strong>，例如：<code>info = ()</code></li><li>输入 <code>info.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>元组</strong> 能够使用的函数如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info.count  info.index</span><br></pre></td></tr></table></figure><blockquote><p>有关 <strong>元组</strong> 的 <strong>常用操作</strong> 可以参照上图练习</p></blockquote><h3 id="2-3-循环遍历"><a href="#2-3-循环遍历" class="headerlink" title="2.3 循环遍历"></a>2.3 循环遍历</h3><ul><li><strong>取值</strong> 就是从 <strong>元组</strong> 中获取存储在指定位置的数据</li><li><strong>遍历</strong> 就是 <strong>从头到尾</strong> <strong>依次</strong> 从 <strong>元组</strong> 中获取数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for 循环内部使用的变量 in 元组</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> info:</span><br><span class="line"></span><br><span class="line">    循环内部针对元组元素进行操作</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure><blockquote><ul><li>在 <code>Python</code> 中，可以使用 <code>for</code> 循环遍历所有非数字型类型的变量：<strong>列表</strong>、<strong>元组</strong>、<strong>字典</strong> 以及 <strong>字符串</strong></li><li>提示：在实际开发中，除非 <strong>能够确认元组中的数据类型</strong>，否则针对元组的循环遍历需求并不是很多</li></ul></blockquote><h3 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a>2.4 应用场景</h3><ul><li>尽管可以使用 <code>for in</code> 遍历 <strong>元组</strong></li><li>但是在开发中，更多的应用场景是：<ul><li><strong>函数的 参数 和 返回值</strong>，一个函数可以接收 <strong>任意多个参数</strong>，或者 <strong>一次返回多个数据</strong><ul><li>有关 <strong>函数的参数 和 返回值</strong>，在后续 <strong>函数高级</strong> 给大家介绍</li></ul></li><li><strong>格式字符串</strong>，格式化字符串后面的 <code>()</code> 本质上就是一个元组</li><li><strong>让列表不可以被修改</strong>，以保护数据安全</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info = (<span class="string">"zhangsan"</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"%s 的年龄是 %d"</span> % info)</span><br></pre></td></tr></table></figure><h4 id="元组和列表之间的转换"><a href="#元组和列表之间的转换" class="headerlink" title="元组和列表之间的转换"></a>元组和列表之间的转换</h4><ul><li>使用 <code>list</code> 函数可以把元组转换成列表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(元组)</span><br></pre></td></tr></table></figure><ul><li>使用 <code>tuple</code> 函数可以把列表转换成元组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple(列表)</span><br></pre></td></tr></table></figure><h2 id="3-字典"><a href="#3-字典" class="headerlink" title="3. 字典"></a>3. 字典</h2><h3 id="3-1-字典的定义"><a href="#3-1-字典的定义" class="headerlink" title="3.1 字典的定义"></a>3.1 字典的定义</h3><ul><li><code>dictionary</code>（字典） 是 <strong>除列表以外</strong> <code>Python</code> 之中 <strong>最灵活</strong> 的数据类型</li><li>字典同样可以用来 <strong>存储多个数据</strong><ul><li>通常用于存储 <strong>描述一个 <code>物体</code> 的相关信息</strong> </li></ul></li><li>和列表的区别<ul><li><strong>列表</strong> 是 <strong>有序</strong> 的对象集合</li><li><strong>字典</strong> 是 <strong>无序</strong> 的对象集合</li></ul></li><li>字典用 <code>{}</code> 定义</li><li>字典使用 <strong>键值对</strong> 存储数据，键值对之间使用 <code>,</code> 分隔<ul><li><strong>键</strong> <code>key</code> 是索引</li><li><strong>值</strong> <code>value</code> 是数据</li><li><strong>键</strong> 和 <strong>值</strong> 之间使用 <code>:</code> 分隔</li><li><strong>键必须是唯一的</strong></li><li><strong>值</strong> 可以取任何数据类型，但 <strong>键</strong> 只能使用 <strong>字符串</strong>、<strong>数字</strong>或 <strong>元组</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xiaoming = &#123;<span class="string">"name"</span>: <span class="string">"小明"</span>,</span><br><span class="line">            <span class="string">"age"</span>: <span class="number">18</span>,</span><br><span class="line">            <span class="string">"gender"</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">"height"</span>: <span class="number">1.75</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/002_字典示意图.png" alt></p><h3 id="3-2-字典常用操作"><a href="#3-2-字典常用操作" class="headerlink" title="3.2 字典常用操作"></a>3.2 字典常用操作</h3><ul><li>在 <code>ipython3</code> 中定义一个 <strong>字典</strong>，例如：<code>xiaoming = {}</code></li><li>输入 <code>xiaoming.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>字典</strong> 能够使用的函数如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [1]: xiaoming.</span><br><span class="line">xiaoming.clear       xiaoming.items       xiaoming.setdefault</span><br><span class="line">xiaoming.copy        xiaoming.keys        xiaoming.update</span><br><span class="line">xiaoming.fromkeys    xiaoming.pop         xiaoming.values</span><br><span class="line">xiaoming.get         xiaoming.popitem</span><br></pre></td></tr></table></figure><blockquote><p>有关 <strong>字典</strong> 的 <strong>常用操作</strong> 可以参照上图练习</p></blockquote><h3 id="3-3-循环遍历"><a href="#3-3-循环遍历" class="headerlink" title="3.3 循环遍历"></a>3.3 循环遍历</h3><ul><li><strong>遍历</strong> 就是 <strong>依次</strong> 从 <strong>字典</strong> 中获取所有键值对</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for 循环内部使用的 `key 的变量` in 字典</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> xiaoming:</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"%s: %s"</span> % (k, xiaoming[k]))</span><br></pre></td></tr></table></figure><blockquote><p>提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多</p></blockquote><h3 id="3-4-应用场景"><a href="#3-4-应用场景" class="headerlink" title="3.4 应用场景"></a>3.4 <strong>应用场景</strong></h3><ul><li>尽管可以使用 <code>for in</code> 遍历 <strong>字典</strong></li><li>但是在开发中，更多的应用场景是：<ul><li>使用 <strong>多个键值对</strong>，存储 <strong>描述一个 <code>物体</code> 的相关信息</strong> —— 描述更复杂的数据信息</li><li>将 <strong>多个字典</strong> 放在 <strong>一个列表</strong> 中，再进行遍历，在循环体内部针对每一个字典进行 <strong>相同的处理</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">card_list = [&#123;<span class="string">"name"</span>: <span class="string">"张三"</span>,</span><br><span class="line">              <span class="string">"qq"</span>: <span class="string">"12345"</span>,</span><br><span class="line">              <span class="string">"phone"</span>: <span class="string">"110"</span>&#125;,</span><br><span class="line">             &#123;<span class="string">"name"</span>: <span class="string">"李四"</span>,</span><br><span class="line">              <span class="string">"qq"</span>: <span class="string">"54321"</span>,</span><br><span class="line">              <span class="string">"phone"</span>: <span class="string">"10086"</span>&#125;</span><br><span class="line">             ]</span><br></pre></td></tr></table></figure><h2 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h2><h3 id="4-1-字符串的定义"><a href="#4-1-字符串的定义" class="headerlink" title="4.1 字符串的定义"></a>4.1 字符串的定义</h3><ul><li><strong>字符串</strong> 就是 <strong>一串字符</strong>，是编程语言中表示文本的数据类型</li><li>在 Python 中可以使用 <strong>一对双引号</strong> <code>&quot;</code> 或者 <strong>一对单引号</strong> <code>&#39;</code> 定义一个字符串<ul><li>虽然可以使用 <code>\&quot;</code> 或者 <code>\&#39;</code> 做字符串的转义，但是在实际开发中：<ul><li>如果字符串内部需要使用 <code>&quot;</code>，可以使用 <code>&#39;</code> 定义字符串</li><li>如果字符串内部需要使用 <code>&#39;</code>，可以使用 <code>&quot;</code> 定义字符串</li></ul></li></ul></li><li>可以使用 <strong>索引</strong> 获取一个字符串中 <strong>指定位置的字符</strong>，索引计数从 <strong>0</strong> 开始</li><li>也可以使用 <code>for</code> <strong>循环遍历</strong> 字符串中每一个字符</li></ul><blockquote><p>大多数编程语言都是用 <code>&quot;</code> 来定义字符串</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">"Hello Python"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> string:</span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/005_字符串示意图.png" alt></p><h3 id="4-2-字符串的常用操作"><a href="#4-2-字符串的常用操作" class="headerlink" title="4.2 字符串的常用操作"></a>4.2 字符串的常用操作</h3><ul><li>在 <code>ipython3</code> 中定义一个 <strong>字符串</strong>，例如：<code>hello_str = &quot;&quot;</code></li><li>输入 <code>hello_str.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>字符串</strong> 能够使用的 <strong>方法</strong> 如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [1]: hello_str.</span><br><span class="line">hello_str.capitalize    hello_str.isidentifier  hello_str.rindex</span><br><span class="line">hello_str.casefold      hello_str.islower       hello_str.rjust</span><br><span class="line">hello_str.center        hello_str.isnumeric     hello_str.rpartition</span><br><span class="line">hello_str.count         hello_str.isprintable   hello_str.rsplit</span><br><span class="line">hello_str.encode        hello_str.isspace       hello_str.rstrip</span><br><span class="line">hello_str.endswith      hello_str.istitle       hello_str.split</span><br><span class="line">hello_str.expandtabs    hello_str.isupper       hello_str.splitlines</span><br><span class="line">hello_str.find          hello_str.join          hello_str.startswith</span><br><span class="line">hello_str.format        hello_str.ljust         hello_str.strip</span><br><span class="line">hello_str.format_map    hello_str.lower         hello_str.swapcase</span><br><span class="line">hello_str.index         hello_str.lstrip        hello_str.title</span><br><span class="line">hello_str.isalnum       hello_str.maketrans     hello_str.translate</span><br><span class="line">hello_str.isalpha       hello_str.partition     hello_str.upper</span><br><span class="line">hello_str.isdecimal     hello_str.replace       hello_str.zfill</span><br><span class="line">hello_str.isdigit       hello_str.rfind</span><br></pre></td></tr></table></figure><blockquote><p>提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！</p></blockquote><h4 id="1-判断类型-9"><a href="#1-判断类型-9" class="headerlink" title="1) 判断类型 - 9"></a>1) 判断类型 - 9</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.isspace()</td><td>如果 string 中只包含空格，则返回 True</td></tr><tr><td>string.isalnum()</td><td>如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True</td></tr><tr><td>string.isalpha()</td><td>如果 string 至少有一个字符并且所有字符都是字母则返回 True</td></tr><tr><td>string.isdecimal()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code></td></tr><tr><td>string.isdigit()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code>、<code>⑴</code>、<code>\u00b2</code></td></tr><tr><td>string.isnumeric()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code>，<code>汉字数字</code></td></tr><tr><td>string.istitle()</td><td>如果 string 是标题化的(每个单词的首字母大写)则返回 True</td></tr><tr><td>string.islower()</td><td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True</td></tr><tr><td>string.isupper()</td><td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True</td></tr></tbody></table><h4 id="2-查找和替换-7"><a href="#2-查找和替换-7" class="headerlink" title="2) 查找和替换 - 7"></a>2) 查找和替换 - 7</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.startswith(str)</td><td>检查字符串是否是以 str 开头，是则返回 True</td></tr><tr><td>string.endswith(str)</td><td>检查字符串是否是以 str 结束，是则返回 True</td></tr><tr><td>string.find(str, start=0, end=len(string))</td><td>检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 <code>-1</code></td></tr><tr><td>string.rfind(str, start=0, end=len(string))</td><td>类似于 find()，不过是从右边开始查找</td></tr><tr><td>string.index(str, start=0, end=len(string))</td><td>跟 find() 方法类似，不过如果 str 不在 string 会报错</td></tr><tr><td>string.rindex(str, start=0, end=len(string))</td><td>类似于 index()，不过是从右边开始</td></tr><tr><td>string.replace(old_str, new_str, num=string.count(old))</td><td>把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次</td></tr></tbody></table><h4 id="3-大小写转换-5"><a href="#3-大小写转换-5" class="headerlink" title="3) 大小写转换 - 5"></a>3) 大小写转换 - 5</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.capitalize()</td><td>把字符串的第一个字符大写</td></tr><tr><td>string.title()</td><td>把字符串的每个单词首字母大写</td></tr><tr><td>string.lower()</td><td>转换 string 中所有大写字符为小写</td></tr><tr><td>string.upper()</td><td>转换 string 中的小写字母为大写</td></tr><tr><td>string.swapcase()</td><td>翻转 string 中的大小写</td></tr></tbody></table><h4 id="4-文本对齐-3"><a href="#4-文本对齐-3" class="headerlink" title="4) 文本对齐 - 3"></a>4) 文本对齐 - 3</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.ljust(width)</td><td>返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串</td></tr><tr><td>string.rjust(width)</td><td>返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串</td></tr><tr><td>string.center(width)</td><td>返回一个原字符串居中，并使用空格填充至长度 width 的新字符串</td></tr></tbody></table><h4 id="5-去除空白字符-3"><a href="#5-去除空白字符-3" class="headerlink" title="5) 去除空白字符 - 3"></a>5) 去除空白字符 - 3</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.lstrip()</td><td>截掉 string 左边（开始）的空白字符</td></tr><tr><td>string.rstrip()</td><td>截掉 string 右边（末尾）的空白字符</td></tr><tr><td>string.strip()</td><td>截掉 string 左右两边的空白字符</td></tr></tbody></table><h4 id="6-拆分和连接-5"><a href="#6-拆分和连接-5" class="headerlink" title="6) 拆分和连接 - 5"></a>6) 拆分和连接 - 5</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.partition(str)</td><td>把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面)</td></tr><tr><td>string.rpartition(str)</td><td>类似于 partition() 方法，不过是从右边开始查找</td></tr><tr><td>string.split(str=””, num)</td><td>以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\r’, ‘\t’, ‘\n’ 和空格</td></tr><tr><td>string.splitlines()</td><td>按照行(‘\r’, ‘\n’, ‘\r\n’)分隔，返回一个包含各行作为元素的列表</td></tr><tr><td>string.join(seq)</td><td>以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串</td></tr></tbody></table><h3 id="4-3-字符串的切片"><a href="#4-3-字符串的切片" class="headerlink" title="4.3 字符串的切片"></a>4.3 字符串的切片</h3><ul><li><strong>切片</strong> 方法适用于 <strong>字符串</strong>、<strong>列表</strong>、<strong>元组</strong><ul><li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li><li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li><li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li></ul></li></ul><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/006_字符串索引示意图.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串[开始索引:结束索引:步长]</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>指定的区间属于 <strong>左闭右开</strong> 型 <code>[开始索引,  结束索引)</code> =&gt; <code>开始索引 &gt;= 范围 &lt; 结束索引</code><ul><li>从 <code>起始</code> 位开始，到 <strong><code>结束</code>位的前一位</strong> 结束（<strong>不包含结束位本身</strong>)</li></ul></li><li>从头开始，<strong>开始索引</strong> <strong>数字可以省略，冒号不能省略</strong></li><li>到末尾结束，<strong>结束索引</strong> <strong>数字可以省略，冒号不能省略</strong></li><li>步长默认为 <code>1</code>，如果连续切片，<strong>数字和冒号都可以省略</strong></li></ol><h4 id="索引的顺序和倒序"><a href="#索引的顺序和倒序" class="headerlink" title="索引的顺序和倒序"></a>索引的顺序和倒序</h4><ul><li>在 Python 中不仅支持 <strong>顺序索引</strong>，同时还支持 <strong>倒序索引</strong></li><li>所谓倒序索引就是 <strong>从右向左</strong> 计算索引<ul><li>最右边的索引值是 <strong>-1</strong>，依次递减</li></ul></li></ul><p><strong>演练需求</strong></p><ul><li><ol><li>截取从 2 ~ 5 位置 的字符串</li></ol></li><li><ol start="2"><li>截取从 2 ~ <code>末尾</code> 的字符串</li></ol></li><li><ol start="3"><li>截取从 <code>开始</code> ~ 5 位置 的字符串</li></ol></li><li><ol start="4"><li>截取完整的字符串</li></ol></li><li><ol start="5"><li>从开始位置，每隔一个字符截取字符串</li></ol></li><li><ol start="6"><li>从索引 1 开始，每隔一个取一个</li></ol></li><li><ol start="7"><li>截取从 2 ~ <code>末尾 - 1</code> 的字符串</li></ol></li><li><ol start="8"><li>截取字符串末尾两个字符</li></ol></li><li><ol start="9"><li>字符串的逆序</li></ol></li></ul><p><strong>答案</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">num_str = &quot;0123456789&quot;</span><br><span class="line"></span><br><span class="line"># 1. 截取从 2 ~ 5 位置 的字符串</span><br><span class="line">print(num_str[2:6])</span><br><span class="line">---&gt;2345</span><br><span class="line"></span><br><span class="line"># 2. 截取从 2 ~ `末尾` 的字符串</span><br><span class="line">print(num_str[2:])</span><br><span class="line">---&gt;23456789</span><br><span class="line"></span><br><span class="line"># 3. 截取从 `开始` ~ 5 位置 的字符串</span><br><span class="line">print(num_str[:6])</span><br><span class="line">---&gt;012345</span><br><span class="line"></span><br><span class="line"># 4. 截取完整的字符串</span><br><span class="line">print(num_str[:])</span><br><span class="line">---&gt;0123456789</span><br><span class="line"></span><br><span class="line"># 5. 从开始位置，每隔一个字符截取字符串</span><br><span class="line">print(num_str[::2])</span><br><span class="line">---&gt;02468</span><br><span class="line"></span><br><span class="line"># 6. 从索引 1 开始，每隔一个取一个</span><br><span class="line">print(num_str[1::2])</span><br><span class="line">---&gt;13579</span><br><span class="line"></span><br><span class="line"># 倒序切片</span><br><span class="line"># -1 表示倒数第一个字符</span><br><span class="line">print(num_str[-1])</span><br><span class="line">---&gt;9</span><br><span class="line"></span><br><span class="line"># 7. 截取从 2 ~ `末尾 - 1` 的字符串</span><br><span class="line">print(num_str[2:-1])</span><br><span class="line">---&gt;2345678</span><br><span class="line"></span><br><span class="line"># 8. 截取字符串末尾两个字符</span><br><span class="line">print(num_str[-2:])</span><br><span class="line">---&gt;89</span><br><span class="line"></span><br><span class="line"># 9. 字符串的逆序</span><br><span class="line">print(num_str[::-1])</span><br><span class="line">---&gt;9876543210</span><br></pre></td></tr></table></figure><h2 id="5-公共方法"><a href="#5-公共方法" class="headerlink" title="5. 公共方法"></a>5. 公共方法</h2><h3 id="5-1-Python-内置函数"><a href="#5-1-Python-内置函数" class="headerlink" title="5.1 Python 内置函数"></a>5.1 Python 内置函数</h3><p>Python 包含了以下内置函数：</p><table><thead><tr><th>函数</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>len(item)</td><td>计算容器中元素个数</td><td></td></tr><tr><td>del(item)</td><td>删除变量</td><td>del 有两种方式</td></tr><tr><td>max(item)</td><td>返回容器中元素最大值</td><td>如果是字典，只针对 key 比较</td></tr><tr><td>min(item)</td><td>返回容器中元素最小值</td><td>如果是字典，只针对 key 比较</td></tr><tr><td>cmp(item1, item2)</td><td>比较两个值，-1 小于/0 相等/1 大于</td><td>Python 3.x 取消了 cmp 函数</td></tr></tbody></table><p><strong>注意</strong></p><ul><li><strong>字符串</strong> 比较符合以下规则： “0” &lt; “A” &lt; “a”</li></ul><h3 id="5-2-切片"><a href="#5-2-切片" class="headerlink" title="5.2 切片"></a>5.2 切片</h3><table><thead><tr><th style="text-align:center">描述</th><th>Python 表达式</th><th>结果</th><th>支持的数据类型</th></tr></thead><tbody><tr><td style="text-align:center">切片</td><td>“0123456789”[::-2]</td><td>“97531”</td><td>字符串、列表、元组</td></tr></tbody></table><ul><li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li><li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li><li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li></ul><h3 id="5-3-运算符"><a href="#5-3-运算符" class="headerlink" title="5.3 运算符"></a>5.3 运算符</h3><table><thead><tr><th style="text-align:center">运算符</th><th>Python 表达式</th><th>结果</th><th>描述</th><th>支持的数据类型</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td>[1, 2] + [3, 4]</td><td>[1, 2, 3, 4]</td><td>合并</td><td>字符串、列表、元组</td></tr><tr><td style="text-align:center">*</td><td>[“Hi!”] * 4</td><td>[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td><td>重复</td><td>字符串、列表、元组</td></tr><tr><td style="text-align:center">in</td><td>3 in (1, 2, 3)</td><td>True</td><td>元素是否存在</td><td>字符串、列表、元组、字典</td></tr><tr><td style="text-align:center">not in</td><td>4 not in (1, 2, 3)</td><td>True</td><td>元素是否不存在</td><td>字符串、列表、元组、字典</td></tr><tr><td style="text-align:center">&gt; &gt;= == &lt; &lt;=</td><td>(1, 2, 3) &lt; (2, 2, 3)</td><td>True</td><td>元素比较</td><td>字符串、列表、元组</td></tr></tbody></table><p><strong>注意</strong></p><ul><li><code>in</code> 在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></li><li><code>in</code> 和 <code>not in</code> 被称为 <strong>成员运算符</strong></li></ul><h4 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h4><p>成员运算符用于 <strong>测试</strong> 序列中是否包含指定的 <strong>成员</strong></p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False</td><td><code>3 in (1, 2, 3)</code> 返回 <code>True</code></td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False</td><td><code>3 not in (1, 2, 3)</code> 返回 <code>False</code></td></tr></tbody></table><p>注意：在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></p><h3 id="5-4-完整的-for-循环语法"><a href="#5-4-完整的-for-循环语法" class="headerlink" title="5.4 完整的 for 循环语法"></a>5.4 完整的 for 循环语法</h3><ul><li>在 <code>Python</code> 中完整的 <code>for 循环</code> 的语法如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 集合:</span><br><span class="line">    </span><br><span class="line">    循环体代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    没有通过 <span class="keyword">break</span> 退出循环，循环结束后，会执行的代码</span><br></pre></td></tr></table></figure><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>在 <strong>迭代遍历</strong> 嵌套的数据类型时，例如 <strong>一个列表包含了多个字典</strong></li><li>需求：要判断 某一个字典中 是否存在 指定的 值 <ul><li>如果 <strong>存在</strong>，提示并且退出循环</li><li>如果 <strong>不存在</strong>，在 <strong>循环整体结束</strong> 后，希望 <strong>得到一个统一的提示</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">students = [</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"阿土"</span>,</span><br><span class="line">     <span class="string">"age"</span>: <span class="number">20</span>,</span><br><span class="line">     <span class="string">"gender"</span>: <span class="literal">True</span>,</span><br><span class="line">     <span class="string">"height"</span>: <span class="number">1.7</span>,</span><br><span class="line">     <span class="string">"weight"</span>: <span class="number">75.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"小美"</span>,</span><br><span class="line">     <span class="string">"age"</span>: <span class="number">19</span>,</span><br><span class="line">     <span class="string">"gender"</span>: <span class="literal">False</span>,</span><br><span class="line">     <span class="string">"height"</span>: <span class="number">1.6</span>,</span><br><span class="line">     <span class="string">"weight"</span>: <span class="number">45.0</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">find_name = <span class="string">"阿土"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> stu_dict <span class="keyword">in</span> students:</span><br><span class="line"></span><br><span class="line">    print(stu_dict)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断当前遍历的字典中姓名是否为find_name</span></span><br><span class="line">    <span class="keyword">if</span> stu_dict[<span class="string">"name"</span>] == find_name:</span><br><span class="line">        print(<span class="string">"找到了"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"没有找到"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"循环结束"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量进阶</title>
      <link href="/2019/04/22/python-%E5%8F%98%E9%87%8F%E8%BF%9B%E9%98%B6/"/>
      <url>/2019/04/22/python-%E5%8F%98%E9%87%8F%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li><p>变量的引用</p></li><li><p>可变和不可变类型</p></li><li><p>局部变量和全局变量</p></li></ul><a id="more"></a><h2 id="01-变量的引用"><a href="#01-变量的引用" class="headerlink" title="01. 变量的引用"></a>01. 变量的引用</h2><blockquote><ul><li>变量 和 数据 都是保存在 <strong>内存</strong> 中的</li><li>在 <code>Python</code> 中 <strong>函数 的 参数传递</strong> 以及 <strong>返回值</strong> 都是靠 <strong>引用</strong> 传递的</li></ul></blockquote><h3 id="1-1-引用的概念"><a href="#1-1-引用的概念" class="headerlink" title="1.1 引用的概念"></a>1.1 引用的概念</h3><p>在 <code>Python</code> 中</p><ul><li><strong>变量</strong> 和 <strong>数据</strong> 是分开存储的</li><li><strong>数据</strong> 保存在内存中的一个位置</li><li><strong>变量</strong> 中保存着数据在内存中的地址</li><li><strong>变量</strong> 中 <strong>记录数据的地址</strong>，就叫做 <strong>引用</strong></li><li>使用 <code>id()</code> 函数可以查看变量中保存数据所在的 <strong>内存地址</strong></li></ul><blockquote><p>注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 <strong>修改了数据的引用</strong></p><ul><li>变量 <strong>不再</strong> 对之前的数据引用</li><li>变量 <strong>改为</strong> 对新赋值的数据引用</li></ul></blockquote><h3 id="1-2-变量引用-的示例"><a href="#1-2-变量引用-的示例" class="headerlink" title="1.2 变量引用 的示例"></a>1.2 <code>变量引用</code> 的示例</h3><p>在 <code>Python</code> 中，变量的名字类似于 <strong>便签纸</strong> 贴在 <strong>数据</strong> 上</p><ul><li>定义一个整数变量 <code>a</code>，并且赋值为 <code>1</code></li></ul><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">图示</th></tr></thead><tbody><tr><td style="text-align:center">a = 1</td><td style="text-align:center"><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/004_a1tag.png" alt></td></tr></tbody></table><ul><li>将变量 <code>a</code> 赋值为 <code>2</code></li></ul><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">图示</th></tr></thead><tbody><tr><td style="text-align:center">a = 2</td><td style="text-align:center"><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/005_a2tag.png" alt></td></tr></tbody></table><ul><li>定义一个整数变量 <code>b</code>，并且将变量 <code>a</code> 的值赋值给 <code>b</code></li></ul><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">图示</th></tr></thead><tbody><tr><td style="text-align:center">b = a</td><td style="text-align:center"><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/006_ab2tag.png" alt></td></tr></tbody></table><blockquote><p>变量 <code>b</code> 是第 2 个贴在数字 <code>2</code> 上的标签</p></blockquote><h3 id="1-3-函数的参数和返回值的传递"><a href="#1-3-函数的参数和返回值的传递" class="headerlink" title="1.3 函数的参数和返回值的传递"></a>1.3 函数的参数和返回值的传递</h3><p>在 <code>Python</code> 中，函数的 <strong>实参</strong>/<strong>返回值</strong> 都是是靠 <strong>引用</strong> 来传递来的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(num)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line">    print(<span class="string">"%d 在函数内的内存地址是 %x"</span> % (num, id(num)))</span><br><span class="line"></span><br><span class="line">    result = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"返回值 %d 在内存中的地址是 %x"</span> % (result, id(result)))</span><br><span class="line">    print(<span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  result</span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">print(<span class="string">"调用函数前 内存地址是 %x"</span> % id(a))</span><br><span class="line"></span><br><span class="line">r = test(a)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"调用函数后 实参内存地址是 %x"</span> % id(a))</span><br><span class="line">print(<span class="string">"调用函数后 返回值内存地址是 %x"</span> % id(r))</span><br></pre></td></tr></table></figure><h2 id="02-可变和不可变类型"><a href="#02-可变和不可变类型" class="headerlink" title="02. 可变和不可变类型"></a>02. 可变和不可变类型</h2><ul><li><p><strong>不可变类型</strong>，内存中的数据不允许被修改：</p><ul><li>数字类型 <code>int</code>, <code>bool</code>, <code>float</code>, <code>complex</code>, <code>long(2.x)</code></li><li>字符串 <code>str</code></li><li>元组 <code>tuple</code></li></ul></li><li><p><strong>可变类型</strong>，内存中的数据可以被修改：</p><ul><li>列表 <code>list</code></li><li>字典 <code>dict</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">a = <span class="string">"hello"</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">a = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">demo_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"定义列表后的内存地址 %d"</span> % id(demo_list))</span><br><span class="line"></span><br><span class="line">demo_list.append(<span class="number">999</span>)</span><br><span class="line">demo_list.pop(<span class="number">0</span>)</span><br><span class="line">demo_list.remove(<span class="number">2</span>)</span><br><span class="line">demo_list[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"修改数据后的内存地址 %d"</span> % id(demo_list))</span><br><span class="line"></span><br><span class="line">demo_dict = &#123;<span class="string">"name"</span>: <span class="string">"小明"</span>&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"定义字典后的内存地址 %d"</span> % id(demo_dict))</span><br><span class="line"></span><br><span class="line">demo_dict[<span class="string">"age"</span>] = <span class="number">18</span></span><br><span class="line">demo_dict.pop(<span class="string">"name"</span>)</span><br><span class="line">demo_dict[<span class="string">"name"</span>] = <span class="string">"老王"</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"修改数据后的内存地址 %d"</span> % id(demo_dict))</span><br></pre></td></tr></table></figure><blockquote><p>注意：字典的 <code>key</code> <strong>只能使用不可变类型的数据</strong></p></blockquote><p><strong>注意</strong></p><ol><li><strong>可变类型</strong>的数据变化，是通过 <strong>方法</strong> 来实现的</li><li>如果给一个可变类型的变量，赋值了一个新的数据，<strong>引用会修改</strong><ul><li>变量 <strong>不再</strong> 对之前的数据引用</li><li>变量 <strong>改为</strong> 对新赋值的数据引用</li></ul></li></ol><h3 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希 (hash)"></a>哈希 <code>(hash)</code></h3><ul><li><code>Python</code> 中内置有一个名字叫做 <code>hash(o)</code> 的函数<ul><li>接收一个 <strong>不可变类型</strong> 的数据作为 <strong>参数</strong></li><li><strong>返回</strong> 结果是一个 <strong>整数</strong></li></ul></li><li><code>哈希</code> 是一种 <strong>算法</strong>，其作用就是提取数据的 <strong>特征码（指纹）</strong><ul><li><strong>相同的内容</strong> 得到 <strong>相同的结果</strong></li><li><strong>不同的内容</strong> 得到 <strong>不同的结果</strong></li></ul></li><li>在 <code>Python</code> 中，设置字典的 <strong>键值对</strong> 时，会首先对 <code>key</code> 进行 <code>hash</code> 已决定如何在内存中保存字典的数据，以方便 <strong>后续</strong> 对字典的操作：<strong>增、删、改、查</strong><ul><li>键值对的 <code>key</code> 必须是不可变类型数据</li><li>键值对的 <code>value</code> 可以是任意类型的数据</li></ul></li></ul><h2 id="03-局部变量和全局变量"><a href="#03-局部变量和全局变量" class="headerlink" title="03. 局部变量和全局变量"></a>03. 局部变量和全局变量</h2><ul><li><strong>局部变量</strong> 是在 <strong>函数内部</strong> 定义的变量，<strong>只能在函数内部使用</strong></li><li><strong>全局变量</strong> 是在 <strong>函数外部定义</strong> 的变量（没有定义在某一个函数内），<strong>所有函数</strong> 内部 <strong>都可以使用这个变量</strong></li></ul><blockquote><p>提示：在其他的开发语言中，大多 <strong>不推荐使用全局变量</strong> —— 可变范围太大，导致程序不好维护！</p></blockquote><h3 id="3-1-局部变量"><a href="#3-1-局部变量" class="headerlink" title="3.1 局部变量"></a>3.1 局部变量</h3><ul><li><strong>局部变量</strong> 是在 <strong>函数内部</strong> 定义的变量，<strong>只能在函数内部使用</strong></li><li>函数执行结束后，<strong>函数内部的局部变量，会被系统回收</strong></li><li>不同的函数，可以定义相同的名字的局部变量，但是 <strong>彼此之间</strong> 不会产生影响</li></ul><h4 id="局部变量的作用"><a href="#局部变量的作用" class="headerlink" title="局部变量的作用"></a>局部变量的作用</h4><ul><li>在函数内部使用，<strong>临时</strong> 保存 <strong>函数内部需要使用的数据</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">    num = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"修改后 %d"</span> % num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo2</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">demo1()</span><br><span class="line">demo2()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"over"</span>)</span><br></pre></td></tr></table></figure><h4 id="局部变量的生命周期"><a href="#局部变量的生命周期" class="headerlink" title="局部变量的生命周期"></a>局部变量的生命周期</h4><ul><li>所谓 <strong>生命周期</strong> 就是变量从 <strong>被创建</strong> 到 <strong>被系统回收</strong> 的过程</li><li><strong>局部变量</strong> 在 <strong>函数执行时</strong> 才会被创建</li><li><strong>函数执行结束后</strong> 局部变量 <strong>被系统回收</strong></li><li><strong>局部变量在生命周期</strong> 内，可以用来存储 <strong>函数内部临时使用到的数据</strong></li></ul><h3 id="3-2-全局变量"><a href="#3-2-全局变量" class="headerlink" title="3.2 全局变量"></a>3.2 全局变量</h3><ul><li><strong>全局变量</strong> 是在 <strong>函数外部定义</strong> 的变量，所有函数内部都可以使用这个变量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个全局变量</span></span><br><span class="line">num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo2</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">demo1()</span><br><span class="line">demo2()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"over"</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：函数执行时，<strong>需要处理变量时</strong> 会：</p><ol><li><strong>首先</strong> 查找 <strong>函数内部</strong> 是否存在 <strong>指定名称 的局部变量</strong>，<strong>如果有，直接使用</strong></li><li>如果没有，查找 <strong>函数外部</strong> 是否存在 <strong>指定名称 的全局变量</strong>，<strong>如果有，直接使用</strong></li><li>如果还没有，程序报错！</li></ol><h4 id="1-函数不能直接修改-全局变量的引用"><a href="#1-函数不能直接修改-全局变量的引用" class="headerlink" title="1) 函数不能直接修改 全局变量的引用"></a>1) 函数不能直接修改 <code>全局变量的引用</code></h4><ul><li><strong>全局变量</strong> 是在 <strong>函数外部定义</strong> 的变量（没有定义在某一个函数内），<strong>所有函数</strong> 内部 <strong>都可以使用这个变量</strong></li></ul><blockquote><p>提示：在其他的开发语言中，大多 <strong>不推荐使用全局变量</strong> —— 可变范围太大，导致程序不好维护！</p></blockquote><ul><li>在函数内部，可以 <strong>通过全局变量的引用获取对应的数据</strong></li><li>但是，<strong>不允许直接修改全局变量的引用</strong> —— 使用赋值语句修改全局变量的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"demo1"</span> + <span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo2</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"demo2"</span> + <span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">demo1()</span><br><span class="line">demo2()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"over"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值</p></blockquote><h4 id="2-在函数内部修改全局变量的值"><a href="#2-在函数内部修改全局变量的值" class="headerlink" title="2) 在函数内部修改全局变量的值"></a>2) 在函数内部修改全局变量的值</h4><ul><li>如果在函数中需要修改全局变量，需要使用 <code>global</code> 进行声明</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"demo1"</span> + <span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># global 关键字，告诉 Python 解释器 num 是一个全局变量</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="comment"># 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo2</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"demo2"</span> + <span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">demo1()</span><br><span class="line">demo2()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"over"</span>)</span><br></pre></td></tr></table></figure><h4 id="3-全局变量定义的位置"><a href="#3-全局变量定义的位置" class="headerlink" title="3) 全局变量定义的位置"></a>3) 全局变量定义的位置</h4><ul><li>为了保证所有的函数都能够正确使用到全局变量，应该 <strong>将全局变量定义在其他函数的上方</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"%d"</span> % a)</span><br><span class="line">    print(<span class="string">"%d"</span> % b)</span><br><span class="line">    print(<span class="string">"%d"</span> % c)</span><br><span class="line"></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line">demo()</span><br><span class="line">c = <span class="number">30</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！</li></ul><p><strong>代码结构示意图如下</strong></p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/001_代码结构示意图.png" alt></p><h4 id="4-全局变量命名的建议"><a href="#4-全局变量命名的建议" class="headerlink" title="4) 全局变量命名的建议"></a>4) 全局变量命名的建议</h4><ul><li>为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如：</li><li>全局变量名前应该增加 <code>g_</code> 或者 <code>gl_</code> 的前缀</li></ul><blockquote><p>提示：具体的要求格式，各公司要求可能会有些差异</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++异常</title>
      <link href="/2018/09/22/c++%E9%AB%98%E7%BA%A7-%E5%BC%82%E5%B8%B8/"/>
      <url>/2018/09/22/c++%E9%AB%98%E7%BA%A7-%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>程序的错误大致可以分为三种，分别是<strong>语法错误</strong>、<strong>逻辑错误</strong>和<strong>运行时错误</strong>：</p><ul><li>语法错误在编译和链接阶段就能发现，只有<code>100%</code>符合语法规则的代码才能生成可执行程序。语法错误是最容易发现、最容易定位、最容易排除的错误，程序员最不需要担心的就是这种错误。</li><li>逻辑错误是说我们编写的代码思路有问题，不能够达到最终的目标，这种错误可以通过调试来解决。</li><li>运行时错误是指程序在运行期间发生的错误，例如除数为<code>0</code>、内存分配失败、数组越界、文件不存在等。<code>C++</code>异常（<code>Exception</code>）机制就是为解决运行时错误而引入的。</li></ul><a id="more"></a><h2 id="异常（Exception）机制"><a href="#异常（Exception）机制" class="headerlink" title="异常（Exception）机制"></a>异常（<code>Exception</code>）机制</h2><p><strong>运行时错误如果放任不管，系统就会执行默认的操作，终止程序运行，也就是我们常说的程序崩溃（<code>Crash</code>）。<code>C++</code>提供了异常（<code>Exception</code>）机制，让我们能够捕获运行时错误，给程序一次“起死回生”的机会，或者至少告诉用户发生了什么再终止程序。</strong></p><p> 【例1】一个发生运行时错误的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"http://c.biancheng.net"</span>;</span><br><span class="line">    <span class="keyword">char</span> ch1 = str[<span class="number">100</span>];  <span class="comment">//下标越界，ch1为垃圾值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ch1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> ch2 = str.at(<span class="number">100</span>);  <span class="comment">//下标越界，抛出异常</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ch2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行代码，在控制台输出<code>ch1</code>的值后程序崩溃。下面我们来分析一下原因。</p><p>​    <code>at()</code>是 <code>string</code>类的一个成员函数，它会根据下标来返回字符串的一个字符。与<code>[ ]</code>不同，<code>at()</code>会检查下标是否越界，如果越界就抛出一个异常；而<code>[ ]</code>不做检查，不管下标是多少都会照常访问。</p><blockquote><p>所谓抛出异常，就是报告一个运行时错误，程序员可以根据错误信息来进一步处理。</p></blockquote><p>​    上面的代码中，下标<code>100</code> 显然超出了字符串<code>str</code>的长度。由于第<code>6</code>行代码不会检查下标越界，虽然有逻辑错误，但是程序能够正常运行。而第 <code>8</code>行代码则不同，<code>at()</code>函数检测到下标越界会抛出一个异常，这个异常可以由程序员处理，但是我们在代码中并没有处理，所以系统只能执行默认的操作，也即终止程序执行。</p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>​    我们可以借助<code>C++</code>异常机制来捕获上面的异常，避免程序崩溃。捕获异常的语法为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 可能抛出异常的语句</span></span><br><span class="line"> &#125;<span class="keyword">catch</span>(exceptionType variable)&#123;</span><br><span class="line">   <span class="comment">// 处理异常的语句</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>​    <code>try</code>和<code>catch</code>都是<code>C++</code>中的关键字，后跟语句块，不能省略<code>{ }</code>。<code>try</code>中包含可能会抛出异常的语句，一旦有异常抛出就会被后面的<code>catch</code>捕获。从<code>try</code>的意思可以看出，它只是“检测”语句块有没有异常，如果没有发生异常，它就“检测”不到。<code>catch</code>是“抓住”的意思，用来捕获并处理<code>try</code>检测到的异常；如果<code>try</code>语句块没有检测到异常（没有异常抛出），那么就不会执行<code>catch</code>中的语句。</p><p>​    这就好比，<strong><code>catch</code>告诉<code>try</code>：你去检测一下程序有没有错误，有错误的话就告诉我，我来处理，没有的话就不要理我！</strong></p><p> <code>catch</code>关键字后面的<code>exceptionType variable</code>指明了当前<code>catch</code>可以处理的异常类型，以及具体的出错信息。</p><p> 【例2】修改上面的代码，加入捕获异常的语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"http://c.biancheng.net"</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch1 = str[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ch1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(exception e)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"[1]out of bound!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch2 = str.at(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ch2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(exception &amp;e)&#123;  <span class="comment">//exception类位于&lt;exception&gt;头文件中</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"[2]out of bound!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>(</code><br><code>[2]out of bound!</code></p><p>​    可以看出，第一个<code>try</code>没有捕获到异常，输出了一个没有意义的字符（垃圾值）。因为<code>[ ]</code>不会检查下标越界，不会抛出异常，所以即使有错误，<code>try</code>也检测不到。<strong>换句话说，发生异常时必须将异常明确地抛出，<code>try</code>才能检测到；如果不抛出来，即使有异常<code>try</code>也检测不到。所谓抛出异常，就是明确地告诉程序发生了什么错误。</strong></p><p>​    第二个<code>try</code>检测到了异常，并交给<code>catch</code>处理，执行<code>catch</code>中的语句。需要说明的是，异常一旦抛出，会立刻被<code>try</code>检测到，并且不会再执行异常点（异常发生位置）后面的语句。本例中抛出异常的位置是第<code>17</code>行的 <code>at()</code>函数，它后面的<code>cout</code>语句就不会再被执行，所以看不到它的输出。</p><p>​    <strong>说得直接一点，检测到异常后程序的执行流会发生跳转，从异常点跳转到<code>catch</code> 所在的位置，位于异常点之后的、并且在当前<code>try</code>块内的语句就都不会再执行了；即使 <code>catch</code>语句成功地处理了错误，程序的执行流也不会再回退到异常点，所以这些语句永远都没有执行的机会了。</strong>本例中，第<code>18</code>行代码就是被跳过的代码。</p><p>​    执行完<code>catch</code>块所包含的代码后，程序会继续执行<code>catch</code>块后面的代码，就恢复了正常的执行流。</p><p>​    为了演示「不明确地抛出异常就检测不到异常」，大家不妨将第<code>10</code>行代码改为<code>char ch1 = str[100000000];</code>，访问第<code>100</code>个字符可能不会发生异常，但是访问第 1 亿个字符肯定会发生异常了，这个异常就是内存访问错误。运行更改后的程序，会发现第<code>10</code>行代码产生了异常，导致程序崩溃了，这说明<code>try-catch</code>并没有捕获到这个异常。</p><p>​    关于「如何抛出异常」，我们将在下节讲解，这里重点是让大家明白异常的处理流程：</p><p>​    <code>抛出（Throw）--&gt; 检测（Try） --&gt; 捕获（Catch）</code></p><h3 id="发生异常的位置"><a href="#发生异常的位置" class="headerlink" title="发生异常的位置"></a>发生异常的位置</h3><p>​    异常可以发生在当前的<code>try</code>块中，也可以发生在<code>try</code>块所调用的某个函数中，或者是所调用的函数又调用了另外的一个函数，这个另外的函数中发生了异常。这些异常，都可以被<code>try</code>检测到。</p><p>​     1) 下面的例子演示了<code>try</code>块中直接发生的异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"Unknown Exception"</span>;  <span class="comment">//抛出异常</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">char</span>* &amp;e)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>Unknown Exception</code></p><p>​    <code>throw</code>关键字用来抛出一个异常，这个异常会被 <code>try</code>检测到，进而被<code>catch</code>捕获。关于<code>throw</code>的用法，我们将在下节深入讲解，这里大家只需要知道，在<code>try</code>块中直接抛出的异常会被<code>try</code>检测到。</p><p>​     2) 下面的例子演示了<code>try</code>块中调用的某个函数中发生了异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"Unknown Exception"</span>;  <span class="comment">//抛出异常</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"[1]This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        func();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"[2]This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">char</span>* &amp;e)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>Unknown Exception</code></p><p>​    <code>func()</code>在<code>try</code>块中被调用，它抛出的异常会被<code>try</code>检测到，进而被<code>catch</code>捕获。从运行结果可以看出，<code>func()</code>中的<code>cout</code>和<code>try</code>中的<code>cout</code>都没有被执行。</p><p>​     3)<code>try</code>块中调用了某个函数，该函数又调用了另外的一个函数，这个另外的函数抛出了异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"Unknown Exception"</span>;  <span class="comment">//抛出异常</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"[1]This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func_inner();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"[2]This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        func_outer();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"[3]This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">char</span>* &amp;e)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>Unknown Exception</code></p><p>​    发生异常后，程序的执行流会沿着函数的调用链往前回退，直到遇见<code>try</code>才停止。在这个回退过程中，调用链中剩下的代码（所有函数中未被执行的代码）都会被跳过，没有执行的机会了。</p><h2 id="异常类型以及多级catch匹配"><a href="#异常类型以及多级catch匹配" class="headerlink" title="异常类型以及多级catch匹配"></a>异常类型以及多级<code>catch</code>匹配</h2><p>首先来回顾一下上节讲到的<code>try-catch</code>的用法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 可能抛出异常的语句</span></span><br><span class="line"> &#125;<span class="keyword">catch</span>(exceptionType variable)&#123;</span><br><span class="line">   <span class="comment">// 处理异常的语句</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>​    我们还遗留下一个问题，就是<code>catch</code>关键字后边的<code>exceptionType variable</code>，这节就来详细分析一下。</p><p>​    <code>exceptionType</code>是异常类型，它指明了当前的<code></code> catch <code>可以处理什么类型的异常；</code>variable`是一个变量，用来接收异常信息。当程序抛出异常时，会创建一份数据，这份数据包含了错误信息，程序员可以根据这些信息来判断到底出了什么问题，接下来怎么处理。</p><p>​    异常既然是一份数据，那么就应该有数据类型。<code>C++</code>规定，异常类型可以是<code>int</code>、<code>char</code>、<code>float</code>、<code>bool</code>等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型。<code>C++</code>语言本身以及标准库中的函数抛出的异常，都是<code>exception</code>类或其子类的异常。也就是说，抛出异常时，会创建一个<code>exception</code>类或其子类的对象。</p><p>​    <code>exceptionType variable</code>和函数的形参非常类似，当异常发生后，会将异常数据传递给<code>variable</code>这个变量，这和函数传参的过程类似。当然，只有跟<code>exceptionType</code>类型匹配的异常数据才会被传递给<code>variable</code>，否则 <code>catch</code>不会接收这份异常数据，也不会执行<code>catch</code>块中的语句。换句话说，<code>catch</code>不会处理当前的异常。</p><p>​    我们可以将<code>catch</code>看做一个没有返回值的函数，当异常发生后<code>catch</code>会被调用，并且会接收实参（异常数据）。</p><p> 但是<code>catch</code>和真正的函数调用又有区别：</p><ul><li>真正的函数调用，形参和实参的类型必须要匹配，或者可以自动转换，否则在编译阶段就报错了。</li><li>而对于<code>catch</code>，异常是在运行阶段产生的，它可以是任何类型，没法提前预测，所以不能在编译阶段判断类型是否正确，只能等到程序运行后，真的抛出异常了，再将异常类型和<code>catch</code>能处理的类型进行匹配，匹配成功的话就“调用”当前的<code>catch</code>，否则就忽略当前的<code>catch</code>。</li></ul><p>总起来说，<code>catch</code> 和真正的函数调用相比，多了一个「在运行阶段将实参和形参匹配」的过程。</p><p> 另外需要注意的是，如果不希望<code>catch</code>处理异常数据，也可以将<code>variable</code>省略掉，也即写作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 可能抛出异常的语句</span></span><br><span class="line"> &#125;<span class="keyword">catch</span>(exceptionType)&#123;</span><br><span class="line">   <span class="comment">// 处理异常的语句</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>​    这样只会将异常类型和<code>catch</code>所能处理的类型进行匹配，不会传递异常数据了。</p><h3 id="多级catch"><a href="#多级catch" class="headerlink" title="多级catch"></a>多级<code>catch</code></h3><p>​    前面的例子中，一个<code>try</code>对应一个<code>catch</code>，这只是最简单的形式。其实，一个<code>try</code>后面可以跟多个<code>catch</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (exception_type_1 e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (exception_type_2 e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他的catch</span></span><br><span class="line"><span class="keyword">catch</span> (exception_type_n e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    当异常发生时，程序会按照从上到下的顺序，将异常类型和<code>catch</code>所能接收的类型逐个匹配。一旦找到类型匹配的<code>catch</code>就停止检索，并将异常交给当前的<code>catch</code>处理（其他的<code>catch</code>不会被执行）。如果最终也没有找到匹配的<code>catch</code>，就只能交给系统处理，终止程序的运行。</p><p> 下面的例子演示了多级<code>catch</code>的使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> Derived();  <span class="comment">//抛出自己的异常类型，实际上是创建一个Derived类型的匿名对象</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">int</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception type: int"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">char</span> *)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception type: cahr *"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Base)&#123;  <span class="comment">//匹配成功（向上转型）</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception type: Base"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Derived)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception type: Derived"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>Exception type: Base</code></p><blockquote><p>在<code>catch</code>中，我们只给出了异常类型，没有给出接收异常信息的变量。</p></blockquote><p>​    本例中，我们定义了一个基类<code>Base</code>，又从<code>Base</code>派生类出了<code>Derived</code>。抛出异常时，我们创建了一个<code>Derived</code>类的匿名对象，也就是说，异常的类型是<code>Derived</code>。</p><p>​    我们期望的是，异常被<code>catch(Derived)</code>捕获，但是从输出结果可以看出，异常提前被<code>catch(Base)</code>捕获了，这说明<code>catch</code>在匹配异常类型时发生了向上转型（<code>Upcasting</code>）</p><h3 id="catch在匹配过程中的类型转换"><a href="#catch在匹配过程中的类型转换" class="headerlink" title="catch在匹配过程中的类型转换"></a><code>catch</code>在匹配过程中的类型转换</h3><p>​    <code>C/C++</code>中存在多种多样的类型转换，以普通函数（非模板函数）为例，发生函数调用时，如果实参和形参的类型不是严格匹配，那么会将实参的类型进行适当的转换，以适应形参的类型，这些转换包括：</p><ul><li>算数转换：例如<code>int</code>转换为<code>float</code>，<code>char</code>转换为<code>int</code>，<code>double</code>转换为<code>int</code>等。</li><li>向上转型：也就是派生类向基类的转换。</li><li><code>const</code>转换：也即将非<code>const</code>类型转换为<code>const</code>类型，例如将<code>char *</code>转换为<code>const char *</code>。</li><li>数组或函数指针转换：如果函数形参不是引用类型，那么数组名会转换为数组指针，函数名也会转换为函数指针。</li><li>用户自定的类型转换。</li></ul><p><code>catch</code>在匹配异常类型的过程中，也会进行类型转换，但是这种转换受到了更多的限制，仅能进行「向上转型」、「<code>const</code> 转换」和「数组或函数指针转换」，其他的都不能应用于 <code>catch</code>。</p><p>​    向上转型在上面的例子中已经发生了，下面的例子演示了<code>const</code> 转换以及数组和指针的转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> nums;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">int</span> *)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception type: const int *"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>Exception type: const int *</code></p><p>​    <code>nums</code>本来的类型是<code>int [3]</code>，但是<code>catch</code>中没有严格匹配的类型，所以先转换为<code>int *</code>，再转换为<code>const int *</code>。</p><h2 id="throw（抛出异常）详解"><a href="#throw（抛出异常）详解" class="headerlink" title="throw（抛出异常）详解"></a><code>throw</code>（抛出异常）详解</h2><p>​    <code>C++</code>异常处理的流程，具体为：</p><p><code>抛出（Throw）--&gt; 检测（Try） --&gt; 捕获（Catch）</code></p><p>​    <strong>异常必须显式地抛出，才能被检测和捕获到；如果没有显式的抛出，即使有异常也检测不到。</strong></p><p>​    在<code>C++</code>中，我们<strong>使用<code>throw</code>关键字来显式地抛出异常</strong>，它的用法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw exceptionData;</span><br></pre></td></tr></table></figure></p><p>​    <code>exceptionData</code>是“异常数据”的意思，它可以包含任意的信息，完全有程序员决定。<code>exceptionData</code>可以是 <code>int</code>、<code>float</code>、<code>bool</code>等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型，请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"http://c.biancheng.net"</span>;</span><br><span class="line"><span class="keyword">char</span> *pstr = str;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span>&#125;;</span><br><span class="line">Base obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="number">100</span>;  <span class="comment">//int 类型</span></span><br><span class="line"><span class="keyword">throw</span> str;  <span class="comment">//数组类型</span></span><br><span class="line"><span class="keyword">throw</span> pstr;  <span class="comment">//指针类型</span></span><br><span class="line"><span class="keyword">throw</span> obj;  <span class="comment">//对象类型</span></span><br></pre></td></tr></table></figure><h3 id="一个动态数组的例子"><a href="#一个动态数组的例子" class="headerlink" title="一个动态数组的例子"></a>一个动态数组的例子</h3><p>​    <code>C/C++</code>规定，数组一旦定义后，它的长度就不能改变了；换句话说，数组容量不能动态地增大或者减小。这样的数组称为静态数组（<code>Static array</code>）。静态数组有时候会给编码代码不便，我们可以通过自定义的<code>Array</code> 类来实现动态数组（<code>Dynamic array</code>）。所谓动态数组，是指数组容量能够在使用的过程中随时增大或减小。</p><p>​    下面这段代码虽然有点长，但它是一个典型的使用异常的场景，请大家耐心阅读。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的异常类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutOfRange</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    OutOfRange(): m_flag(<span class="number">1</span>)&#123; &#125;;</span><br><span class="line">    OutOfRange(<span class="keyword">int</span> len, <span class="keyword">int</span> index): m_len(len), m_index(index), m_flag(<span class="number">2</span>)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//获取具体的错误信息</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_flag;  <span class="comment">//不同的flag表示不同的错误</span></span><br><span class="line">    <span class="keyword">int</span> m_len;  <span class="comment">//当前数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> m_index;  <span class="comment">//当前使用的数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> OutOfRange::what() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(m_flag == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error: empty array, no elements to pop."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m_flag == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error: out of range( array length "</span>&lt;&lt;m_len&lt;&lt;<span class="string">", access index "</span>&lt;&lt;m_index&lt;&lt;<span class="string">" )"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Unknown exception."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现动态数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array();</span><br><span class="line">    ~Array()&#123; <span class="built_in">free</span>(m_p); &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>;  <span class="comment">//获取数组元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> ele)</span></span>;  <span class="comment">//在末尾插入数组元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;  <span class="comment">//在末尾删除数组元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_len; &#125;;  <span class="comment">//获取数组长度</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_len;  <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">int</span> m_capacity;  <span class="comment">//当前的内存能容纳多少个元素</span></span><br><span class="line">    <span class="keyword">int</span> *m_p;  <span class="comment">//内存指针</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> m_stepSize = <span class="number">50</span>;  <span class="comment">//每次扩容的步长</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array()&#123;</span><br><span class="line">    m_p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * m_stepSize );</span><br><span class="line">    m_capacity = m_stepSize;</span><br><span class="line">    m_len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Array::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( index&lt;<span class="number">0</span> || index&gt;=m_len )&#123;  <span class="comment">//判断是否越界</span></span><br><span class="line">        <span class="keyword">throw</span> OutOfRange(m_len, index);  <span class="comment">//抛出异常（创建一个匿名对象）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *(m_p + index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Array::push(<span class="keyword">int</span> ele)&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_len &gt;= m_capacity)&#123;  <span class="comment">//如果容量不足就扩容</span></span><br><span class="line">        m_capacity += m_stepSize;</span><br><span class="line">        m_p = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>( m_p, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * m_capacity );  <span class="comment">//扩容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(m_p + m_len) = ele;</span><br><span class="line">    m_len++;</span><br><span class="line">    <span class="keyword">return</span> m_len<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Array::pop()&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_len == <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">throw</span> OutOfRange();  <span class="comment">//抛出异常（创建一个匿名对象）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_len--;</span><br><span class="line">    <span class="keyword">return</span> *(m_p + m_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Array &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断数组是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Empty array! No elements to print."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Array nums;</span><br><span class="line">    <span class="comment">//向数组中添加十个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        nums.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    printArray(nums);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试访问第20个元素</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;nums[<span class="number">20</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(OutOfRange &amp;e)&#123;</span><br><span class="line">        e.what();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试弹出20个元素</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">            nums.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(OutOfRange &amp;e)&#123;</span><br><span class="line">        e.what();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printArray(nums);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>0, 1, 2, 3, 4, 5, 6, 7, 8, 9</code><br><code>Error: out of range( array length 10, access index 20 )</code><br><code>Error: empty array, no elements to pop.</code><br><code>Empty array! No elements to print.</code></p><p>​    <code>Array</code>类实现了动态数组，它的主要思路是：在创建对象时预先分配出一定长度的内存（通过<code>malloc()</code>分配），内存不够用时就再扩展内存（通过<code>realloc()</code> 重新分配）。<code>Array</code>数组只能在尾部一个一个地插入（通过<code>push()</code>插入）或删除（通过<code>pop()</code>删除）元素。</p><p>​    我们通过重载过的<code>[ ]</code>运算符来访问数组元素，如果下标过小或过大，就会抛出异常（第<code>53</code>行代码）；在抛出异常的同时，我们还记录了当前数组的长度和要访问的下标。</p><p>​    在使用<code>pop()</code>删除数组元素时，如果当前数组为空，也会抛出错误。</p><h3 id="throw用作异常规范"><a href="#throw用作异常规范" class="headerlink" title="throw用作异常规范"></a><code>throw</code>用作异常规范</h3><p>​    <code>throw</code>关键字除了可以用在函数体中抛出异常，还可以用在函数头和函数体之间，指明当前函数能够抛出的异常类型，这称为<strong>异常规范（<code>Exception specification</code>）</strong>，有些教程也称为异常指示符或异常列表。请看下面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span> <span class="params">(<span class="keyword">char</span> param)</span> <span class="title">throw</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>​    这条语句声明了一个名为<code>func</code>的函数，它的返回值类型为<code>double</code>，有一个<code>char</code>类型的参数，并且只能抛出<code>int</code>类型的异常。如果抛出其他类型的异常，<code>try</code>将无法捕获，只能终止程序。</p><p>​     如果函数会抛出多种类型的异常，那么可以用逗号隔开：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span> <span class="params">(<span class="keyword">char</span> param)</span> <span class="title">throw</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>, exception)</span></span>;</span><br></pre></td></tr></table></figure></p><p>​    如果函数不会抛出任何异常，那么<code>( )</code>中什么也不写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span> <span class="params">(<span class="keyword">char</span> param)</span> <span class="title">throw</span> <span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>​    如此，<code>func()</code>函数就不能抛出任何类型的异常了，即使抛出了，<code>try</code>也检测不到。</p><h4 id="1-虚函数中的异常规范"><a href="#1-虚函数中的异常规范" class="headerlink" title="1) 虚函数中的异常规范"></a>1) 虚函数中的异常规范</h4><p>​    <code>C++</code>规定，派生类虚函数的异常规范必须与基类虚函数的异常规范一样严格，或者更严格。只有这样，当通过基类指针（或者引用）调用派生类虚函数时，才能保证不违背基类成员函数的异常规范。请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">fun3</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>, <span class="built_in">string</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>)</span></span>;   <span class="comment">//错！异常规范不如 throw() 严格</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>)</span></span>;   <span class="comment">//对！有相同的异常规范</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">fun3</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="built_in">string</span>)</span></span>;  <span class="comment">//对！异常规范比 throw(int,string) 更严格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-异常规范与函数定义和函数声明"><a href="#2-异常规范与函数定义和函数声明" class="headerlink" title="2) 异常规范与函数定义和函数声明"></a>2) 异常规范与函数定义和函数声明</h4><p>​    <code>C++</code>规定，异常规范在函数声明和函数定义中必须同时指明，并且要严格保持一致，不能更加严格或者更加宽松。</p><p>​    请看下面的几组函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错！定义中有异常规范，声明中没有</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错！定义和声明中的异常规范不一致</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对！定义和声明中的异常规范严格一致</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">char</span>*)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="请抛弃异常规范，不要再使用它"><a href="#请抛弃异常规范，不要再使用它" class="headerlink" title="请抛弃异常规范，不要再使用它"></a>请抛弃异常规范，不要再使用它</h3><p>​    异常规范的初衷是好的，它希望让程序员看到函数的定义或声明后，立马就知道该函数会抛出什么类型的异常，这样程序员就可以使用 <code>try-catch</code>来捕获了。如果没有异常规范，程序员必须阅读函数源码才能知道函数会抛出什么异常。</p><p>​    不过这有时候也不容易做到。例如，<code>func_outer()</code>函数可能不会引发异常，但它调用了另外一个函数 <code>func_inner()</code>，这个函数可能会引发异常。再如，您编写的函数调用了老式的库函数，此时不会引发异常，但是库更新以后这个函数却引发了异常。总之，异常规范的初衷实现起来有点困难，所以大家达成的一致意见是，最好不要使用异常规范。</p><p>​    异常规范是<code>C++98</code>新增的一项功能，但是后来的<code>C++11</code>已经将它抛弃了，不再建议使用。</p><p>​    另外，各个编译器对异常规范的支持也不一样，请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span><span class="title">throw</span><span class="params">(<span class="keyword">char</span>*, exception)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"[1]This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">int</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception type: int"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在<code>GCC</code>下，这段代码运行到第 7 行时程序会崩溃。虽然<code>func()</code>函数中发生了异常，但是由于<code>throw</code>限制了函数只能抛出<code>char*</code>、<code>exception</code>类型的异常，所以 <code>try-catch</code>将捕获不到异常，只能交给系统处理，终止程序。<br>​    在<code>Visual C++</code>下，输出结果为<code>Exception type: int</code>，这说明异常被成功捕获了。在 <code>Visual C++</code>中使用异常规范虽然没有语法错误，但是也没有任何效果，<code>Visual C++</code>会直接忽略异常规范的限制，函数可以抛出任何类型的异常。</p><h2 id="exception类：C-标准异常的基类"><a href="#exception类：C-标准异常的基类" class="headerlink" title="exception类：C++标准异常的基类"></a><code>exception</code>类：<code>C++</code>标准异常的基类</h2><p>​    <code>C++</code>语言本身或者标准库抛出的异常都是<code>exception</code>的子类，称为<strong>标准异常（<code>Standard Exception</code>）</strong>。你可以通过下面的语句来捕获所有的标准异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(exception &amp;e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    之所以使用引用，是为了提高效率。如果不使用引用，就要经历一次对象拷贝（要调用拷贝构造函数）的过程。</p><p>​    <code>exception</code>类位于<code>&lt;exception&gt;</code>头文件中，它被声明为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">exception</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    exception () <span class="keyword">throw</span>();  <span class="comment">//构造函数</span></span><br><span class="line">    exception (<span class="keyword">const</span> exception&amp;) <span class="keyword">throw</span>();  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    exception&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> exception&amp;) <span class="keyword">throw</span>();  <span class="comment">//运算符重载</span></span><br><span class="line">    <span class="keyword">virtual</span> ~exception() <span class="keyword">throw</span>();  <span class="comment">//虚析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">//虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里需要说明的是<code>what()</code>函数。<code>what()</code>函数返回一个能识别异常的字符串，正如它的名字<code>“what”</code>一样，可以粗略地告诉你这是什么异常。不过<code>C++</code>标准并没有规定这个字符串的格式，各个编译器的实现也不同，所以<code>what()</code>的返回值仅供参考。</p><p> 下图展示了<code>exception</code>类的继承层次：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/图片12.png"><br> 图：<code>exception</code> 类的继承层次以及它们所对应的头文件</p><p>先来看一下<code>exception</code>类的直接派生类：</p><table><thead><tr><th>异常名称</th><th>说  明</th></tr></thead><tbody><tr><td><code>logic_error</code></td><td>逻辑错误。</td></tr><tr><td><code>runtime_error</code></td><td>运行时错误。</td></tr><tr><td><code>bad_alloc</code></td><td>使用<code>new</code>或<code>new[ ]</code>分配内存失败时抛出的异常。</td></tr><tr><td><code>bad_typeid</code></td><td>使用<code>typeid</code> 操作一个<code>NULL</code>指针，而且该指针是带有虚函数的类，这时抛出<code>bad_typeid</code>异常。</td></tr><tr><td><code>bad_cast</code></td><td>使用<code>dynamic_cast</code>转换失败时抛出的异常。</td></tr><tr><td><code>ios_base::failure</code></td><td><code>io</code>过程中出现的异常。</td></tr><tr><td><code>bad_exception</code></td><td>这是个特殊的异常，如果函数的异常列表里声明了<code>bad_exception</code>异常，当函数内部抛出了异常列表中没有的异常时，如果调用的<code>unexpected()</code>函数中抛出了异常，不论什么类型，都会被替换为<code>bad_exception</code>类型。</td></tr></tbody></table><p><code>logic_error</code>的派生类： </p><table><thead><tr><th>异常名称</th><th>说  明</th></tr></thead><tbody><tr><td><code>length_error</code></td><td>试图生成一个超出该类型最大长度的对象时抛出该异常，例如<code>vector</code>的<code>resize</code> 操作。</td></tr><tr><td><code>domain_error</code></td><td>参数的值域错误，主要用在数学函数中，例如使用一个负值调用只能操作非负数的函数。</td></tr><tr><td><code>out_of_range</code></td><td>超出有效范围。</td></tr><tr><td><code>invalid_argument</code></td><td>参数不合适。在标准库中，当利用<code>string</code>对象构造 <code>bitset</code>时，而 <code>string</code>中的字符不是<code>0</code> 或<code>1</code>的时候，抛出该异常。</td></tr></tbody></table><p><code>runtime_error</code>的派生类： </p><table><thead><tr><th>异常名称</th><th>说  明</th></tr></thead><tbody><tr><td><code>range_error</code></td><td>计算结果超出了有意义的值域范围。</td></tr><tr><td><code>overflow_error</code></td><td>算术计算上溢。</td></tr><tr><td><code>underflow_error</code></td><td>算术计算下溢。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++类型转换</title>
      <link href="/2018/09/17/c++%E9%AB%98%E7%BA%A7-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2018/09/17/c++%E9%AB%98%E7%BA%A7-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C++类型转换"></a><code>C++</code>类型转换</h1><p>​    类型转换(<code>cast</code>)是将一种数据类型转换成另一种数据类型。例如，如果将一个整型值赋给一个浮点类型的变量，编译器会暗地里将其转换成浮点类型。</p><p>​    转换是非常有用的，但是它也会带来一些问题，比如在转换指针时，我们很可能将其转换成一个比它更大的类型，但这可能会破坏其他的数据。</p><p>​    应该小心类型转换，因为转换也就相当于对编译器说：忘记类型检查，把它看做其他的类型。</p><p>​    一般情况下，尽量少的去使用类型转换，除非用来解决非常特殊的问题。</p><p>​    标准<code>c++</code>提供了一个显示的转换的语法，来替代旧的<code>C</code>风格的类型转换。</p><p>​    使用<code>C</code>风格的强制转换可以把想要的任何东西转换成我们需要的类型。那为什么还需要一个新的<code>C++</code>类型的强制转换呢？</p><p>​    新类型的强制转换可以提供更好的控制强制转换过程，允许控制各种不同种类的强制转换。<code>C++</code>风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么。程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的。</p><a id="more"></a><h2 id="静态转换-static-cast"><a href="#静态转换-static-cast" class="headerlink" title="静态转换(static_cast)"></a>静态转换(<code>static_cast</code>)</h2><ul><li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。</li><li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；</li><li>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。</li><li>用于基本数据类型之间的转换，如把<code>int</code>转换成<code>char</code>，把<code>char</code>转换成<code>int</code>。这种转换的安全性也要开发人员来保证。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基础数据类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承关系指针互相转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//继承关系指针转换</span></span><br><span class="line">Animal* animal01 = <span class="literal">NULL</span>;</span><br><span class="line">Dog* dog01 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//子类指针转成父类指针,安全</span></span><br><span class="line">Animal* animal02 = <span class="keyword">static_cast</span>&lt;Animal*&gt;(dog01);</span><br><span class="line"><span class="comment">//父类指针转成子类指针，不安全</span></span><br><span class="line">Dog* dog02 = <span class="keyword">static_cast</span>&lt;Dog*&gt;(animal01);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承关系引用相互转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Animal ani_ref;</span><br><span class="line">Dog dog_ref;</span><br><span class="line"><span class="comment">//继承关系指针转换</span></span><br><span class="line">Animal&amp; animal01 = ani_ref;</span><br><span class="line">Dog&amp; dog01 = dog_ref;</span><br><span class="line"><span class="comment">//子类指针转成父类指针,安全</span></span><br><span class="line">Animal&amp; animal02 = <span class="keyword">static_cast</span>&lt;Animal&amp;&gt;(dog01);</span><br><span class="line"><span class="comment">//父类指针转成子类指针，不安全</span></span><br><span class="line">Dog&amp; dog02 = <span class="keyword">static_cast</span>&lt;Dog&amp;&gt;(animal01);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无继承关系指针转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Animal* animal01 = <span class="literal">NULL</span>;</span><br><span class="line">Other* other01 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换失败</span></span><br><span class="line"><span class="comment">//Animal* animal02 = static_cast&lt;Animal*&gt;(other01);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态转换-dynamic-cast"><a href="#动态转换-dynamic-cast" class="headerlink" title="动态转换(dynamic_cast)"></a>动态转换(<code>dynamic_cast</code>)</h2><p>​    用<code>reinterpret_cast</code>可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。<code>dynamic_cast</code>专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 <code>NULL</code>指针。</p><p>​    <code>dynamic_cast</code> 是通过“运行时类型检查”来保证安全性的。<code>dynamic_cast</code>不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用<code>reinterpret_cast</code>来完成。</p><ul><li><code>dynamic_cast</code>主要用于类层次间的上行转换和下行转换；</li><li>在类层次间进行上行转换时，<code>dynamic_cast</code>和<code>static_cast</code>的效果是一样的；</li><li>在进行下行转换时，<code>dynamic_cast</code>具有类型检查的功能，比<code>static_cast</code>更安全；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowName</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a dog!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"我是其他类!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不支持基础数据类型</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//double a = dynamic_cast&lt;double&gt;(a);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承关系指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Animal* animal01 = <span class="literal">NULL</span>;</span><br><span class="line">Dog* dog01 = <span class="keyword">new</span> Dog;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类指针转换成父类指针 可以</span></span><br><span class="line">Animal* animal02 = <span class="keyword">dynamic_cast</span>&lt;Animal*&gt;(dog01);</span><br><span class="line">animal02-&gt;ShowName();</span><br><span class="line"><span class="comment">//父类指针转换成子类指针 不可以</span></span><br><span class="line"><span class="comment">//Dog* dog02 = dynamic_cast&lt;Dog*&gt;(animal01);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承关系引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Dog dog_ref;</span><br><span class="line">Dog&amp; dog01 = dog_ref;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类引用转换成父类引用 可以</span></span><br><span class="line">Animal&amp; animal02 = <span class="keyword">dynamic_cast</span>&lt;Animal&amp;&gt;(dog01);</span><br><span class="line">animal02.ShowName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无继承关系指针转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Animal* animal01 = <span class="literal">NULL</span>;</span><br><span class="line">Other* other = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不可以</span></span><br><span class="line"><span class="comment">//Animal* animal02 = dynamic_cast&lt;Animal*&gt;(other);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量转换-const-cast"><a href="#常量转换-const-cast" class="headerlink" title="常量转换(const_cast)"></a>常量转换(<code>const_cast</code>)</h2><p>该运算符用来修改类型的<code>const</code>属性。</p><ul><li>常量指针被转化成非常量指针，并且仍然指向原来的对象；</li><li>常量引用被转换成非常量引用，并且仍然指向原来的对象；</li></ul><p><strong>注意:不能直接对非指针和非引用的变量使用<code>const_cast</code>操作符去直接移除它的<code>const</code>。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量指针转换成非常量指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span>* np = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* pp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* npp = <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span>*&gt;(pp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;  <span class="comment">//不能对非指针或非引用进行转换</span></span><br><span class="line"><span class="comment">//int b = const_cast&lt;int&gt;(a); </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量引用转换成非常量引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; refNum = num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; refNum2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span>&amp;&gt;(refNum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重新解释转换-reinterpret-cast"><a href="#重新解释转换-reinterpret-cast" class="headerlink" title="重新解释转换(reinterpret_cast)"></a>重新解释转换(<code>reinterpret_cast</code>)</h2><p>​    这是最不安全的一种转换机制，最有可能出问题。</p><p>​    主要用于将一种数据类型从一种类型转换为另一种类型。它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针.</p><p>​    <code>reinterpret_cast</code>用法示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    A(<span class="keyword">int</span> n):i(n),j(n) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;r = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(a); <span class="comment">//强行让 r 引用 a</span></span><br><span class="line">    r = <span class="number">200</span>;  <span class="comment">//把 a.i 变成了 200</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.i &lt;&lt; <span class="string">","</span> &lt;&lt; a.j &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 200,100</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">300</span>;</span><br><span class="line">    A *pa = <span class="keyword">reinterpret_cast</span>&lt;A*&gt; ( &amp; n); <span class="comment">//强行让 pa 指向 n</span></span><br><span class="line">    pa-&gt;i = <span class="number">400</span>;  <span class="comment">// n 变成 400</span></span><br><span class="line">    pa-&gt;j = <span class="number">500</span>;  <span class="comment">//此条语句不安全，很可能导致程序崩溃</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 400</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> la = <span class="number">0x12345678abcd</span>LL;</span><br><span class="line">    pa = <span class="keyword">reinterpret_cast</span>&lt;A*&gt;(la); <span class="comment">//la太长，只取低32位0x5678abcd拷贝给pa</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> u = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(pa);<span class="comment">//pa逐个比特拷贝到u</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; u &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 5678abcd</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* PF1)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(* PF2)</span> <span class="params">(<span class="keyword">int</span>,<span class="keyword">char</span> *)</span></span>;</span><br><span class="line">    PF1 pf1;  PF2 pf2;</span><br><span class="line">    pf2 = <span class="keyword">reinterpret_cast</span>&lt;PF2&gt;(pf1); <span class="comment">//两个不同类型的函数指针之间可以互相转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br><code>200, 100</code><br><code>400</code><br><code>5678abed</code></p><p>​    第<code>19</code>行的代码不安全，因为在编译器看来，<code>pa-&gt;j</code>的存放位置就是<code>n</code>后面的<code>4</code>个字节。 本条语句会向这 <code>4</code>个字节中写入 <code>500</code>。但这<code>4</code>个字节不知道是用来存放什么的，贸然向其中写入可能会导致程序错误甚至崩溃。</p><p>​    上面程序中的各种转换都没有实际意义，只是为了演示<code>reinteipret_cast</code>的用法而已。在编写黑客程序、病毒或反病毒程序时，也许会用到这样怪异的转换。</p><p>​    <code>reinterpret_cast</code>体现了<code>C++</code>语言的设计思想：用户可以做任何操作，但要为自己的行为负责。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++STL库函数set</title>
      <link href="/2018/09/14/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0set%E5%92%8Cmultiset/"/>
      <url>/2018/09/14/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0set%E5%92%8Cmultiset/</url>
      
        <content type="html"><![CDATA[<h2 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a><code>set/multiset</code>容器</h2><h3 id="set-multiset容器基本概念"><a href="#set-multiset容器基本概念" class="headerlink" title="set/multiset容器基本概念"></a><code>set/multiset</code>容器基本概念</h3><h4 id="set容器基本概念"><a href="#set容器基本概念" class="headerlink" title="set容器基本概念"></a><code>set</code>容器基本概念</h4><p>​    <code>Set</code>的特性是：所有元素都会根据元素的键值自动被排序。<code>Set</code>的元素不像<code>map</code>那样可以同时拥有实值和键值，<code>set</code>的元素即是键值又是实值。<code>Set</code>不允许两个元素有相同的键值。</p><p>​    我们可以通过<code>set</code>的迭代器改变<code>set</code>元素的值吗？不行，因为<code>set</code>元素值就是其键值，关系到<code>set</code>元素的排序规则。如果任意改变<code>set</code>元素值，会严重破坏<code>set</code>组织。换句话说，<code>set</code>的<code>iterator</code>是一种<code>const_iterator</code>。</p><a id="more"></a><p>​    <code>set</code>拥有和<code>list</code>某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外。</p><h4 id="multiset容器基本概念"><a href="#multiset容器基本概念" class="headerlink" title="multiset容器基本概念"></a><code>multiset</code>容器基本概念</h4><p>​    <code>multiset</code>特性及用法和<code>set</code>完全相同，唯一的差别在于它允许键值重复。</p><h3 id="set-multiset定义"><a href="#set-multiset定义" class="headerlink" title="set/multiset定义"></a><code>set/multiset</code>定义</h3><h4 id="multiset定义"><a href="#multiset定义" class="headerlink" title="multiset定义"></a><code>multiset</code>定义</h4><p>​    不能直接修改<code>multiset</code>容器中元素的值。因为元素被修改后，容器并不会自动重新调整顺序，于是容器的有序性就会被破坏，再在其上进行查找等操作就会得到错误的结果。因此，如果要修改<code>multiset</code>容器中某个元素的值，正确的做法是先删除该元素，再插入新元素。</p><p>​    使用<code>multiset</code>必须包含头文件<code>&lt;set&gt;</code>。<code>multiset</code>类模板的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">B</span> = <span class="title">allocator</span>&lt;Key&gt; &gt; <span class="title">class</span> <span class="title">multiset</span> &#123;</span></span><br><span class="line">   ...</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><p>​    该模板有三个类型参数：<code>Key</code>、<code>Pred</code>和<code>B</code>。类型参数可以有默认值，默认值就是某种类型。例如，<code>Pred</code>类型参数的默认值就是<code>less&lt;Key&gt;</code>类型，<code>B</code>的默认值就是<code>allocator&lt;Key&gt;</code>类型。第三个类型参数极少用到，一般都用默认值，因此这里不做介绍。</p><p>​    第一个类型参数说明<code>multiset</code>容器中的每个元素都是<code>Key</code>类型的。第二个类型参数<code>Pred</code>用于指明容器中元素的排序规则，在被实例化后，<code>Pred</code> 可以是函数对象类，也可以是函数指针类型。</p><p>​    <code>multiset</code>内部在排序时定义了一个变量<code>Pred op</code>，根据表达式<code>op(x, y)</code>来比较两个元素<code>x</code>、<code>y</code>的大小。该表达式的值为<code>true</code>，则说明<code>x</code>比<code>y</code>小。<code>Pred</code>的默认值是<code>less&lt;Key&gt;</code>，<code>less</code>是<code>STL</code>中的函数对象类模板，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> _Tp &amp;__x, <span class="keyword">const</span> _Tp &amp;__y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    这说明，在默认情况下，<code>multiset</code>容器中的元素是用<code>&lt;</code>运算符比较大小的。例如，假设<code>A</code>是一个类的名字，可以定义一个如下的容器对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multiset</span> &lt;A&gt; s;</span><br></pre></td></tr></table></figure></p><p>​    由于<code>multiset</code>的类型参数可以使用默认值，因此上面的语句等价于：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multiset</span> &lt; <span class="keyword">int</span>, less&lt;A&gt;, allocator&lt;A&gt; &gt; s;</span><br></pre></td></tr></table></figure></p><p>​    模板类<code>multiset &lt; A, less&lt;A&gt;, allocator&lt;A&gt; &gt;</code>的<code>insert</code>成员函数可以用来插入一个元素。 插入过程中需要进行元素之间的比较，可以认为<code>insert</code>成员函数中定义了一个变量<code>less &lt;A&gt; op</code>，用<code>op(x, y)</code>来比较元素<code>x</code>、<code>y</code>的大小。归根到底，还是用<code>&lt;</code>运算符比较<code>x</code>、<code>y</code>的大小。 因此，<code>&lt;</code>运算符必须经过适当重载，才可以向<code>multiset &lt;A&gt;</code>容器中插人元素。</p><p>​     下面的程序 会编译出错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">multiset</span> &lt;A&gt; a;</span><br><span class="line">    a.insert( A() );  <span class="comment">//编译出错，因为不能用“&lt;”运算符比较两个A对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set定义"><a href="#set定义" class="headerlink" title="set定义"></a><code>set</code>定义</h4><p>​    使用<code>set</code>必须包含头文件<code>&lt;set&gt;</code>。<code>set</code>的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;Key&gt; &gt; <span class="title">class</span> <span class="title">set</span> &#123;</span>...&#125;</span><br></pre></td></tr></table></figure></p><p>​    由于不能有重复元素，所以<code>set</code>中插入单个元素的<code>insert</code>成员函数与<code>multiset</code>中的有所不同，其原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;iterator, <span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> T &amp; val);</span><br></pre></td></tr></table></figure></p><p>​    如果<code>set</code>的<code>insert</code>成员函数的返回值是<code>pair</code>模板类对象<code>x</code>，如果<code>x.second</code>为<code>true</code>，则说明插入成功，此时<code>x.first</code>就是指向被插入元素的迭代器；如果<code>x.second</code>为<code>false</code>，则说明要插入的元素已在容器中，此时<code>x.first</code>就是指向原有那个元素的迭代器。</p><p>​    关联容器的<code>equal_range</code>成员函数的返回值也是<code>pair</code>模板类对象，其原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;iterator, iterator&gt; equal_range(<span class="keyword">const</span> T &amp; val);</span><br></pre></td></tr></table></figure></p><p>​    返回值对象中的<code>first</code>就是<code>lower_bound</code>的值，<code>second</code>就是<code>upper_bound</code>的值。</p><h3 id="set-multiset实现原理"><a href="#set-multiset实现原理" class="headerlink" title="set/multiset实现原理"></a><code>set/multiset</code>实现原理</h3><p><code>set</code>和<code>multiset</code>的底层实现是红黑树，红黑树为平衡二叉树的一种。</p><p>树的简单知识：</p><p>​    二叉树就是任何节点最多只允许有两个子节点。分别是左子结点和右子节点。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/图片9.png" style="zoom:67%;"></p><p>​    二叉搜索树，是指二叉树中的节点按照一定的规则进行排序，使得对二叉树中元素访问更加高效。<strong>二叉搜索树的放置规则是：任何节点的元素值一定大于其左子树中的每一个节点的元素值，并且小于其右子树的值。</strong>因此从根节点一直向左走，一直到无路可走，即得到最小值，一直向右走，直至无路可走，可得到最大值。那么在二叉搜索树中找到最大元素和最小元素是非常简单的事情。下图为二叉搜索树：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/图片8.png" style="zoom: 80%;"></p><pre><code>上面我们介绍了二叉搜索树，那么当一个二叉搜索树的左子树和右子树不平衡的时候，那么搜索依据上图表示，搜索`9`所花费的时间要比搜索`17`所花费的时间要多，由于我们的输入或者经过我们插入或者删除操作，二叉树失去平衡，造成搜索效率降低。</code></pre><p>​    所以我们有了一个平衡二叉树的概念，所谓的平衡不是指的完全平衡。</p><p> <img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/图片7.png" style="zoom:67%;"> </p><p>​    <code>RB-tree</code>(红黑树)为二叉树的一种。</p><h3 id="set-multiset常用API"><a href="#set-multiset常用API" class="headerlink" title="set/multiset常用API"></a><code>set/multiset</code>常用<code>API</code></h3><table><thead><tr><th>成员函数或成员函数模板</th><th>作  用</th></tr></thead><tbody><tr><td><code>iterator find (const T &amp; val);</code></td><td>在容器中查找值为<code>val</code>的元素，返回其迭代器。如果找不到，返 回<code>end()</code></td></tr><tr><td><code>iterator insert( const T &amp; val);</code></td><td>将<code>val</code>插入容器中并返回其迭代器</td></tr><tr><td><code>void insert(iterator first, iterator last);</code></td><td>将区间<code>[first, last)</code>中的元素插人容器</td></tr><tr><td><code>int count( const T &amp; val);</code></td><td>统计有多少个元素的值和<code>val</code>相等</td></tr><tr><td><code>iterator lower_bound( const T &amp; val);</code></td><td>查找一个最大的位置 <code>it</code>，使得<code>[begin(), it)</code>中所有的元素者比<code>val</code>小</td></tr><tr><td><code>iterator upper_bound( const T &amp; val);</code></td><td>查找一个最小的位置<code>it</code>，使得<code>[it, end())</code>中所有的元素都比<code>val</code>大</td></tr><tr><td><code>pair &lt;iterator, iterator &gt; equal_range (const T &amp; val);</code></td><td>同时求得<code>lower_bound</code> 和<code>upper_bound</code></td></tr><tr><td><code>iterator erase(iterator it);</code></td><td>删除<code>it</code>指向的元素，返回其后面的元素的迭代器（<code>Visual Studio 2010</code>中如此，但是在<code>C++</code>标准和<code>Dev C++</code>中，返回值不是这样）</td></tr><tr><td><code>iterator erase(iterator first, iterator last);</code></td><td>删除区间<code>[first, last)</code>，返回<code>last</code>（<code>Visual Studio 2010</code>中如此，但是在 <code>C++</code>标准和 <code>Dev C++</code>中，返回值不是这样）<code>multiset</code>及 <code>set</code>中的<code>find</code>和 <code>count</code>并不是用<code>==</code>运算符比较元素是否和待查找的值相等的。它们进行比较的原则是：如果<code>x</code>比<code>y</code>小和<code>y</code>比<code>x</code>小同时为假，就认为<code>x</code>和<code>y</code>相等。</td></tr></tbody></table><h4 id="set-multiset构造函数"><a href="#set-multiset构造函数" class="headerlink" title="set/multiset构造函数"></a><code>set/multiset</code>构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;T&gt; st;<span class="comment">//set默认构造函数：</span></span><br><span class="line">mulitset&lt;T&gt; mst; <span class="comment">//multiset默认构造函数: </span></span><br><span class="line"><span class="built_in">set</span>(<span class="keyword">const</span> <span class="built_in">set</span> &amp;st);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><h4 id="set-multiset赋值操作"><a href="#set-multiset赋值操作" class="headerlink" title="set/multiset赋值操作"></a><code>set/multiset</code>赋值操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">set</span> &amp;st);<span class="comment">//重载等号操作符</span></span><br><span class="line">swap(st);<span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure><h4 id="set-multiset大小操作"><a href="#set-multiset大小操作" class="headerlink" title="set/multiset大小操作"></a><code>set/multiset</code>大小操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size();<span class="comment">//返回容器中元素的数目</span></span><br><span class="line">empty();<span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure><h4 id="set-multiset插入和删除操作"><a href="#set-multiset插入和删除操作" class="headerlink" title="set/multiset插入和删除操作"></a><code>set/multiset</code>插入和删除操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert(elem);<span class="comment">//在容器中插入元素。</span></span><br><span class="line">clear();<span class="comment">//清除所有元素</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line">erase(beg, end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line">erase(elem);<span class="comment">//删除容器中值为elem的元素。</span></span><br></pre></td></tr></table></figure><h4 id="set-multiset查找操作"><a href="#set-multiset查找操作" class="headerlink" title="set/multiset查找操作"></a><code>set/multiset</code>查找操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find(key);<span class="comment">//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span></span><br><span class="line">count(key);<span class="comment">//查找键key的元素个数</span></span><br><span class="line">lower_bound(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line">upper_bound(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line">equal_range(keyElem);<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器。</span></span><br></pre></td></tr></table></figure><h3 id="multiset的用法"><a href="#multiset的用法" class="headerlink" title="multiset的用法"></a><code>multiset</code>的用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;  //使用multiset须包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Print</span>(<span class="title">T</span> <span class="title">first</span>, <span class="title">T</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> n_) &#123; n = n_; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span><br><span class="line">    &#123; <span class="keyword">return</span> a1.n &lt; a2.n; &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; o, <span class="keyword">const</span> A &amp; a2)</span><br><span class="line">    &#123; o &lt;&lt; a2.n; <span class="keyword">return</span> o; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLess</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLess</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span>  <span class="comment">//按个位数比较大小</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> (a1.n % <span class="number">10</span>) &lt; (a2.n % <span class="number">10</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span> &lt;A&gt; MSET1;  <span class="comment">//MSET1 用“&lt;”运算符比较大小</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span> &lt;A, MyLess&gt; MSET2;  <span class="comment">//MSET2 用 MyLess::operator() 比较大小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">6</span>;</span><br><span class="line">    A a[SIZE] = &#123; <span class="number">4</span>, <span class="number">22</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">33</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    MSET1 m1;</span><br><span class="line">    m1.insert(a, a + SIZE);</span><br><span class="line">    m1.insert(<span class="number">22</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1)"</span> &lt;&lt; m1.count(<span class="number">22</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 1)2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2)"</span>; Print(m1.begin(), m1.end());  <span class="comment">//输出 2)4 8 19 22 22 33 40</span></span><br><span class="line">    </span><br><span class="line">    MSET1::iterator pp = m1.find(<span class="number">19</span>);</span><br><span class="line">    <span class="keyword">if</span> (pp != m1.end())  <span class="comment">//条件为真说明找到</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//本行会被执行，输出 found</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3)"</span>; <span class="built_in">cout</span> &lt;&lt; *m1.lower_bound(<span class="number">22</span>)</span><br><span class="line">        &lt;&lt; <span class="string">","</span> &lt;&lt; *m1.upper_bound(<span class="number">22</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 3)22,33</span></span><br><span class="line">    </span><br><span class="line">    pp = m1.erase(m1.lower_bound(<span class="number">22</span>), m1.upper_bound(<span class="number">22</span>));</span><br><span class="line">    <span class="comment">//pp指向被删元素的下一个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4)"</span>; Print(m1.begin(), m1.end());  <span class="comment">//输出 4)4 8 19 33 40</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5)"</span>; <span class="built_in">cout</span> &lt;&lt; *pp &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 5)33</span></span><br><span class="line">    </span><br><span class="line">    MSET2 m2;  <span class="comment">//m2中的元素按n的个位数从小到大排序</span></span><br><span class="line">    m2.insert(a, a + SIZE);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"6)"</span>; Print(m2.begin(), m2.end());  <span class="comment">//输出 6)40 22 33 4 8 19</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    第<code>33</code>行，<code>MSET2</code>类的排序规则和<code>MSET1</code>不同。<code>MSET2</code>用<code>MyLess</code>定义排序规则，即<code>n</code>的个位数小的元素排在前面。</p><p>​    第<code>49</code>、<code>50</code>行，<code>lower_bound</code>返回的迭代器指向第一个<code>22</code>，<code>upper_bound</code>返回的迭代器指向 33。</p><p>​    第<code>52</code>行，删除所有值为<code>22</code> 的元素。<code>erase</code>成员函数删除一个元素后，返回下一个元素的迭代器应该是很合理的，但是<code>C++</code>标准委员会认为，返回下一个元素的迭代器也是需要时间开销的，如果程序员不想要这个返回值，那么这个开销就是浪费的——因此在遵循<code>C++</code>标准的<code>Dev C++</code> 中，本行无法编译通过。但是微软公司认为应该对这一点做出改进，因此<code>Visual Studio 2010</code>将<code>erase</code> 成员函数处理成返回被删元素下一个元素的迭代器。</p><h3 id="set的用法"><a href="#set的用法" class="headerlink" title="set的用法"></a><code>set</code>的用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;  //使用set须包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator IT;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st(a,a+<span class="number">5</span>);    <span class="comment">// st里是 1 2 3 4 6</span></span><br><span class="line">    pair&lt; IT,<span class="keyword">bool</span>&gt; result;</span><br><span class="line">    result = st.insert(<span class="number">5</span>); <span class="comment">// st变成  1 2 3 4 5 6</span></span><br><span class="line">    <span class="keyword">if</span>(result.second)    <span class="comment">//插入成功则输出被插入元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * result.first  &lt;&lt; <span class="string">" inserted"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出: 5 inserted</span></span><br><span class="line">    <span class="keyword">if</span>(st.insert(<span class="number">5</span>).second)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * result.first  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * result.first &lt;&lt; <span class="string">" already exists"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 5 already exists</span></span><br><span class="line">    pair&lt;IT,IT&gt; bounds = st.equal_range(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; * bounds.first &lt;&lt; <span class="string">","</span> &lt;&lt; * bounds.second ;  <span class="comment">//输出：4,5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br><code>5 inserted</code><br><code>5 already exists</code><br><code>4,5</code></p><h4 id="指定set排序规则"><a href="#指定set排序规则" class="headerlink" title="指定set排序规则"></a>指定<code>set</code>排序规则</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入操作返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">pair&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator,<span class="keyword">bool</span>&gt; ret = s.insert(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.second)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"插入成功:"</span> &lt;&lt; *ret.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"插入失败:"</span> &lt;&lt; *ret.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = s.insert(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(ret.second)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"插入成功:"</span> &lt;&lt; *ret.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"插入失败:"</span> &lt;&lt; *ret.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCompare02</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set从大到小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="comment">//我们发现set容器的第二个模板参数可以设置排序规则，默认规则是less&lt;_Kty&gt;</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, MyCompare02&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">s.insert(rand() % <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>, MyCompare02&gt;::iterator it = s.begin(); it != s.end(); it ++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set容器中存放对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name,<span class="keyword">int</span> age)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> mName;</span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCompare03</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p1,<span class="keyword">const</span> Person&amp; p2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p1.mAge &gt; p2.mAge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;Person, MyCompare03&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"aaa"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"bbb"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"ccc"</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"ddd"</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">s.insert(p1);</span><br><span class="line">s.insert(p2);</span><br><span class="line">s.insert(p3);</span><br><span class="line">s.insert(p4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;Person, MyCompare03&gt;::iterator it = s.begin(); it != s.end(); it++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Name:"</span> &lt;&lt; it-&gt;mName &lt;&lt; <span class="string">" Age:"</span> &lt;&lt; it-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++STL库函数map</title>
      <link href="/2018/09/11/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0map%E5%92%8Cmultimap/"/>
      <url>/2018/09/11/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0map%E5%92%8Cmultimap/</url>
      
        <content type="html"><![CDATA[<h2 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map/multimap容器"></a><code>map/multimap</code>容器</h2><h3 id="map-multimap基本概念"><a href="#map-multimap基本概念" class="headerlink" title="map/multimap基本概念"></a><code>map/multimap</code>基本概念</h3><p>​    <code>map</code>的特性是，所有元素都会根据元素的键值自动排序。<code>map</code>所有的元素都是<code>pair</code>，同时拥有实值和键值，<code>pair</code>的第一元素被视为键值，第二元素被视为实值，<code>map</code>不允许两个元素有相同的键值。</p><p>​    我们可以通过<code>map</code>的迭代器改变<code>map</code>的键值吗？答案是不行，因为<code>map</code>的键值关系到<code>map</code>元素的排列规则，任意改变<code>map</code>键值将会严重破坏<code>map</code>组织。如果想要修改元素的实值，那么是可以的。</p><a id="more"></a><p>​    <code>map</code>和<code>list</code>拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。</p><p>​    <code>multimap</code>和<code>map</code>的操作类似，唯一区别<code>multimap</code>键值可重复。</p><p>​    <code>map</code>和<code>multimap</code>都是以红黑树为底层实现机制。</p><h3 id="map-multimap定义"><a href="#map-multimap定义" class="headerlink" title="map/multimap定义"></a><code>map/multimap</code>定义</h3><h4 id="multimap定义"><a href="#multimap定义" class="headerlink" title="multimap定义"></a><code>multimap</code>定义</h4><p>​    使用<code>multimap</code> 必须包含头文件<code>map</code>。<code>multimap</code>的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"> <span class="title">class</span> <span class="title">multimap</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">typedef</span> pair &lt;<span class="keyword">const</span> Key, T&gt; value_type;</span><br><span class="line">   ...</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><p>​    <code>multimap</code>中的元素都是<code>pair</code>模板类的对象。元素的<code>first</code>成员变量也叫“关键字”，<code>second</code>成员变量也叫“值”。<code>multimap</code>容器中的元素是按关键字从小到大排序的。默认情况下，元素的关键之间用<code>less &lt;Key&gt;</code>  比较大小，也就是用<code>&lt;</code>运算符比较大小。<code>multimap</code>允许多个元素的关键字相同。</p><p>​    <code>multimap</code>中的<code>value_type</code>实际上就表示容器中元素的类型。<code>C++</code>允许在类的内部定义类型。</p><h4 id="map定义"><a href="#map定义" class="headerlink" title="map定义"></a><code>map</code>定义</h4><p>​    要使用<code>map</code>，必须包含头文件<code>&lt;map&gt;</code>。<code>map</code>的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"> <span class="title">class</span> <span class="title">map</span>&#123;</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">typedef</span> pair&lt; <span class="keyword">const</span> Key, T &gt; value_type;</span><br><span class="line">   ...</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><p>​    <code>map</code>和<code>multimap</code>十分类似，区别在于<code>map</code>容器中元素的关键字不能重复。<code>multimap</code>有的成员函数，<code>map</code>都有。此外，<code>map</code>还有成员函数<code>operator[]</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T &amp; <span class="keyword">operator</span>[] (Key k);</span><br></pre></td></tr></table></figure></p><p>​    该成员函数返回<code>first</code>值为<code>k</code>的元素的<code>second</code>部分的引用。如果容器中没有元素的<code>first</code>值等于<code>k</code>，则自动添加一个<code>first</code>值为<code>k</code>的元素。如果该元素的<code>second</code>成员变量是一个对象，则用无参构造函数对其初始化。</p><h3 id="map-multimap常用API"><a href="#map-multimap常用API" class="headerlink" title="map/multimap常用API"></a><code>map/multimap</code>常用<code>API</code></h3><table><thead><tr><th>成员函数或成员函数模板</th><th>作  用</th></tr></thead><tbody><tr><td><code>iterator find( const Key &amp; val);</code></td><td>在容器中查找关键字等于<code>val</code> 的元素，返回其迭代器；如果找不到，返回<code>end()</code></td></tr><tr><td><code>iterator insert (pair &lt;Key, T&gt; const &amp;p);</code></td><td>将<code>pair</code> 对象<code>p</code>插入容器中并返回其迭代器</td></tr><tr><td><code>void insert(iterator first, iterator last);</code></td><td>将区间<code>[first, last)</code>插入容器</td></tr><tr><td><code>int count( const Key &amp; val);</code></td><td>统计有多少个元素的关键字和<code>val</code>相等</td></tr><tr><td><code>iterator lower_bound( const Key &amp; val);</code></td><td>查找一个最大的位置<code>it</code>，使得<code>[begin( ), it)</code>中所有的元素的关键字都比<code>val</code>小</td></tr><tr><td><code>iterator upper_bound(const Key &amp; val);</code></td><td>查找一个最小的位置<code>it</code>，使得<code>[it, end())</code>中所有的元素的关键字都比<code>val</code>大</td></tr><tr><td><code>pair &lt; iterator, iterator &gt; equal_range (const Key &amp; val);</code></td><td>同时求得<code>lower_bound</code>和<code>upper_bound</code></td></tr><tr><td><code>iterator erase(iterator it);</code></td><td>删除<code>it</code>指向的元素，返回其后面的元素的迭代器（<code>Visual Studio 2010</code>中如此，但是在<code>C++</code>标准和<code>Dev C++</code>中，返回值不是这样）</td></tr><tr><td><code>iterator erase(iterator first, iterator last);</code></td><td>删除区间<code>[first, last)</code>，返回<code>last</code>（<code>Visual Studio 2010</code>中如此，但是在<code>C++</code>标准和<code>Dev C++</code>中，返回值不是这样）</td></tr></tbody></table><p>​    <code>multimap</code>及<code>map</code>中的<code>find</code>和<code>count</code>不用<code>==</code>运算符比较两个关键字是否相等。如果<code>x</code>比<code>y</code>小和<code>y</code>比<code>x</code>小同时为假，就认为 <code>x</code>和<code>y</code>相等。</p><h4 id="map-multimap构造函数"><a href="#map-multimap构造函数" class="headerlink" title="map/multimap构造函数"></a><code>map/multimap</code>构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;T1, T2&gt; mapTT;<span class="comment">//map默认构造函数: </span></span><br><span class="line"><span class="built_in">map</span>(<span class="keyword">const</span> <span class="built_in">map</span> &amp;mp);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><h4 id="map-multimap赋值操作"><a href="#map-multimap赋值操作" class="headerlink" title="map/multimap赋值操作"></a><code>map/multimap</code>赋值操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">map</span> &amp;mp);<span class="comment">//重载等号操作符</span></span><br><span class="line">swap(mp);<span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure><h4 id="map-multimap大小操作"><a href="#map-multimap大小操作" class="headerlink" title="map/multimap大小操作"></a><code>map/multimap</code>大小操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size();<span class="comment">//返回容器中元素的数目</span></span><br><span class="line">empty();<span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure><h4 id="map-multimap插入数据元素操作"><a href="#map-multimap插入数据元素操作" class="headerlink" title="map/multimap插入数据元素操作"></a><code>map/multimap</code>插入数据元素操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.insert(...); <span class="comment">//往容器插入元素，返回pair&lt;iterator,bool&gt;</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStu;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"小张"</span>));</span><br><span class="line"><span class="comment">// 第二种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.inset(make_pair(<span class="number">-1</span>, <span class="string">"校长"</span>));</span><br><span class="line"><span class="comment">// 第三种 通过value_type的方式插入对象</span></span><br><span class="line">mapStu.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">1</span>, <span class="string">"小李"</span>));</span><br><span class="line"><span class="comment">// 第四种 通过数组的方式插入值</span></span><br><span class="line">mapStu[<span class="number">3</span>] = <span class="string">"小刘"</span>;</span><br><span class="line">mapStu[<span class="number">5</span>] = <span class="string">"小王"</span>;</span><br></pre></td></tr></table></figure><h4 id="map-multimap删除操作"><a href="#map-multimap删除操作" class="headerlink" title="map/multimap删除操作"></a><code>map/multimap</code>删除操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear();<span class="comment">//删除所有元素</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line">erase(beg,end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line">erase(keyElem);<span class="comment">//删除容器中key为keyElem的对组。</span></span><br></pre></td></tr></table></figure><h4 id="map-multimap查找操作"><a href="#map-multimap查找操作" class="headerlink" title="map/multimap查找操作"></a><code>map/multimap</code>查找操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find(key);<span class="comment">//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();</span></span><br><span class="line">count(keyElem);<span class="comment">//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span></span><br><span class="line">lower_bound(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line">upper_bound(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line">equal_range(keyElem);<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器。</span></span><br></pre></td></tr></table></figure><h3 id="multimap用法"><a href="#multimap用法" class="headerlink" title="multimap用法"></a><code>multimap</code>用法</h3><h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//multimap 案例</span></span><br><span class="line"><span class="comment">//公司今天招聘了 5 个员工，5 名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">//人员信息有: 姓名 年龄 电话 工资等组成</span></span><br><span class="line"><span class="comment">//通过 Multimap 进行信息的插入 保存 显示</span></span><br><span class="line"><span class="comment">//分部门显示员工信息 显示全部员工信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALE_DEPATMENT 1 <span class="comment">//销售部门</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVELOP_DEPATMENT 2 <span class="comment">//研发部门</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FINACIAL_DEPATMENT 3 <span class="comment">//财务部门</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL_DEPATMENT 4 <span class="comment">//所有部门</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> name; <span class="comment">//员工姓名</span></span><br><span class="line"><span class="keyword">int</span> age; <span class="comment">//员工年龄</span></span><br><span class="line"><span class="keyword">double</span> salary; <span class="comment">//员工工资</span></span><br><span class="line"><span class="built_in">string</span> tele; <span class="comment">//员工电话</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建5个员工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePerson</span><span class="params">(<span class="built_in">vector</span>&lt;person&gt;&amp; vlist)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> seed = <span class="string">"ABCDE"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">person p;</span><br><span class="line">p.name = <span class="string">"员工"</span>;</span><br><span class="line">p.name += seed[i];</span><br><span class="line">p.age = rand() % <span class="number">30</span> + <span class="number">20</span>;</span><br><span class="line">p.salary = rand() % <span class="number">20000</span> + <span class="number">10000</span>;</span><br><span class="line">p.tele = <span class="string">"010-8888888"</span>;</span><br><span class="line">vlist.push_back(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5名员工分配到不同的部门</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PersonByGroup</span><span class="params">(<span class="built_in">vector</span>&lt;person&gt;&amp; vlist, <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, person&gt;&amp; plist)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> operate = <span class="number">-1</span>; <span class="comment">//用户的操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;person&gt;::iterator it = vlist.begin(); it != vlist.end(); it++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"当前员工信息:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">" 年龄:"</span> &lt;&lt; it-&gt;age &lt;&lt; <span class="string">" 工资:"</span> &lt;&lt; it-&gt;salary &lt;&lt; <span class="string">" 电话："</span> &lt;&lt; it-&gt;tele &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请对该员工进行部门分配(1 销售部门, 2 研发部门, 3 财务部门):"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;operate);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (operate == SALE_DEPATMENT)&#123;  <span class="comment">//将该员工加入到销售部门</span></span><br><span class="line">plist.insert(make_pair(SALE_DEPATMENT, *it));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (operate == DEVELOP_DEPATMENT)&#123;</span><br><span class="line">plist.insert(make_pair(DEVELOP_DEPATMENT, *it));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (operate == FINACIAL_DEPATMENT)&#123;</span><br><span class="line">plist.insert(make_pair(FINACIAL_DEPATMENT, *it));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"您的输入有误，请重新输入(1 销售部门, 2 研发部门, 3 财务部门):"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;operate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"员工部门分配完毕!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"***********************************************************"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印员工信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, person&gt;&amp; plist, <span class="keyword">int</span> myoperate)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myoperate == ALL_DEPATMENT)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, person&gt;::iterator it = plist.begin(); it != plist.end(); it++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; it-&gt;second.name &lt;&lt; <span class="string">" 年龄:"</span> &lt;&lt; it-&gt;second.age &lt;&lt; <span class="string">" 工资:"</span> &lt;&lt; it-&gt;second.salary &lt;&lt; <span class="string">" 电话："</span> &lt;&lt; it-&gt;second.tele &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, person&gt;::iterator it = plist.find(myoperate);</span><br><span class="line"><span class="keyword">int</span> depatCount = plist.count(myoperate);</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (it != plist.end())&#123;</span><br><span class="line"><span class="keyword">while</span> (it != plist.end() &amp;&amp; num &lt; depatCount)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; it-&gt;second.name &lt;&lt; <span class="string">" 年龄:"</span> &lt;&lt; it-&gt;second.age &lt;&lt; <span class="string">" 工资:"</span> &lt;&lt; it-&gt;second.salary &lt;&lt; <span class="string">" 电话："</span> &lt;&lt; it-&gt;second.tele &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">it++;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据用户操作显示不同部门的人员列表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowPersonList</span><span class="params">(<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, person&gt;&amp; plist, <span class="keyword">int</span> myoperate)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (myoperate)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> SALE_DEPATMENT:</span><br><span class="line">printList(plist, SALE_DEPATMENT);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DEVELOP_DEPATMENT:</span><br><span class="line">printList(plist, DEVELOP_DEPATMENT);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FINACIAL_DEPATMENT:</span><br><span class="line">printList(plist, FINACIAL_DEPATMENT);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ALL_DEPATMENT:</span><br><span class="line">printList(plist, ALL_DEPATMENT);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户操作菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PersonMenue</span><span class="params">(<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, person&gt;&amp; plist)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> isexit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入您的操作((1 销售部门, 2 研发部门, 3 财务部门, 4 所有部门, 0退出)："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;flag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> SALE_DEPATMENT:</span><br><span class="line">ShowPersonList(plist, SALE_DEPATMENT);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DEVELOP_DEPATMENT:</span><br><span class="line">ShowPersonList(plist, DEVELOP_DEPATMENT);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FINACIAL_DEPATMENT:</span><br><span class="line">ShowPersonList(plist, FINACIAL_DEPATMENT);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ALL_DEPATMENT:</span><br><span class="line">ShowPersonList(plist, ALL_DEPATMENT);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">isexit = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"您的输入有误，请重新输入!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isexit == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;person&gt;  vlist; <span class="comment">//创建的5个员工 未分组</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, person&gt; plist; <span class="comment">//保存分组后员工信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建5个员工</span></span><br><span class="line">CreatePerson(vlist);</span><br><span class="line"><span class="comment">//5名员工分配到不同的部门</span></span><br><span class="line">PersonByGroup(vlist, plist);</span><br><span class="line"><span class="comment">//根据用户输入显示不同部门员工信息列表 或者 显示全部员工的信息列表</span></span><br><span class="line">PersonMenue(plist);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><p>​    例题：一个学生成绩录入和查询系统接受以下两种输入：<br><code>1) Add name id score</code><br><code>2) Query score</code></p><p>​    <code>name</code>是一个字符串，其中不包含空格，表示学生姓名。<code>id</code>是一个整数，表示学号。<code>score</code>是一个整数，表示分数。学号不会重复，分数和姓名都可能重复。</p><p> 两种输入交替出现。</p><ul><li>第一种输入表示要添加一个学生的信息，碰到这种输入，就记下学生的姓名、<code>id</code>和分数。</li><li>第二种输入表示要查询分数为<code>score</code>的学生的信息，碰到这种输入，就输出已有记录中分数比查询分数低的最高分获得者的姓名、学号和分数。如果有多个学生满足条件，则输出学号最大的学生的信息。如果找不到满足条件的学生，则输出<code>“Nobody”</code>。</li></ul><p>输入样例：<br> <code>Add Jack 12 78</code><br><code>Query 78</code><br><code>Query 81</code><br><code>Add Percy 9 81</code><br><code>Add Marry 8 81</code><br><code>Query 82</code><br><code>Add Tom 11 79</code><br><code>Query 80</code><br><code>Query 81</code></p><p> 输出结果样例：<br><code>Nobody</code><br><code>Jack 12 78</code><br><code>Percy 9 81</code><br><code>Tom 11 79</code><br><code>Tom 11 79</code></p><p>​    此题如果用<code>vector</code>存放所有学生的信息，然后进行顺序查找的话，在学生数量很大和查询很多的情况下非常费时，因为顺序查找的时间复杂度是<code>O(n)</code>。将<code>vector</code>排序后再查找也不行，因为会不断插入新元素，每次插入新元素就要进行元素的移动，而这一步骤的时间复杂度是<code>O(n)</code>，这会导致效率低下。</p><p>​    下面程序的思路是用<code>multimap</code>存放学生信息，使学生信息按照分数排序。</p><p>​    要添加学生时，就用<code>insert</code>成员函数插入学生记录，这步操作的时间复杂度是<code>O(log(n))</code>。</p><p>​    输入一个要查询的分数<code>score</code>时，就用<code>lower_bound</code>求得该分数对应的下界——迭代器<code>p</code>（这一步的时间复杂度是<code>O(log(n)）</code>。<code>*p</code>这个元素的分数是大于或等于<code>score</code>的，往前再找一个元素，其分数就是低于<code>score</code>  的最高分了。继续往前遍历所有等于该分数的元素，找出<code>id</code>最大的元素输出即可。</p><p>解题程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //使用multimap需要包含此头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CInfo</span>  //类的内部还可以定义类</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    CInfo info;  <span class="comment">//学生的其他信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multimap</span> &lt;<span class="keyword">int</span>, CStudent::CInfo&gt; MAP_STD;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    MAP_STD mp;</span><br><span class="line">    CStudent st;</span><br><span class="line">    <span class="built_in">string</span> cmd;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; cmd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmd == <span class="string">"Add"</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; st.info.name &gt;&gt; st.info.id &gt;&gt; st.score;</span><br><span class="line">            mp.insert(MAP_STD::value_type(st.score, st.info));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">"Query"</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> score;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line">            MAP_STD::iterator p = mp.lower_bound(score);</span><br><span class="line">            <span class="keyword">if</span> (p != mp.begin()) &#123;</span><br><span class="line">                --p;</span><br><span class="line">                score = p-&gt;first;  <span class="comment">//比要查询分数低的最高分</span></span><br><span class="line">                MAP_STD::iterator maxp = p;</span><br><span class="line">                <span class="keyword">int</span> maxId = p-&gt;second.id;</span><br><span class="line">                <span class="keyword">for</span> (; p != mp.begin() &amp;&amp; p-&gt;first == score; --p) &#123;</span><br><span class="line">                    <span class="comment">//遍历所有成绩和score相等的学生</span></span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;second.id &gt; maxId) &#123;</span><br><span class="line">                        maxp = p;</span><br><span class="line">                        maxId = p-&gt;second.id;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;first == score) &#123; <span class="comment">//如果上面的循环因为 p == mp.begin()</span></span><br><span class="line">                                         <span class="comment">//而终止，则p指向的元素还要处理</span></span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;second.id &gt; maxId) &#123;</span><br><span class="line">                        maxp = p;</span><br><span class="line">                        maxId = p-&gt;second.id;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; maxp-&gt;second.name &lt;&lt; <span class="string">" "</span> &lt;&lt; maxp-&gt;second.id &lt;&lt; <span class="string">" "</span></span><br><span class="line">                    &lt;&lt; maxp-&gt;first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//lower_bound 的结果就是 begin，说明没有分数比查询分数低</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Nobody"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>multimap</code>容器中的元素必须是<code>pair</code>类模板对象。本题需要用<code>multimap</code>来存放学生信息，然而学生信息由三部分组成：姓名、学号、分数，解决的办法就是将用于排序的<code>score</code>作为一个成员变量，而且把其他部分一起作为一个<code>CInfo</code>对象，这样，第<code>16</code>行实例化出来的类<code>multimap &lt;int, CStudent::CInfo&gt;</code>中的元素的类型就会是如下<code>pair</code>模板类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pair</span> &lt;int, CStudent::CInfo&gt;</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> first; <span class="comment">//对应于CStudent::score</span></span><br><span class="line">   CStudent::CInfo second; <span class="comment">//对应于 CStudent::info</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><p>​    第<code>26</code>行如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.insert( MAP_STD::value_type(st.score, st.info) );</span><br></pre></td></tr></table></figure></p><p>​    参看<code>multimap</code>的定义，<code>MAP_STD::value_type</code>就是容器中元素的类型，该类型是<code>pair &lt;int,  CStudent::CInfo&gt;</code>。类型名后面跟构造函数的参数表就代表一个对象。因此，此条语句生成了一个<code>pair &lt;int,  CStudent::CInfo&gt;</code>对象并将其插入<code>multimap</code>容器中。该对象内部存放的信息和<code>st</code>相同，<code>first</code>对应于<code>st.score</code>，<code>second</code>对应于<code>st.info</code>。</p><p>​    第<code>31</code>行，<code>lower_bound</code>的返回结果<code>p</code>满足以下条件：<code>[begin(), p)</code>中的分数都比查询分数低，但是<code>*p</code>的分数不比查询分数低。所以执行<code>--p</code>操作之后，<code>*p</code>的分数就是低于查询分数的最高分了。</p><h3 id="map的用法"><a href="#map的用法" class="headerlink" title="map的用法"></a><code>map</code>的用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //使用map需要包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ostream</span> &amp; <span class="title">operator</span> &lt;&lt;(ostream &amp; o,const pair&lt;T1,T2&gt; &amp; p)</span></span><br><span class="line"><span class="class">&#123; //将pair对象输出为 (first,second)形式</span></span><br><span class="line"><span class="class">    o &lt;&lt; "(" &lt;&lt; p.first  &lt;&lt; "," &lt;&lt; p.second &lt;&lt; ")";</span></span><br><span class="line"><span class="class">    return o;</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">template&lt;class T&gt;</span></span><br><span class="line"><span class="class">void Print(T first,T last)</span></span><br><span class="line"><span class="class">&#123;//打印区间[first,last)</span></span><br><span class="line"><span class="class">    for( ; first != last; ++ first)</span></span><br><span class="line"><span class="class">        cout &lt;&lt;  * first &lt;&lt; " ";</span></span><br><span class="line"><span class="class">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">typedef map&lt;int,double,greater&lt;int&gt; &gt; MYMAP; //此容器关键字是整型，元素按关键字从大到小排序</span></span><br><span class="line"><span class="class">int main()</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    MYMAP mp;</span></span><br><span class="line"><span class="class">    mp.insert(MYMAP::value_type(15,2.7));</span></span><br><span class="line"><span class="class">    pair&lt;MYMAP::iterator,bool&gt; p = mp.insert(make_pair(15,99.3));</span></span><br><span class="line"><span class="class">    if(!p.second)</span></span><br><span class="line"><span class="class">        cout &lt;&lt; * (p.first) &lt;&lt; " already exists" &lt;&lt; endl; //会输出</span></span><br><span class="line"><span class="class">    cout &lt;&lt; "1) " &lt;&lt; mp.count(15) &lt;&lt; endl; //输出 1) 1</span></span><br><span class="line"><span class="class">    mp.insert(make_pair(20,9.3));</span></span><br><span class="line"><span class="class">    cout &lt;&lt; "2) " &lt;&lt; mp[40] &lt;&lt; endl;//如果没有关键字为40的元素，则插入一个</span></span><br><span class="line"><span class="class">    cout &lt;&lt; "3) ";Print(mp.begin(),mp.end());//输出：3) (40,0)(20,9.3)(15,2.7)</span></span><br><span class="line"><span class="class">    mp[15] = 6.28; //把关键字为15的元素值改成6.28</span></span><br><span class="line"><span class="class">    mp[17] = 3.14; //插入关键字为17的元素，并将其值设为3.14</span></span><br><span class="line"><span class="class">    cout &lt;&lt; "4) ";Print(mp.begin(),mp.end());</span></span><br><span class="line"><span class="class">    return 0;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>程序的输出结果如下：<br><code>(15,2.7) already exists</code><br><code>1) 1</code><br><code>2) 0</code><br><code>3) (40,0) (20,9.3) (15,2.7)</code><br><code>4) (40,0) (20,9.3) (17,3.14) (15,6.28)</code></p><p>​    第<code>17</code>行的<code>greater  &gt;</code>最右边的两个<code>&gt;</code>之间要有空格，否则<code>Dev C++</code>会将它们当作右移运算符，导致编译出错。在<code>Visual Studio 2010</code>中无此问题。</p><p>​    第<code>22</code>行用<code>STL</code>中的函数模板<code>make_pair</code>生成一个<code>pair</code>模板类对象插入<code>mp</code>中。</p><p>​    第<code>23</code>行，如果插入成功，<code>p.second</code>的值会是<code>true</code>。显然这里不能成功，因为<code>map</code>不允许关键字重复。因为关键字重复而插入失败时，<code>p.first</code> 就指向容器中关键字相同的那个元素。</p><p>​    第<code>27</code>行要访问关键字为<code>40</code>的元素。在没有这个元素的情况下，一个关键字为<code>40</code>、值为<code>0</code>的元素被自动插入容器。<code>mp[40]</code>等价于<code>mp.operator[](40);</code>，其返回值是关键字为<code>40</code>的那个元素（不论是原有的还是新插入的）的<code>second</code>成员变量的引用。第<code>29</code>行和第<code>30</code>行的道理与此类似。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++STL-pair类模板</title>
      <link href="/2018/09/10/c++-STL-pair%E7%B1%BB%E6%A8%A1%E6%9D%BF/"/>
      <url>/2018/09/10/c++-STL-pair%E7%B1%BB%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>在学习关联容器之前，首先要了解<code>STL</code>中的<code>pair</code> 类模板，因为关联容器的一些成员函数的返回值是<code>pair</code>对象，而且<code>map</code>和<code>multimap</code>容器中的元素都是<code>pair</code>对象。<code>pair</code>的定义如下：</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Tl, class_T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _T1 first;</span><br><span class="line">    _T2 second;</span><br><span class="line">    pair(): first(), second() &#123;&#125;  <span class="comment">//用无参构造函数初始化 first 和 second</span></span><br><span class="line">    pair(<span class="keyword">const</span> _T1 &amp;__a, <span class="keyword">const</span> _T2 &amp;__b): first(__a), second(__b) &#123;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;class_U1, class_U2&gt;</span><br><span class="line">    pair(<span class="keyword">const</span> pair &lt;_U1, _U2&gt; &amp;__p): first(__p.first), second(__p.second) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    <code>pair</code>实例化出来的类都有两个成员变量，一个是<code>first</code>, 一个是<code>second</code>。</p><p>​    <code>STL</code>中还有一个函数模板<code>make_pair</code>，其功能是生成一个<code>pair</code>模板类对象。<code>make_pair</code>的源代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;T1, T2 &gt; <span class="title">make_pair</span>(<span class="title">T1</span> <span class="title">x</span>, <span class="title">T2</span> <span class="title">y</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> ( pair&lt;T1, T2&gt; (x, y) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    下面的程序演示了<code>pair</code>和<code>make_pair</code>的用法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; p1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.first &lt;&lt; <span class="string">","</span> &lt;&lt; p1.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出  0,0   </span></span><br><span class="line">    </span><br><span class="line">    pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p2(<span class="string">"this"</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p2.first &lt;&lt; <span class="string">","</span> &lt;&lt; p2.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出  this,20</span></span><br><span class="line">    </span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p3(pair&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt;(<span class="string">'a'</span>,<span class="string">'b'</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p3.first &lt;&lt; <span class="string">","</span> &lt;&lt; p3.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出  97,98</span></span><br><span class="line">    </span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; p4 = make_pair(<span class="number">200</span>,<span class="string">"hello"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p4.first &lt;&lt; <span class="string">","</span> &lt;&lt; p4.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出  200,hello</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>pair</code>模板中的第三个构造函数是函数模板，参数必须是一个<code>pair</code>模板类对象的引用。程序中第<code>11</code>行的<code>p3</code>就是用这个构造函数初始化的。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++STL库函数bitset</title>
      <link href="/2018/09/01/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0bitset/"/>
      <url>/2018/09/01/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0bitset/</url>
      
        <content type="html"><![CDATA[<p><code>bitset</code>模板类由若干个位（<code>bit</code>）组成，它提供一些成员函数，使程序员不必通过位运算就能很方便地访问、修改其中的任意一位。<code>bitset</code> 模板类在头文件<code>&lt;bitset&gt;</code>中定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">bitset</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   ...</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>​    <code>size_t</code>可看作<code>unsigned int</code>。将<code>bitset</code>实例化时，<code>N</code>必须是一个整型常数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span> &lt;40&gt; bst;</span><br></pre></td></tr></table></figure><p>​    则<code>bst</code>是一个由<code>40</code>个位组成的对象，用<code>bitset</code>的成员函数可以方便地访问其中任意一位。<code>bitset 中</code>的位从<code>0</code>开始编号，第<code>0</code>位是最右边的位。</p><p><code>bitset</code> 有许多成员函数，有些成员函数执行的就是类似于位运算的操作。<code>bitset</code>成员函数列表如下：<br>|成员函数|功能|<br>|————|————-|<br>| <code>bitset &lt;N&gt; &amp; operator &amp;= (const bitset &lt;N&gt; &amp;rhs);</code> |和另一个<code>bitset</code>对象进行与操作|<br>| <code>bitset &lt;N&gt; &amp; operator|=(const bitset &lt;N&gt; &amp;rhs);</code>  | 和另一个<code>bitset</code> 对象进行或操作 |<br>| <code>bitset &lt;N&gt; &amp; operator ^= (const bitset &lt;N&gt; &amp;rhs);</code> | 和另一个<code>bitset</code>对象进行异或操作 |<br>| <code>bitset &lt;N&gt; &amp; operator &lt;&lt;= (size_t num);</code> |左移<code>num</code>位|<br>| <code>bitset &lt;N&gt; &amp; operator &gt;&gt;= (size_t num);</code> |右移<code>num</code>位|<br>| <code>bitset &lt;N&gt; &amp; set();</code> |将所有位全部设成<code>1</code>|<br>| <code>bitset &lt;N&gt; &amp; set(size_t pos, bool val = true);</code> |将第<code>pos</code>位设为<code>val</code>|<br>| <code>bitset &lt;N&gt; &amp; reset();</code> |将所有位全部设成<code>0</code>|<br>| <code>bitset &lt;N&gt; &amp; reset (size_t pos);</code> |将第<code>pos</code> 位设成 <code>0</code>|<br>| <code>bitset &lt;N&gt; &amp; flip();</code> |将所有位翻转（<code>0</code>变成<code>1</code>，<code>1</code>变成<code>0</code>）|<br>| <code>bitset &lt;N&gt; &amp; flip(size_t pos);</code> |翻转第<code>pos</code>位|<br>| <code>reference operator[] (size_t pos);</code> |返回对第<code>pos</code>位的引用|<br>| <code>bool operator[] (size_t pos) const;</code> |返回第<code>pos</code>位的值|<br>| <code>reference at(size_t pos);</code> |返回对第<code>pos</code>位的引用|<br>| <code>bool at (size_t pos) const;</code> |返回第<code>pos</code>位的值|<br>| <code>unsigned long to_ulong() const;</code> |将对象中的<code>0</code>、<code>1</code>串转换成整数|<br>| <code>string to_string () const;</code> |将对象中的<code>0</code>、<code>1</code>串转换成字符串|<br>| <code>size_t count() const;</code> |计算<code>1</code>的个数|<br>| <code>size_t size () const;</code> |返回总位数|<br>| <code>bool operator == (const bitset &lt;N&gt; &amp; rhs) const;</code> ||<br>| <code>bool operator != (const bitset &lt;N&gt; &amp; rhs) const;</code> ||<br>| <code>bool test(size_t pos) const;</code> |测试第<code>pos</code>位是否为<code>1</code>|<br>| <code>bool any() const;</code> |判断是否有某位为<code>1</code>|<br>| <code>bool none() const;</code> |判断是否全部为<code>0</code>|<br>| <code>bitset &lt;N&gt; operator &lt;&lt; (size_t pos) const;</code> |返回左移<code>pos</code>位后的结果|<br>| <code>bitset &lt;N&gt; operator &gt;&gt; (size_t pos) const;</code> |返回右移<code>pos</code>位后的结果|<br>| <code>bitset &lt;N&gt; operator ~ ();</code> |返回取反后的结果|<br>| <code>bitset &lt;N&gt; operator &amp; (const bitset &lt;N&gt; &amp; rhs) const;</code> |返回和另一个<code>bitset</code> 对象<code>rhs</code>进行与运算的结果|<br>| <code>bitset &lt;N&gt; operator | (const bitset &lt;N&gt; &amp; rhs) const;</code>  |返回和另一个<code>bitset</code>对象<code>rhs</code>进行或运算的结果|<br>| <code>bitset &lt;N&gt; operator ^ (const bitset &lt;N&gt; &amp; rhs) const;</code> |返回和另一个<code>bitset</code>对象<code>rhs</code>进行异或运算的结果|</p><p> 下面的程序演示了<code>bitset</code>的用法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;7&gt; bst1;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;7&gt; bst2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1) "</span> &lt;&lt; bst1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 1) 0000000</span></span><br><span class="line">    bst1.<span class="built_in">set</span>(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//将第0位变成1，bst1变为 0000001</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2) "</span> &lt;&lt; bst1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 2) 0000001</span></span><br><span class="line">    bst1 &lt;&lt;= <span class="number">4</span>; <span class="comment">//左移4位，变为 0010000</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3) "</span> &lt;&lt; bst1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 3) 0010000</span></span><br><span class="line">    bst2.<span class="built_in">set</span>(<span class="number">2</span>);<span class="comment">//第二位设置为1，bst2变成  0000100</span></span><br><span class="line">    bst2 |=bst1; <span class="comment">// bst2变成  0010100</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4) "</span> &lt;&lt; bst2 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 4) 0010100</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5) "</span> &lt;&lt; bst2.to_ulong () &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 5) 20</span></span><br><span class="line">    bst2.flip(); <span class="comment">//每一位都取反，bst2变成 1101011</span></span><br><span class="line">    bst1.<span class="built_in">set</span>(<span class="number">3</span>); <span class="comment">//bst1变成  0011000</span></span><br><span class="line">    bst2.flip(<span class="number">6</span>); <span class="comment">//bst2变成 0101011</span></span><br><span class="line">    <span class="built_in">bitset</span>&lt;7&gt; bst3 = bst2^ bst1;<span class="comment">//bst3 变成 0110011</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"6) "</span> &lt;&lt; bst3 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 6) 0110011</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"7) "</span> &lt;&lt; bst3[<span class="number">3</span>] &lt;&lt; <span class="string">","</span> &lt;&lt; bst3[<span class="number">4</span>] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 7) 0,1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++STL库函数string</title>
      <link href="/2018/08/28/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0string/"/>
      <url>/2018/08/28/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0string/</url>
      
        <content type="html"><![CDATA[<h2 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a><code>string</code>容器</h2><h3 id="string容器基本概念"><a href="#string容器基本概念" class="headerlink" title="string容器基本概念"></a><code>string</code>容器基本概念</h3><p>​    <code>C</code>风格字符串(以空字符结尾的字符数组)太过复杂难于掌握，不适合大程序的开发，所以<code>C++</code>标准库定义了一种<code>string</code>类，定义在头文件<code>&lt;string&gt;</code>。</p><p>​    <code>string</code>类是 <code>STL</code>中<code>basic_string</code>模板实例化得到的模板类。其定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> basic_string &lt;<span class="keyword">char</span>&gt; <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><code>String</code>和<code>c</code>风格字符串对比：</p><ul><li><p><code>Char*</code>是一个指针，<code>String</code>是一个类</p><p><code>string</code>封装了<code>char*</code>，管理这个字符串，是一个<code>char*</code>型的容器。</p></li><li><p><code>String</code>封装了很多实用的成员方法</p><p>查找<code>find</code>，拷贝<code>copy</code>，删除<code>delete</code>替换<code>replace</code>，插入<code>insert</code></p></li><li><p>不用考虑内存释放和越界</p><p> <code>string</code>管理<code>char*</code>所分配的内存。每一次<code>string</code>的复制，取值都由<code>string</code>类负责维护，不用担心复制越界和取值越界等。</p></li></ul><h3 id="string容器常用操作"><a href="#string容器常用操作" class="headerlink" title="string容器常用操作"></a><code>string</code>容器常用操作</h3><h4 id="string-构造函数"><a href="#string-构造函数" class="headerlink" title="string 构造函数"></a><code>string</code> 构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>();<span class="comment">//创建一个空的字符串 例如: string str;      </span></span><br><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str);<span class="comment">//使用一个string对象初始化另一个string对象</span></span><br><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s);<span class="comment">//使用字符串s初始化</span></span><br><span class="line"><span class="built_in">string</span>(<span class="keyword">int</span> n, <span class="keyword">char</span> c);<span class="comment">//使用n个字符c初始化 </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="string">"12345"</span>, <span class="number">1</span>, <span class="number">3</span>)</span></span>;  <span class="comment">//s4 = "234"，即 "12345" 的从下标 1 开始，长度为 3 的子串</span></span><br></pre></td></tr></table></figure><p>​    <code>string</code>类没有接收一个整型参数或一个字符型参数的构造函数。下面的两种写法是错误的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">'K'</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="string基本赋值操作"><a href="#string基本赋值操作" class="headerlink" title="string基本赋值操作"></a><code>string</code>基本赋值操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* s);<span class="comment">//char*类型字符串 赋值给当前的字符串</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s);<span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">char</span> c);<span class="comment">//字符赋值给当前的字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">assign</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;<span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">assign</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符赋给当前的字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">assign</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>;<span class="comment">//把字符串s赋给当前字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">assign</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;<span class="comment">//用n个字符c赋给当前字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">assign</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> start, <span class="keyword">int</span> n)</span></span>;<span class="comment">//将s从start开始n个字符赋值给字符串</span></span><br></pre></td></tr></table></figure><h4 id="string存取字符操作"><a href="#string存取字符操作" class="headerlink" title="string存取字符操作"></a><code>string</code>存取字符操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> n);<span class="comment">//通过[]方式取字符</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>&amp; <span class="title">at</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//通过at方法获取字符</span></span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><p>​    为了修改<code>string</code>字符串的内容，下标操作符<code>[]</code>和<code>at</code>都会返回字符的引用。但当字符串的内存被重新分配之后，可能发生错误</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">char</span>&amp; a = s[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span>&amp; b = s[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">a = <span class="string">'1'</span>;</span><br><span class="line">b = <span class="string">'2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>*)s.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">s = <span class="string">"pppppppppppppppppppppppp"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a = '1';</span></span><br><span class="line"><span class="comment">//b = '2';</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>*)s.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h4 id="string求字符串的长度"><a href="#string求字符串的长度" class="headerlink" title="string求字符串的长度"></a><code>string</code>求字符串的长度</h4><p><code>length</code>成员函数返回字符串的长度。<code>size</code>成员函数可以实现同样的功能。</p><h4 id="string拼接操作"><a href="#string拼接操作" class="headerlink" title="string拼接操作"></a><code>string</code>拼接操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str);<span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="keyword">char</span>* str);<span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="keyword">char</span> c);<span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;<span class="comment">//把字符串s连接到当前字符串结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>;<span class="comment">//同operator+=()</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span></span>;<span class="comment">//把字符串s中从pos开始的n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;<span class="comment">//在当前字符串结尾添加n个字符c</span></span><br></pre></td></tr></table></figure><h4 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a><code>string</code>查找和替换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>; <span class="comment">//查找str第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;  <span class="comment">//查找s第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;  <span class="comment">//从pos位置查找s的前n个字符第一次位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;  <span class="comment">//查找字符c第一次出现位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>;<span class="comment">//查找str最后一次位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>;<span class="comment">//查找s最后一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos查找s的前n个字符最后一次位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>; <span class="comment">//查找字符c最后一次出现位置</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">replace</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>; <span class="comment">//替换从pos开始n个字符为字符串str</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">replace</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>; <span class="comment">//替换从pos开始的n个字符为字符串s</span></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"Source Code"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find(<span class="string">'u'</span>)) != <span class="built_in">string</span>::npos) <span class="comment">//查找 u 出现的位置</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1) "</span> &lt;&lt; n &lt;&lt; <span class="string">","</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 l)2,urce Code</span></span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find(<span class="string">"Source"</span>, <span class="number">3</span>)) == <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="comment">//从下标3开始查找"Source"，找不到</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"2) "</span> &lt;&lt; <span class="string">"Not Found"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 2) Not Found</span></span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find(<span class="string">"Co"</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="comment">//查找子串"Co"。能找到，返回"Co"的位置</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"3) "</span> &lt;&lt; n &lt;&lt; <span class="string">", "</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 3) 7, Code</span></span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find_first_of(<span class="string">"ceo"</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="comment">//查找第一次出现或 'c'、'e'或'o'的位置</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"4) "</span> &lt;&lt; n &lt;&lt; <span class="string">", "</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 4) l, ource Code</span></span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find_last_of(<span class="string">'e'</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="comment">//查找最后一个 'e' 的位置</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"5) "</span> &lt;&lt; n &lt;&lt; <span class="string">", "</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 5) 10, e</span></span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find_first_not_of(<span class="string">"eou"</span>, <span class="number">1</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="comment">//从下标1开始查找第一次出现非 'e'、'o' 或 'u' 字符的位置</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"6) "</span> &lt;&lt; n &lt;&lt; <span class="string">", "</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 6) 3, rce Code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string比较操作"><a href="#string比较操作" class="headerlink" title="string比较操作"></a><code>string</code>比较操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。</span></span><br><span class="line"><span class="comment">比较区分大小写，比较时参考字典顺序，排越前面的越小。</span></span><br><span class="line"><span class="comment">大写的A比小写的a小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span></span>;<span class="comment">//与字符串s比较</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> <span class="keyword">const</span></span>;<span class="comment">//与字符串s比较</span></span><br></pre></td></tr></table></figure><h4 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a><code>string</code>子串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span><span class="params">(<span class="keyword">int</span> pos = <span class="number">0</span>, <span class="keyword">int</span> n = npos)</span> <span class="keyword">const</span></span>;<span class="comment">//返回由pos开始的n个字符组成的字符串</span></span><br></pre></td></tr></table></figure><h4 id="string插入和删除操作"><a href="#string插入和删除操作" class="headerlink" title="string插入和删除操作"></a><code>string</code>插入和删除操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;<span class="comment">//在指定位置插入n个字符c</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">erase</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n = npos)</span></span>;<span class="comment">//删除从Pos开始的n个字符</span></span><br></pre></td></tr></table></figure><h4 id="string和c-style字符串转换"><a href="#string和c-style字符串转换" class="headerlink" title="string和c-style字符串转换"></a><code>string</code>和<code>c-style</code>字符串转换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string 转 char*</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"itcast"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cstr = str.c_str();</span><br><span class="line"><span class="comment">//char* 转 string </span></span><br><span class="line"><span class="keyword">char</span>* s = <span class="string">"itcast"</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(s)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><p>​    在<code>c++</code>中存在一个从<code>const char*</code>到<code>string</code>的隐式类型转换，却不存在从一个<code>string</code>对象到<code>C_string</code>的自动类型转换。对于<code>string</code>类型的字符串，可以通过<code>c_str()</code>函数返回<code>string</code>对象对应的<code>C_string</code>。</p><p>​    通常，程序员在整个程序中应坚持使用<code>string</code>类对象，直到必须将内容转化为<code>char*</code>时才将其转换为<code>C_string</code>.</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++STL库函数stack</title>
      <link href="/2018/08/26/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0stack/"/>
      <url>/2018/08/26/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0stack/</url>
      
        <content type="html"><![CDATA[<h2 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a><code>stack</code>容器</h2><h3 id="stack容器基本概念"><a href="#stack容器基本概念" class="headerlink" title="stack容器基本概念"></a><code>stack</code>容器基本概念</h3><p>​    <code>stack</code>是一种先进后出(<code>First In Last Out</code>，<code>FILO</code>)的数据结构，它只有一个出口，形式如图所示。stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取<code>stack</code>的其他元素。换言之，<code>stack</code>不允许有遍历行为。</p><a id="more"></a><p>​    有元素推入栈的操作称为：<code>push</code>，将元素推出<code>stack</code>的操作称为<code>pop</code>。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/8b82b9014a90f603eab7c55f3912b31bb051eda7.jpg" style="zoom:50%;"></p><p>​    <code>stack</code>的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Cont</span> == <span class="title">deque</span> &lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"> <span class="title">class</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">   ...</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><p>​    第二个参数表明，在默认情况下，<code>stack</code>就是用<code>deque</code>实现的。当然，也可以指定用<code>vector</code>或<code>list</code>实现。</p><p>​    虽然<code>stack</code>使用顺序容器实现，但它不提供顺序容器具有的成员函数。除了<code>size</code>、<code>empty</code>这两个所有容器都有的成员函数外，<code>stack</code>还有以下三个成员函数。</p><h3 id="stack没有迭代器"><a href="#stack没有迭代器" class="headerlink" title="stack没有迭代器"></a><code>stack</code>没有迭代器</h3><p>​    <code>Stack</code>所有元素的进出都必须符合”先进后出”的条件，只有<code>stack</code>顶端的元素，才有机会被外界取用。<code>Stack</code>不提供遍历功能，也不提供迭代器。</p><h3 id="stack常用API"><a href="#stack常用API" class="headerlink" title="stack常用API"></a><code>stack</code>常用<code>API</code></h3><table><thead><tr><th>成员函数</th><th>功  能</th></tr></thead><tbody><tr><td><code>void pop();</code></td><td>弹出（即删除）栈顶元素</td></tr><tr><td><code>T &amp;top();</code></td><td>返回栈顶元素的引用。通过此函数可以读取栈顶元素的值，也可以修改栈顶元素</td></tr><tr><td><code>void push (const T &amp;x);</code></td><td>将<code>x</code>压入栈顶</td></tr></tbody></table><h4 id="stack构造函数"><a href="#stack构造函数" class="headerlink" title="stack构造函数"></a><code>stack</code>构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;T&gt; stkT;<span class="comment">//stack采用模板类实现， stack对象的默认构造形式： </span></span><br><span class="line"><span class="built_in">stack</span>(<span class="keyword">const</span> <span class="built_in">stack</span> &amp;stk);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><h4 id="stack赋值操作"><a href="#stack赋值操作" class="headerlink" title="stack赋值操作"></a><code>stack</code>赋值操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">stack</span> &amp;stk);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure><h4 id="stack数据存取操作"><a href="#stack数据存取操作" class="headerlink" title="stack数据存取操作"></a><code>stack</code>数据存取操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push(elem);<span class="comment">//向栈顶添加元素</span></span><br><span class="line">pop();<span class="comment">//从栈顶移除第一个元素</span></span><br><span class="line">top();<span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure><h4 id="stack大小操作"><a href="#stack大小操作" class="headerlink" title="stack大小操作"></a><code>stack</code>大小操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">empty();<span class="comment">//判断堆栈是否为空</span></span><br><span class="line">size();<span class="comment">//返回堆栈的大小</span></span><br></pre></td></tr></table></figure><h3 id="stack案例"><a href="#stack案例" class="headerlink" title="stack案例"></a><code>stack</code>案例</h3><p>例题：编写程序，输入一个十进制数<code>n</code>和进制<code>k</code>（<code>k≤10</code>），输出<code>n</code>对应的<code>k</code>进制数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;  //使用stack需要包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;  <span class="comment">//将n转换为k进制数</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        stk.push(n%k);</span><br><span class="line">        n /= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++STL库函数queue</title>
      <link href="/2018/08/25/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0queue/"/>
      <url>/2018/08/25/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0queue/</url>
      
        <content type="html"><![CDATA[<h2 id="queue-priority-queue容器"><a href="#queue-priority-queue容器" class="headerlink" title="queue/priority_queue容器"></a><code>queue/priority_queue</code>容器</h2><h3 id="queue容器基本概念"><a href="#queue容器基本概念" class="headerlink" title="queue容器基本概念"></a><code>queue</code>容器基本概念</h3><p>​    <code>queue</code>就是“队列”。队列是先进先出的，和排队类似。队头的访问和删除操作只能在队头进行，添加操作只能在队尾进行。不能访问队列中间的元素。</p><a id="more"></a><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/图片5.png" style="zoom: 50%;"></p><p>​    <code>queue</code>可以用<code>list</code>和<code>deque</code>实现，默认情况下用<code>deque</code>实现。</p><p>​    <code>queue</code>的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Cont</span> = <span class="title">deque</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"> <span class="title">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">   ...</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><p>​    <code>queue</code> 同样也有和<code>stack</code>类似的<code>push</code>、<code>pop</code>、<code>top</code>函数。区别在于，<code>queue</code>的<code>push</code>发生在队尾，<code>pop</code>和<code>top</code>发生在队头。</p><h3 id="priority-queue容器基本概念"><a href="#priority-queue容器基本概念" class="headerlink" title="priority_queue容器基本概念"></a><code>priority_queue</code>容器基本概念</h3><p>​    <code>priority_queue</code>是“优先队列”。它和普通队列的区别在于，优先队列的队头元素总是最大的——即执行<code>pop</code>操作时，删除的总是最大的元素；执行<code>top</code>操作时，返回的是最大元素的引用。</p><p>​    <code>priority_queue</code> 可以用 <code>vector</code>和<code>deque</code>实现，默认情况下用<code>vector</code>实现。</p><p>​    <code>priority_queue</code>默认的元素比较器是<code>less &lt;T&gt;</code>。也就是说，在默认情况下，要放入<code>priority_queue</code>的元素必须是能用<code>“&lt;”</code>运算符进行比较的，而且<code>priority _queue</code>保证以下条件总是成立：对于队头的元素<code>x</code>和任意非队头的元素<code>y</code>，表达式<code>“x&lt;y”</code>必为<code>false</code>。</p><p>​    priority_queue 定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span> = <span class="title">vector</span> &lt;T&gt;, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"> <span class="title">class</span> <span class="title">priority_queue</span>&#123;</span></span><br><span class="line">   ...</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><p>​    <code>priority_queue</code>的第三个类型参数可以用来指定排序规则。</p><p>​    和<code>set/multiset</code>不同，<code>priority_queue</code>是使用“堆排序”技术实现的，其内部并非完全有序，但却能确保最大元素总在队头。因此，<code>priority_queue</code>特别适用于“不停地在一堆元素中取走最大的元素”这种情况。    </p><p>​    <code>priority_queue</code>插入和删除元素的复杂度都是<code>O(log(n))</code>。虽然用<code>set/multiset</code>也能完成此项工作，但是<code>priority_queue</code>比它们略快一些。</p><p>​    <code>priority_queue</code>队头的元素只能被查看或者修改，不能被删除。</p><h3 id="queue-priority-queue没有迭代器"><a href="#queue-priority-queue没有迭代器" class="headerlink" title="queue/priority_queue没有迭代器"></a><code>queue/priority_queue</code>没有迭代器</h3><p>​    <code>queue</code>所有元素的进出都必须符合”先进先出”的条件，只有<code>queue</code>的顶端元素，才有机会被外界取用。<code>queue</code>不提供遍历功能，也不提供迭代器。</p><h3 id="queue-priority-queue常用API"><a href="#queue-priority-queue常用API" class="headerlink" title="queue/priority_queue常用API"></a><code>queue/priority_queue</code>常用<code>API</code></h3><h4 id="queue-priority-queue构造函数"><a href="#queue-priority-queue构造函数" class="headerlink" title="queue/priority_queue构造函数"></a><code>queue/priority_queue</code>构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;T&gt; queT;<span class="comment">//queue采用模板类实现，queue对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">queue</span>(<span class="keyword">const</span> <span class="built_in">queue</span> &amp;que);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><h4 id="queue-priority-queue存取、插入和删除操作"><a href="#queue-priority-queue存取、插入和删除操作" class="headerlink" title="queue/priority_queue存取、插入和删除操作"></a><code>queue/priority_queue</code>存取、插入和删除操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push(elem);<span class="comment">//往队尾添加元素</span></span><br><span class="line">pop();<span class="comment">//从队头移除第一个元素</span></span><br><span class="line">back();<span class="comment">//返回最后一个元素</span></span><br><span class="line">front();<span class="comment">//返回第一个元素</span></span><br></pre></td></tr></table></figure><h4 id="queue-priority-queue赋值操作"><a href="#queue-priority-queue赋值操作" class="headerlink" title="queue/priority_queue赋值操作"></a><code>queue/priority_queue</code>赋值操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">queue</span> &amp;que);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure><h4 id="queue-priority-queue大小操作"><a href="#queue-priority-queue大小操作" class="headerlink" title="queue/priority_queue大小操作"></a><code>queue/priority_queue</code>大小操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">empty();<span class="comment">//判断队列是否为空</span></span><br><span class="line">size();<span class="comment">//返回队列的大小</span></span><br></pre></td></tr></table></figure><h3 id="priority-queue用法"><a href="#priority-queue用法" class="headerlink" title="priority_queue用法"></a><code>priority_queue</code>用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">double</span>&gt; pq1;</span><br><span class="line">    pq1.push(<span class="number">3.2</span>); pq1.push(<span class="number">9.8</span>); pq1.push(<span class="number">9.8</span>); pq1.push(<span class="number">5.4</span>);</span><br><span class="line">    <span class="keyword">while</span>(!pq1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pq1.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        pq1.pop();</span><br><span class="line">    &#125; <span class="comment">//上面输出 9.8 9.8 5.4 3.2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    priority_queue&lt;<span class="keyword">double</span>,<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;,greater&lt;<span class="keyword">double</span>&gt; &gt; pq2;</span><br><span class="line">    pq2.push(<span class="number">3.2</span>); pq2.push(<span class="number">9.8</span>); pq2.push(<span class="number">9.8</span>); pq2.push(<span class="number">5.4</span>);</span><br><span class="line">    <span class="keyword">while</span>(!pq2.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pq2.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        pq2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面输出 3.2 5.4 9.8 9.8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    程序的输出结果是：<br><code>9.8 9.8 5.4 3.2</code><br><code>3.2 5.4 9.8 9.8</code></p><p>​    <code>pq2</code>的排序规则和<code>pq1</code>相反，因此元素出队的顺序也相反。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++STL库函数list</title>
      <link href="/2018/08/22/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0list/"/>
      <url>/2018/08/22/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0list/</url>
      
        <content type="html"><![CDATA[<h2 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a><code>list</code>容器</h2><h3 id="list容器基本概念"><a href="#list容器基本概念" class="headerlink" title="list容器基本概念"></a><code>list</code>容器基本概念</h3><p>​    链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p><p>​    相较于<code>vector</code>的连续线性空间，<code>list</code>就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，<code>list</code>对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，<code>list</code>永远是常数时间。</p><a id="more"></a><p>​    <code>list</code>和<code>vector</code>是两个最常被使用的容器。</p><p>​    <code>list</code>容器是一个双向链表。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/图片6.png" style="zoom: 50%;"></p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li><li>链表灵活，但是空间和时间额外耗费较大</li></ul><h3 id="list容器的迭代器"><a href="#list容器的迭代器" class="headerlink" title="list容器的迭代器"></a><code>list</code>容器的迭代器</h3><p>​    <code>list</code>容器不能像<code>vector</code>一样以普通指针作为迭代器，因为其节点不能保证在同一块连续的内存空间上。<code>list</code>迭代器必须有能力指向<code>list</code>的节点，并有能力进行正确的递增、递减、取值、成员存取操作。所谓”<code>list</code>正确的递增，递减、取值、成员取用”是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取的是节点的成员。</p><p>​    由于<code>list</code>是一个双向链表，迭代器必须能够具备前移、后移的能力，所以<code>list</code>容器提供的是<code>Bidirectional Iterators</code>.</p><p>​    <code>list</code>有一个重要的性质，插入操作和删除操作都不会造成原有<code>list</code>迭代器的失效。这在<code>vector</code>是不成立的，因为<code>vector</code>的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效，甚至<code>list</code>元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。</p><h3 id="list容器的数据结构"><a href="#list容器的数据结构" class="headerlink" title="list容器的数据结构"></a><code>list</code>容器的数据结构</h3><p>​    <code>list</code>容器不仅是一个双向链表，而且还是一个循环的双向链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; myList;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">myList.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::_Nodeptr node =  myList._Myhead-&gt;_Next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myList._Mysize * <span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Node:"</span> &lt;&lt; node-&gt;_Myval &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">node = node-&gt;_Next;</span><br><span class="line"><span class="keyword">if</span> (node == myList._Myhead)&#123;</span><br><span class="line">node = node-&gt;_Next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="list常用API"><a href="#list常用API" class="headerlink" title="list常用API"></a><code>list</code>常用<code>API</code></h3><table><thead><tr><th>成员函数或成员函数模板</th><th>作  用</th></tr></thead><tbody><tr><td><code>void push_front(const T &amp; val)</code></td><td>将<code>val</code>插入链表最前面</td></tr><tr><td><code>void pop_front()</code></td><td>删除链表最前面的元素</td></tr><tr><td><code>void sort()</code></td><td>将链表从小到大排序</td></tr><tr><td><code>void remove (const T &amp; val)</code></td><td>删除和<code>val</code>相等的元素</td></tr><tr><td><code>remove_if</code></td><td>删除符合某种条件的元素</td></tr><tr><td><code>void unique()</code></td><td>删除所有和前一个元素相等的元素</td></tr><tr><td><code>void merge(list &lt;T&gt; &amp;x)</code></td><td>将链表<code>x</code>合并进来并清空<code>x</code>。要求链表自身和<code>x</code>都是有序的</td></tr><tr><td><code>void splice(iterator i, list &lt;T&gt; &amp;x, iterator first, iterator last)</code></td><td>在位置<code>i</code>前面插入链表<code>x</code>中的区间<code>[first, last)</code>，并在链表 <code>x</code> 中删除该区间。链表自身和链表<code>x</code>可以是同一个链表，只要<code>i</code>不在<code>[first, last)</code>中即可</td></tr></tbody></table><p>​    <code>STL</code>中的算法<code>sort</code>可以用来对<code>vector</code>和<code>deque</code>排序，它需要随机访问迭代器的支持。因为<code>list</code>不支持随机访问迭代器，所以不能用算法<code>sort</code>对<code>list</code>容器排序。因此，<code>list</code>容器引入了<code>sort</code>成员函数以完成排序。</p><h4 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a><code>list</code>构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;T&gt; lstT;<span class="comment">//list采用采用模板类实现,对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">list</span>(beg,end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(n,elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(<span class="keyword">const</span> <span class="built_in">list</span> &amp;lst);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure><h4 id="list数据元素插入和删除操作"><a href="#list数据元素插入和删除操作" class="headerlink" title="list数据元素插入和删除操作"></a><code>list</code>数据元素插入和删除操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">push_back(elem);<span class="comment">//在容器尾部加入一个元素</span></span><br><span class="line">pop_back();<span class="comment">//删除容器中最后一个元素</span></span><br><span class="line">push_front(elem);<span class="comment">//在容器开头插入一个元素</span></span><br><span class="line">pop_front();<span class="comment">//从容器开头移除第一个元素</span></span><br><span class="line">insert(pos,elem);<span class="comment">//在pos位置插elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line">insert(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line">insert(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line">clear();<span class="comment">//移除容器的所有数据</span></span><br><span class="line">erase(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line">remove(elem);<span class="comment">//删除容器中所有与elem值匹配的元素。</span></span><br></pre></td></tr></table></figure><h4 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a><code>list</code>大小操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line">empty();<span class="comment">//判断容器是否为空</span></span><br><span class="line">resize(num);<span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line">resize(num, elem);<span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure><h4 id="list赋值操作"><a href="#list赋值操作" class="headerlink" title="list赋值操作"></a><code>list</code>赋值操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line">assign(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">list</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">list</span> &amp;lst);<span class="comment">//重载等号操作符</span></span><br><span class="line">swap(lst);<span class="comment">//将lst与本身的元素互换。</span></span><br></pre></td></tr></table></figure><h4 id="list数据的存取"><a href="#list数据的存取" class="headerlink" title="list数据的存取"></a><code>list</code>数据的存取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">front();<span class="comment">//返回第一个元素。</span></span><br><span class="line">back();<span class="comment">//返回最后一个元素。</span></span><br></pre></td></tr></table></figure><h4 id="list反转排序"><a href="#list反转排序" class="headerlink" title="list反转排序"></a><code>list</code>反转排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse();<span class="comment">//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</span></span><br><span class="line">sort(); <span class="comment">//list排序</span></span><br></pre></td></tr></table></figure><h3 id="list案例"><a href="#list案例" class="headerlink" title="list案例"></a><code>list</code>案例</h3><h4 id="list的示例程序如下："><a href="#list的示例程序如下：" class="headerlink" title="list的示例程序如下："></a><code>list</code>的示例程序如下：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;  //使用 list 需要包含此头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  //使用STL中的算法需要包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> n_) &#123; n = n_; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; o, <span class="keyword">const</span> A &amp; a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1.n &lt; a2.n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1.n == a2.n;</span><br><span class="line">&#125;</span><br><span class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; o, <span class="keyword">const</span> A &amp; a) &#123;</span><br><span class="line">    o &lt;&lt; a.n;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> <span class="title">first</span>, <span class="title">T</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    A b[<span class="number">7</span>] = &#123; <span class="number">10</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;A&gt; lst1(a, a + <span class="number">5</span>), lst2(b, b + <span class="number">7</span>);</span><br><span class="line">    lst1.sort();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1)"</span>; </span><br><span class="line">    print(lst1.begin(), lst1.end());  <span class="comment">//输出：1)1 2 2 3 4</span></span><br><span class="line">    </span><br><span class="line">    lst1.remove(<span class="number">2</span>);  <span class="comment">//删除所有和A(2)相等的元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2)"</span>; </span><br><span class="line">    print(lst1.begin(), lst1.end());  <span class="comment">//输出：2)1 3 4</span></span><br><span class="line">    </span><br><span class="line">    lst2.pop_front();  <span class="comment">//删除第一个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3)"</span>; </span><br><span class="line">    print(lst2.begin(), lst2.end());  <span class="comment">//输出：3)30 20 30 30 40 40</span></span><br><span class="line">    </span><br><span class="line">    lst2.unique();  <span class="comment">//删除所有和前一个元素相等的元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4)"</span>; </span><br><span class="line">    print(lst2.begin(), lst2.end());  <span class="comment">//输出：4)30 20 30 40</span></span><br><span class="line">    </span><br><span class="line">    lst2.sort();</span><br><span class="line">    lst1.merge(lst2);  <span class="comment">//合并 lst2 到 lst1 并清空 lst2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5)"</span>; </span><br><span class="line">    print(lst1.begin(), lst1.end());  <span class="comment">//输出：5)1 3 4 20 30 30 40</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"6)"</span>; </span><br><span class="line">    print(lst2.begin(), lst2.end());  <span class="comment">//lst2是空的，输出：6)</span></span><br><span class="line">    </span><br><span class="line">    lst1.reverse();  <span class="comment">//将 lst1 前后颠倒</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"7)"</span>; </span><br><span class="line">    print(lst1.begin(), lst1.end());  <span class="comment">//输出 7)40 30 30 20 4 3 1</span></span><br><span class="line">    </span><br><span class="line">    lst2.insert(lst2.begin(), a + <span class="number">1</span>, a + <span class="number">4</span>);  <span class="comment">//在 lst2 中插入 3,2,4 三个元素</span></span><br><span class="line">    <span class="built_in">list</span> &lt;A&gt;::iterator p1, p2, p3;</span><br><span class="line">    p1 = find(lst1.begin(), lst1.end(), <span class="number">30</span>);</span><br><span class="line">    p2 = find(lst2.begin(), lst2.end(), <span class="number">2</span>);</span><br><span class="line">    p3 = find(lst2.begin(), lst2.end(), <span class="number">4</span>);</span><br><span class="line">    lst1.splice(p1, lst2, p2, p3);  <span class="comment">//将[p2, p3)插入p1之前，并从 lst2 中删除[p2,p3)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"8)"</span>; </span><br><span class="line">    print(lst1.begin(), lst1.end());  <span class="comment">//输出：8)40 2 30 30 20 4 3 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"9)"</span>; </span><br><span class="line">    print(lst2.begin(), lst2.end());  <span class="comment">//输出：9)3 4</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="【实例】用list解决约瑟夫问题。"><a href="#【实例】用list解决约瑟夫问题。" class="headerlink" title="【实例】用list解决约瑟夫问题。"></a>【实例】用<code>list</code>解决约瑟夫问题。</h4><p>​    约瑟夫问题是：有<code>n</code>只猴子，按顺时针方向围成一圈选大王（编号为<code>1~n</code>），从第<code>1</code>号开始报数，一直数到<code>m</code>，数到<code>m</code>的猴子退到圈外，剩下的猴子再接着从<code>1</code>开始报数。就这样，直到圈内只剩下一只猴子时，这个猴子就是猴王。编程求输入<code>n</code>、<code>m</code> 后，输出最后猴王的编号。</p><p>​    输入数据：每行是用空格分开的两个整数，第一个是<code>n</code>，第二个是<code>m</code>（<code>0&lt;m, n&lt;=1 000 000</code>）。最后一行是：<br><code>0 0</code></p><p>​    输出要求：对于每行输入数据（最后一行除外），输出数据也是一行，即最后猴王的编号。</p><p> 输入样例：<br><code>6 2</code><br><code>12 4</code><br><code>8 3</code><br><code>0 0</code></p><p> 输出样例：<br><code>5</code><br><code>1</code><br><code>7</code></p><p> 示例程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; monkeys;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        monkeys.clear();  <span class="comment">//清空list容器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)  <span class="comment">//将猴子的编号放入list</span></span><br><span class="line">            monkeys.push_back(i);</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = monkeys.begin();</span><br><span class="line">        <span class="keyword">while</span> (monkeys.size() &gt; <span class="number">1</span>) &#123; <span class="comment">//只要还有不止一只猴子，就要找一只猴子让其出列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123; <span class="comment">//报数</span></span><br><span class="line">                ++it;</span><br><span class="line">                <span class="keyword">if</span> (it == monkeys.end())</span><br><span class="line">                    it = monkeys.begin();</span><br><span class="line">            &#125;</span><br><span class="line">            it = monkeys.erase(it); <span class="comment">//删除元素后，迭代器失效，</span></span><br><span class="line">                                    <span class="comment">//要重新让迭代器指向被删元素的后面</span></span><br><span class="line">            <span class="keyword">if</span> (it == monkeys.end())</span><br><span class="line">                it = monkeys.begin();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; monkeys.front() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//front返回第一个元素的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>erase</code>成员函数返回被删除元素后面那个元素的迭代器。如果被删除的是最后一个元素，则返回<code>end()</code>。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++STL库函数deque</title>
      <link href="/2018/08/20/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0deque/"/>
      <url>/2018/08/20/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0deque/</url>
      
        <content type="html"><![CDATA[<h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a><code>deque</code>容器</h2><h3 id="deque容器基本概念"><a href="#deque容器基本概念" class="headerlink" title="deque容器基本概念"></a><code>deque</code>容器基本概念</h3><p>​    <code>vector</code>容器是单向开口的连续内存空间，<code>deque</code>则是一种双向开口的连续线性空间。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，<code>vector</code>容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受。</p><a id="more"></a><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/图片2.png" style="zoom: 50%;"></p><pre><code>`deque`容器和`vector`容器最大的差异，一在于`deque`允许使用常数项时对头端进行元素的插入和删除操作。二在于`deque`没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像`vector`那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在`deque`身上是不会发生的。也因此，`deque`没有必须要提供所谓的空间保留(`reserve`)功能.</code></pre><p>​    虽然<code>deque</code>容器也提供了<code>Random Access Iterator</code>，但是它的迭代器并不是普通的指针，其复杂度和<code>vector</code>不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用<code>vector</code>，而不是<code>deque</code>。对<code>deque</code>进行的排序操作，为了最高效率，可将<code>deque</code>先完整的复制到一个<code>vector</code>中，对<code>vector</code>容器进行排序，再复制回<code>deque</code>。</p><h3 id="deque容器实现原理"><a href="#deque容器实现原理" class="headerlink" title="deque容器实现原理"></a><code>deque</code>容器实现原理</h3><p>​    <code>deque</code>容器是连续的空间，至少逻辑上看来如此，连续现行空间总是令我们联想到<code>array</code>和<code>vector</code>，<code>array</code>无法成长，<code>vector</code>虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上<code>(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间</code>三步骤，如果不是<code>vector</code>每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。</p><p>​    <code>deque</code>是由一段一段的定量的连续空间构成。一旦有必要在<code>deque</code>前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在<code>deque</code>的头端或者尾端。<code>deque</code>最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p><p>​    既然<code>deque</code>是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。<code>deque</code>代码的实现远比<code>vector</code>或<code>list</code>都多得多。</p><p>​    <code>deque</code>采取一块所谓的<code>map</code>(注意，不是<code>STL</code>的<code>map</code>容器)作为主控，这里所谓的<code>map</code>是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是<code>deque</code>的存储空间的主体。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/图片3.png" style="zoom:67%;"></p><h3 id="deque常用API"><a href="#deque常用API" class="headerlink" title="deque常用API"></a><code>deque</code>常用<code>API</code></h3><h4 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a><code>deque</code>构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;T&gt; deqT;<span class="comment">//默认构造形式</span></span><br><span class="line"><span class="built_in">deque</span>(beg, end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure><h4 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a><code>deque</code>赋值操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line">assign(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">deque</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq); <span class="comment">//重载等号操作符 </span></span><br><span class="line">swap(deq);<span class="comment">// 将deq与本身的元素互换</span></span><br></pre></td></tr></table></figure><h4 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a><code>deque</code>大小操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.size();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line"><span class="built_in">deque</span>.empty();<span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="built_in">deque</span>.resize(num);<span class="comment">//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="built_in">deque</span>.resize(num, elem); <span class="comment">//重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure><h4 id="deque双端插入和删除操作"><a href="#deque双端插入和删除操作" class="headerlink" title="deque双端插入和删除操作"></a><code>deque</code>双端插入和删除操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push_back(elem);<span class="comment">//在容器尾部添加一个数据</span></span><br><span class="line">push_front(elem);<span class="comment">//在容器头部插入一个数据</span></span><br><span class="line">pop_back();<span class="comment">//删除容器最后一个数据</span></span><br><span class="line">pop_front();<span class="comment">//删除容器第一个数据</span></span><br></pre></td></tr></table></figure><h4 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a><code>deque</code>数据存取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at(idx);<span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</span></span><br><span class="line">front();<span class="comment">//返回第一个数据。</span></span><br><span class="line">back();<span class="comment">//返回最后一个数据</span></span><br></pre></td></tr></table></figure><h4 id="deque插入操作"><a href="#deque插入操作" class="headerlink" title="deque插入操作"></a><code>deque</code>插入操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert(pos,elem);<span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line">insert(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line">insert(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br></pre></td></tr></table></figure><h4 id="deque删除操作"><a href="#deque删除操作" class="headerlink" title="deque删除操作"></a><code>deque</code>删除操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clear();<span class="comment">//移除容器的所有数据</span></span><br><span class="line">erase(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure><h4 id="案例（作业）"><a href="#案例（作业）" class="headerlink" title="案例（作业）"></a>案例（作业）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</span></span><br><span class="line"><span class="comment">//1. 创建五名选手，放到vector中</span></span><br><span class="line"><span class="comment">//2. 遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</span></span><br><span class="line"><span class="comment">//3. sort算法对deque容器中分数排序，pop_back pop_front去除最高和最低分</span></span><br><span class="line"><span class="comment">//4. deque容器遍历一遍，累加分数，累加分数/d.size()</span></span><br><span class="line"><span class="comment">//5. person.score = 平均分</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++STL库函数vector</title>
      <link href="/2018/08/18/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0vector/"/>
      <url>/2018/08/18/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0vector/</url>
      
        <content type="html"><![CDATA[<h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a><code>vector</code>容器</h2><h3 id="2-1-vector容器基本概念"><a href="#2-1-vector容器基本概念" class="headerlink" title="2.1 vector容器基本概念"></a>2.1 <code>vector</code>容器基本概念</h3><p>​    <code>vector</code>的数据安排以及操作方式，与<code>array</code>非常相似，两者的唯一差别在于空间的运用的灵活性。</p><p>​    <code>Array</code>是静态空间，一旦配置了就不能改变，要换大一点或者小一点的空间，可以，一切琐碎得由自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。</p><p>​    <code>Vector</code>是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此<code>vector</code>的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必害怕空间不足而一开始就要求一个大块头的<code>array</code>了。</p><a id="more"></a><p>​    <code>Vector</code>的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，一旦<code>vector</code>旧空间满了，如果客户每新增一个元素，<code>vector</code>内部只是扩充一个元素的空间，实为不智，因为所谓的扩充空间(不论多大)，一如刚所说，是”配置新空间-数据移动-释放旧空间”的大工程，时间成本很高，应该加入某种未雨绸缪的考虑，稍后我们便可以看到<code>vector</code>的空间配置策略。</p><h3 id="2-2-vector迭代器"><a href="#2-2-vector迭代器" class="headerlink" title="2.2 vector迭代器"></a>2.2 <code>vector</code>迭代器</h3><p>​    <code>Vector</code>维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为<code>vector</code>的迭代器，因为<code>vector</code>迭代器所需要的操作行为，如<code>operaroe*</code>， <code>operator-&gt;</code>，<code>operator++</code>， <code>operator--</code>，<code>operator+</code>，<code>operator-</code>，<code>operator+=</code>，<code>operator-=</code>，普通指针天生具备。<code>Vector</code>支持随机存取，而普通指针正有着这样的能力。所以<code>vector</code>提供的是随机访问迭代器(<code>Random Access Iterators</code>).</p><p>根据上述描述，如果我们写如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;int&gt;::iterator it1;</span><br><span class="line">Vector&lt;Teacher&gt;::iterator it2;</span><br></pre></td></tr></table></figure></p><p><code>it1</code>的型别其实就是<code>int*</code>，<code>it2</code>的型别其实就是<code>Teacher *</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i ++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// v.capacity()容器的容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-vector的数据结构"><a href="#2-3-vector的数据结构" class="headerlink" title="2.3 vector的数据结构"></a>2.3 <code>vector</code>的数据结构</h3><p>​    <code>Vector</code>所采用的数据结构非常简单，线性连续空间，它以两个迭代器<code>_Myfirst</code>和<code>_Mylast</code>分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器<code>_Myend</code>指向整块连续内存空间的尾端。</p><p>​    为了降低空间配置时的速度成本，<code>vector</code>实际配置的大小可能比客户端需求大一些，以备将来可能的扩充，这边是<strong>容量</strong>的概念。换句话说，<strong>一个<code>vector</code>的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个<code>vector</code>容器就得另觅居所。</strong></p><p>​    <strong>注意：</strong> 所谓动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间)，而是一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。因此，对<code>vector</code>的任何操作，一旦引起空间的重新配置，指向原<code>vector</code>的所有迭代器就都失效了。这是程序员容易犯的一个错误，务必小心。<img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/图片1.png" style="zoom:67%;"></p><h3 id="2-4-vector常用API操作"><a href="#2-4-vector常用API操作" class="headerlink" title="2.4 vector常用API操作"></a>2.4 <code>vector</code>常用<code>API</code>操作</h3><p>​    <code>vector</code>有很多成员函数，常用的如表<code>1</code>所示。</p><table><thead><tr><th>成员函数</th><th>作 用</th></tr></thead><tbody><tr><td><code>vector()</code></td><td>无参构造函数，将容器初始化为空</td></tr><tr><td><code>vector(int n)</code></td><td>将容器初始化为有 <code>n</code>个元素</td></tr><tr><td><code>vector(int n, const T &amp;val)</code></td><td>假定元素的类型是<code>T</code>，此构造函数将容器初始化为有<code>n</code>个元素，每 个元素的值都是<code>val</code></td></tr><tr><td><code>vector(iterator first, iterator last)</code></td><td><code>first</code>和<code>last</code>可以是其他容器的迭代器。一般来说，本构造函数初始化的结果就是将<code>vector</code>容器的内容变成与其他容器上的区间<code>[first, last)</code>—致</td></tr><tr><td><code>void clear()</code></td><td>删除所有元素</td></tr><tr><td><code>bool empty()</code></td><td>判断容器是否为空</td></tr><tr><td><code>void pop_back()</code></td><td>删除容器末尾的元素</td></tr><tr><td><code>void push_back( const T &amp;val)</code></td><td>将<code>val</code>添加到容器末尾</td></tr><tr><td><code>int size()</code></td><td>返回容器中元素的个数</td></tr><tr><td><code>T &amp;front()</code></td><td>返回容器中第一个元素的引用</td></tr><tr><td><code>T &amp;back()</code></td><td>返回容器中最后一个元素的引用</td></tr><tr><td><code>iterator insert(iterator i, const T &amp;val)</code></td><td>将<code>val</code>插入迭代器<code>i</code>指向的位置，返回<code>i</code></td></tr><tr><td><code>iterator insert( iterator i, iterator first, iterator last)</code></td><td>将其他容器上的区间<code>[first, last)</code> 中的元素插入迭代器<code>i</code>指向的位置</td></tr><tr><td><code>iterator erase(iterator i)</code></td><td>删除迭代器<code>i</code>指向的元素，返回值是被删元素后面的元素的迭代器</td></tr><tr><td><code>iterator erase(iterator first, iterator last)</code></td><td>删除容器中的区间<code>[first, last)</code></td></tr><tr><td><code>void swap( vector &lt;T&gt; &amp; v)</code></td><td>将容器自身的内容和另一个同类型的容器<code>v</code>互换</td></tr></tbody></table><h4 id="2-4-1-vector构造函数"><a href="#2-4-1-vector构造函数" class="headerlink" title="2.4.1 vector构造函数"></a>2.4.1 <code>vector</code>构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt; v; <span class="comment">//采用模板实现类实现，默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(v.begin(), v.end());<span class="comment">//将v[begin(), end())区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">const</span> <span class="built_in">vector</span> &amp;vec);<span class="comment">//拷贝构造函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子 使用第二个构造函数 我们可以...</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><h4 id="2-4-2-vector常用赋值操作"><a href="#2-4-2-vector常用赋值操作" class="headerlink" title="2.4.2 vector常用赋值操作"></a>2.4.2 <code>vector</code>常用赋值操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line">assign(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">vector</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">vector</span>  &amp;vec);<span class="comment">//重载等号操作符</span></span><br><span class="line">swap(vec);<span class="comment">// 将vec与本身的元素互换。</span></span><br></pre></td></tr></table></figure><h4 id="2-4-3-vector大小操作"><a href="#2-4-3-vector大小操作" class="headerlink" title="2.4.3 vector大小操作"></a>2.4.3 <code>vector</code>大小操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line">empty();<span class="comment">//判断容器是否为空</span></span><br><span class="line">resize(<span class="keyword">int</span> num);<span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line">resize(<span class="keyword">int</span> num, elem);<span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</span></span><br><span class="line">  <span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line">capacity();<span class="comment">//容器的容量</span></span><br><span class="line">reserve(<span class="keyword">int</span> len);<span class="comment">//容器预留len个元素长度，预留位置不初始化，元素不可访问。</span></span><br></pre></td></tr></table></figure><h4 id="2-4-4-vector数据存取操作"><a href="#2-4-4-vector数据存取操作" class="headerlink" title="2.4.4 vector数据存取操作"></a>2.4.4 <code>vector</code>数据存取操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at(<span class="keyword">int</span> idx); <span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，越界时，运行直接报错</span></span><br><span class="line">front();<span class="comment">//返回容器中第一个数据元素</span></span><br><span class="line">back();<span class="comment">//返回容器中最后一个数据元素</span></span><br></pre></td></tr></table></figure><h4 id="2-4-5-vector插入和删除操作"><a href="#2-4-5-vector插入和删除操作" class="headerlink" title="2.4.5 vector插入和删除操作"></a>2.4.5 <code>vector</code>插入和删除操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insert(const_iterator pos, <span class="keyword">int</span> count,ele);<span class="comment">//迭代器指向位置pos插入count个元素ele.</span></span><br><span class="line">push_back(ele); <span class="comment">//尾部插入元素ele</span></span><br><span class="line">pop_back();<span class="comment">//删除最后一个元素</span></span><br><span class="line">erase(const_iterator start, const_iterator end);<span class="comment">//删除迭代器从start到end之间的元素</span></span><br><span class="line">erase(const_iterator pos);<span class="comment">//删除迭代器指向的元素</span></span><br><span class="line">clear();<span class="comment">//删除容器中所有元素</span></span><br></pre></td></tr></table></figure><h3 id="2-5-vector案例"><a href="#2-5-vector案例" class="headerlink" title="2.5 vector案例"></a>2.5 <code>vector</code>案例</h3><h4 id="2-5-1-vector基础用法"><a href="#2-5-1-vector基础用法" class="headerlink" title="2.5.1  vector基础用法"></a>2.5.1  <code>vector</code>基础用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;  //使用vector需要包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">printVector</span>(<span class="title">const</span> <span class="title">vector</span> &lt;T&gt; &amp; <span class="title">v</span>)</span></span><br><span class="line"><span class="class">&#123;</span>  <span class="comment">//用于输出vector容器的全部元素的函数模板</span></span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">vector</span> &lt;T&gt;::const_iterator i;</span><br><span class="line">    <span class="comment">//typename 用来说明 vector &lt;T&gt;::const_iterator 是一个类型，在 Visual Studio 中不写也可以</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.begin(); i != v.end(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v(a, a + <span class="number">5</span>);  <span class="comment">//将数组a的内容放入</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1) "</span> &lt;&lt; v.end() - v.begin() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//两个随机迭代器可以相减，输出：1)5</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2)"</span>; </span><br><span class="line">    printVector(v);  <span class="comment">//输出：2)1 2 3 4 5</span></span><br><span class="line">    </span><br><span class="line">    v.insert(v.begin() + <span class="number">2</span>, <span class="number">13</span>);  <span class="comment">//在 begin()+2 位置插人 13</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3)"</span>; </span><br><span class="line">    printVector(v);  <span class="comment">//输出：3)1 2 13 3 4 5</span></span><br><span class="line">    </span><br><span class="line">    v.erase(v.begin() + <span class="number">2</span>);  <span class="comment">//删除位于 begin()+2 位置的元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4)"</span>; </span><br><span class="line">    printVector(v);  <span class="comment">//输出：4)1 2 3 4 5</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">4</span>, <span class="number">100</span>);  <span class="comment">//v2 有 4 个元素，都是 100</span></span><br><span class="line">    v2.insert(v2.begin(), v.begin() + <span class="number">1</span>, v.begin() + <span class="number">3</span>);  <span class="comment">//将v的一段插入v2开头</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5)v2:"</span>; </span><br><span class="line">    printVector(v2);  <span class="comment">//输出：5)v2: 2 3 100 100 100 100</span></span><br><span class="line">    </span><br><span class="line">    v.erase(v.begin() + <span class="number">1</span>, v.begin() + <span class="number">3</span>);  <span class="comment">//删除 v 上的一个区间，即 [2,3)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"6)"</span>; </span><br><span class="line">    printVector(v);  <span class="comment">//输出：6)1 4 5</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-巧用swap，收缩内存空间"><a href="#2-5-2-巧用swap，收缩内存空间" class="headerlink" title="2.5.2  巧用swap，收缩内存空间"></a>2.5.2  巧用<code>swap</code>，收缩内存空间</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>;i ++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时 通过resize改变容器大小</span></span><br><span class="line">v.resize(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容量没有改变</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(v).swap(v);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-3-reserve预留空间"><a href="#2-5-3-reserve预留空间" class="headerlink" title="2.5.3 reserve预留空间"></a>2.5.3 <code>reserve</code>预留空间</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预先开辟空间</span></span><br><span class="line">v.reserve(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* pStart = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>;i ++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line"><span class="keyword">if</span> (pStart != &amp;v[<span class="number">0</span>])&#123;</span><br><span class="line">pStart = &amp;v[<span class="number">0</span>];</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"count:"</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++STL库函数概述</title>
      <link href="/2018/08/16/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/08/16/c++-STL%E5%BA%93%E5%87%BD%E6%95%B0%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="STL概论"><a href="#STL概论" class="headerlink" title="STL概论"></a><code>STL</code>概论</h1><p>​    长久以来，软件界一直希望建立一种可重复利用的东西，以及一种得以制造出”可重复运用的东西”的方法，让程序员的心血不止于随时间的迁移，人事异动而烟消云散，从函数(<code>functions</code>)，类别(<code>classes</code>)，函数库(<code>function libraries</code>)，类别库(<code>class libraries</code>)、各种组件，从模块化设计，到面向对象(<code>object oriented</code>)，为的就是复用性的提升。</p><p>​    复用性必须建立在某种标准之上。但是在许多环境下，就连软件开发最基本的数据结构(<code>data structures</code>) 和算法(<code>algorithm</code>)都未能有一套标准。大量程序员被迫从事大量重复的工作，竟然是为了完成前人已经完成而自己手上并未拥有的程序代码，这不仅是人力资源的浪费，也是挫折与痛苦的来源。</p><p>​    为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性(相互合作性，<code>interoperability</code>)，诞生了<code>STL</code>。</p> <a id="more"></a><h2 id="STL基本概念"><a href="#STL基本概念" class="headerlink" title="STL基本概念"></a><code>STL</code>基本概念</h2><p>​    <code>STL</code>(<code>Standard Template Library</code>，标准模板库)，是惠普实验室开发的一系列软件的统称。现在主要出现在<code>c++</code>中，但是在引入<code>c++</code>之前该技术已经存在很长时间了。<br>​    <code>STL</code>从广义上分为: 容器(<code>container</code>) 、算法(<code>algorithm</code>) 、迭代器(<code>iterator</code>)，容器和算法之间通过迭代器进行无缝连接。<code>STL</code> 几乎所有的代码都采用了模板类或者模板函数，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。<code>STL</code>(<code>Standard Template Library</code>)标准模板库，在我们<code>c++</code>标准程序库中隶属于<code>STL</code>的占到了 80%以上。</p><h2 id="STL六大组件简介"><a href="#STL六大组件简介" class="headerlink" title="STL六大组件简介"></a><code>STL</code>六大组件简介</h2><p>​    <code>STL</code>提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p><p>​    <strong>容器：</strong>各种数据结构，如<code>vector</code>、<code>list</code>、<code>deque</code>、<code>set</code>、<code>map</code>等，用来存放数据，从实现角度来看，<code>STL</code>容器是一种<code>class template</code>。</p><p>​    <strong>算法：</strong>各种常用的算法，如<code>sort</code>、<code>find</code>、<code>copy</code>、<code>for_each</code>。从实现的角度来看，<code>STL</code>算法是一种<code>function tempalte</code>.</p><p>​    <strong>迭代器：</strong>扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将<code>operator*</code> , <code>operator-&gt;</code> , <code>operator++</code>,<code>operator--</code>等指针相关操作予以重载的<code>class template</code>. 所有<code>STL</code>容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(<code>native pointer</code>)也是一种迭代器。</p><p>​    <strong>仿函数：</strong>行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了<code>operator()</code>的<code>class</code> 或者<code>class template</code></p><p>​    <strong>适配器：</strong>一种用来修饰容器或者仿函数或迭代器接口的东西。</p><p>​    <strong>空间配置器：</strong>负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的<code>class tempalte</code>.</p><p>​    <code>STL</code>六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。</p><h2 id="STL优点"><a href="#STL优点" class="headerlink" title="STL优点"></a><code>STL</code>优点</h2><p>​    <code>STL</code> 是 <code>C++</code>的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p><p>​    <code>STL</code> 的一个重要特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”，以使算法可以和容器交互运作</p><p>​    程序员可以不用思考<code>STL</code>具体的实现过程，只要能够熟练使用 <code>STL</code> 就 <code>OK</code> 了。这样他们就可以把精力放在程序开发的别的方面。</p><p><code>STL</code> 具有高可重用性，高性能，高移植性，跨平台的优点。</p><ul><li><strong>高可重用性：</strong><code>STL</code> 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</li><li><strong>高性能：</strong>如<code>map</code> 可以高效地从十万条记录里面查找出指定的记录，因为 <code>map</code> 是采用红黑树的变体实现的。</li><li><strong>高移植性：</strong>如在项目<code>A</code> 上用 <code>STL</code> 编写的模块，可以直接移植到项目 <code>B</code> 上。</li></ul><h1 id="STL三大组件"><a href="#STL三大组件" class="headerlink" title="STL三大组件"></a><code>STL</code>三大组件</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器，置物之所也。</p><p>​    研究数据的特定排列方式，以利于搜索或排序或其他特殊目的，这一门学科我们称为数据结构。大学信息类相关专业里面，与编程最有直接关系的学科，首推数据结构与算法。几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。<code>STL</code>容器就是将运用最广泛的一些数据结构实现出来。</p><p>​    常用的数据结构：可变长动态数组 (<code>vector</code>)，双向链表(<code>list</code>)，<code>tree</code>(树)，栈(<code>stack</code>)，双端队列(<code>deque</code>)，集合(<code>set</code>)，映射表(<code>map</code>)，根据数据在容器中的排列特性，这些数据分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种。</p><ul><li><p><strong>序列式容器</strong>是指元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置（尾部、头部或中间某处）插入，元素就会位于什么位置。可变长动态数组 (<code>vector</code>)，双端队列(<code>deque</code>)，双向链表(<code>list</code>)。</p></li><li><p><strong>关联式容器</strong>内的元素是排序的。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。</p><p>​    默认情况下，关联容器中的元素是从小到大排序（或按关键字从小到大排序）的，而且用<code>&lt;</code>运算符比较元素或关键字大小。因为是排好序的，所以关联容器在查找时具有非常好的性能。关联式容器另一个显著特点是：在值中选择一个值作为关键字<code>key</code>，这个关键字对值起到索引的作用，方便查找。其包括<code>set</code>、<code>multiset</code>、 <code>map</code>、<code>multimap</code>容器</p></li><li><p>除了以上两类容器外，<code>STL</code>还在两类容器的基础上屏蔽一部分功能，突出或增加另一部分功能，实现了三种容器适配器：栈<code>stack</code>、队列<code>queue</code>、优先级队列<code>priority_queue</code>。</p></li></ul><p>容器都是类模板。它们实例化后就成为容器类。用容器类定义的对象称为容器对象。 </p><p>​    例如，<code>vector</code>是一个容器类的名字，<code>vector&lt;int&gt; a;</code>就定义了一个容器对象<code>a</code>，<code>a</code>代表一个长度可变的数组，数组中的每个元素都是<code>int</code>类型的变量；<code>vector&lt;double&gt; b;</code>定义了另一个容器对象<code>b</code>，<code>a</code>和<code>b</code>的类型是不同的。</p><p>​    任何两个容器对象，只要它们的类型相同，就可以用<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>==</code>、<code>!=</code>进行词典式的比较运算。假设<code>a</code>、<code>b</code>是两个类型相同的容器对象，这些运算符的运算规则如下。</p><ul><li><code>a == b</code>：若<code>a</code>和<code>b</code>中的元素个数相同，且对应元素均相等，则<code>a == b</code>的值为<code>true</code>，否则值为 <code>false</code>。元素是否相等是用<code>==</code>运算符进行判断的。</li><li><code>a&lt;b</code>：规则类似于词典中两个单词比较大小，从头到尾依次比较每个元素，如果发生<code>a</code>中的元素小于<code>b</code>中的元素的情况，则<code>a&lt;b</code>的值为<code>true</code>；如果没有发生<code>b</code>中的元素小于<code>a</code>中的元素的情况，且<code>a</code>中的元素个数比<code>b</code>少，<code>a&lt;b</code>的值也为<code>true</code>；其他情况下值为<code>false</code>。元素比较大小是通过<code>&lt;</code>运算符进行的。</li><li><code>a != b</code>：等价于<code>!(a == b)</code>。</li><li><code>a &gt; b</code>：等价于<code>b &lt; a</code>。</li><li><code>a &lt;= b</code>：等价于<code>!(b &lt; a)</code>。</li><li><code>a &gt;= b</code>：等价于<code>!(a &lt; b)</code>。</li></ul><p> 所有容器都有以下两个成员函数：</p><ul><li><code>int size()</code>：返回容器对象中元素的个数。</li><li><p><code>bool empty()</code>：判断容器对象是否为空。</p><p>顺序容器和关联容器还有以下成员函数：</p></li><li><p><code>begin()</code>：返回指向容器中第一个元素的迭代器。</p></li><li><code>end()</code>：返回指向容器中最后一个元素后面的位置的迭代器。</li><li><code>rbegin()</code>：返回指向容器中最后一个元素的反向迭代器。</li><li><code>rend()</code>：返回指向容器中第一个元素前面的位置的反向迭代器。</li><li><code>erase(...)</code>：从容器中删除一个或几个元素。</li><li><p><code>clear()</code>：从容器中删除所有元素。</p><p>如果一个容器是空的，则<code>begin()</code>和<code>end()</code>的返回值相等，<code>rbegin()</code>和<code>rend()</code>的返回值也相等。</p><p>顺序容器还有以下常用成员函数：</p></li><li><p><code>front()</code>：返回容器中第一个元素的引用。</p></li><li><code>back()</code>：返回容器中最后一个元素的引用。</li><li><code>push_back()</code>：在容器末尾增加新元素。</li><li><code>pop_back()</code>：删除容器末尾的元素。</li><li><code>insert(...)</code>：插入一个或多个元素。</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>​    <code>STL</code> 提供能在各种容器中通用的算法，如插入、删除、查找、排序等。算法就是函数模板。<strong>算法通过迭代器来操纵容器中的元素。</strong></p><p>​    <strong>许多算法操作的是容器上的一个区间</strong>（也可以是整个容器），因此需要两个参数，一个是区间起点元素的迭代器，另一个是区间终点元素的后面一个元素的迭代器。例如，排序和查找算法都需要这两个参数来指明待排序或待查找的区间。</p><p>​    <strong>有的算法返回一个迭代器。</strong>例如，<code>find</code>算法在容器中查找一个元素，并返回一个指向该元素的迭代器。</p><p>​    <strong>算法可以处理容器，也可以处理普通的数组。</strong></p><p>有的算法会改变其所作用的容器。例如：</p><ul><li><code>copy</code>：将一个容器的内容复制到另一个容器。</li><li><code>remove</code>：在容器中删除一个元素。</li><li><code>random_shuffle</code>：随机打乱容器中的元素。</li><li><code>fill</code>：用某个值填充容器。</li></ul><p>有的算法不会改变其所作用的容器。例如：</p><ul><li><code>find</code>：在容器中查找元素。</li><li><code>count_if</code>：统计容器中符合某种条件的元素的个数。</li></ul><p><code>STL</code>中的大部分常用算法都在头文件<code>algorithm</code>中定义。此外，头文件<code>numeric</code>中也有一些算法。</p><p>​    下面介绍一个常用算法<code>find</code>。<code>find</code>算法和其他算法一样都是函数模板。find 模板的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InIt</span> <span class="title">find</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>);</span></span><br></pre></td></tr></table></figure><p>​    其功能可以是在迭代器<code>first</code>、<code>last</code>指定的容器的一个区间<code>[first, last)</code>中，按顺序查找和<code>val</code> 相等的元素。如果找到，就返回该元素的迭代器；如果找不到，就返回<code>last</code>。</p><blockquote><p><code>[first, last)</code>这个区间是一个左闭右开的区间，即<code>last</code>指向的元素其实不在此区间内。</p></blockquote><p>​    <code>find</code>模板使用<code>==</code>运算符判断元素是否相等。因此，如果<code>[first, last)</code>区间中存放的是对象，则<code>==</code>运算符应该被适当重载，使得两个对象可以用<code>==</code>运算符比较。</p><p>​    演示<code>find</code>用法的程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);    </span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">3</span>);    </span><br><span class="line">    v.push_back(<span class="number">4</span>); <span class="comment">//此后v里放着4个元素：1,2,3,4</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator p;</span><br><span class="line">    p = find(v.begin(),v.end(),<span class="number">3</span>); <span class="comment">//在v中查找3</span></span><br><span class="line">    <span class="keyword">if</span>(p != v.end()) <span class="comment">//若找不到,find返回 v.end()</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1) "</span> &lt;&lt;  * p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//找到了</span></span><br><span class="line">    p = find(v.begin(),v.end(),<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == v.end())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found "</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//没找到</span></span><br><span class="line">    p = find(v.begin()+<span class="number">1</span>,v.end()<span class="number">-1</span>,<span class="number">4</span>); <span class="comment">//在,3 这两个元素中查找4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2) "</span> &lt;&lt; * p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> * pp = find(a,a+<span class="number">4</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span>(pp == a + <span class="number">4</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"3) "</span> &lt;&lt;* pp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br><code>1) 3</code><br> <code>not found</code><br><code>2) 4</code><br><code>3) 20</code></p><p> 第<code>13</code>行，要查找的区间是<code>[v.begin(), v.end( ))</code>，<code>v.end()</code>不在查找范围内，因此没有问题。本行的查找会成功，因此<code>p</code>指向找到的元素<code>3</code>。</p><p> 第<code>19</code>行，因为要查找的区间是<code>[v.begin()+l，v.end()-1)</code>，这个区间中只有<code>2、3</code>这两个元素，因此查找会失败，<code>p</code>的值变为<code>v.end() - 1</code>，因此<code>p</code>正好指向<code>4</code>这个元素。</p><p> 第<code>21</code>行，数组<code>a</code>是一个容器。数组名<code>a</code>的类型是<code>int *</code>，可以做迭代器使用，表达式<code>a+4</code>的类型也是<code>int*</code>，因此也能做迭代器。本次调用<code>find</code>,查找区间是<code>[a, a+4)</code>，即数组<code>a</code>的前<code>4</code>个元素。如果查找失败，<code>find</code>就会返回<code>a+4</code>。</p><p>​    <code>STL</code>中还有一个常用的算法<code>sort</code>，用于对容器排序，其原型为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class_RandIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(_RandIt first, _RandIt last)</span></span>;</span><br></pre></td></tr></table></figure><p>​    该算法可以用来对区间<code>[first, last)</code>从小到大进行排序。下面两行程序就能对数组<code>a</code>排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">sort(a, a+<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>​    迭代器(<code>iterator</code>)是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。在&lt;&lt;<code>Design Patterns</code>&gt;&gt;一书中提供了<code>23</code>中设计模式的完整描述，其中<code>iterator</code>模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>​    迭代器的设计思维-<code>STL</code>的关键所在，<code>STL</code>的中心思想在于将容器(<code>container</code>)和算法(<code>algorithms</code>)分开，彼此独立设计，最后再一贴胶着剂将他们撮合在一起。从技术角度来看，容器和算法的泛型化并不困难，<code>c++</code>的<code>class template</code>和<code>function template</code>可分别达到目标，如果设计出两这个之间的良好的胶着剂，才是大难题。</p><p>迭代器按照定义方式分成以下四种。</p><ul><li><p><strong>正向迭代器</strong>，定义方法如下：</p><p><code>容器类名::iterator 迭代器名;</code></p></li><li><p><strong>常量正向迭代器</strong>，定义方法如下：</p><p><code>容器类名::const_iterator 迭代器名;</code></p></li><li><p><strong>反向迭代器</strong>，定义方法如下：</p><p><code>容器类名::reverse_iterator 迭代器名;</code></p></li><li><p><strong>常量反向迭代器</strong>，定义方法如下：</p><p><code>容器类名::const_reverse_iterator 迭代器名;</code></p></li></ul><h3 id="迭代器用法示例"><a href="#迭代器用法示例" class="headerlink" title="迭代器用法示例"></a>迭代器用法示例</h3><p>​    通过迭代器可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</p><p> 迭代器都可以进行<code>++</code>操作。反向迭代器和正向迭代器的区别在于：</p><ul><li>对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；</li><li>而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素。</li></ul><p> 下面的程序演示了如何通过迭代器遍历一个<code>vector</code>容器中的所有元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;  <span class="comment">//v是存放int类型变量的可变长数组，开始时没有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n&lt;<span class="number">5</span>; ++n)</span><br><span class="line">        v.push_back(n);  <span class="comment">//push_back成员函数在vector容器尾部添加一个元素</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;  <span class="comment">//定义正向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.begin(); i != v.end(); ++i) &#123;  <span class="comment">//用迭代器遍历容器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;  <span class="comment">//*i 就是迭代器i指向的元素</span></span><br><span class="line">        *i *= <span class="number">2</span>;  <span class="comment">//每个元素变为原来的2倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//用反向迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator j = v.rbegin(); j != v.rend(); ++j)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *j &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br><code>0 1 2 3 4</code><br><code>8 6 4 2 0</code></p><p>​    第<code>10</code>行，<code>begin</code>成员函数返回指向容器中第一个元素的迭代器。<code>++i</code>使得<code>i</code>指向容器中的下一个元素。<code>end</code>成员函数返回的不是指向最后一个元素的迭代器，而是指向最后一个元素后面的位置的迭代器，因此循环的终止条件是<code>i != v.end()</code>。</p><p>​    第<code>16</code>行定义了反向迭代器用以遍历容器。反向迭代器进行<code>++</code>操作后，会指向容器中的上一个元素。<code>rbegin</code> 成员函数返回指向容器中最后一个元素的迭代器，<code>rend</code>成员函数返回指向容器中第一个元素前面的位置的迭代器，因此本循环实际上是从后往前遍历整个数组。</p><p>​    如果迭代器指向了容器中最后一个元素的后面或第一个元素的前面，再通过该迭代器访问元素，就有可能导致程序崩溃，这和访问<code>NULL</code>或未初始化的指针指向的地方类似。</p><p>​    第<code>10</code>行和第<code>16</code>行，写<code>++i</code>、<code>++j</code>相比于写<code>i++</code>、<code>j++</code>，程序的执行速度更快。回顾<code>++</code>被重载成前置和后置运算符的例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CDemo CDemo::<span class="keyword">operator</span>++ ()</span><br><span class="line">&#123;  <span class="comment">//前置++</span></span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">CDemo CDemo::<span class="keyword">operator</span> ++(<span class="keyword">int</span> k)</span><br><span class="line">&#123;  <span class="comment">//后置++</span></span><br><span class="line">    <span class="function">CDemo <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;  <span class="comment">//记录修改前的对象</span></span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> tmp;  <span class="comment">//返回修改前的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    后置<code>++</code>要多生成一个局部对象<code>tmp</code>，因此执行速度比前置的慢。同理，迭代器是一个对象，<code>STL</code>在重载迭代器的<code>++</code>运算符时，后置形式也比前置形式慢。在次数很多的循环中，<code>++i</code>和<code>i++</code>可能就会造成运行时间上可观的差别了。因此，对循环控制变量<code>i</code>，要养成写<code>++i</code>、不写<code>i++</code>的习惯。</p><p>​    注意，容器适配器<code>stack</code>、<code>queue</code>和<code>priority_queue</code>没有迭代器。容器适配器有一些成员函数，可以用来对元素进行访问。</p><h3 id="迭代器的功能分类"><a href="#迭代器的功能分类" class="headerlink" title="迭代器的功能分类"></a>迭代器的功能分类</h3><p>​    不同容器的迭代器，其功能强弱有所不同。容器的迭代器的功能强弱，决定了该容器是否支持<code>STL</code>中的某种算法。例如，排序算法需要通过随机访问迭代器来访问容器中的元素，因此有的容器就不支持排序算法。</p><p>​    常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问五种，这里只介绍常用的三种。</p><ul><li><p><strong>正向迭代器</strong>。假设<code>p</code>是一个正向迭代器，则<code>p</code>支持以下操作：<code>++p</code>，<code>p++</code>，<code>*p</code>。此外，两个正向迭代器可以互相赋值，还可以用<code>==</code>和<code>!=</code>运算符进行比较。</p></li><li><p><strong>双向迭代器。</strong>双向迭代器具有正向迭代器的全部功能。除此之外，若<code>p</code>是一个双向迭代器，则<code>--p</code>和<code>p--</code>都是有定义的。<code>--p</code>使得<code>p</code>朝和<code>++p</code>相反的方向移动。</p></li><li><p><strong>随机访问迭代器。</strong>随机访问迭代器具有双向迭代器的全部功能。若<code>p</code>是一个随机访问迭代器，<code>i</code>是一个整型变量或常量，则<code>p</code>还支持以下操作：</p><ul><li><code>p+=i</code>：使得<code>p</code>往后移动<code>i</code>个元素。</li><li><code>p-=i</code>：使得<code>p</code> 往前移动<code>i</code>个元素。</li><li><code>p+i</code>：返回<code>p</code>后面第<code>i</code>个元素的迭代器。</li><li><code>p-i</code>：返回<code>p</code>前面第<code>i</code>个元素的迭代器。</li><li><code>p[i]</code>：返回<code>p</code>后面第<code>i</code>个元素的引用。</li></ul></li></ul><pre><code>​     此外，两个随机访问迭代器` p1`、`p2 `还可以用` &lt;`、`&gt;`、`&lt;=`、`&gt;= `运算符进行比较。`p1&lt;p2`的含义是：`p1 `经过若干次（至少一次）`++`操作后，就会等于` p2`。其他比较方式的含义与此类似。​     对于两个随机访问迭代器` p1`、`p2`，表达式`p2-p1`也是有定义的，其返回值是` p2 `所指向元素和` p1 `所指向元素的序号之差（也可以说是` p2 `和` p1 `之间的元素个数减一）。</code></pre><p> 表1所示为不同容器的迭代器的功能。</p><table><thead><tr><th>容器</th><th>迭代器功能</th></tr></thead><tbody><tr><td><code>vector</code></td><td>随机访问</td></tr><tr><td><code>deque</code></td><td>随机访问</td></tr><tr><td><code>list</code></td><td>双向</td></tr><tr><td><code>set / multiset</code></td><td>双向</td></tr><tr><td><code>map / multimap</code></td><td>双向</td></tr><tr><td><code>stack</code></td><td>不支持迭代器</td></tr><tr><td><code>queue</code></td><td>不支持迭代器</td></tr><tr><td><code>priority_queue</code></td><td>不支持迭代器</td></tr></tbody></table><p>​    例如，<code>vector</code>的迭代器是随机迭代器，因此遍历<code>vector</code>容器有以下几种做法。下面的程序中，每个循环演示了一种做法。</p><p> 【实例】遍历<code>vector</code>容器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">100</span>); <span class="comment">//v被初始化成有100个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; v.size() ; ++i) <span class="comment">//size返回元素个数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i]; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="keyword">for</span>(i = v.begin(); i != v.end (); ++i) <span class="comment">//用 != 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i;</span><br><span class="line">    <span class="keyword">for</span>(i = v.begin(); i &lt; v.end ();++i) <span class="comment">//用 &lt; 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i;</span><br><span class="line">    i = v.begin();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; v.end()) &#123; <span class="comment">//间隔一个输出</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 "+= 整数"  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>list</code>容器的迭代器是双向迭代器。假设<code>v</code>和<code>i</code>的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure><p>​    则以下代码是合法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.begin(); i!=v.end(); ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>​    以下代码则不合法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.begin(); i&lt;v.end(); ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>​    因为双向迭代器不支持用<code>“&lt;”</code>进行比较。以下代码也不合法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v.size(); ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v[i];</span><br></pre></td></tr></table></figure><p>​    因为<code>list</code>不支持随机访问迭代器的容器，也不支持用下标随机访问其元素。</p><pre><code>在`C++`中，数组也是容器。数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组` int a[10]`，`int * `类型的指针就是其迭代器。则` a`、`a+1`、`a+2`都是`a`的迭代器。</code></pre><h3 id="迭代器的辅助函数"><a href="#迭代器的辅助函数" class="headerlink" title="迭代器的辅助函数"></a>迭代器的辅助函数</h3><p><code>STL</code>中有用于操作迭代器的三个函数模板，它们是：</p><ul><li><code>advance(p, n)</code>：使迭代器<code>p</code>向前或向后移动<code>n</code>个元素。</li><li><code>distance(p, q)</code>：计算两个迭代器之间的距离，即迭代器<code>p</code>经过多少次<code>+ +</code>操作后和迭代器<code>q</code>相等。如果调用时<code>p</code>已经指向<code>q</code>的后面，则这个函数会陷入死循环。</li><li><code>iter_swap(p, q)</code>：用于交换两个迭代器<code>p</code>、<code>q</code>指向的值。</li></ul><p> 要使用上述模板，需要包含头文件<code>algorithm</code>。下面的程序演示了这三个函数模板的 用法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //要使用操作迭代器的函数模板，需要包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; lst(a, a+<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt;::iterator p = lst.begin();</span><br><span class="line">    advance(p, <span class="number">2</span>);  <span class="comment">//p向后移动两个元素，指向3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1)"</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 1)3</span></span><br><span class="line">    advance(p, <span class="number">-1</span>);  <span class="comment">//p向前移动一个元素，指向2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2)"</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 2)2</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator q = lst.end();</span><br><span class="line">    q--;  <span class="comment">//q 指向 5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3)"</span> &lt;&lt; distance(p, q) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 3)3</span></span><br><span class="line">    iter_swap(p, q); <span class="comment">//交换 2 和 5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4)"</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = lst.begin(); p != lst.end(); ++p)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br><code>1) 3</code><br><code>2) 2</code><br><code>3) 3</code><br><code>4) 1 5 3 4 2</code></p><h2 id="STL容器使用时机"><a href="#STL容器使用时机" class="headerlink" title="STL容器使用时机"></a><code>STL</code>容器使用时机</h2><table><thead><tr><th></th><th><code>vector</code></th><th><code>deque</code></th><th><code>list</code></th><th><code>set</code></th><th><code>multiset</code></th><th><code>map</code></th><th><code>multimap</code></th></tr></thead><tbody><tr><td>典型内存结构</td><td>单端数组</td><td>双端数组</td><td>双向链表</td><td>二叉树</td><td>二叉树</td><td>二叉树</td><td>二叉树</td></tr><tr><td>可随机存取</td><td>是</td><td>是</td><td>否</td><td>否</td><td>否</td><td>对<code>key</code>而言：不是</td><td>否</td></tr><tr><td>元素搜寻速度</td><td>慢</td><td>慢</td><td>非常慢</td><td>快</td><td>快</td><td>对<code>key</code>而言：快</td><td>对key而言：快</td></tr><tr><td>元素安插移除</td><td>尾端</td><td>头尾两端</td><td>任何位置</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><ul><li><p><code>vector</code>的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。</p></li><li><p><code>deque</code>的使用场景：比如排队购票系统，对排队者的存储可以采用<code>deque</code>，支持头端的快速移除，尾端的快速添加。如果采用<code>vector</code>，则头端移除时，会移动大量的数据，速度慢。  </p><p><code>vector</code>与<code>deque</code>的比较：</p><ul><li><p><code>vector.at()</code>比<code>deque.at()</code>效率高，比如<code>vector.at(0)</code>是固定的，<code>deque</code>的开始位置却是不固定的。</p></li><li><p>如果有大量释放操作的话，<code>vector</code>花的时间更少，这跟二者的内部实现有关。</p></li><li><p><code>deque</code>支持头部的快速插入与快速移除，这是<code>deque</code>的优点。</p></li></ul></li><li><p><code>list</code>的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</p></li><li><p><code>set</code>的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 </p></li><li><p><code>map</code>的使用场景：比如按<code>ID</code>号存储十万个用户，想要快速要通过<code>ID</code>查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是<code>vector</code>容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++STL函数对象</title>
      <link href="/2018/08/15/c++-STL%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/08/15/c++-STL%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>如果一个类将<code>()</code>运算符重载为成员函数，这个类就称为<strong>函数对象类</strong>，这个类的对象就是<strong>函数对象</strong>。函数对象是一个对象，但是使用的形式看起来像函数调用，实际上也执行了函数调用，因而得名。</p><a id="more"></a><p>​    下面是一个函数对象的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CAverage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">//重载()运算符</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)(a1 + a2 + a3) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CAverage average;  <span class="comment">//能够求三个整数平均数的函数对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; average(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//等价于 cout &lt;&lt; average.operator(3, 2, 3);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    程序的输出结果是：<br><code>2. 66667</code></p><p>​    <code>()</code>是目数不限的运算符，因此重载为成员函数时，有多少个参数都可以。</p><p>​    <code>average</code>是一个对象，<code>average(3, 2, 3)</code>实际上就是<code>average.operator(3, 2, 3)</code>，这使得<code>average</code>看上去像函数的名字，故称其为<strong>函数对象</strong>。</p><h2 id="函数对象在accumulate算法中的应用"><a href="#函数对象在accumulate算法中的应用" class="headerlink" title="函数对象在accumulate算法中的应用"></a>函数对象在<code>accumulate</code>算法中的应用</h2><p>​    <code>STL</code>中有以下实现“累加”功能的算法（函数模板）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">val</span>, <span class="title">Pred</span> <span class="title">op</span>);</span></span><br></pre></td></tr></table></figure></p><p>​    该模板的功能是对<code>[first, last)</code>中的每个迭代器<code>I</code>执行<code>val = op(val, *I)</code>，返回最终的<code>val</code>。在<code>numeric</code>头文件中 <code>accumulate</code>的源代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">Init</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">init</span>, <span class="title">Pred</span> <span class="title">op</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        init = op(init, *first);</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    此模板被实例化后，<code>op(init, *first)</code>必须要有定义，则<code>op</code>只能是函数指针或者函数对象。因此调用该 <code>accmulate</code>模板时，形参<code>op</code>对应的实参只能是函数名、函数指针或者函数对象。</p><pre><code>下面的程序通过`accumulate`模板求一个`vector`中元素的平方和，其中用到了函数对象。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; //accumulate 在此头文件定义</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">PrintInterval</span>(<span class="title">T</span> <span class="title">first</span>, <span class="title">T</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span> <span class="comment">//输出区间[first,last)中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SumSquares</span><span class="params">(<span class="keyword">int</span> total, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> total + value * value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SumPowers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> power;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SumPowers(<span class="keyword">int</span> p) :power(p) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T &amp; total, <span class="keyword">const</span> T &amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">//计算 value的power次方，加到total上</span></span><br><span class="line">        T v = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; power - <span class="number">1</span>; ++i)</span><br><span class="line">            v = v * value;</span><br><span class="line">        <span class="keyword">return</span> total + v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a1[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(a1, a1 + SIZE);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1) "</span>; </span><br><span class="line">    PrintInterval(v.begin(), v.end());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = accumulate(v.begin(), v.end(), <span class="number">0</span>, SumSquares);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2) 平方和："</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    result = accumulate(v.begin(), v.end(), <span class="number">0</span>, SumPowers&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3) 立方和："</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    result = accumulate(v.begin(), v.end(), <span class="number">0</span>, SumPowers&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4) 4次方和："</span> &lt;&lt; result;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    程序的输出结果如下：<br><code>1)1 2 3 4 5 6 7 8 9 10</code><br><code>2)平方和:385</code><br><code>3)立方和3025</code><br><code>4)4次方和:25333</code></p><p>​    第<code>44</code> 行，第四个参数是<code>SumSquares</code>函数的名字。函数名字的类型是函数指针，因此本行将<code>accumulate</code> 模板实例化后得到的模板函数定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accumulate</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;::iterator first, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;::iterator last, <span class="keyword">int</span> init, <span class="keyword">int</span>(*op)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        init = op(init, *first);</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    形参<code>op</code>是一个函数指针，而<code>op(init, *first)</code>就调用了指针<code>op</code>指向的函数，在第<code>44</code>行的情况下就是函数<code>SumSquares</code>。</p><p>​    第<code>47</code>行，第四个参数是<code>SumPowers&lt;int&gt;(3)</code>。<code>SumPowers</code>是类模板的名字，<code>SumPowers&lt;int&gt;</code> 就是类的名字。类的名字后面跟着构造函数的参数列表，就代表一个临时对象。因此<code>SumPowers&lt;int&gt;(3)</code>就是一个 <code>SumPowers&lt;int&gt;</code>类的临时对象。</p><pre><code>编译器在编译此行时，会将`accumulate`模板实例化成以下函数：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accumulate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator first, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator last, <span class="keyword">int</span> init, SumPowers&lt;<span class="keyword">int</span>&gt; op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        init = op(init, *first);</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    形参<code>op</code>是一个函数对象，而<code>op(init, *first)</code>等价于：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op.<span class="keyword">operator</span>()(init, *first);</span><br></pre></td></tr></table></figure></p><p>​    即调用了<code>SumPowers&lt;int&gt;</code>类的<code>operator()</code>成员函数。</p><p>​    对比<code>SumPowers</code>和<code>SumSquares</code>可以发现，函数对象的<code>operator()</code>成员函数可以根据对象内部的不同状态执行不同操作，而普通函数就无法做到这一点。因此函数对象的功能比普通函数更强大。</p><h2 id="函数对象在sort算法中的应用"><a href="#函数对象在sort算法中的应用" class="headerlink" title="函数对象在sort算法中的应用"></a>函数对象在<code>sort</code>算法中的应用</h2><p>​    <code>STL</code>中的排序模板<code>sort</code>能将区间从小到大排序。<code>sort</code>算法有两个版本。第一个版本的原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Randlt&gt;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(_Randlt first, _RandIt last)</span></span>;</span><br></pre></td></tr></table></figure></p><p>​    该模板可以用来将区间<code>[first, last)</code>中的元素从小到大排序，要求<code>first</code>、<code>last</code>是随机访问迭代器。元素比较大小是用<code>&lt;</code>进行的。如果表达式<code>a</code>的值为<code>true</code>，则<code>a</code>排在<code>b</code>前面；如果<code>a</code>的值为<code>false</code>，则<code>b</code>未必排在<code>a</code>前面，还要看<code>b</code>是否成立，成立的话<code>b</code>才排在<code>a</code>前面。要使用这个版本的<code>sort</code>算法，待排序的对象必须能用<code>&lt;</code>运算符进行比较。</p><p>​    <code>sort</code>算法第二个版本的原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Randlt, <span class="class"><span class="keyword">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">void</span> <span class="title">sort</span>(_<span class="title">Randlt</span> <span class="title">first</span>, _<span class="title">RandIt</span> <span class="title">last</span>, <span class="title">Pred</span> <span class="title">op</span>);</span></span><br></pre></td></tr></table></figure></p><p>​    这个版本和第一个版本的差别在于，元素<code>a</code>、<code>b</code>比较大小是通过表达式<code>op(a, b)</code>进行的。如果该表达式的值为<code>true</code>，则<code>a</code>比<code>b</code>小；如果该表达式的值为<code>false</code>，也不能认为<code>b</code>比<code>a</code>小，还要看<code>op(b, a)</code>的值。总之，<code>op</code>定义了元素比较大小的规则。下面是一个使用<code>sort</code>算法的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  //sort算法在此头文件中定义</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Printlnterva1</span>(<span class="title">T</span> <span class="title">first</span>, <span class="title">T</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span>  <span class="comment">//用以输出 [first, last) 区间中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    A(<span class="keyword">int</span> n) : v(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span><br><span class="line">&#123;  <span class="comment">//重载为 A 的 const 成员函数也可以，重载为非 const 成员函数在某些编译器上会出错</span></span><br><span class="line">    <span class="keyword">return</span> a1.v &lt; a2.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GreaterA</span><span class="params">(<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//v值大的元素作为较小的数</span></span><br><span class="line">    <span class="keyword">return</span> a1.v &gt; a2.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LessA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">//v的个位数小的元素就作为较小的数</span></span><br><span class="line">        <span class="keyword">return</span> (a1.v % <span class="number">10</span>) &lt; (a2.v % <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; o, <span class="keyword">const</span> A &amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    o &lt;&lt; a.v;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1[<span class="number">4</span>] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    A a2[<span class="number">5</span>] = &#123; <span class="number">13</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">16</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    sort(a1, a1 + <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1)"</span>; </span><br><span class="line">    Printlnterva1(a1, a1 + <span class="number">4</span>);  <span class="comment">//输出 1)1 2 4 5</span></span><br><span class="line">    </span><br><span class="line">    sort(a2, a2 + <span class="number">5</span>);  <span class="comment">//按v的值从小到大排序</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2)"</span>; </span><br><span class="line">    Printlnterva1(a2, a2 + <span class="number">5</span>);  <span class="comment">//输出 2)8 9 12 13 16</span></span><br><span class="line">    </span><br><span class="line">    sort(a2, a2 + <span class="number">5</span>, GreaterA);  <span class="comment">//按v的值从大到小排序</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3)"</span>; </span><br><span class="line">    Printlnterva1(a2, a2 + <span class="number">5</span>);  <span class="comment">//输出 3)16 13 12 9 8</span></span><br><span class="line">    </span><br><span class="line">    sort(a2, a2 + <span class="number">5</span>, LessA());  <span class="comment">//按v的个位数从小到大排序</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4)"</span>; </span><br><span class="line">    Printlnterva1(a2, a2 + <span class="number">5</span>);  <span class="comment">//输出 4)12 13 16 8 9</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    编译至第<code>57</code>行时，编译器将<code>sort</code>实例化得到的函数原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(A* first, A* last, <span class="keyword">bool</span> (*op)(<span class="keyword">const</span> A &amp;, <span class="keyword">const</span> A &amp;) )</span></span>;</span><br></pre></td></tr></table></figure></p><p>​    该函数在执行过程中，当要比较两个元素<code>a</code>、<code>b</code>的大小时，就是看 <code>op(a, b)</code>和<code>op(b, a)</code>的返回值。本程序中<code>op</code>指向<code>GreaterA</code>，因此就用<code>GreaterA</code>定义的规则来比较大小。</p><p>​    编译至第<code>61</code>行时，编译器将<code>sort</code>实例化得到的函数原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">( A* first, A* last, LessA op)</span></span>;</span><br></pre></td></tr></table></figure></p><p>​    该函数在执行过程中，当要比较两个元素<code>a</code>、<code>b</code>的大小时，就是看<code>op(a, b)</code>和 <code>op(b, a)</code>的返回值。本程序中，<code>op(a, b)</code>等价于<code>op.opeartor(a, b)</code>，因此就用<code>LessA</code>定义的规则来比较大小。</p><p>​    <code>STL</code>中定义了一些函数对象类模板，都位于头文件<code>functional</code> 中。例如，<code>greater</code>模板的源代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">greater</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    假设有以下数组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">34</span>, <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>​    要将该数组从大到小排序，则只需写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort( a, a+<span class="number">4</span>, greater&lt;<span class="keyword">int</span>&gt;() );</span><br></pre></td></tr></table></figure></p><p>​    要使用<code>greater</code>模板，须确保<code>&gt;</code>运算符本来就有定义，或经过了适当的重载。</p><p>​    <code>list</code>容器的<code>sort</code>成员能将元素从小到大排序。它也有两个版本：一个是没有参数的函数，比较大小用<code>&lt;</code>运算符；另一个是函数模板，原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">void</span> <span class="title">sort</span>(<span class="title">Pred</span> <span class="title">op</span>);</span></span><br></pre></td></tr></table></figure></p><p>​    <code>sort</code>函数允许自定义比较大小的规则，即<code>op(x, y)</code>为真就认为<code>x</code>比<code>y</code>小。例如，假设有：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst;</span><br></pre></td></tr></table></figure></p><p>​    如果希望将<code>lst</code> 中的元素按其整数数值从大到小排序，只需写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lst.sort( greater&lt;<span class="keyword">int</span>&gt;() );</span><br></pre></td></tr></table></figure></p><p>​    在使用关联容器和许多算法时，都可以用函数对象来定义比较大小的规则，以及其他一些规则和操作。</p><h2 id="STL中的函数对象类模板"><a href="#STL中的函数对象类模板" class="headerlink" title="STL中的函数对象类模板"></a><code>STL</code>中的函数对象类模板</h2><p><code>STL</code>中有一些函数对象类模板，如表<code>1</code>所示。</p><table><thead><tr><th>函数对象类模板</th><th>成员函数<code>T operator ( const T &amp; x, const T &amp; y)</code>的功能</th></tr></thead><tbody><tr><td><code>plus &lt;T&gt;</code></td><td><code>return x + y;</code></td></tr><tr><td><code>minus &lt;T&gt;</code></td><td><code>return x - y;</code></td></tr><tr><td><code>multiplies &lt;T&gt;</code></td><td><code>return x * y;</code></td></tr><tr><td><code>divides &lt;T&gt;</code></td><td><code>return x / y;</code></td></tr><tr><td><code>modulus &lt;T&gt;</code></td><td><code>return x % y;</code></td></tr><tr><td></td><td>成员函数<code>bool operator( const T &amp; x, const T &amp; y)</code>的功能</td></tr><tr><td><code>equal_to &lt;T&gt;</code></td><td><code>return x == y;</code></td></tr><tr><td><code>not_equal_to &lt;T&gt;</code></td><td><code>return x! = y;</code></td></tr><tr><td><code>greater &lt;T&gt;</code></td><td><code>return x &gt; y;</code></td></tr><tr><td><code>less &lt;T&gt;</code></td><td><code>return x &lt; y;</code></td></tr><tr><td><code>greater_equal &lt;T&gt;</code></td><td><code>return x &gt; = y;</code></td></tr><tr><td><code>less_equal &lt;T&gt;</code></td><td><code>return x &lt;= y;</code></td></tr><tr><td><code>logical_and &lt;T&gt;</code></td><td><code>return x &amp;&amp; y;</code></td></tr><tr><td><code>logical_or &lt;T&gt;</code></td><td>`return x \</td><td>\</td><td>y;`</td></tr><tr><td></td><td>成员函数<code>T operator( const T &amp; x)</code>的功能</td></tr><tr><td><code>negate &lt;T&gt;</code></td><td><code>return - x;</code></td></tr><tr><td></td><td>成员函数<code>bool operator( const T &amp; x)</code>的功能</td></tr><tr><td><code>logical_not &lt;T&gt;</code></td><td><code>return ! x;</code></td></tr></tbody></table><p> 例如，如果要求两个<code>double</code>型变量<code>x</code>、<code>y</code>的乘积，可以写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiplies&lt;<span class="keyword">double</span>&gt; () (x, y)</span><br></pre></td></tr></table></figure></p><p>​    <code>less</code>是<code>STL</code>中最常用的函数对象类模板，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(const_Tp &amp; __x, const_Tp &amp; __y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要判断两个<code>int</code>变量<code>x</code>、<code>y</code>中<code>x</code>是否比<code>y</code>小，可以写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( less&lt;<span class="keyword">int</span>&gt;()(x, y) ) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><h2 id="引入函数对象后STL-中的“大”、“小”和“相等”概念"><a href="#引入函数对象后STL-中的“大”、“小”和“相等”概念" class="headerlink" title="引入函数对象后STL 中的“大”、“小”和“相等”概念"></a>引入函数对象后<code>STL</code> 中的“大”、“小”和“相等”概念</h2><p>​    前面提到过，默认情况下，<code>STL</code>中的容器和算法比较元素的大小是通过<code>&lt;</code>运算符进行的。<code>sort</code>和<code>list::sort</code>都可以通过一个函数对象或函数自定义比较元素大小的规则。例如以下的 sort 版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_RandIt, <span class="class"><span class="keyword">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">void</span> <span class="title">sort</span>(_<span class="title">RandIt</span> <span class="title">first</span>, _<span class="title">RandIt</span> <span class="title">last</span>, <span class="title">Pred</span> <span class="title">op</span>);</span></span><br></pre></td></tr></table></figure></p><p>​    实际调用<code>sort</code>时，和 <code>op</code>对应的实参可以是一个函数对象或者函数的名字。<code>sort</code>在执行过程中用<code>op(x, y)</code> 比较<code>x</code>和<code>y</code>的大小，因此可以将<code>op</code>称为自定义的“比较器”。</p><p>​    关联容器中的元素是从小到大排序的。使用关联容器时，也可以用自定义的比较器取代<code>&lt;</code>运算符，以规定元素之间的大小关系。<code>STL</code>中还有许多算法都可以自定义比较器。在自定义比较器<code>op</code>的情况下，以下三种说法是等价的：</p><ul><li><code>x</code>小于<code>y</code>。</li><li><code>op(x, y)</code>的返回值为<code>true</code>。</li><li><code>y</code>大于<code>x</code>。</li></ul><p> 同样地，对关联容器的<code>find</code>和<code>count</code>成员函数以及其他一些在有序区间上的<code>STL</code>算法而言，在自定义比较器<code>op</code>的情况下，<code>x</code>和<code>y</code>相等与<code></code>op(x, y)<code>和</code>op(y, x)`都为假是等价的。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++类模板</title>
      <link href="/2018/08/15/c++%E6%A8%A1%E6%9D%BF3-%E7%B1%BB%E6%A8%A1%E6%9D%BF/"/>
      <url>/2018/08/15/c++%E6%A8%A1%E6%9D%BF3-%E7%B1%BB%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="类模板的显式具体化"><a href="#类模板的显式具体化" class="headerlink" title="类模板的显式具体化"></a>类模板的显式具体化</h3><p>​    下面的函数模板，它用来获取两个变量中较大的一个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">Max</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">b</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    请读者注意<code>a &gt; b</code>这条语句，<code>&gt;</code>能够用来比较 <code>int</code>、<code>float</code>、<code>char</code>等基本类型数据的大小，但是却不能用来比较结构体变量、对象以及数组的大小，因为我们并没有针对结构体、类和数组重载<code>&gt;</code>。另外，该函数模板虽然可以用于指针，但比较的是地址大小，而不是指针指向的数据，所以也没有现实的意义。</p><a id="more"></a><p>​    模板是一种泛型技术，它能接受的类型是宽泛的、没有限制的，并且对这些类型使用的算法都是一样的（函数体或类体一样）。但是现在我们希望改变这种“游戏规则”，让模板能够针对某种具体的类型使用不同的算法（函数体或类体不同），这在<code>C++</code>中是可以做到的，这种技术称为模板的<strong>显示具体化（<code>Explicit Specialization</code>）</strong>。</p><p>​    函数模板和类模板都可以显示具体化。除了函数模板，类模板也可以显示具体化，并且它们的语法是类似的。</p><p>​        在<code>C++</code>类模板一节中我们定义了一个<code>Point</code>类，用来输出不同类型的坐标。在输出结果中，横坐标<code>x</code>和纵坐标<code>y</code>是以逗号<code>,</code>为分隔的，但是由于个人审美的不同，我希望当<code>x</code>和<code>y</code>都是字符串时以<code>|</code>为分隔，是数字或者其中一个是数字时才以逗号<code>,</code>为分隔。为了满足我这种奇葩的要求，可以使用显示具体化技术对字符串类型的坐标做特殊处理。</p><p> 下面的例子演示了如何对<code>Point</code>类进行显示具体化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt; <span class="title">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(T1 x, T2 y): m_x(x), m_y(y)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T1 <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(T1 x)</span></span>&#123; m_x = x; &#125;</span><br><span class="line">    <span class="function">T2 <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(T2 y)</span></span>&#123; m_y = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_x;</span><br><span class="line">    T2 m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;  //这里要带上模板头</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Point</span>&lt;T1, T2&gt;:</span>:display() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;m_x&lt;&lt;<span class="string">", y="</span>&lt;&lt;m_y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板的显示具体化（针对字符串类型的显示具体化）</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;char*, char*&gt;&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">char</span> *x, <span class="keyword">char</span> *y): m_x(x), m_y(y)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">char</span> *x)</span></span>&#123; m_x = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">char</span> *y)</span></span>&#123; m_y = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_x;  <span class="comment">//x坐标</span></span><br><span class="line">    <span class="keyword">char</span> *m_y;  <span class="comment">//y坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里不能带模板头template&lt;&gt;</span></span><br><span class="line"><span class="keyword">void</span> Point&lt;<span class="keyword">char</span>*, <span class="keyword">char</span>*&gt;::display() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;m_x&lt;&lt;<span class="string">" | y="</span>&lt;&lt;m_y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ( <span class="keyword">new</span> Point&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">10</span>, <span class="number">20</span>) ) -&gt; display();</span><br><span class="line">    ( <span class="keyword">new</span> Point&lt;<span class="keyword">int</span>, <span class="keyword">char</span>*&gt;(<span class="number">10</span>, <span class="string">"东京180度"</span>) ) -&gt; display();</span><br><span class="line">    ( <span class="keyword">new</span> Point&lt;<span class="keyword">char</span>*, <span class="keyword">char</span>*&gt;(<span class="string">"东京180度"</span>, <span class="string">"北纬210度"</span>) ) -&gt; display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>x=10, y=20</code><br><code>x=10, y=东京180度</code><br><code>x=东京180度 | y=北纬210度</code></p><p>​    请读者注意第<code>25</code>行代码，<code>Point</code>表明了要将类型参数<code>T1</code>、<code>T2</code>都具体化为<code>char*</code>类型，原来使用<code>T1</code>、<code>T2</code>的位置都应该使用<code>char*</code>替换。<code>Point</code>类有两个类型参数<code>T1</code>、<code>T2</code>，并且都已经被具体化了，所以整个类模板就不再有类型参数了，模板头应该写作<code>template&lt;&gt;</code>。</p><p>​    再来对比第<code>19</code>、<code>40</code>行代码，可以发现，<strong>当在类的外部定义成员函数时，普通类模板的成员函数前面要带上模板头，而具体化的类模板的成员函数前面不能带模板头。</strong></p><h4 id="部分显式具体化"><a href="#部分显式具体化" class="headerlink" title="部分显式具体化"></a>部分显式具体化</h4><p>​    在上面的显式具体化例子中，我们为所有的类型参数都提供了实参，所以最后的模板头为空，也即<code>template&lt;&gt;</code>。另外<code>C++</code>还允许只为一部分类型参数提供实参，这称为部分显式具体化。</p><p>​    部分显式具体化只能用于类模板，不能用于函数模板。</p><p>​    仍然以<code>Point</code>为例，假设我现在希望“只要横坐标<code>x</code>是字符串类型”就以<code>|</code>来分隔输出结果，而不管纵坐标 <code>y</code>是什么类型，这种要求就可以使用部分显式具体化技术来满足。请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt; <span class="title">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(T1 x, T2 y): m_x(x), m_y(y)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T1 <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(T1 x)</span></span>&#123; m_x = x; &#125;</span><br><span class="line">    <span class="function">T2 <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(T2 y)</span></span>&#123; m_y = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_x;</span><br><span class="line">    T2 m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;  //这里需要带上模板头</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Point</span>&lt;T1, T2&gt;:</span>:display() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;m_x&lt;&lt;<span class="string">", y="</span>&lt;&lt;m_y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板的部分显示具体化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt; <span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;char*, T2&gt;&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">char</span> *x, T2 y): m_x(x), m_y(y)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">char</span> *x)</span></span>&#123; m_x = x; &#125;</span><br><span class="line">    <span class="function">T2 <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(T2 y)</span></span>&#123; m_y = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_x;  <span class="comment">//x坐标</span></span><br><span class="line">    T2 m_y;  <span class="comment">//y坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;  <span class="comment">//这里需要带上模板头</span></span><br><span class="line"><span class="keyword">void</span> Point&lt;<span class="keyword">char</span>*, T2&gt;::display() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;m_x&lt;&lt;<span class="string">" | y="</span>&lt;&lt;m_y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ( <span class="keyword">new</span> Point&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">10</span>, <span class="number">20</span>) ) -&gt; display();</span><br><span class="line">    ( <span class="keyword">new</span> Point&lt;<span class="keyword">char</span>*, <span class="keyword">int</span>&gt;(<span class="string">"东京180度"</span>, <span class="number">10</span>) ) -&gt; display();</span><br><span class="line">    ( <span class="keyword">new</span> Point&lt;<span class="keyword">char</span>*, <span class="keyword">char</span>*&gt;(<span class="string">"东京180度"</span>, <span class="string">"北纬210度"</span>) ) -&gt; display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>x=10, y=20</code><br><code>x=东京180度 | y=10</code><br><code>x=东京180度 | y=北纬210度</code></p><p>​    本例中，<code>T1</code>对应横坐标<code>x</code>的类型，我们将<code>T1</code>具体化为<code>char*</code>，第<code>25</code>行代码就是类模板的部分显示具体化。</p><p>​    模板头<code>template</code>中声明的是没有被具体化的类型参数；类名<code>Point</code>列出了所有类型参数，包括未被具体化的和已经被具体化的。</p><p>​    类名后面之所以要列出所有的类型参数，是为了让编译器确认“到底是第几个类型参数被具体化了”，如果写作<code>template class Point</code>，编译器就不知道<code>char*</code>代表的是第一个类型参数，还是第二个类型参数。</p><h3 id="类模板中使用非类型参数"><a href="#类模板中使用非类型参数" class="headerlink" title="类模板中使用非类型参数"></a>类模板中使用非类型参数</h3><p>​    模板是一种泛型技术，目的是将数据的类型参数化，以增强<code>C++</code>语言（强类型语言）的灵活性。<code>C++</code>对模板的支持非常自由，模板中除了可以包含类型参数，还可以包含非类型参数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt; <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span> &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">N</span>&gt; <span class="title">void</span> <span class="title">func</span>(<span class="title">T</span> (&amp;<span class="title">arr</span>)[<span class="title">N</span>]);</span></span><br></pre></td></tr></table></figure><p>​    <code>T</code>是一个类型参数，它通过<code>class</code>或<code>typename</code>关键字指定。<code>N</code>是一个非类型参数，用来传递数据的值，而不是类型，它和普通函数的形参一样，都需要指明具体的类型。类型参数和非类型参数都可以用在函数体或者类体中。</p><p>​    当调用一个函数模板或者通过一个类模板创建对象时，非类型参数会被用户提供的、或者编译器推断出的值所取代。</p><p>​    <strong><code>C/C++</code>规定，数组一旦定义后，它的长度就不能改变了；换句话说，数组容量不能动态地增大或者减小。这样的数组称为静态数组（<code>Static array</code>）。静态数组有时候会给编码代码不便，我们可以通过自定义的<code>Array</code>类来实现动态数组（<code>Dynamic array</code>）。所谓动态数组，是指数组容量能够在使用的过程中随时增大或减小。</strong></p><p> 动态数组的完整实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array();</span><br><span class="line">    ~Array();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);  <span class="comment">//重载下标运算符[]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;  <span class="comment">//获取数组长度</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> n)</span></span>;  <span class="comment">//改变数组容量</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length;  <span class="comment">//数组的当前长度</span></span><br><span class="line">    <span class="keyword">int</span> m_capacity;  <span class="comment">//当前内存的容量（能容乃的元素的个数）</span></span><br><span class="line">    T *m_p;  <span class="comment">//指向数组内存的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</span><br><span class="line">Array&lt;T, N&gt;::Array()&#123;</span><br><span class="line">    m_p = <span class="keyword">new</span> T[N];</span><br><span class="line">    m_capacity = m_length = N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</span><br><span class="line">Array&lt;T, N&gt;::~Array()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</span><br><span class="line">T &amp; Array&lt;T, N&gt;::<span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=m_length)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception: Array index out of bounds!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> Array&lt;T, N&gt;::capacity(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;  <span class="comment">//增大数组</span></span><br><span class="line">        <span class="keyword">int</span> len = m_length + n;  <span class="comment">//增大后的数组长度</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt;= m_capacity)&#123;  <span class="comment">//现有内存足以容纳增大后的数组</span></span><br><span class="line">            m_length = len;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//现有内存不能容纳增大后的数组</span></span><br><span class="line">            T *pTemp = <span class="keyword">new</span> T[m_length + <span class="number">2</span> * n * <span class="keyword">sizeof</span>(T)];  <span class="comment">//增加的内存足以容纳 2*n 个元素</span></span><br><span class="line">            <span class="keyword">if</span>(pTemp == <span class="literal">NULL</span>)&#123;  <span class="comment">//内存分配失败</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception: Failed to allocate memory!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//内存分配成功</span></span><br><span class="line">                <span class="built_in">memcpy</span>( pTemp, m_p, m_length*<span class="keyword">sizeof</span>(T) );</span><br><span class="line">                <span class="keyword">delete</span>[] m_p;</span><br><span class="line">                m_p = pTemp;</span><br><span class="line">                m_capacity = m_length = len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">//收缩数组</span></span><br><span class="line">        <span class="keyword">int</span> len = m_length - <span class="built_in">abs</span>(n);  <span class="comment">//收缩后的数组长度</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception: Array length is too small!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m_length = len;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Array&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt; arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为数组元素赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, len=arr.length(); i&lt;len; i++)&#123;</span><br><span class="line">        arr[i] = <span class="number">2</span>*i;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//第一次打印数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, len=arr.length(); i&lt;len; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩大容量并为增加的元素赋值</span></span><br><span class="line">    arr.capacity(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>, len=arr.length(); i&lt;len; i++)&#123;</span><br><span class="line">        arr[i] = <span class="number">2</span>*i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二次打印数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, len=arr.length(); i&lt;len; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收缩容量</span></span><br><span class="line">    arr.capacity(<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三次打印数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, len=arr.length(); i&lt;len; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>0 2 4 6 8</code><br><code>0 2 4 6 8 10 12 14 16 18 20 22 24</code><br><code>0 2 4 6 8 10 12 14 16</code></p><p>​    <code>Array</code>是一个类模板，它有一个类型参数<code>T</code>和一个非类型参数<code>N</code>，<code>T</code>指明了数组元素的类型，<code>N</code>指明了数组长度。</p><p>​    <code>capacity()</code>成员函数是<code>Array</code>类的关键，它使得数组容量可以动态地增加或者减小。传递给它一个正数时，数组容量增大；传递给它一个负数时，数组容量减小。</p><p>​    之所以能通过<code>[ ]</code>来访问数组元素，是因为在<code>Array</code>类中以成员函数的形式重载了<code>[ ]</code>运算符，并且返回值是数组元素的引用。如果直接返回数组元素的值，那么将无法给数组元素赋值。</p><h4 id="非类型参数的限制"><a href="#非类型参数的限制" class="headerlink" title="非类型参数的限制"></a>非类型参数的限制</h4><p>​    非类型参数的类型不能随意指定，它受到了严格的限制，只能是一个整数，或者是一个指向对象或函数的指针（也可以是引用）。</p><p> 1) 当非类型参数是一个整数时，传递给它的实参，或者由编译器推导出的实参必须是一个常量表达式，例如<code>10</code>、<code>2 * 30</code>、<code>18 + 23 - 4</code>等，但不能是<code>n</code>、<code>n + 10</code>、<code>n + m</code>等（<code>n</code>和<code>m</code>都是变量）。</p><p>对上面的 Array 类，以下创建对象的方式是错误的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;len;</span><br><span class="line">Array&lt;<span class="keyword">int</span>, len&gt; arr;</span><br></pre></td></tr></table></figure><p>这种情况，编译器推导出来的实参是<code>len</code>，是一个变量，而不是常量。</p><p> 2) 当非类型参数是一个指针（引用）时，绑定到该指针的实参必须具有静态的生存期；换句话说，实参必须存储在虚拟地址空间中的静态数据区。局部变量位于栈区，动态创建的对象位于堆区，它们都不能用作实参。</p><h3 id="类模板实例化"><a href="#类模板实例化" class="headerlink" title="类模板实例化"></a>类模板实例化</h3><p>​    <strong>模板（<code>Templet</code>）并不是真正的函数或类，它仅仅是编译器用来生成函数或类的一张“图纸”。模板不会占用内存，最终生成的函数或者类才会占用内存。由模板生成函数或类的过程叫做模板的实例化（<code>Instantiate</code>），相应地，针对某个类型生成的特定版本的函数或类叫做模板的一个实例（<code>Instantiation</code>）。</strong></p><p>​    模板也可以看做是编译器的一组指令，它命令编译器生成我们想要的代码。</p><p>​    <strong>模板的实例化是按需进行的，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码。也就是说，编译器会根据传递给类型参数的实参（也可以是编译器自己推演出来的实参）来生成一个特定版本的函数或类，并且相同的类型只生成一次。实例化的过程也很简单，就是将所有的类型参数用实参代替。</strong></p><p>​    <strong>类模板的实例化，通过类模板创建对象时并不会实例化所有的成员函数，只有等到真正调用它们时才会被实例化；如果一个成员函数永远不会被调用，那它就永远不会被实例化。<code>这说明类的实例化是延迟的、局部的，编译器并不着急生成所有的代码</code>。</strong></p><p>​    通过类模板创建对象时，一般只需要实例化成员变量和构造函数。成员变量被实例化后就能够知道对象的大小了（占用的字节数），构造函数被实例化后就能够知道如何初始化了；对象的创建过程就是分配一块大小已知的内存，并对这块内存进行初始化。</p><p>​    请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(T1 x, T2 y): m_x(x), m_y(y)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T1 <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(T1 x)</span></span>&#123; m_x = x; &#125;</span><br><span class="line">    <span class="function">T2 <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_y; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(T2 y)</span></span>&#123; m_y = y; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_x;</span><br><span class="line">    T2 m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Point</span>&lt;T1, T2&gt;:</span>:display() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;m_x&lt;&lt;<span class="string">", y="</span>&lt;&lt;m_y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p1(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    p1.setX(<span class="number">40</span>);</span><br><span class="line">    p1.setY(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;p1.getX()&lt;&lt;<span class="string">", y="</span>&lt;&lt;p1.getY()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Point&lt;<span class="keyword">char</span>*, <span class="keyword">char</span>*&gt; p2(<span class="string">"东京180度"</span>, <span class="string">"北纬210度"</span>);</span><br><span class="line">    p2.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>x=40, y=50</code><br><code>x=东京180度, y=北纬210度</code></p><p>​    <code>p1</code>调用了所有的成员函数，整个类会被完整地实例化。<code>p2</code>只调用了构造函数和<code>display()</code>函数，剩下的 <code>get</code>函数和<code>set</code>函数不会被实例化。</p><p>​    值得提醒的是，<code>Point</code>和<code>Point</code>是两个相互独立的类，它们的类型是不同的，不能相互兼容，也不能自动地转换类型，所以诸如<code>p1 = p2;</code>这样的语句是错误的，除非重载了<code>=</code>运算符。</p><h3 id="将类模板的声明和实现分散到不同的文件"><a href="#将类模板的声明和实现分散到不同的文件" class="headerlink" title="将类模板的声明和实现分散到不同的文件"></a>将类模板的声明和实现分散到不同的文件</h3><p>​    <strong>总起来说，不管是函数还是类，声明和定义（实现）的分离其实是一回事，都是将函数定义放到其他文件中，最终要解决的问题也只有一个，就是把函数调用和函数定义对应起来（找到函数定义的地址，并填充到函数调用处），而保证完成这项工作的就是链接器。</strong></p><p>​    基于传统的编程思维，初学者往往也会将模板（函数模板和类模板）的声明和定义分散到不同的文件中，以期达到「模块化编程」的目的。但事实证明这种做法是不对的，**程序员惯用的做法是将模板的声明和定义都放到头文件中。</p><p>​    我们看一个类模板的反面教材，它将类模板的声明和实现分别放到了头文件和源文件。</p><p><code>point.h</code>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _POINT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _POINT_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(T1 x, T2 y): m_x(x), m_y(y)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T1 <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(T1 x)</span></span>&#123; m_x = x; &#125;</span><br><span class="line">    <span class="function">T2 <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_y; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(T2 y)</span></span>&#123; m_y = y; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_x;</span><br><span class="line">    T2 m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>point.cpp</code>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"point.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Point</span>&lt;T1, T2&gt;:</span>:display() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;m_x&lt;&lt;<span class="string">", y="</span>&lt;&lt;m_y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"point.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p1(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    p1.setX(<span class="number">40</span>);</span><br><span class="line">    p1.setY(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;p1.getX()&lt;&lt;<span class="string">", y="</span>&lt;&lt;p1.getY()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Point&lt;<span class="keyword">char</span>*, <span class="keyword">char</span>*&gt; p2(<span class="string">"东京180度"</span>, <span class="string">"北纬210度"</span>);</span><br><span class="line">    p2.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    该工程包含了两个源文件和一个头文件，<code>point.h</code>中声明了类模板，<code>point.cpp</code>中对类模板进行了实现，<code>main.cpp</code>中通过类模板创建了对象，并调用了成员函数，这是典型的将类的声明和实现分离的编程模式。</p><p>​    运行上面的程序，会产生一个链接错误，意思是无法通过<code>p2</code>调用<code>Point::display() const</code>这个函数。</p><p>​    类模板声明位于<code>point.h</code>中，它包含了所有成员变量的定义以及构造函数、<code>get</code>函数、<code>set</code>函数的定义，这些信息足够创建出一个完整的对象了，并且可以通过对象调用<code>get</code>函数和<code>set</code>函数，所以<code>main.cpp</code>的前<code>11</code> 行代码都不会报错。而第<code>12</code>行代码调用了<code>display()</code>函数，该函数的定义位于<code>point.cpp</code>文件中，并且<code>point.cpp</code>中也没有生成对应的实例，所以会在链接期间抛出错误。</p><h3 id="类模板的显式实例化"><a href="#类模板的显式实例化" class="headerlink" title="类模板的显式实例化"></a>类模板的显式实例化</h3><p>​    前面讲到的模板的实例化是在调用函数或者创建对象时由编译器自动完成的，不需要程序员引导，因此称为<strong>隐式实例化</strong>。相对应的，我们也可以通过代码明确地告诉编译器需要针对哪个类型进行实例化，这称为<strong>显式实例化。</strong></p><p>​    编译器在实例化的过程中需要知道模板的所有细节：<strong>对于函数模板，也就是函数定义；对于类模板，需要同时知道类声明和类定义。我们必须将显式实例化的代码放在包含了模板定义的源文件中，而不是仅仅包含了模板声明的头文件中。</strong></p><p>​    <strong>显式实例化的一个好处是，可以将模板的声明和定义（实现）分散到不同的文件中了。</strong></p><p>​    类模板的显式实例化和函数模板类似。以上节的<code>Point</code>类为例，针对<code>char*</code>类型的显式实例化（定义形式）代码为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;char*, char*&gt;;</span></span><br></pre></td></tr></table></figure></p><p>相应地，它的声明形式为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;char*, char*&gt;;</span></span><br></pre></td></tr></table></figure></p><p>​    不管是声明还是定义，都要带上<code>class</code>关键字，以表明这是针对类模板的。</p><p>​    另外需要注意的是，显式实例化一个类模板时，会一次性实例化该类的所有成员，包括成员变量和成员函数。</p><p>​    有了类模板的显式实例化，就可以将类模板的声明和定义分散到不同的文件中了，下面我们就来修复上节的代码。</p><p>​     <code>point.cpp</code>源文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"point.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Point</span>&lt;T1, T2&gt;:</span>:display() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;m_x&lt;&lt;<span class="string">", y="</span>&lt;&lt;m_y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显式实例化定义</span></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;char*, char*&gt;;</span></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;int, int&gt;;</span></span><br></pre></td></tr></table></figure><p><code>point.h</code>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _POINT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _POINT_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(T1 x, T2 y): m_x(x), m_y(y)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T1 <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(T1 x)</span></span>&#123; m_x = x; &#125;</span><br><span class="line">    <span class="function">T2 <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_y; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(T2 y)</span></span>&#123; m_y = y; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_x;</span><br><span class="line">    T2 m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"point.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显式实例化声明（也可以不写）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;char*, char*&gt;;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;int, int&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p1(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    p1.setX(<span class="number">40</span>);</span><br><span class="line">    p1.setY(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;p1.getX()&lt;&lt;<span class="string">", y="</span>&lt;&lt;p1.getY()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Point&lt;<span class="keyword">char</span>*, <span class="keyword">char</span>*&gt; p2(<span class="string">"东京180度"</span>, <span class="string">"北纬210度"</span>);</span><br><span class="line">    p2.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    函数模板和类模板的实例化语法是类似的，我们不妨对它们做一下总结：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;  <span class="comment">//实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;  <span class="comment">//实例化定义</span></span><br></pre></td></tr></table></figure></p><p>​    对于函数模板来说，<code>declaration</code>就是一个函数原型；对于类模板来说，<code>declaration</code>就是一个类声明。</p><h4 id="显式实例化的缺陷"><a href="#显式实例化的缺陷" class="headerlink" title="显式实例化的缺陷"></a>显式实例化的缺陷</h4><p>​    <code>C++</code>支持显式实例化的目的是为「模块化编程」提供一种解决方案，这种方案虽然有效，但是也有明显的缺陷：程序员必须要在模板的定义文件（实现文件）中对所有使用到的类型进行实例化。这就意味着，每次更改了模板使用文件（调用函数模板的文件，或者通过类模板创建对象的文件），也要相应地更改模板定义文件，以增加对新类型的实例化，或者删除无用类型的实例化。</p><p>​     一个模板可能会在多个文件中使用到，要保持这些文件的同步更新是非常困难的。而对于库的开发者来说，他不能提前假设用户会使用哪些类型，所以根本就无法使用显式实例化，只能将模板的声明和定义（实现）全部放到头文件中；<code>C++</code>标准库几乎都是用模板来实现的，这些模板的代码也都位于头文件中。</p><p>​    总起来说，如果我们开发的模板只有我们自己使用，那也可以勉强使用显式实例化；如果希望让其他人使用（例如库、组件等），那只能将模板的声明和定义都放到头文件中了。</p><h3 id="类模板与继承详解"><a href="#类模板与继承详解" class="headerlink" title="类模板与继承详解"></a>类模板与继承详解</h3><p>​    类模板和类模板之间、类模板和类之间可以互相继承。它们之间的派生关系有以下四种情况。</p><h4 id="类模板从类模板派生"><a href="#类模板从类模板派生" class="headerlink" title="类模板从类模板派生"></a>类模板从类模板派生</h4><p>​    示例程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Tl v1; T2 v2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &lt;T2, T1&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T1 v3; T2 v4;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B &lt;T, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T v5;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; obj1;</span><br><span class="line">    C&lt;<span class="keyword">int</span>&gt; obj2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    编译到第<code>18</code>行，编译器用<code>int</code>替换类模板<code>B</code>中的<code>T1</code>，用<code>double</code> 替换<code>T2</code>，生成<code>B&lt;int, double&gt;</code>类如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &lt;int, double&gt;:</span> <span class="keyword">public</span> A &lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> v3; <span class="keyword">double</span> v4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    <code>B &lt;int, double&gt;</code>的基类是<code>A &lt;double, int&gt;</code>。于是编译器就要用<code>double</code>替换类模板<code>A</code>中的<code>T1</code>，用<code>int</code>替换<code>T2</code>，生成<code>A&lt;double, int&gt;</code>类如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &lt;double, int&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> v1; <span class="keyword">int</span> v2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    编译到第<code>19</code>行，编译器生成类<code>C&lt;int&gt;</code>，还有<code>C&lt;int&gt;</code>的直接基类<code>B&lt;int, int&gt;</code>，以及<code>B&lt;int, int&gt;</code>的基类<code>A&lt;int, int&gt;</code>。</p><h4 id="类模板从模板类派生"><a href="#类模板从模板类派生" class="headerlink" title="类模板从模板类派生"></a>类模板从模板类派生</h4><p>​    示例程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    T1 v1; T2 v2; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    B &lt;<span class="keyword">char</span>&gt; obj1; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    第<code>4</code>行，<code>A&lt;int, double&gt;</code>是一个具体的类的名字，而且它是一个模板类，因此说类模板<code>B</code>是从模板类派生而来的。</p><p>​    编译器编译到第<code>5</code>行<code>Bobj1;</code>时会自动生成两个模板类：<code>A&lt;int, double&gt;</code>和<code>B&lt;char&gt;</code>。</p><h4 id="类模板从普通类派生"><a href="#类模板从普通类派生" class="headerlink" title="类模板从普通类派生"></a>类模板从普通类派生</h4><p>​    示例程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> v1; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123; </span><br><span class="line">    T v; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    B &lt;<span class="keyword">char</span>&gt; obj1; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="普通类从模板类派生"><a href="#普通类从模板类派生" class="headerlink" title="普通类从模板类派生"></a>普通类从模板类派生</h4><p>​    示例程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    T v1; </span><br><span class="line">    <span class="keyword">int</span> n; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &lt;<span class="keyword">int</span>&gt; </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">double</span> v; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    B obj1; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板与友元详解"><a href="#类模板与友元详解" class="headerlink" title="类模板与友元详解"></a>类模板与友元详解</h3><p>​    下面我们分四种情况分别讨论。</p><h4 id="函数、类、类的成员函数作为类模板的友元"><a href="#函数、类、类的成员函数作为类模板的友元" class="headerlink" title="函数、类、类的成员函数作为类模板的友元"></a>函数、类、类的成员函数作为类模板的友元</h4><p>​    函数、类、类的成员函数都可以作为类模板的友元。程序示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span> </span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Tmpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> B::Func();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tmpl&lt;<span class="keyword">int</span>&gt; i;</span><br><span class="line">    Tmpl&lt;<span class="keyword">double</span>&gt; f;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    类模板实例化时，除了类型参数被替换外，其他所有内容都原样保留，因此任何从<code>Tmp1</code>实例化得到的类都包含上面三条友元声明，因而也都会把<code>Func1</code>、类<code>A</code>和<code>B::Func</code>当作友元。</p><h4 id="函数模板作为类模板的友元"><a href="#函数模板作为类模板的友元" class="headerlink" title="函数模板作为类模板的友元"></a>函数模板作为类模板的友元</h4><p>​    之前我们定义了<code>Pair</code>模板，将<code>&lt;&lt;</code>运算符重载为一个函数模板，并将该函数模板作为<code>Pair</code>模板的友元，这样，任何从<code>Pair</code>模板实例化得到的对象都能用<code>&lt;&lt;</code>运算符通过<code>cout</code>输出。</p><pre><code>程序代码如下（函数模板作为类模板的友元）：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Pair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 key;  <span class="comment">//关键字</span></span><br><span class="line">    T2 value;  <span class="comment">//值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Pair(T1 k, T2 v) : key(k), value(v) &#123; &#125;;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Pair&lt;T1, T2&gt; &amp; p) <span class="keyword">const</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T3</span>, <span class="title">class</span> <span class="title">T4</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">friend</span> <span class="title">ostream</span> &amp; <span class="title">operator</span> &lt;&lt; (ostream &amp; o, const Pair&lt;T3, T4&gt; &amp; p);</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">template &lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="class">bool Pair &lt;T1, T2&gt;::operator&lt; (const Pair&lt;T1, T2&gt; &amp; p) const</span></span><br><span class="line"><span class="class">&#123;  //“小”的意思就是关键字小</span></span><br><span class="line"><span class="class">    return key &lt; p.key;</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">template &lt;class Tl, class T2&gt;</span></span><br><span class="line"><span class="class">ostream &amp; operator &lt;&lt; (ostream &amp; o, const Pair&lt;T1, T2&gt; &amp; p)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    o &lt;&lt; "(" &lt;&lt; p.key &lt;&lt; "," &lt;&lt; p.value &lt;&lt; ")";</span></span><br><span class="line"><span class="class">    return o;</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">int main()</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    Pair&lt;string, int&gt; student("Tom", 29);</span></span><br><span class="line"><span class="class">    Pair&lt;int, double&gt; obj(12, 3.14);</span></span><br><span class="line"><span class="class">    cout &lt;&lt; student &lt;&lt; " " &lt;&lt; obj;</span></span><br><span class="line"><span class="class">    return 0;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br><code>(Torn, 29) (12, 3.14)</code></p><p>​    第<code>13</code>、<code>14</code>行将函数模板<code>operator&lt;&lt;</code>声明为类模板<code>Pair</code> 的友元。在<code>Visual Studio</code>中，这两行也可以用下面的写法替代：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt; &lt;T1, T2&gt;(ostream &amp; o, <span class="keyword">const</span> Pair&lt;T1, T2&gt; &amp; p);</span><br></pre></td></tr></table></figure></p><p>​    但在<code>Dev C ++</code>中，替代后编译就无法通过了。</p><p>​    编译本程序时，编译器自动生成了两个<code>operator &lt;&lt;</code>函数，它们的原型分别是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; o, <span class="keyword">const</span> Pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &amp; p);</span><br><span class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; o, <span class="keyword">const</span> Pair&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; &amp; p);</span><br></pre></td></tr></table></figure></p><p>​    前者是<code>Pair &lt;string, int&gt;</code> 类的友元，但不是<code>Pair&lt;int, double&gt;</code>类的友元；后者是<code>Pair&lt;int, double&gt;</code>类的友元，但不是<code>Pair&lt;string, int&gt;</code>类的友元。</p><h5 id="函数模板作为类的友元"><a href="#函数模板作为类的友元" class="headerlink" title="函数模板作为类的友元"></a>函数模板作为类的友元</h5><p>​    实际上，类也可以将函数模板声明为友元。程序示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> n) :v(n) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">friend</span> <span class="title">void</span> <span class="title">Print</span>(<span class="title">const</span> <span class="title">T</span> &amp; <span class="title">p</span>);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Print</span>(<span class="title">const</span> <span class="title">T</span> &amp; <span class="title">p</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    Print(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br><code>4</code></p><p>​    编译器编译到第<code>19</code>行<code>Print(a);</code>时，就从<code>Print</code>模板实例化出一个<code>Print</code>函数，原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> A &amp; p)</span></span>;</span><br></pre></td></tr></table></figure></p><p>​    这个函数本来不能访问<code>p</code>的私有成员。但是编译器发现，如果将类<code>A</code>的友元声明中的<code>T</code>换成<code>A</code>，就能起到将该<code>Print</code>函数声明为友元的作用，因此编译器就认为该<code>Print</code>函数是类<code>A</code>的友元。</p><h4 id="类模板作为类模板的友元"><a href="#类模板作为类模板的友元" class="headerlink" title="类模板作为类模板的友元"></a>类模板作为类模板的友元</h4><p>一个类模板还可以将另一个类模板声明为友元。程序示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> T &amp; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(T n) : v(n) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">friend</span> <span class="title">class</span> <span class="title">A</span>;</span>  <span class="comment">//把类模板A声明为友元</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B&lt;<span class="keyword">int</span>&gt; b(<span class="number">5</span>);</span><br><span class="line">    A&lt; B&lt;<span class="keyword">int</span>&gt; &gt; a;  <span class="comment">//用B&lt;int&gt;替换A模板中的 T</span></span><br><span class="line">    a.Func(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br><code>5</code></p><p>​    在本程序中，<code>A&lt; B&lt;int&gt; &gt;</code>类成为<code>B&lt;int&gt;</code>类的友元。</p><h3 id="类模板中的静态成员"><a href="#类模板中的静态成员" class="headerlink" title="类模板中的静态成员"></a>类模板中的静态成员</h3><p>​    类模板中可以定义静态成员，从该类模板实例化得到的所有类都包含同样的静态成员。</p><p>​    程序示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; count ++; &#125;</span><br><span class="line">    ~A() &#123; count -- ; &#125;;</span><br><span class="line">    A(A &amp;) &#123; count ++ ; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintCount</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">int</span> A&lt;<span class="keyword">int</span>&gt;::count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">int</span> A&lt;<span class="keyword">double</span>&gt;::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A&lt;<span class="keyword">int</span>&gt; ia;</span><br><span class="line">    A&lt;<span class="keyword">double</span>&gt; da;</span><br><span class="line">    ia.PrintCount();</span><br><span class="line">    da.PrintCount();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br><code>1</code><br><code>1</code></p><p>​    第<code>14</code> 行和第<code>15</code>行，对静态成员变量在类外部加以声明是必需的。在<code>Visual Studio 2008</code> 中，这两行也可以简单地写成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A&lt;<span class="keyword">int</span>&gt;::count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> A&lt;<span class="keyword">double</span>&gt;::count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>​    <code>A&lt;int&gt;</code>和<code>A&lt;double&gt;</code>是两个不同的类。虽然它们都有静态成员变量<code>count</code>，但是显然，<code>A&lt;int&gt;</code>的对象<code>ia</code>和<code>A&lt;double&gt;</code> 的对象 <code>da</code>不会共享一份<code>count</code>。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++函数模板</title>
      <link href="/2018/08/10/c++%E6%A8%A1%E6%9D%BF2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2018/08/10/c++%E6%A8%A1%E6%9D%BF2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="函数模板的重载"><a href="#函数模板的重载" class="headerlink" title="函数模板的重载"></a>函数模板的重载</h3><p>​    当需要对不同的类型使用同一种算法（同一个函数体）时，为了避免定义多个功能重复的函数，可以使用模板。然而，并非所有的类型都使用同一种算法，有些特定的类型需要单独处理，为了满足这种需求，<strong><code>C++</code>允许对函数模板进行重载</strong>，程序员可以像重载常规函数那样重载模板定义。</p><a id="more"></a><p>​    前面我们定义了<code>Swap()</code>函数用来交换两个变量的值，一种方案是使用指针，另外一种方案是使用引用，请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方案①：使用指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T *a, T *b)</span></span>&#123;</span><br><span class="line">    T temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方案②：使用引用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Swap</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> &amp;<span class="title">b</span>)&#123;</span></span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这两种方案都可以交换<code>int</code>、<code>float</code>、<code>char</code>、<code>bool</code>等基本类型变量的值，但是却不能交换两个数组。</p><pre><code>对于方案`①`，调用函数时传入的是数组指针，或者说是指向第` 0  `个元素的指针，这样交换的仅仅是数组的第` 0 `个元素，而不是整个数组。数组和指针本来是不等价的，只是当函数的形参为指针时，传递的数组也会隐式地转换为指针。</code></pre><p>​    对于方案<code>②</code>，假设传入的是一个长度为<code>5</code>的<code>int</code>类型数组（该数组的类型是<code>int [5]</code>），那么<code>T</code>的真实类型为<code>int [5]</code>，<code>T temp</code>会被替换为<code>int [5] temp</code>，这显然是错误的。另外一方面，语句<code>a=b;</code>尝试对数组<code>a</code>赋值，而数组名是常量，它的值不允许被修改，所以也会产生错误。总起来说，方案<code>②</code>会有两处语法错误。</p><p>​    交换两个数组唯一的办法就是逐个交换所有的数组元素，请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T a[], T b[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">        b[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在该函数模板中，最后一个参数的类型为具体类型（<code>int</code>），而不是泛型。并不是所有的模板参数都必须被泛型化。</p><p>​    下面是一个重载函数模板的完整示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Swap</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> &amp;<span class="title">b</span>);</span>  <span class="comment">//模板①：交换基本类型的值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T a[], T b[], <span class="keyword">int</span> len)</span></span>;  <span class="comment">//模板②：交换两个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>;  <span class="comment">//打印数组元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//交换基本类型的值</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">10</span>, n = <span class="number">99</span>;</span><br><span class="line">    Swap(m, n);  <span class="comment">//匹配模板①</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="string">", "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两个数组</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">5</span>] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);  <span class="comment">//数组长度</span></span><br><span class="line">    Swap(a, b, len);  <span class="comment">//匹配模板②</span></span><br><span class="line">    printArray(a, len);</span><br><span class="line">    printArray(b, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Swap</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> &amp;<span class="title">b</span>)&#123;</span></span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T a[], T b[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">        b[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>99, 10</code><br><code>10, 20, 30, 40, 50</code><br><code>1, 2, 3, 4, 5</code></p><h3 id="函数模板的实参推断"><a href="#函数模板的实参推断" class="headerlink" title="函数模板的实参推断"></a>函数模板的实参推断</h3><p>​    在使用类模板创建对象时，程序员需要显式的指明实参（也就是具体的类型）。例如对于下面的<code>Point</code>类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="class"><span class="keyword">class</span> <span class="title">Point</span>;</span></span><br></pre></td></tr></table></figure><p>​    我们可以在栈上创建对象，也可以在堆上创建对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p1(<span class="number">10</span>, <span class="number">20</span>);  <span class="comment">//在栈上创建对象</span></span><br><span class="line">Point&lt;<span class="keyword">char</span>*, <span class="keyword">char</span>*&gt; *p = <span class="keyword">new</span> Point&lt;<span class="keyword">char</span>*, <span class="keyword">char</span>*&gt;(<span class="string">"东京180度"</span>, <span class="string">"北纬210度"</span>);  <span class="comment">//在堆上创建对象</span></span><br></pre></td></tr></table></figure><p>​    因为已经显式地指明了<code>T1</code>、<code>T2</code>的具体类型，所以编译器就不用再自己推断了，直接拿来使用即可。</p><p>​    而对于函数模板，调用函数时可以不显式地指明实参（也就是具体的类型）。请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用</span></span><br><span class="line"><span class="keyword">int</span> n1 = <span class="number">100</span>, n2 = <span class="number">200</span>;</span><br><span class="line">Swap(n1, n2);</span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">12.5</span>, f2 = <span class="number">56.93</span>;</span><br><span class="line">Swap(f1, f2);</span><br></pre></td></tr></table></figure><p>​    虽然没有显式地指明<code>T</code>的具体类型，但是编译器会根据<code>n1</code>和<code>n2</code>、<code>f1</code>和<code>f2</code>的类型自动推断出<code>T</code>的类型。<strong>这种通过函数实参来确定模板实参（也就是类型参数的具体类型）的过程称为模板实参推断。</strong></p><p>​    在模板实参推断过程中，编译器使用函数调用中的实参类型来寻找类型参数的具体类型。</p><h4 id="模板实参推断过程中的类型转换"><a href="#模板实参推断过程中的类型转换" class="headerlink" title="模板实参推断过程中的类型转换"></a>模板实参推断过程中的类型转换</h4><h5 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h5><p>​    对于普通函数（非模板函数），发生函数调用时会对实参的类型进行适当的转换，以适应形参的类型。这些转换包括：</p><ul><li>算数转换：例如<code>int</code>转换为<code>float</code>，<code>char</code>转换为<code>int</code>，<code>double</code>转换为<code>int</code>等。</li><li>派生类向基类的转换：也就是向上转型。</li><li><code>const</code>转换：也即将非<code>const</code>类型转换为<code>const</code>类型，例如将<code>char *</code>转换为<code>const char *</code>。</li><li>数组或函数指针转换：如果函数形参不是引用类型，那么数组名会转换为数组指针，函数名也会转换为函数指针。</li><li>用户自定的类型转换。</li></ul><p> 例如有下面两个函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">float</span> f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br></pre></td></tr></table></figure><p>​    它们具体的调用形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> *url = <span class="string">"http://c.biancheng.net"</span>;</span><br><span class="line">func1(<span class="number">12.5</span>, <span class="number">45</span>);</span><br><span class="line">func2(nums, url);</span><br></pre></td></tr></table></figure><p>​    对于<code>func1()</code>，<code>12.5</code>会从<code>double</code>转换为<code>int</code>，45 会从<code>int</code>转换为<code>float</code>；对于<code>func2()</code>，<code>nums</code>会从<code>int [5]</code>转换为<code>int *</code>，<code>url</code>会从<code>char *</code>转换为<code>const char *</code>。</p><h5 id="函数模板-1"><a href="#函数模板-1" class="headerlink" title="函数模板"></a>函数模板</h5><p>​    <strong>对于函数模板，类型转换则受到了更多的限制，仅能进行「<code>const</code>转换」和「数组或函数指针转换」，其他的都不能应用于函数模板。</strong>例如有下面几个函数模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(T a, T b)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(T *buffer)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">const</span> T &amp;stu)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">(T a)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">func5</span><span class="params">(T &amp;a)</span></span>;</span><br></pre></td></tr></table></figure><p>​    它们具体的调用形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">"张华"</span>, <span class="number">20</span>, <span class="number">96.5</span>)</span></span>;  <span class="comment">//创建一个Student类型的对象</span></span><br><span class="line"></span><br><span class="line">func1(<span class="number">12.5</span>, <span class="number">30</span>);  <span class="comment">//Error</span></span><br><span class="line">func2(name);  <span class="comment">//name的类型从 int [20] 换转换为 int *，所以 T 的真实类型为 int</span></span><br><span class="line">func3(stu1);  <span class="comment">//非const转换为const，T 的真实类型为 Student</span></span><br><span class="line">func4(name);  <span class="comment">//name的类型从 int [20] 换转换为 int *，所以 T 的真实类型为 int *</span></span><br><span class="line">func5(name);  <span class="comment">//name的类型依然为 int [20]，不会转换为 int *，所以 T 的真实类型为 int [20]</span></span><br></pre></td></tr></table></figure><p>​    对于<code>func1(12.5, 30)</code>，<code>12.5</code>的类型为<code>double</code>，<code>30</code>的类型为<code>int</code>，编译器不知道该将<code>T</code> 实例化为 <code>double</code>还是<code>int</code>，也不会尝试将<code>int</code>转换为<code>double</code>，或者将<code>double</code>转换为<code>int</code>，所以调用失败。</p><p> 请读者注意<code>name</code>，它本来的类型是<code>int [20]</code>：</p><ul><li>对于<code>func2(name)</code>和<code>func4(name)</code>，<code>name</code>的类型会从<code>int [20]</code>转换为<code>int *</code>，也即将数组转换为指针，所以 <code>T</code>的类型分别为<code>int *</code> 和<code>int</code>。</li><li>对于<code>func5(name)</code>，<code>name</code>的类型依然为<code>int [20]</code>，不会转换为<code>int *</code>，所以<code>T</code>的类型为<code>int [20]</code>。</li></ul><p>可以发现，<strong>当函数形参是引用类型时，数组不会转换为指针。</strong>这个时候读者要注意下面这样的函数模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T &amp;a, T &amp;b)</span></span>;</span><br></pre></td></tr></table></figure><p>​    如果它的具体调用形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> str1[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> str2[<span class="number">10</span>];</span><br><span class="line">func(str1, str2);</span><br></pre></td></tr></table></figure><p>​    由于<code>str1</code>、<code>str2</code>的类型分别为<code>int [20]</code>和<code>int [10]</code>，在函数调用过程中又不会转换为指针，所以编译器不知道应该将<code>T</code>实例化为<code>int [20]</code>还是<code>int [10]</code>，导致调用失败。</p><h4 id="为函数模板显式地指明实参（也就是具体的类型）"><a href="#为函数模板显式地指明实参（也就是具体的类型）" class="headerlink" title="为函数模板显式地指明实参（也就是具体的类型）"></a>为函数模板显式地指明实参（也就是具体的类型）</h4><p>​    函数模板的实参推断是指「在函数调用过程中根据实参的类型来寻找类型参数的具体类型」的过程，这在大部分情况下是奏效的，但是<strong>当类型参数的个数较多时，就会有个别的类型无法推断出来，这个时候就必须显式地指明实参。</strong></p><p>​    下面是一个实参推断失败的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T1 a)</span></span>&#123;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">10</span>);  <span class="comment">//函数调用</span></span><br></pre></td></tr></table></figure><p>​    <code>func()</code>有两个类型参数，分别是<code>T1</code>和<code>T2</code>，但是编译器只能从函数调用中推断出<code>T1</code>的类型来，不能推断出<code>T2</code>的类型来，所以这种调用是失败的，这个时候就必须显式地指明<code>T1</code>、<code>T2</code>的具体类型。</p><p>​    「为函数模板显式地指明实参」和「为类模板显式地指明实参」的形式是类似的，就是在函数名后面添加尖括号<code>&lt; &gt;</code>，里面包含具体的类型。例如对于上面的<code>func()</code>，我们要这样来指明实参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>​    显式指明的模板实参会按照从左到右的顺序与对应的模板参数匹配：第一个实参与第一个模板参数匹配，第二个实参与第二个模板参数匹配，以此类推。只有尾部（最右）的类型参数的实参可以省略，而且前提是它们可以从传递给函数的实参中推断出来。</p><p>​    对于上面的<code>func()</code>，虽然只有<code>T2</code>的类型不能自动推断出来，但是由于它位于类型参数列表的尾部（最右），所以必须同时指明<code>T1</code>和<code>T2</code>的类型。对代码稍微做出修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T2 a)</span></span>&#123;</span><br><span class="line">    T1 b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用</span></span><br><span class="line">func&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);  <span class="comment">//省略 T2 的类型</span></span><br><span class="line">func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">20</span>);  <span class="comment">//指明 T1、T2 的类型</span></span><br></pre></td></tr></table></figure><p>​    由于<code>T2</code>的类型能够自动推断出来，并且它位于参数列表的尾部（最右），所以可以省略。</p><h4 id="显式地指明实参时可以应用正常的类型转换"><a href="#显式地指明实参时可以应用正常的类型转换" class="headerlink" title="显式地指明实参时可以应用正常的类型转换"></a>显式地指明实参时可以应用正常的类型转换</h4><p>​    上面我们提到，函数模板仅能进行「<code>const</code>转换」和「数组或函数指针转换」两种形式的类型转换，但是<strong>当我们显式地指明类型参数的实参（具体类型）时，就可以使用正常的类型转换（非模板函数可以使用的类型转换）了。</strong></p><p>​    例如对于下面的函数模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T a, T b)</span></span>;</span><br></pre></td></tr></table></figure><p>​    它的具体调用形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="number">10</span>, <span class="number">23.5</span>);  <span class="comment">//Error</span></span><br><span class="line">func&lt;<span class="keyword">float</span>&gt;(<span class="number">20</span>, <span class="number">93.7</span>);  <span class="comment">//Correct</span></span><br></pre></td></tr></table></figure><p>​    在第二种调用形式中，我们已经显式地指明了<code>T</code>的类型为<code>float</code>，编译器不会再为「<code>T</code>的类型到底是<code>int</code>还是<code>double</code>」而纠结了，所以可以从容地使用正常的类型转换了。</p><h3 id="函数模板的显式具体化"><a href="#函数模板的显式具体化" class="headerlink" title="函数模板的显式具体化"></a>函数模板的显式具体化</h3><p>​    下面的函数模板，它用来获取两个变量中较大的一个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">Max</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">b</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    请读者注意<code>a &gt; b</code>这条语句，<code>&gt;</code>能够用来比较 <code>int</code>、<code>float</code>、<code>char</code>等基本类型数据的大小，但是却不能用来比较结构体变量、对象以及数组的大小，因为我们并没有针对结构体、类和数组重载<code>&gt;</code>。另外，该函数模板虽然可以用于指针，但比较的是地址大小，而不是指针指向的数据，所以也没有现实的意义。</p><p>​    模板是一种泛型技术，它能接受的类型是宽泛的、没有限制的，并且对这些类型使用的算法都是一样的（函数体或类体一样）。但是现在我们希望改变这种“游戏规则”，让模板能够针对某种具体的类型使用不同的算法（函数体或类体不同），这在<code>C++</code>中是可以做到的，这种技术称为模板的<strong>显示具体化（<code>Explicit Specialization</code>）</strong>。</p><p>​    函数模板和类模板都可以显示具体化。</p><p>在讲解函数模板的显示具体化语法之前，我们先来看一个显示具体化的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125; STU;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">Max</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">b</span>);</span></span><br><span class="line"><span class="comment">//函数模板的显示具体化（针对STU类型的显示具体化）</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">const</span> STU&amp; Max&lt;STU&gt;(<span class="keyword">const</span> STU&amp; a, <span class="keyword">const</span> STU&amp; b);</span><br><span class="line"><span class="comment">//重载&lt;&lt;</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> STU &amp;stu);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Max(a, b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    STU stu1 = &#123; <span class="string">"王明"</span>, <span class="number">16</span>, <span class="number">95.5</span>&#125;;</span><br><span class="line">    STU stu2 = &#123; <span class="string">"徐亮"</span>, <span class="number">17</span>, <span class="number">90.0</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Max(stu1, stu2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">Max</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">b</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">const</span> STU&amp; Max&lt;STU&gt;(<span class="keyword">const</span> STU&amp; a, <span class="keyword">const</span> STU&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.score &gt; b.score ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> STU &amp;stu)&#123;</span><br><span class="line">    out&lt;&lt;stu.name&lt;&lt;<span class="string">" , "</span>&lt;&lt;stu.age &lt;&lt;<span class="string">" , "</span>&lt;&lt;stu.score;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>20</code><br><code>王明 , 16 , 95.5</code></p><p> 本例中，<code>STU</code>结构体用来表示一名学生(<code>Student</code>)，它有三个成员，分别是姓名(<code>name</code>)、年龄(<code>age</code>)、成绩(<code>score</code>)；<code>Max()</code>函数用来获取两份数据中较大的一份。</p><p>​    要想获取两份数据中较大的一份，必然会涉及到对两份数据的比较。对于<code>int</code>、<code>float</code>、<code>char</code>等基本类型的数据，直接比较它们本身的值即可，而对于<code>STU</code> 类型的数据，直接比较它们本身的值不但会有语法错误，而且毫无意义，这就要求我们设计一套不同的比较方案，从语法和逻辑上都能行得通，所以本例中我们比较的是两名学生的成绩（<code>score</code>）。</p><p>​    不同的比较方案最终导致了算法（函数体）的不同，我们不得不借助模板的显示具体化技术对<code>STU</code>类型进行单独处理。第<code>14</code>行代码就是显示具体化的声明，第<code>34</code>行代码进行了定义。</p><p>​    请读者注意第<code>34</code>行代码，<code>Max</code>中的<code>STU</code>表明了要将类型参数<code>T</code>具体化为<code>STU</code>类型，原来使用<code>T</code>的位置都应该使用<code>STU</code>替换，包括返回值类型、形参类型、局部变量的类型。</p><p>​    <code>Max</code>只有一个类型参数<code>T</code>，并且已经被具体化为<code>STU</code>了，这样<strong>整个模板就不再有类型参数了，类型参数列表也就为空了，所以模板头应该写作<code>template&lt;&gt;</code>。</strong></p><p>​    另外，<code>Max</code>中的<code>STU</code>是可选的，因为函数的形参已经表明，这是<code>STU</code>类型的一个具体化，编译器能够逆推出<code>T</code>的具体类型。简写后的函数声明为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">const</span> STU&amp; <span class="title">Max</span><span class="params">(<span class="keyword">const</span> STU&amp; a, <span class="keyword">const</span> STU&amp; b)</span></span>;</span><br></pre></td></tr></table></figure></p><h4 id="函数的调用规则"><a href="#函数的调用规则" class="headerlink" title="函数的调用规则"></a>函数的调用规则</h4><p>​    回顾一下前面学习到的知识，在<code>C++</code>中，对于给定的函数名，可以有非模板函数、模板函数、显示具体化模板函数以及它们的重载版本，在调用函数时，显示具体化优先于常规模板，而非模板函数优先于显示具体化和常规模板。</p><h3 id="函数模板中使用非类型参数"><a href="#函数模板中使用非类型参数" class="headerlink" title="函数模板中使用非类型参数"></a>函数模板中使用非类型参数</h3><p>​    <strong>模板是一种泛型技术，目的是将数据的类型参数化，以增强<code>C++</code>语言（强类型语言）的灵活性。<code>C++</code>对模板的支持非常自由，模板中除了可以包含类型参数，还可以包含非类型参数，</strong>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt; <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span> &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">N</span>&gt; <span class="title">void</span> <span class="title">func</span>(<span class="title">T</span> (&amp;<span class="title">arr</span>)[<span class="title">N</span>]);</span></span><br></pre></td></tr></table></figure><p>​    <code>T</code>是一个类型参数，它通过<code>class</code>或<code>typename</code>关键字指定。<code>N</code>是一个非类型参数，用来传递数据的值，而不是类型，它和普通函数的形参一样，都需要指明具体的类型。类型参数和非类型参数都可以用在函数体或者类体中。</p><p>​    当调用一个函数模板或者通过一个类模板创建对象时，非类型参数会被用户提供的、或者编译器推断出的值所取代。</p><p>​    之前我们通过<code>Swap()</code>函数来交换两个数组的值，其原型为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T a[], T b[], <span class="keyword">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure></p><p>​    形参<code>len</code>用来指明要交换的数组的长度，调用<code>Swap()</code>函数之前必须先通过<code>sizeof</code>求得数组长度再传递给它。</p><p>​    有读者可能会疑惑，为什么在函数内部不能求得数组长度，一定要通过形参把数组长度传递进去呢？这是因为数组在作为函数参数时会自动转换为数组指针，而<code>sizeof</code>只能通过数组名求得数组长度，不能通过数组指针求得数组长度。</p><p>​    多出来的形参<code>len</code>给编码带来了不便，我们可以借助模板中的非类型参数将它消除，请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">unsigned</span> N&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T (&amp;a)[N], T (&amp;b)[N])</span></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">        b[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>T (&amp;a)[N]</code>表明<code>a</code>是一个引用，它引用的数据的类型是<code>T [N]</code>，也即一个数组；<code>T (&amp;b)[N]</code>也是类似的道理。分析一个引用和分析一个指针的方法类似，编译器总是从它的名字开始读取，然后按照优先级顺序依次解析。</p><p>​    调用<code>Swap()</code>函数时，需要将数组名字传递给它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">5</span>] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line">Swap(a, b);</span><br></pre></td></tr></table></figure><p>​    编译器会使用数组类型<code>int</code>来代替类型参数<code>T</code>，使用数组长度<code>5</code>来代替非类型参数<code>N</code>。</p><p>​    下面是一个完整的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Swap</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> &amp;<span class="title">b</span>);</span>  <span class="comment">//模板①：交换基本类型的值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">unsigned</span> N&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T (&amp;a)[N], T (&amp;b)[N])</span></span>;  <span class="comment">//模板②：交换两个数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">unsigned</span> N&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T (&amp;arr)[N])</span></span>;  <span class="comment">//打印数组元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//交换基本类型的值</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">10</span>, n = <span class="number">99</span>;</span><br><span class="line">    Swap(m, n);  <span class="comment">//匹配模板①</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="string">", "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两个数组</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">5</span>] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line">    Swap(a, b);  <span class="comment">//匹配模板②</span></span><br><span class="line">    printArray(a);</span><br><span class="line">    printArray(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Swap</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> &amp;<span class="title">b</span>)&#123;</span></span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">unsigned</span> N&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T (&amp;a)[N], T (&amp;b)[N])</span></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">        b[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">unsigned</span> N&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T (&amp;arr)[N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == N<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>99, 10</code><br><code>10, 20, 30, 40, 50</code><br><code>1, 2, 3, 4, 5</code></p><p>​    <code>printArray()</code>也使用了非类型参数，这样只传递数组名字就能够打印数组元素了。</p><h4 id="非类型参数的限制"><a href="#非类型参数的限制" class="headerlink" title="非类型参数的限制"></a>非类型参数的限制</h4><p>​    非类型参数的类型不能随意指定，它受到了严格的限制，只能是一个整数，或者是一个指向对象或函数的指针（也可以是引用）。</p><p>​    1) 当非类型参数是一个整数时，传递给它的实参，或者由编译器推导出的实参必须是一个常量表达式，例如<code>10</code>、<code>2 * 30</code>、<code>18 + 23 - 4</code>等，但不能是<code>n</code>、<code>n + 10</code>、<code>n + m</code>等（<code>n</code>和<code>m</code>都是变量）。</p><p> 对于上面的<code>Swap()</code>函数，下面的调用就是错误的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;len;</span><br><span class="line"><span class="keyword">int</span> a[len];</span><br><span class="line"><span class="keyword">int</span> b[len];</span><br><span class="line">Swap(a, b);</span><br></pre></td></tr></table></figure><p>这种情况，编译器推导出来的实参是<code>len</code>，是一个变量，而不是常量。</p><p> 2) 当非类型参数是一个指针（引用）时，绑定到该指针的实参必须具有静态的生存期；换句话说，实参必须存储在虚拟地址空间中的静态数据区。局部变量位于栈区，动态创建的对象位于堆区，它们都不能用作实参。</p><h3 id="函数模板实例化"><a href="#函数模板实例化" class="headerlink" title="函数模板实例化"></a>函数模板实例化</h3><p>​    <strong>模板（<code>Templet</code>）并不是真正的函数或类，它仅仅是编译器用来生成函数或类的一张“图纸”。模板不会占用内存，最终生成的函数或者类才会占用内存。由模板生成函数或类的过程叫做模板的实例化（<code>Instantiate</code>），相应地，针对某个类型生成的特定版本的函数或类叫做模板的一个实例（<code>Instantiation</code>）。</strong></p><p>​    模板也可以看做是编译器的一组指令，它命令编译器生成我们想要的代码。</p><p>​    <strong>模板的实例化是按需进行的，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码。也就是说，编译器会根据传递给类型参数的实参（也可以是编译器自己推演出来的实参）来生成一个特定版本的函数或类，并且相同的类型只生成一次。实例化的过程也很简单，就是将所有的类型参数用实参代替。</strong></p><p>​    例如，给定下面的函数模板和函数调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">100</span>, n2 = <span class="number">200</span>, n3 = <span class="number">300</span>, n4 = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">float</span> f1 = <span class="number">12.5</span>, f2 = <span class="number">56.93</span>;</span><br><span class="line">   </span><br><span class="line">    Swap(n1, n2);  <span class="comment">//T为int，实例化出 void Swap(int &amp;a, int &amp;b);</span></span><br><span class="line">    Swap(f1, f2);  <span class="comment">//T为float，实例化出 void Swap(float &amp;a, float &amp;b);</span></span><br><span class="line">    Swap(n3, n4);  <span class="comment">//T为int，调用刚才生成的 void Swap(int &amp;a, int &amp;b);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    编译器会根据不同的实参实例化出不同版本的<code>Swap()</code>函数。对于<code>Swap(n1, n2)</code>调用，编译器会生成并编译一个<code>Swap()</code>版本，其中<code>T</code>被替换为<code>int</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    对于<code>Swap(f1, f2)</code>调用，编译器会生成另一个<code>Swap()</code>版本，其中<code>T</code>被替换为<code>float</code>。对于<code>Swap(n3, n4)</code>调用，编译器不会再生成新版本的 <code>Swap()</code>了，因为刚才已经针对<code>int</code>生成了一个版本，直接拿来使用即可。</p><h3 id="将函数模板的声明和定义分散到不同的文件"><a href="#将函数模板的声明和定义分散到不同的文件" class="headerlink" title="将函数模板的声明和定义分散到不同的文件"></a>将函数模板的声明和定义分散到不同的文件</h3><p>​    <strong>总起来说，不管是函数还是类，声明和定义（实现）的分离其实是一回事，都是将函数定义放到其他文件中，最终要解决的问题也只有一个，就是把函数调用和函数定义对应起来（找到函数定义的地址，并填充到函数调用处），而保证完成这项工作的就是链接器。</strong></p><p>​    基于传统的编程思维，初学者往往也会将模板（函数模板和类模板）的声明和定义分散到不同的文件中，以期达到「模块化编程」的目的。但事实证明这种做法是不对的，<strong>程序员惯用的做法是将模板的声明和定义都放到头文件中。</strong></p><p>​    模板并不是真正的函数或类，它仅仅是用来生成函数或类的一张“图纸”，在这个生成过程中有三点需要明确：</p><ul><li>模板的实例化是按需进行的，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码；</li><li>模板的实例化是由编译器完成的，而不是由链接器完成的；</li><li>在实例化过程中需要知道模板的所有细节，包含声明和定义。</li></ul><p>为了更加深入地说明问题，现在有一个反面教材，它将函数模板的声明和实现分别放到了头文件和源文件。</p><p>​    <code>func.cpp</code>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换两个数的值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> isSorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n<span class="number">-1</span>-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                isSorted = <span class="literal">false</span>;</span><br><span class="line">                Swap(arr[j], arr[j+<span class="number">1</span>]);  <span class="comment">//调用Swap()函数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSorted) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>func.h</code>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _FUNC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _FUNC_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​    <code>main.cpp</code>源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"func.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">10</span>, n2 = <span class="number">20</span>;</span><br><span class="line">    Swap(n1, n2);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">double</span> f1 = <span class="number">23.8</span>, f2 = <span class="number">92.6</span>;</span><br><span class="line">    Swap(f1, f2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    该工程包含了两个源文件和一个头文件，<code>func.cpp</code>中定义了两个函数，<code>func.h</code>中对函数进行了声明，<code>main.cpp</code>中对函数进行了调用，这是典型的将函数的声明和实现分离的编程模式。</p><p>​    运行上面的程序，会产生一个链接错误，意思是无法找到<code>void Swap(double &amp;, double &amp;)</code>这个函数。主函数<code>main()</code>中共调用了两个版本的<code>Swap()</code>函数，它们的原型分别是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Swap&lt;<span class="keyword">double</span>&gt;(<span class="keyword">int</span> &amp;, <span class="keyword">int</span> &amp;);</span><br><span class="line"> <span class="keyword">void</span> Swap&lt;<span class="keyword">double</span>&gt;(<span class="keyword">double</span> &amp;, <span class="keyword">double</span> &amp;);</span><br></pre></td></tr></table></figure></p><p>​    为什么针对<code>int</code>的版本能够找到定义，而针对<code>double</code>的版本就找不到呢？</p><p>​    我们先来说针对<code>double</code>的版本为什么找不到定义。当编译器编译<code>main.cpp</code>时，发现使用到了<code>double</code>版本的<code>Swap()</code>函数，于是尝试生成一个<code>double</code>版本的实例，但是由于只有声明没有定义，所以生成失败。不过这个时候编译器不会报错，而是对该函数的调用做一个记录，希望等到链接程序时在其他目标文件（<code>.obj</code>文件或<code>.o</code>文件）中找到该函数的定义。很明显，本例需要到<code>func.obj</code>中寻找。但是遗憾的是，<code>func.cpp</code>中没有调用<code>double</code> 版本的<code>Swap()</code>函数，编译器不会生成<code>double</code>版本的实例，所以链接器最终也找不到<code>double</code>版本的函数定义，只能抛出一个链接错误，让程序员修改代码。</p><p>​    那么，针对<code>int</code>的版本为什么能够找到定义呢？请读者注意<code>bubble_sort()</code>函数，该函数用来对数组元素进行排序，在排序过程中需要频繁的交换两个元素的值，所以调用了<code>Swap()</code>函数，这样做的结果是：编译生成的<code>func.obj</code>中会有一个<code>int</code>版本的<code>Swap()</code>函数定义。编译器在编译<code>main.cpp</code>时虽然找不到<code>int</code>版本的实例，但是等到链接程序时，链接器在<code>func.obj</code>中找到了，所以针对<code>int</code>版本的调用就不会出错。</p><h3 id="函数模板的显式实例化"><a href="#函数模板的显式实例化" class="headerlink" title="函数模板的显式实例化"></a>函数模板的显式实例化</h3><p>​    前面讲到的模板的实例化是在调用函数或者创建对象时由编译器自动完成的，不需要程序员引导，因此称为<strong>隐式实例化</strong>。相对应的，我们也可以通过代码明确地告诉编译器需要针对哪个类型进行实例化，这称为<strong>显式实例化</strong>。</p><p>​    编译器在实例化的过程中需要知道模板的所有细节：对于函数模板，也就是函数定义；对于类模板，需要同时知道类声明和类定义。我们必须将显式实例化的代码放在包含了模板定义的源文件中，而不是仅仅包含了模板声明的头文件中。</p><p>​    <strong>显式实例化的一个好处是，可以将模板的声明和定义（实现）分散到不同的文件中了。</strong></p><p>​    以上节讲到的<code>compare()</code>函数为例，针对<code>double</code>类型的显式实例化代码为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">double</span> &amp;a, <span class="keyword">double</span> &amp;b)</span></span>;</span><br></pre></td></tr></table></figure></p><p>​    这条语言由两部分组成，前边是一个<code>template</code>关键字（后面不带<code>&lt; &gt;</code>），后面是一个普通的函数原型，组合在一起的意思是：<strong>将模板实例化成和函数原型对应的一个具体版本。</strong></p><p> 将该代码放到<code>func.cpp</code>文件的最后，再运行程序就不会出错了。</p><p> 另外，还可以在包含了函数调用的源文件（<code>main.cpp</code>）中再增加下面的一条语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">double</span> &amp;a, <span class="keyword">double</span> &amp;b)</span></span>;</span><br></pre></td></tr></table></figure></p><p>​    该语句在前面增加了<code>extern</code>关键字，它的作用是明确地告诉编译器，该版本的函数实例在其他文件中，请在链接期间查找。不过这条语句是多余的，即使不写，编译器发现当前文件中没有对应的模板定义，也会自动去其他文件中查找。</p><pre><code>上节我们展示了一个反面教材，告诉大家不能把函数模板的声明和定义分散到不同的文件中，但是现在有了显式实例化，这一点就可以做到了，下面就对上节的代码进行修复。</code></pre><p><code>func.cpp</code>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换两个数的值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> isSorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n<span class="number">-1</span>-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                isSorted = <span class="literal">false</span>;</span><br><span class="line">                Swap(arr[j], arr[j+<span class="number">1</span>]);  <span class="comment">//调用Swap()函数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSorted) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">double</span> &amp;a, <span class="keyword">double</span> &amp;b)</span></span>;  <span class="comment">//显式实例化定义</span></span><br></pre></td></tr></table></figure><p><code>func.h</code>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _FUNC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _FUNC_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"func.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示实例化声明（也可以不写）</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">double</span> &amp;a, <span class="keyword">double</span> &amp;b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">10</span>, n2 = <span class="number">20</span>;</span><br><span class="line">    Swap(n1, n2);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">double</span> f1 = <span class="number">23.8</span>, f2 = <span class="number">92.6</span>;</span><br><span class="line">    Swap(f1, f2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    显式实例化也包括声明和定义，定义要放在模板定义（实现）所在的源文件，声明要放在模板声明所在的头文件（当然也可以不写）。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    函数模板和类模板的实例化语法是类似的，我们不妨对它们做一下总结：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;  <span class="comment">//实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;  <span class="comment">//实例化定义</span></span><br></pre></td></tr></table></figure></p><p>​    对于函数模板来说，<code>declaration</code>就是一个函数原型；对于类模板来说，<code>declaration</code>就是一个类声明。</p><h4 id="显式实例化的缺陷"><a href="#显式实例化的缺陷" class="headerlink" title="显式实例化的缺陷"></a>显式实例化的缺陷</h4><p>​    <code>C++</code>支持显式实例化的目的是为「模块化编程」提供一种解决方案，这种方案虽然有效，但是也有明显的缺陷：程序员必须要在模板的定义文件（实现文件）中对所有使用到的类型进行实例化。这就意味着，每次更改了模板使用文件（调用函数模板的文件，或者通过类模板创建对象的文件），也要相应地更改模板定义文件，以增加对新类型的实例化，或者删除无用类型的实例化。</p><p>​     一个模板可能会在多个文件中使用到，要保持这些文件的同步更新是非常困难的。而对于库的开发者来说，他不能提前假设用户会使用哪些类型，所以根本就无法使用显式实例化，只能将模板的声明和定义（实现）全部放到头文件中；<code>C++</code>标准库几乎都是用模板来实现的，这些模板的代码也都位于头文件中。</p><p>​    总起来说，如果我们开发的模板只有我们自己使用，那也可以勉强使用显式实例化；如果希望让其他人使用（例如库、组件等），那只能将模板的声明和定义都放到头文件中了。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++模板定义</title>
      <link href="/2018/08/07/c++%E6%A8%A1%E6%9D%BF1-%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89/"/>
      <url>/2018/08/07/c++%E6%A8%A1%E6%9D%BF1-%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>为了交换不同类型的变量的值，我们通过函数重载定义了四个名字相同、参数列表不同的函数，如下所示：</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换 int 变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换 float 变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">float</span> *a, <span class="keyword">float</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换 char 变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换 bool 变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">bool</span> *a, <span class="keyword">bool</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些函数虽然在调用时方便了一些，但从本质上说还是定义了三个功能相同、函数体相同的函数，只是数据的类型不同而已，我们可以借助本节讲的函数模板把它们压缩成一个函数。</p><p>​    我们知道，数据的值可以通过函数参数传递，在函数定义时数据的值是未知的，只有等到函数调用时接收了实参才能确定其值。这就是值的参数化。</p><h2 id="模板的定义"><a href="#模板的定义" class="headerlink" title="模板的定义"></a>模板的定义</h2><p>​    在<code>C++</code>中，数据的类型也可以通过参数来传递，在函数定义时可以不指明具体的数据类型，当发生函数调用时，编译器可以根据传入的实参自动推断数据类型。这就是类型的参数化。</p><p>​    值（<code>Value</code>）和类型（<code>Type</code>）是数据的两个主要特征，它们在<code>C++</code>中都可以被参数化。</p><h3 id="函数模板定义"><a href="#函数模板定义" class="headerlink" title="函数模板定义"></a>函数模板定义</h3><p>​    所谓函数模板，实际上是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个虚拟的类型来代替（实际上是用一个标识符来占位），等发生函数调用时再根据传入的实参来逆推出真正的类型。这个通用函数就称为<strong>函数模板（<code>Function Template</code>）</strong>。</p><p>​    定义模板函数的语法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span> , <span class="keyword">typename</span> 类型参数<span class="number">2</span> , ...&gt; 返回值类型  函数名(形参列表)&#123;</span><br><span class="line">   <span class="comment">//在函数体中可以使用类型参数</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>​    类型参数可以有多个，它们之间以逗号<code>,</code>分隔。类型参数列表以<code>&lt;&gt;</code>包围，形式参数列表以<code>()</code>包围。<code>typename</code>关键字也可以使用<code>class</code>关键字替代，它们没有任何区别。</p><p>​    在函数模板中，数据的值和类型都被参数化了，发生函数调用时编译器会根据传入的实参来推演形参的值和类型。换个角度说，函数模板除了支持值的参数化，还支持类型的参数化。</p><p>​    一但定义了函数模板，就可以将类型参数用于函数定义和函数声明了。说得直白一点，原来使用<code>int</code>、<code>float</code>、<code>char</code>等内置类型的地方，都可以用类型参数来代替。</p><p>​    下面我们就来实践一下，将上面的四个<code>Swap()</code>函数压缩为一个函数模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T *a, T *b)</span></span>&#123;</span><br><span class="line">    T temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;typename T&gt; void Swap(T &amp;a, T &amp;b)&#123;</span></span><br><span class="line"><span class="comment">    T temp = a;</span></span><br><span class="line"><span class="comment">    a = b;</span></span><br><span class="line"><span class="comment">    b = temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//交换 int 变量的值</span></span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">100</span>, n2 = <span class="number">200</span>;</span><br><span class="line">    Swap(&amp;n1, &amp;n2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n1&lt;&lt;<span class="string">", "</span>&lt;&lt;n2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//交换 float 变量的值</span></span><br><span class="line">    <span class="keyword">float</span> f1 = <span class="number">12.5</span>, f2 = <span class="number">56.93</span>;</span><br><span class="line">    Swap(&amp;f1, &amp;f2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f1&lt;&lt;<span class="string">", "</span>&lt;&lt;f2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//交换 char 变量的值</span></span><br><span class="line">    <span class="keyword">char</span> c1 = <span class="string">'A'</span>, c2 = <span class="string">'B'</span>;</span><br><span class="line">    Swap(&amp;c1, &amp;c2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="string">", "</span>&lt;&lt;c2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//交换 bool 变量的值</span></span><br><span class="line">    <span class="keyword">bool</span> b1 = <span class="literal">false</span>, b2 = <span class="literal">true</span>;</span><br><span class="line">    Swap(&amp;b1, &amp;b2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b1&lt;&lt;<span class="string">", "</span>&lt;&lt;b2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>200, 100</code><br><code>56.93, 12.5</code><br><code>B, A</code><br><code>1, 0</code></p><p>​    请读者重点关注第<code>4</code>行代码。<code>template</code>是定义函数模板的关键字，它后面紧跟尖括号<code>&lt;&gt;</code>，尖括号包围的是类型参数（也可以说是虚拟的类型，或者说是类型占位符）。<code>typename</code>是另外一个关键字，用来声明具体的类型参数，这里的类型参数就是<code>T</code>。从整体上看，<code>template</code>被称为模板头。</p><h3 id="类模板定义"><a href="#类模板定义" class="headerlink" title="类模板定义"></a>类模板定义</h3><p>​    <code>C++</code>除了支持函数模板，还支持<strong>类模板（<code>Class Template</code>）</strong>。函数模板中定义的类型参数可以用在函数声明和函数定义中，类模板中定义的类型参数可以用在类声明和类实现中。类模板的目的同样是将数据的类型参数化。</p><p>​    声明类模板的语法为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span> , <span class="keyword">typename</span> 类型参数<span class="number">2</span> , ...&gt; <span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line">   <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><p>​    类模板和函数模板都是以<code>template</code>开头（当然也可以使用<code>class</code>，目前来讲它们没有任何区别），后跟类型参数；类型参数不能为空，多个类型参数用逗号隔开。</p><p>​    一但声明了类模板，就可以将类型参数用于类的成员函数和成员变量了。换句话说，原来使用<code>int</code>、<code>float</code>、<code>char</code>等内置类型的地方，都可以用类型参数来代替。</p><p>​    假如我们现在要定义一个类来表示坐标，要求坐标的数据类型可以是整数、小数和字符串，例如：</p><ul><li><code>x = 10</code>、<code>y = 10</code></li><li><code>x = 12.88</code>、<code>y = 129.65</code></li><li><code>x = &quot;东经180度&quot;</code>、<code>y = &quot;北纬210度&quot;</code></li></ul><p> 这个时候就可以使用类模板，请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;  <span class="comment">//这里不能有分号</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(T1 x, T2 y): m_x(x), m_y(y)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T1 <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//获取x坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(T1 x)</span></span>;  <span class="comment">//设置x坐标</span></span><br><span class="line">    <span class="function">T2 <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//获取y坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(T2 y)</span></span>;  <span class="comment">//设置y坐标</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_x;  <span class="comment">//x坐标</span></span><br><span class="line">    T2 m_y;  <span class="comment">//y坐标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    <code>x</code>坐标和<code>y</code>坐标的数据类型不确定，借助类模板可以将数据类型参数化，这样就不必定义多个类了。</p><blockquote><p>注意：模板头和类头是一个整体，可以换行，但是中间不能有分号。</p></blockquote><p>​    上面的代码仅仅是类的声明，我们还需要在类外定义成员函数。在类外定义成员函数时仍然需要带上模板头，格式为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span> , <span class="keyword">typename</span> 类型参数<span class="number">2</span> , .....&gt;</span><br><span class="line"> 返回值类型 类名&lt;类型参数<span class="number">1</span> , 类型参数<span class="number">2</span>, ...&gt;::函数名(形参列表)&#123;</span><br><span class="line">   <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>​    第一行是模板头，第二行是函数头，它们可以合并到一行，不过为了让代码格式更加清晰，一般是将它们分成两行。</p><p>​    下面就对<code>Point</code>类的成员函数进行定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;  <span class="comment">//模板头</span></span><br><span class="line">T1 Point&lt;T1, T2&gt;::getX() <span class="keyword">const</span> <span class="comment">/*函数头*/</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m_x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">void</span> Point&lt;T1, T2&gt;::setX(T1 x)&#123;</span><br><span class="line">    m_x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">T2 Point&lt;T1, T2&gt;::getY() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">void</span> Point&lt;T1, T2&gt;::setY(T2 y)&#123;</span><br><span class="line">    m_y = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    仔细观察代码，除了<code>template</code>关键字后面要指明类型参数，类名<code>Point</code>后面也要带上类型参数，只是不加<code>typename</code>关键字了。另外需要注意的是，在类外定义成员函数时，<code>template</code>后面的类型参数要和类声明时的一致。</p><h4 id="使用类模板创建对象"><a href="#使用类模板创建对象" class="headerlink" title="使用类模板创建对象"></a>使用类模板创建对象</h4><p>​    上面的两段代码完成了类的定义，接下来就可以使用该类创建对象了。使用类模板创建对象时，需要指明具体的数据类型。请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p1(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">Point&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt; p2(<span class="number">10</span>, <span class="number">15.5</span>);</span><br><span class="line">Point&lt;<span class="keyword">float</span>, <span class="keyword">char</span>*&gt; p3(<span class="number">12.4</span>, <span class="string">"东经180度"</span>);</span><br></pre></td></tr></table></figure><p>​    与函数模板不同的是，类模板在实例化时必须显式地指明数据类型，编译器不能根据给定的数据推演出数据类型。</p><p>​    除了对象变量，我们也可以使用对象指针的方式来实例化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt; *p1 = <span class="keyword">new</span> Point&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt;(<span class="number">10.6</span>, <span class="number">109.3</span>);</span><br><span class="line">Point&lt;<span class="keyword">char</span>*, <span class="keyword">char</span>*&gt; *p = <span class="keyword">new</span> Point&lt;<span class="keyword">char</span>*, <span class="keyword">char</span>*&gt;(<span class="string">"东经180度"</span>, <span class="string">"北纬210度"</span>);</span><br></pre></td></tr></table></figure><p>​    需要注意的是，赋值号两边都要指明具体的数据类型，且要保持一致。下面的写法是错误的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值号两边的数据类型不一致</span></span><br><span class="line">Point&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt; *p = <span class="keyword">new</span> Point&lt;<span class="keyword">float</span>, <span class="keyword">int</span>&gt;(<span class="number">10.6</span>, <span class="number">109</span>);</span><br><span class="line"><span class="comment">//赋值号右边没有指明数据类型</span></span><br><span class="line">Point&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt; *p = <span class="keyword">new</span> Point(<span class="number">10.6</span>, <span class="number">109</span>);</span><br></pre></td></tr></table></figure><h4 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h4><p>​    【实例1】将上面的类定义和类实例化的代码整合起来，构成一个完整的示例，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;  //这里不能有分号</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(T1 x, T2 y): m_x(x), m_y(y)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T1 <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//获取x坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(T1 x)</span></span>;  <span class="comment">//设置x坐标</span></span><br><span class="line">    <span class="function">T2 <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//获取y坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(T2 y)</span></span>;  <span class="comment">//设置y坐标</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_x;  <span class="comment">//x坐标</span></span><br><span class="line">    T2 m_y;  <span class="comment">//y坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;  //模板头</span></span><br><span class="line"><span class="class"><span class="title">T1</span> <span class="title">Point</span>&lt;T1, T2&gt;:</span>:getX() <span class="keyword">const</span> <span class="comment">/*函数头*/</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m_x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Point</span>&lt;T1, T2&gt;:</span>:setX(T1 x)&#123;</span><br><span class="line">    m_x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T2</span> <span class="title">Point</span>&lt;T1, T2&gt;:</span>:getY() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Point</span>&lt;T1, T2&gt;:</span>:setY(T2 y)&#123;</span><br><span class="line">    m_y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p1(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;p1.getX()&lt;&lt;<span class="string">", y="</span>&lt;&lt;p1.getY()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    Point&lt;<span class="keyword">int</span>, <span class="keyword">char</span>*&gt; p2(<span class="number">10</span>, <span class="string">"东经180度"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;p2.getX()&lt;&lt;<span class="string">", y="</span>&lt;&lt;p2.getY()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    Point&lt;<span class="keyword">char</span>*, <span class="keyword">char</span>*&gt; *p3 = <span class="keyword">new</span> Point&lt;<span class="keyword">char</span>*, <span class="keyword">char</span>*&gt;(<span class="string">"东经180度"</span>, <span class="string">"北纬210度"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;p3-&gt;getX()&lt;&lt;<span class="string">", y="</span>&lt;&lt;p3-&gt;getY()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>x=10, y=20</code><br><code>x=10, y=东经180度</code><br><code>x=东经180度, y=北纬210度</code></p><p>​    在定义类型参数时我们使用了<code>class</code>，而不是<code>typename</code>，这样做的目的是让读者对两种写法都熟悉。</p><p>【实例2】用类模板实现可变长数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">//数组元素的个数</span></span><br><span class="line">    T *ptr; <span class="comment">//指向动态分配的数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CArray(<span class="keyword">int</span> s = <span class="number">0</span>);  <span class="comment">//s代表数组元素的个数</span></span><br><span class="line">    CArray(CArray &amp; a);</span><br><span class="line">    ~CArray();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp; v)</span></span>; <span class="comment">//用于在数组尾部添加一个元素v</span></span><br><span class="line">    CArray &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CArray &amp; a); <span class="comment">//用于数组对象间的赋值</span></span><br><span class="line">    <span class="function">T <span class="title">length</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    T &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i)</span><br><span class="line">    &#123;<span class="comment">//用以支持根据下标访问数组元素，如a[i] = 4;和n = a[i]这样的语句</span></span><br><span class="line">        <span class="keyword">return</span> ptr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">CArray</span>&lt;T&gt;:</span>:CArray(<span class="keyword">int</span> s):size(s)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(s == <span class="number">0</span>)</span><br><span class="line">         ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ptr = <span class="keyword">new</span> T[s];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">CArray</span>&lt;T&gt;:</span>:CArray(CArray &amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a.ptr) &#123;</span><br><span class="line">        ptr = <span class="literal">NULL</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = <span class="keyword">new</span> T[a.size];</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, a.ptr, <span class="keyword">sizeof</span>(T ) * a.size);</span><br><span class="line">    size = a.size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">CArray</span>&lt;T&gt;:</span>:~CArray()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(ptr) <span class="keyword">delete</span> [] ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">CArray</span>&lt;T&gt; &amp; <span class="title">CArray</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>=(<span class="keyword">const</span> CArray &amp; a)</span><br><span class="line">&#123; <span class="comment">//赋值号的作用是使"="左边对象里存放的数组，大小和内容都和右边的对象一样</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp; a) <span class="comment">//防止a=a这样的赋值导致出错</span></span><br><span class="line">    <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.ptr == <span class="literal">NULL</span>) &#123;  <span class="comment">//如果a里面的数组是空的</span></span><br><span class="line">        <span class="keyword">if</span>( ptr )</span><br><span class="line">            <span class="keyword">delete</span> [] ptr;</span><br><span class="line">        ptr = <span class="literal">NULL</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span>(size &lt; a.size) &#123; <span class="comment">//如果原有空间够大，就不用分配新的空间</span></span><br><span class="line">         <span class="keyword">if</span>(ptr)</span><br><span class="line">            <span class="keyword">delete</span> [] ptr;</span><br><span class="line">        ptr = <span class="keyword">new</span> T[a.size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr,a.ptr,<span class="keyword">sizeof</span>(T)*a.size);   </span><br><span class="line">    size = a.size;</span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">CArray</span>&lt;T&gt;:</span>:push_back(<span class="keyword">const</span> T &amp; v)</span><br><span class="line">&#123;  <span class="comment">//在数组尾部添加一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(ptr) &#123;</span><br><span class="line">        T *tmpPtr = <span class="keyword">new</span> T[size+<span class="number">1</span>]; <span class="comment">//重新分配空间</span></span><br><span class="line">    <span class="built_in">memcpy</span>(tmpPtr,ptr,<span class="keyword">sizeof</span>(T)*size); <span class="comment">//拷贝原数组内容</span></span><br><span class="line">    <span class="keyword">delete</span> []ptr;</span><br><span class="line">    ptr = tmpPtr;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//数组本来是空的</span></span><br><span class="line">        ptr = <span class="keyword">new</span> T[<span class="number">1</span>];</span><br><span class="line">    ptr[size++] = v; <span class="comment">//加入新的数组元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CArray&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i)</span><br><span class="line">        a.push_back(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板编程来源"><a href="#模板编程来源" class="headerlink" title="模板编程来源"></a>模板编程来源</h2><p>​    计算机编程语言种类繁多，这些编程语言根据不同的标准可以分为不同的种类，根据“在定义变量时是否需要显式地指明数据类型”可以分为<strong>强类型语言</strong>和<strong>弱类型语言</strong>。</p><h3 id="强类型语言"><a href="#强类型语言" class="headerlink" title="强类型语言"></a>强类型语言</h3><p>​    <strong>强类型语言在定义变量时需要显式地指明数据类型，并且一旦为变量指明了某种数据类型，该变量以后就不能赋予其他类型的数据了，除非经过强制类型转换或隐式类型转换。</strong>典型的强类型语言有<code>C/C++</code>、<code>Java</code>、<code>C#</code>等。</p><p>​    下面的代码演示了如何在<code>C/C++</code>中使用变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;  <span class="comment">//不转换</span></span><br><span class="line">a = <span class="number">12.34</span>;  <span class="comment">//隐式转换（直接舍去小数部分，得到12）</span></span><br><span class="line">a = (<span class="keyword">int</span>)<span class="string">"http://c.biancheng.net"</span>;  <span class="comment">//强制转换（得到字符串的地址）</span></span><br></pre></td></tr></table></figure><p>​    下面的代码演示了如何在<code>Java</code>中使用变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;  <span class="comment">//不转换</span></span><br><span class="line">a = (<span class="keyword">int</span>)<span class="number">12.34</span>;  <span class="comment">//强制转换（直接舍去小数部分，得到12）</span></span><br></pre></td></tr></table></figure><p>​    <code>Java</code>对类型转换的要求比<code>C/C++</code>更为严格，隐式转换只允许由低向高转，由高向低转必须强制转换。</p><h3 id="弱类型语言"><a href="#弱类型语言" class="headerlink" title="弱类型语言"></a>弱类型语言</h3><p>​    <strong>弱类型语言在定义变量时不需要显式地指明数据类型，编译器（解释器）会根据赋给变量的数据自动推导出类型，并且可以赋给变量不同类型的数据。</strong>典型的弱类型语言有<code>JavaScript</code>、<code>Python</code>、<code>PHP</code>、<code>Ruby</code>、<code>Shell</code>、<code>Perl</code>等。</p><p>​    下面的代码演示了如何在 <code>JavaScript</code>中使用变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;  <span class="comment">//赋给整数</span></span><br><span class="line">a = <span class="number">12.34</span>;  <span class="comment">//赋给小数</span></span><br><span class="line">a = <span class="string">"http://c.biancheng.net"</span>;  <span class="comment">//赋给字符串</span></span><br><span class="line">a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"JavaScript"</span>,<span class="string">"React"</span>,<span class="string">"JSON"</span>);  <span class="comment">//赋给数组</span></span><br></pre></td></tr></table></figure><p>​    <code>var</code>是<code>JavaScript</code>中的一个关键字，表示定义一个新的变量，而不是数据类型。</p><p>​    下面的代码演示了如何在<code>PHP</code>中使用变量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="number">100</span>;  <span class="comment">//赋给整数</span></span><br><span class="line">$a = <span class="number">12.34</span>;  <span class="comment">//赋给小数</span></span><br><span class="line">$a = <span class="string">"http://c.biancheng.net"</span>;  <span class="comment">//赋给字符串</span></span><br><span class="line">$a = <span class="keyword">array</span>(<span class="string">"JavaScript"</span>,<span class="string">"React"</span>,<span class="string">"JSON"</span>);  <span class="comment">//赋给数组</span></span><br></pre></td></tr></table></figure><p>​    <code>$</code>是一个特殊符号，所有的变量名都要以<code>$</code>开头。<code>PHP</code>中的变量不用特别地定义，变量名首次出现即视为定义。</p><blockquote><p>这里的强类型和弱类型是站在变量定义和类型转换的角度讲的，并把<code>C/C++</code>归为强类型语言。另外还有一种说法是站在编译和运行的角度，并把<code>C/C++</code>归为弱类型语言。本节我们只关注第一种说法。</p></blockquote><p>​    类型对于编程语言来说非常重要，不同的类型支持不同的操作，例如<code>class Student</code>类型的变量可以调用 <code>display()</code>方法，<code>int</code>类型的变量就不行。不管是强类型语言还是弱类型语言，在编译器（解释器）内部都有一个类型系统来维护变量的各种信息。</p><p>​    <strong>对于强类型的语言，变量的类型从始至终都是确定的、不变的，编译器在编译期间就能检测某个变量的操作是否正确，这样最终生成的程序中就不用再维护一套类型信息了，从而减少了内存的使用，加快了程序的运行。</strong></p><p>​    不过这种说法也不是绝对的，有些特殊情况还是要等到运行阶段才能确定变量的类型信息。比如<code>C++</code>中的多态，编译器在编译阶段会在对象内存模型中增加虚函数表、<code>type_info</code>对象等辅助信息，以维护一个完整的继承链，等到程序运行后再执行一段代码才能确定调用哪个函数。</p><p>​    <strong>对于弱类型的语言，变量的类型可以随时改变，赋予它什么类型的数据它就是什么类型，编译器在编译期间不好确定变量的类型，只有等到程序运行后、真的赋给变量一个值了，才能确定变量当前是什么类型</strong>，所以传统的编译对弱类型语言意义不大，因为即使编译了也有很多东西确定不下来。</p><p>​    弱类型语言往往是一边执行一边编译，这样可以根据上下文（可以理解为当前的执行环境）推导出很多有用信息，让编译更加高效。</p><p>​    我们将这种<strong>一边执行一边编译的语言称为解释型语言</strong>，而将<strong>传统的先编译后执行的语言称为编译型语言。</strong></p><p>​    强类型语言较为严谨，在编译时就能发现很多错误，适合开发大型的、系统级的、工业级的项目；而弱类型语言较为灵活，编码效率高，部署容易，学习成本低，在<code>Web</code>开发中大显身手。另外，强类型语言的<code>IDE</code>一般都比较强大，代码感知能力好，提示信息丰富；而弱类型语言一般都是在编辑器中直接书写代码。</p><p>​    为了展示弱类型语言的灵活，我们以<code>PHP</code>为例来实现上节中的<code>Point</code>类，让它可以处理整数、小数以及字符串：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Point</span><span class="params">($x, $y)</span></span>&#123;  <span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">$this</span> -&gt; m_x = $x;</span><br><span class="line">        <span class="keyword">$this</span> -&gt; m_y = $y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span> -&gt; m_x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getY</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span> -&gt; m_y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setX</span><span class="params">($x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span> -&gt; m_x = $x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setY</span><span class="params">($y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span> -&gt; m_y = $y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> $m_x;</span><br><span class="line">    <span class="keyword">private</span> $m_y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$p = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);  <span class="comment">//处理整数</span></span><br><span class="line"><span class="keyword">echo</span> $p-&gt;getX() . <span class="string">", "</span> . $p-&gt;getY() . <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line"></span><br><span class="line">$p = <span class="keyword">new</span> Point(<span class="number">24.56</span>, <span class="string">"东京180度"</span>);  <span class="comment">//处理小数和字符串</span></span><br><span class="line"><span class="keyword">echo</span> $p-&gt;getX() . <span class="string">", "</span> . $p-&gt;getY() . <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line"></span><br><span class="line">$p = <span class="keyword">new</span> Point(<span class="string">"东京180度"</span>, <span class="string">"北纬210度"</span>);  <span class="comment">//处理字符串</span></span><br><span class="line"><span class="keyword">echo</span> $p-&gt;getX() . <span class="string">", "</span> . $p-&gt;getY() . <span class="string">"&lt;br /&gt;"</span>;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>10, 20</code><br><code>24.56, 东京180度</code><br><code>东京180度, 北纬210度</code></p><p>​    <code>PHP</code>不需要使用模板就可以处理多种类型的数据，它天生对类型就不敏感。<code>C++</code>就不一样了，它是强类型的，比较“死板”，所以后来<code>C++</code>开始支持模板了，主要就是为了弥补强类型语言“不够灵活”的缺点。</p><p>​    <strong>模板所支持的类型是宽泛的，没有限制的，我们可以使用任意类型来替换，这种编程方式称为泛型编程（<code>Generic Programming</code>）。</strong>相应地，可以将参数<code>T</code>看做是一个泛型，而将<code>int</code>、<code>float</code>、<code>string</code>等看做是一种具体的类型。除了<code>C++</code>，<code>Java</code>、<code>C#</code>、<code>Pascal（Delphi）</code>也都支持泛型编程。</p><p>​    <strong><code>C++</code>模板也是被迫推出的，最直接的动力来源于对数据结构的封装。</strong>数据结构关注的是数据的存储，以及存储后如何进行增加、删除、修改和查询操作，它是一门基础性的学科，在实际开发中有着非常广泛的应用。<code>C++</code>开发者们希望为线性表、链表、图、树等常见的数据结构都定义一个类，并把它们加入到标准库中，这样以后程序员就不用重复造轮子了，直接拿来使用即可。</p><p>​    但是这个时候遇到了一个无法解决的问题，就是数据结构中每份数据的类型无法提前预测。以链表为例，它的每个节点可以用来存储小数、整数、字符串等，也可以用来存储一名学生、教师、司机等，还可以直接存储二进制数据，这些都是可以的，没有任何限制。而<code>C++</code>又是强类型的，数据的种类受到了严格的限制，这种矛盾是无法调和的。</p><p>​    要想解决这个问题，<code>C++</code>必须推陈出新，跳出现有规则的限制，开发新的技术，于是模板就诞生了。模板虽然不是<code>C++</code>的首创，但是却在<code>C++</code>中大放异彩，后来也被<code>Java</code>、<code>C#</code>等其他强类型语言采用。</p><p>​    <code>C++</code>模板有着复杂的语法，也非常重要，整个标准库几乎都是使用模板来开发的，<code>STL</code>更是经典之作。</p><blockquote><p><code>STL</code>（<code>Standard Template Library</code>，标准模板库）就是<code>C++</code>对数据结构进行封装后的称呼。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++运行时类型识别(RTTI)</title>
      <link href="/2018/08/03/c++%E5%A4%9A%E6%80%813-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB(RTTI)/"/>
      <url>/2018/08/03/c++%E5%A4%9A%E6%80%813-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB(RTTI)/</url>
      
        <content type="html"><![CDATA[<h2 id="运行时类型识别-RTTI-机制精讲"><a href="#运行时类型识别-RTTI-机制精讲" class="headerlink" title="运行时类型识别(RTTI)机制精讲"></a>运行时类型识别(<code>RTTI</code>)机制精讲</h2><p>​    一般情况下，在编译期间就能确定一个表达式的类型，但是当存在多态时，有些表达式的类型在编译期间就无法确定了，必须等到程序运行后根据实际的环境来确定。下面的例子演示了这种情况：</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Base::func()&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Derived::func()&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base *p;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">        p = <span class="keyword">new</span> Base();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p = <span class="keyword">new</span> Derived();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(*p).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入<code>45</code>，运行结果为：</p><p><code>45↙</code><br><code>class Base</code></p><p>输入<code>130</code>，运行结果为：</p><p><code>130↙</code><br><code>class Derived</code></p><p>​    基类<code>Base</code>包含了一个虚函数，派生类<code>Derived</code>又定义了一个原型相同的函数遮蔽了它，这就构成了多态。<code>p</code>是基类的指针，可以指向基类对象，也可以指向派生类对象；<code>*p</code>表示 p 指向的对象。</p><p>​    从代码中可以看出，用户输入的数字不同，<code>*p</code>表示的对象就不同，<code>typeid</code>获取到的类型也就不同，编译器在编译期间无法预估用户的输入，所以无法确定<code>*p</code>的类型，必须等到程序真的运行了、用户输入完毕了才能确定<code>*p</code>的类型。</p><p>根据前面讲过的知识，<code>C++</code>的对象内存模型主要包含了以下几个方面的内容：</p><ul><li>如果没有虚函数也没有虚继承，那么对象内存模型中只有成员变量。</li><li>如果类包含了虚函数，那么会额外添加一个虚函数表，并在对象内存中插入一个指针，指向这个虚函数表。</li><li>如果类包含了虚继承，那么会额外添加一个虚基类表，并在对象内存中插入一个指针，指向这个虚基类表。</li></ul><p> 现在我们要补充的一点是，如果类包含了虚函数，那么该类的对象内存中还会额外增加类型信息，也即 <code>type_info</code>对象。以上面的代码为例，<code>Base</code>和<code>Derived</code>的对象内存模型如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/14461RX1-0.jpg" alt></p><p>​    编译器会在虚函数表<code>vftable</code>的开头插入一个指针，指向当前类对应的<code>type_info</code>对象。当程序在运行阶段获取类型信息时，可以通过对象指针<code>p</code>找到虚函数表指针<code>vfptr</code>，再通过<code>vfptr</code>找到<code>type_info</code>对象的指针，进而取得类型信息。下面的代码演示了这种转换过程：</p><p><code>**(p-&gt;vfptr - 1)</code></p><p>​    程序运行后，不管<code>p</code>指向<code>Base</code>类对象还是指向<code>Derived</code>类对象，只要执行这条语句就可以取得 <code>type_info</code>对象。</p><p>​    编译器在编译阶段无法确定<code>p</code>指向哪个对象，也就无法获取<code>*p</code>的类型信息，但是编译器可以在编译阶段做好各种准备，这样程序在运行后可以借助这些准备好的数据来获取类型信息。这些准备包括：</p><ul><li>创建<code>type_info</code>对象，并在<code>vftable</code>的开头插入一个指针，指向<code>type_info</code>对象。</li><li>将获取类型信息的操作转换成类似<code>**(p-&gt;vfptr - 1)</code>这样的语句。</li></ul><p>这样做虽然会占用更多的内存，效率也降低了，但这是没办法的事情，编译器实在是无能为力了。</p><p>​    <strong>这种在程序运行后确定对象的类型信息的机制称为运行时类型识别（<code>Run-Time Type Identification，RTTI</code>）。</strong>在<code>C++</code>中，只有类中包含了虚函数时才会启用<code>RTTI</code>机制，其他所有情况都可以在编译阶段确定类型信息。</p><p>​    下面是<code>RTTI</code>机制的一个具体应用，可以让代码根据不同的类型进行不同的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> People&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    People *p;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">        p = <span class="keyword">new</span> People();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p = <span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据不同的类型进行不同的操作</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeid</span>(*p) == <span class="keyword">typeid</span>(People))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am human."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am a student."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能的运行结果：<br><code>83↙</code><br><code>I am human.</code></p><p>​    多态（<code>Polymorphism</code>）是面向对象编程的一个重要特征，它极大地增加了程序的灵活性，<code>C++</code>、<code>C#</code>、<code>Java</code>等“正统的”面向对象编程语言都支持多态。但是支持多态的代价也是很大的，有些信息在编译阶段无法确定下来，必须提前做好充足的准备，让程序运行后再执行一段代码获取，这会消耗更多的内存和<code>CPU</code>资源。</p><h2 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h2><p>​    <code>C/C++</code>用变量来存储数据，用函数来定义一段可以重复使用的代码，它们最终都要放到内存中才能供 <code>CPU</code>使用。<code>CPU</code>通过地址来取得内存中的代码和数据，程序在执行过程中会告知<code>CPU</code>要执行的代码以及要读写的数据的地址。</p><p>​    <code>CPU</code>访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。编译和链接过程的一项重要任务就是找到这些名称所对应的地址。</p><p>​    假设变量<code>a</code>、<code>b</code>、<code>c</code>在内存中的地址分别是<code>0X1000</code>、<code>0X2000</code>、<code>0X3000</code>，那么加法运算<code>c = a + b;</code>将会被转换成类似下面的形式：</p><p><code>0X3000 = (0X1000) + (0X2000);</code></p><p>​    <code>( )</code>表示取值操作，整个表达式的意思是，取出地址<code>0X1000</code>和 <code>0X2000</code>上的值，将它们相加，把相加的结果赋值给地址为<code>0X3000</code>的内存。</p><p>​    变量名和函数名为我们提供了方便，让我们在编写代码的过程中可以使用易于阅读和理解的英文字符串，不用直接面对二进制地址，那场景简直让人崩溃。</p><p>​    我们不妨将变量名和函数名统称为符号（<code>Symbol</code>），找到符号对应的地址的过程叫做符号绑定。本节只讨论函数名和地址的绑定，变量名也是类似的道理。</p><h3 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h3><p>​    我们知道，函数调用实际上是执行函数体中的代码。函数体是内存中的一个代码段，函数名就表示该代码段的首地址，函数执行时就从这里开始。说得简单一点，就是必须要知道函数的入口地址，才能成功调用函数。</p><p>​    找到函数名对应的地址，然后将函数调用处用该地址替换，这称为函数绑定。</p><p>​    <strong>一般情况下，在编译期间（包括链接期间）就能找到函数名对应的地址，完成函数的绑定，程序运行后直接使用这个地址即可。这称为静态绑定（<code>Static binding</code>）。</strong></p><p>​    <strong>但是有时候在编译期间想尽所有办法都不能确定使用哪个函数，必须要等到程序运行后根据具体的环境或者用户操作才能决定。这称为动态绑定（<code>dynamic binding</code>）。</strong></p><p>​    <code>C++</code> 是一门静态性的语言，会尽力在编译期间找到函数的地址，以提高程序的运行效率，但是有时候实在没办法，只能等到程序运行后再执行一段代码（很少的代码）才能找到函数的地址。</p><p>​    上节我们讲到，通过<code>p -&gt; display();</code>语句调用<code>display()</code>函数时会转换为下面的表达式：</p><p><code>( *( *(p+0) + 0 ) )(p);</code></p><p>​    这里的<code>p</code> 有可能指向<code>People</code>类的对象，也可能指向<code>Student</code>或<code>Senior</code>类的对象，编译器不能提前假设 <code>p</code>指向哪个对象，也就不能确定调用哪个函数，所以编译器干脆不管了，<code>p</code>爱指向哪个对象就指向哪个对象，等到程序运行后执行一下这个表达式自然就知道了。</p><p> 有读者可能会问，对于下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = new Senior(&quot;李智&quot;, 22, 92.0, true);</span><br><span class="line">p -&gt; display();</span><br></pre></td></tr></table></figure><p>​    <code>p</code>不是已经确定了指向<code>Senior</code>类的对象吗，难道编译器不知道吗？对，编译器编译到第二条语句的时候如果向前逆推一下，确实能够知道<code>p</code>指向<code>Senior</code>类的对象。但是，如果是下面的情况呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">if</span>(n &gt; <span class="number">100</span>)&#123;</span><br><span class="line">    p = <span class="keyword">new</span> Student(<span class="string">"王刚"</span>, <span class="number">16</span>, <span class="number">84.5</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    p = <span class="keyword">new</span> Senior(<span class="string">"李智"</span>, <span class="number">22</span>, <span class="number">92.0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">p -&gt; display();</span><br></pre></td></tr></table></figure><p>​    如果用户输入的数字大于<code>100</code>，那么<code>p</code>指向<code>Student</code>类的对象，否则就指向<code>Senior</code>类的对象，这种情况编译器如何逆推呢？鬼知道用户输入什么数字！所以编译器干脆不会向前逆推，因为编译器不知道前方是什么情况，可能会很复杂，它也无能为力。</p><p>​    这就是动态绑定的本质：<strong>编译器在编译期间不能确定指针指向哪个对象，只能等到程序运行后根据具体的情况再决定。</strong></p><h2 id="RTTI机制下的对象内存模型"><a href="#RTTI机制下的对象内存模型" class="headerlink" title="RTTI机制下的对象内存模型"></a><code>RTTI</code>机制下的对象内存模型</h2><p>​    上节所示的<code>Base</code>和<code>Derived</code>的对象内存模型非常简单，读者也很容易理解，它满足了<code>typeid</code>运算符在程序运行期间动态地获取表达式的类型信息的需求。在<code>C++</code>中，除了<code>typeid</code>运算符，<code>dynamic_cast</code>运算符和异常处理也依赖于<code>RTTI</code>机制，并且要能够通过派生类获取基类的信息，或者说要能够判断一个类是否是另一个类的基类，这样上节讲到的内存模型就不够用了，我们必须要在基类和派生类之间再增加一条<code>绳索</code>，把它们<code>连接</code>起来，形成一条通路，让程序在各个对象之间<code>游走</code>。在面向对象的编程语言中，我们称此为继承链（<code>Inheritance Chain</code>）。</p><p>​    将基类和派生类连接起来很容易，只需要在基类对象中增加一个指向派生类对象的指针，然而考虑到多继承、降低内存使用等诸多方面的因素，真正的对象内存模型比上节讲到的要复杂很多，并且不同的编译器有不同的实现（<code>C++</code>标准并没有对对象内存模型的细节做出规定）。</p><p>​    我们以下面的代码为例来展示<code>Visual C++</code>下真正的对象内存模型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A_virt1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A_virt2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">A_static1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">A_simple1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b1;</span><br><span class="line">    <span class="keyword">int</span> b2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">B_virt1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">B_virt2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> c1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A_virt2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">B_virt2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最终的内存模型如下所示（<strong>猛击图片可查看大图</strong>）：<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/144S01059-0.jpg" style="zoom:150%;"><br>    图片来源于<code>http://www.openrce.org/articles/full_view/23</code>，红色是我加的说明。</p><p>​    从图中可以看出，对于有虚函数的类，内存模型中除了有虚函数表，还会额外增加好几个表，以维护当前类和基类的信息，空间上的开销不小。<code>typeid(type).name()</code>方法返回的类名就来自“当前类的信息表”。</p><p>​    如果你希望深入了解上图的结构，请查看下面几篇文章：</p><ul><li><code>VC++逆向：类、方法和 RTTI</code>(<a href="http://www.openrce.org/articles/full_view/23" target="_blank" rel="noopener">http://www.openrce.org/articles/full_view/23</a>)</li><li><code>RTTI结构详细分析(VC++)</code>(<a href="http://bbs.pediy.com/showthread.php?t=196996" target="_blank" rel="noopener">http://bbs.pediy.com/showthread.php?t=196996</a>)</li><li><code>C++中RTTI机制剖析</code>(<a href="http://blog.csdn.net/pi9nc/article/details/21742355" target="_blank" rel="noopener">http://blog.csdn.net/pi9nc/article/details/21742355</a>)</li><li><code>C++ dynamic_cast实现原理</code>(<a href="http://blog.csdn.net/passion_wu128/article/details/38511957" target="_blank" rel="noopener">http://blog.csdn.net/passion_wu128/article/details/38511957</a>)</li><li><code>dynamic_cast, RTTI， 整理</code>(<a href="http://www.cnblogs.com/dirichlet/p/3221066.html" target="_blank" rel="noopener">http://www.cnblogs.com/dirichlet/p/3221066.html</a>)</li></ul><p><code>typeid</code>经过固定次数的间接转换返回<code>type_info</code>对象，间接次数不会随着继承层次的增加而增加，对效率的影响很小，读者可以放心使用。而<code>dynamic_cast</code>运算符和异常处理不仅要经过数次间接转换，还要遍历继承链，如果继承层次较深，那么它们的性能堪忧，读者应当谨慎使用！</p><p>​    类型是表达式的一个属性，不同的类型支持不同的操作，例如<code>class Student</code>类型的表达式可以调用 <code>display()</code>方法，<code>int</code>类型的表达式就不行。类型对于编程语言来说非常重要，编译器内部有一个类型系统来维护表达式的各种信息。</p><p>​    在<code>C/C++</code>中，变量、函数参数、函数返回值等在定义时都必须显式地指明类型，并且一旦指明类型后就不能再更改了，所以大部分表达式的类型都能够精确的推测出来，编译器在编译期间就能够搞定这些事情，这样的编程语言称为静态语言（<code>Static Language</code>）。</p><p>​    静态语言在定义变量时通常需要显式地指明类型，并且在编译期间会拼尽全力来确定表达式的类型信息，只有在万不得已时才让程序等到运行后动态地获取类型信息（例如多态），这样做可以提高程序运行效率，降低内存消耗。</p><p>​    与静态语言（<code>Static Language</code>）相对的是动态语言（<code>Dynamic Language</code>）。动态语言在定义变量时往往不需要指明类型，并且变量的类型可以随时改变（赋给它不同类型的数据），编译器在编译期间也不容易确定表达式的类型信息，只能等到程序运行后再动态地获取。典型的动态语言有<code>JavaScript</code>、<code>Python</code>、<code>PHP</code>、<code>Perl</code>、<code>Ruby</code> 等。</p><p>​    <strong>动态语言为了能够使用灵活，部署简单，往往是一边编译一边执行，模糊了传统的编译和运行的过程。</strong>例如<code>JavaScript</code>主要用来给网页添加各种特效（这是一种简单的理解），浏览器访问一个页面时会从服务器上下载<code>JavaScript</code>源文件，并负责编译和运行它。如果我们提前将 JavaScript  源码编译成可执行文件，那么这个文件就会比较大，下载就会更加耗时，结果就是网页打开速度非常慢，这在网络不发达的早期是不能忍受的。</p><p> 总起来说，静态语言由于类型的限制会降低编码的速度，但是它的执行效率高，适合开发大型的、系统级的程序；动态语言则比较灵活，编码简单，部署容易，在<code>Web</code>开发中大显身手。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++typpeid运算符：获取类型信息</title>
      <link href="/2018/07/28/c++%E5%A4%9A%E6%80%812-typeid%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/"/>
      <url>/2018/07/28/c++%E5%A4%9A%E6%80%812-typeid%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="typeid运算符：获取类型信息"><a href="#typeid运算符：获取类型信息" class="headerlink" title="typeid运算符：获取类型信息"></a><code>typeid</code>运算符：获取类型信息</h2><p>​    <code>typeid</code>运算符用来获取一个表达式的类型信息。类型信息对于编程语言非常重要，它描述了数据的各种属性：</p><ul><li>对于基本类型（<code>int</code>、<code>float</code> 等<code>C++</code>内置类型）的数据，类型信息所包含的内容比较简单，主要是指数据的类型。</li><li>对于类类型的数据（也就是对象），类型信息是指对象所属的类、所包含的成员、所在的继承关系等。</li></ul><a id="more"></a><p><strong>类型信息是创建数据的模板，数据占用多大内存、能进行什么样的操作、该如何操作等，这些都由它的类型信息决定。</strong></p><p>​    <code>typeid</code>的操作对象既可以是表达式，也可以是数据类型，下面是它的两种使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeid</span>( dataType )</span><br><span class="line"><span class="keyword">typeid</span>( expression )</span><br></pre></td></tr></table></figure><p>​    <code>dataType</code>是数据类型，<code>expression</code>是表达式，这和<code>sizeof</code>运算符非常类似，只不过<code>sizeof</code> 有时候可以省略括号<code>( )</code>，而<code>typeid</code>必须带上括号。</p><p>​    <code>typeid</code>会把获取到的类型信息保存到一个<code>type_info</code>类型的对象里面，并返回该对象的常引用；当需要具体的类型信息时，可以通过成员函数来提取。<code>typeid</code>的使用非常灵活，请看下面的例子（只能在<code>VC/VS</code>下运行）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span>&#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取一个普通变量的类型信息</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> type_info &amp;nInfo = <span class="keyword">typeid</span>(n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;nInfo.name()&lt;&lt;<span class="string">" | "</span>&lt;&lt;nInfo.raw_name()&lt;&lt;<span class="string">" | "</span>&lt;&lt;nInfo.hash_code()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个字面量的类型信息</span></span><br><span class="line">    <span class="keyword">const</span> type_info &amp;dInfo = <span class="keyword">typeid</span>(<span class="number">25.65</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dInfo.name()&lt;&lt;<span class="string">" | "</span>&lt;&lt;dInfo.raw_name()&lt;&lt;<span class="string">" | "</span>&lt;&lt;dInfo.hash_code()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个对象的类型信息</span></span><br><span class="line">    Base obj;</span><br><span class="line">    <span class="keyword">const</span> type_info &amp;objInfo = <span class="keyword">typeid</span>(obj);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;objInfo.name()&lt;&lt;<span class="string">" | "</span>&lt;&lt;objInfo.raw_name()&lt;&lt;<span class="string">" | "</span>&lt;&lt;objInfo.hash_code()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个类的类型信息</span></span><br><span class="line">    <span class="keyword">const</span> type_info &amp;baseInfo = <span class="keyword">typeid</span>(Base);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;baseInfo.name()&lt;&lt;<span class="string">" | "</span>&lt;&lt;baseInfo.raw_name()&lt;&lt;<span class="string">" | "</span>&lt;&lt;baseInfo.hash_code()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个结构体的类型信息</span></span><br><span class="line">    <span class="keyword">const</span> type_info &amp;stuInfo = <span class="keyword">typeid</span>(struct STU);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;stuInfo.name()&lt;&lt;<span class="string">" | "</span>&lt;&lt;stuInfo.raw_name()&lt;&lt;<span class="string">" | "</span>&lt;&lt;stuInfo.hash_code()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个普通类型的类型信息</span></span><br><span class="line">    <span class="keyword">const</span> type_info &amp;charInfo = <span class="keyword">typeid</span>(<span class="keyword">char</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;charInfo.name()&lt;&lt;<span class="string">" | "</span>&lt;&lt;charInfo.raw_name()&lt;&lt;<span class="string">" | "</span>&lt;&lt;charInfo.hash_code()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个表达式的类型信息</span></span><br><span class="line">    <span class="keyword">const</span> type_info &amp;expInfo = <span class="keyword">typeid</span>(<span class="number">20</span> * <span class="number">45</span> / <span class="number">4.5</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;expInfo.name()&lt;&lt;<span class="string">" | "</span>&lt;&lt;expInfo.raw_name()&lt;&lt;<span class="string">" | "</span>&lt;&lt;expInfo.hash_code()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>int | .H | 529034928</code><br><code>double | .N | 667332678</code><br><code>class Base | .?AVBase@@ | 1035034353</code><br><code>class Base | .?AVBase@@ | 1035034353</code><br><code>struct STU | .?AUSTU@@ | 734635517</code><br><code>char | .D | 4140304029</code><br><code>double | .N | 667332678</code></p><p>​    从本例可以看出，<code>typeid</code>的使用非常灵活，它的操作数可以是普通变量、对象、内置类型（<code>int</code>、<code>float</code>等）、自定义类型（结构体和类），还可以是一个表达式。</p><p>本例中还用到了<code>type_info</code>类的几个成员函数，下面是对它们的介绍：</p><ul><li><code>name()</code>用来返回类型的名称。</li><li><code>raw_name()</code>用来返回名字编码（<code>Name Mangling</code>）算法产生的新名称。</li><li><code>hash_code()</code>用来返回当前类型对应的<code>hash</code> 值。<code>hash</code>值是一个可以用来标志当前类型的整数，有点类似学生的学号、公民的身份证号、银行卡号等。不过<code>hash</code>值有赖于编译器的实现，在不同的编译器下可能会有不同的整数，但它们都能唯一地标识某个类型。</li></ul><p>遗憾的是，<code>C++</code>标准只对<code>type_info</code>类做了很有限的规定，不仅成员函数少，功能弱，而且各个平台的实现不一致。例如上面代码中的<code>name()</code>函数，<code>nInfo.name()</code>、<code>objInfo.name()</code>在<code>VC/VS</code>下的输出结果分别是<code>int</code>和<code>class Base</code>，而在<code>GCC</code>下的输出结果分别是<code>i</code>和<code>4Base</code>。</p><p>​    <code>C++</code>标准规定，<code>type_info</code>类至少要有如下所示的<code>4</code>个 <code>public</code> 属性的成员函数，其他的扩展函数编译器开发者可以自由发挥，不做限制。</p><h4 id="1-原型：const-char-name-const"><a href="#1-原型：const-char-name-const" class="headerlink" title="1) 原型：const char* name() const;"></a>1) 原型：<code>const char* name() const;</code></h4><p>​    返回一个能表示类型名称的字符串。但是<code>C++</code>标准并没有规定这个字符串是什么形式的，例如对于上面的<code>objInfo.name()</code>语句，<code>VC/VS</code>下返回<code>“class Base”</code>，但<code>GCC</code>下返回<code>“4Base”</code>。</p><h4 id="2-原型：bool-before-const-type-info-amp-rhs-const"><a href="#2-原型：bool-before-const-type-info-amp-rhs-const" class="headerlink" title="2) 原型：bool before (const type_info&amp; rhs) const;"></a>2) 原型：<code>bool before (const type_info&amp; rhs) const;</code></h4><p>​    判断一个类型是否位于另一个类型的前面，<code>rhs</code>参数是一个<code>type_info</code>  对象的引用。但是<code>C++</code>标准并没有规定类型的排列顺序，不同的编译器有不同的排列规则，程序员也可以自定义。要特别注意的是，这个排列顺序和继承顺序没有关系，基类并不一定位于派生类的前面。</p><h4 id="3-原型：bool-operator-const-type-info-amp-rhs-const"><a href="#3-原型：bool-operator-const-type-info-amp-rhs-const" class="headerlink" title="3) 原型：bool operator== (const type_info&amp; rhs) const;"></a>3) 原型：<code>bool operator== (const type_info&amp; rhs) const;</code></h4><p>​    重载运算符<code>“==”</code>，判断两个类型是否相同，<code>rhs</code>参数是一个<code>type_info</code>对象的引用。</p><h4 id="4-原型：bool-operator-const-type-info-amp-rhs-const"><a href="#4-原型：bool-operator-const-type-info-amp-rhs-const" class="headerlink" title="4) 原型：bool operator!= (const type_info&amp; rhs) const;"></a>4) 原型：<code>bool operator!= (const type_info&amp; rhs) const;</code></h4><p>​    重载运算符<code>“!=”</code>，判断两个类型是否不同，<code>rhs</code>参数是一个<code>type_info</code>对象的引用。</p><p><code>raw_name()</code>是<code>VC/VS</code>独有的一个成员函数，<code>hash_code()</code>在<code>VC/VS</code>和较新的<code>GCC</code>下有效。</p><p>可以发现，<code>C++</code>能获取到的类型信息非常有限，也没有统一的标准，如同“鸡肋”一般，大部分情况下我们只是使用重载过的<code>“==”</code>运算符来判断两个类型是否相同。</p><h3 id="判断类型是否相等"><a href="#判断类型是否相等" class="headerlink" title="判断类型是否相等"></a>判断类型是否相等</h3><p>​    <code>typeid</code>运算符经常被用来判断两个类型是否相等。</p><h4 id="1-内置类型的比较"><a href="#1-内置类型的比较" class="headerlink" title="1) 内置类型的比较"></a>1) 内置类型的比较</h4><p>例如有下面的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> f;</span><br></pre></td></tr></table></figure><p>类型判断结果为：</p><table><thead><tr><th>类型比较</th><th>结果</th><th>类型比较</th><th>结果</th></tr></thead><tbody><tr><td><code>typeid(int) == typeid(int)</code></td><td><code>true</code></td><td><code>typeid(int) == typeid(char)</code></td><td><code>false</code></td></tr><tr><td><code>typeid(char*) == typeid(char)</code></td><td><code>false</code></td><td><code>typeid(str) == typeid(char*)</code></td><td><code>true</code></td></tr><tr><td><code>typeid(a) == typeid(int)</code></td><td><code>true</code></td><td><code>typeid(b) == typeid(int)</code></td><td><code>true</code></td></tr><tr><td><code>typeid(a) == typeid(a)</code></td><td><code>true</code></td><td><code>typeid(a) == typeid(b)</code></td><td><code>true</code></td></tr><tr><td><code>typeid(a) == typeid(f)</code></td><td><code>false</code></td><td><code>typeid(a/b) == typeid(int)</code></td><td><code>true</code></td></tr></tbody></table><p>​    <code>typeid</code>返回<code>type_info</code>对象的引用，而表达式<code>typeid(a) == typeid(b)</code>的结果为<code>true</code>，可以说明，一个类型不管使用了多少次，编译器都只为它创建一个对象，所有<code>typeid</code>都返回这个对象的引用。</p><p>​    需要提醒的是，为了减小编译后文件的体积，编译器不会为所有的类型创建<code>type_info</code>对象，只会为使用了<code>typeid</code>运算符的类型创建。不过有一种特殊情况，就是带虚函数的类（包括继承来的），不管有没有使用<code>typeid</code>运算符，编译器都会为带虚函数的类创建<code>type_info</code>对象。</p><h4 id="2-类的比较"><a href="#2-类的比较" class="headerlink" title="2) 类的比较"></a>2) 类的比较</h4><p>​    例如有下面的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base obj1;</span><br><span class="line">Base *p1;</span><br><span class="line">Derived obj2;</span><br><span class="line">Derived *p2 = <span class="keyword">new</span> Derived;</span><br><span class="line">p1 = p2;</span><br></pre></td></tr></table></figure><p>类型判断结果为：</p><table><thead><tr><th>类型比较</th><th>结果</th><th>类型比较</th><th>结果</th></tr></thead><tbody><tr><td><code>typeid(obj1) == typeid(p1)</code></td><td><code>false</code></td><td><code>typeid(obj1) == typeid(*p1)</code></td><td><code>true</code></td></tr><tr><td><code>typeid(&amp;obj1) == typeid(p1)</code></td><td><code>true</code></td><td><code>typeid(obj1) == typeid(obj2)</code></td><td><code>false</code></td></tr><tr><td><code>typeid(obj1) == typeid(Base)</code></td><td><code>true</code></td><td><code>typeid(*p1) == typeid(Base)</code></td><td><code>true</code></td></tr><tr><td><code>typeid(p1) == typeid(Base*)</code></td><td><code>true</code></td><td><code>typeid(p1) == typeid(Derived*)</code></td><td><code>false</code></td></tr></tbody></table><p>​    表达式<code>typeid(*p1) == typeid(Base)</code>和<code>typeid(p1) == typeid(Base*)</code>的结果为<code>true</code>可以说明：即使将派生类指针<code>p2</code>赋值给基类指针<code>p1</code>，<code>p1</code>的类型仍然为<code>Base*</code>。</p><h3 id="type-info类的声明"><a href="#type-info类的声明" class="headerlink" title="type_info类的声明"></a><code>type_info</code>类的声明</h3><p>​    最后我们再来看一下<code>type_info</code>类的声明，以进一步了解它所包含的成员函数以及这些函数的访问权限。<code>type_info</code>类位于<code>typeinfo</code>头文件，声明形式类似于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">type_info</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~type_info();</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> type_info&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> type_info&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">before</span><span class="params">(<span class="keyword">const</span> type_info&amp; rhs)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">raw_name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">void</span> *_m_data;</span><br><span class="line">    <span class="keyword">char</span> _m_d_name[<span class="number">1</span>];</span><br><span class="line">    type_info(<span class="keyword">const</span> type_info&amp; rhs);</span><br><span class="line">    type_info&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> type_info&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    它的构造函数是<code>private</code>属性的，所以不能在代码中直接实例化，只能由编译器在内部实例化（借助友元）。而且还重载了<code>“=”</code>运算符，也是<code>private</code>属性的，所以也不能赋值。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++虚函数和纯虚函数</title>
      <link href="/2018/07/25/c++%E5%A4%9A%E6%80%811-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2018/07/25/c++%E5%A4%9A%E6%80%811-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>  有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为<strong>多态（<code>Polymorphism</code>）</strong>。</p><a id="more"></a><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="指针实现多态"><a href="#指针实现多态" class="headerlink" title="指针实现多态"></a>指针实现多态</h3><p>​    基类的指针也可以指向派生类对象，请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类People</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    People(<span class="keyword">char</span> *name, <span class="keyword">int</span> age);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line">People::People(<span class="keyword">char</span> *name, <span class="keyword">int</span> age): m_name(name), m_age(age)&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> People::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁了，是个无业游民。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类Teacher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span> <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Teacher(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">int</span> salary);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_salary;</span><br><span class="line">&#125;;</span><br><span class="line">Teacher::Teacher(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">int</span> salary): People(name, age), m_salary(salary)&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> Teacher::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁了，是一名教师，每月有"</span>&lt;&lt;m_salary&lt;&lt;<span class="string">"元的收入。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    People *p = <span class="keyword">new</span> People(<span class="string">"王志刚"</span>, <span class="number">23</span>);</span><br><span class="line">    p -&gt; display();</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">new</span> Teacher(<span class="string">"赵宏佳"</span>, <span class="number">45</span>, <span class="number">8200</span>);</span><br><span class="line">    p -&gt; display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">王志刚今年<span class="number">23</span>岁了，是个无业游民。</span><br><span class="line">赵宏佳今年<span class="number">45</span>岁了，是个无业游民。</span><br></pre></td></tr></table></figure></p><p>​    我们直观上认为，如果指针指向了派生类对象，那么就应该使用派生类的成员变量和成员函数，这符合人们的思维习惯。但是本例的运行结果却告诉我们，当基类指针<code>p</code>指向派生类<code>Teacher</code>的对象时，虽然使用了<code>Teacher</code> 的成员变量，但是却没有使用它的成员函数，导致输出结果不伦不类（赵宏佳本来是一名老师，输出结果却显示人家是个无业游民），不符合我们的预期。</p><p>​    换句话说，<strong>通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。</strong></p><p>​    为了消除这种尴尬，让基类指针能够访问派生类的成员函数，<code>C++</code>增加了<strong>虚函数（<code>Virtual Function</code>）</strong>。使用虚函数非常简单，只需要在函数声明前面增加<code>virtual</code>关键字。</p><p>​    更改上面的代码，将<code>display()</code>声明为虚函数： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类People</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    People(<span class="keyword">char</span> *name, <span class="keyword">int</span> age);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;  <span class="comment">//声明为虚函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line">People::People(<span class="keyword">char</span> *name, <span class="keyword">int</span> age): m_name(name), m_age(age)&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> People::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁了，是个无业游民。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类Teacher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span> <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Teacher(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">int</span> salary);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;  <span class="comment">//声明为虚函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_salary;</span><br><span class="line">&#125;;</span><br><span class="line">Teacher::Teacher(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">int</span> salary): People(name, age), m_salary(salary)&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> Teacher::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁了，是一名教师，每月有"</span>&lt;&lt;m_salary&lt;&lt;<span class="string">"元的收入。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    People *p = <span class="keyword">new</span> People(<span class="string">"王志刚"</span>, <span class="number">23</span>);</span><br><span class="line">    p -&gt; display();</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">new</span> Teacher(<span class="string">"赵宏佳"</span>, <span class="number">45</span>, <span class="number">8200</span>);</span><br><span class="line">    p -&gt; display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>运行结果：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">王志刚今年<span class="number">23</span>岁了，是个无业游民。</span><br><span class="line">赵宏佳今年<span class="number">45</span>岁了，是一名教师，每月有<span class="number">8200</span>元的收入。</span><br></pre></td></tr></table></figure><p>​    和前面的例子相比，本例仅仅是在<code>display()</code>函数声明前加了一个<code>virtual</code>关键字，将成员函数声明为了<strong>虚函数（<code>Virtual Function</code>）</strong>，这样就可以通过<code>p</code>指针调用<code>Teacher</code>类的成员函数了，运行结果也证明了这一点（赵宏佳已经是一名老师了，不再是无业游民了）。</p><p>​    <strong>有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（<code>Polymorphism</code>）</strong>。</p><p>​    上面的代码中，同样是<code>p-&gt;display();</code>这条语句，当<code>p</code>指向不同的对象时，它执行的操作是不一样的。同一条语句可以执行不同的操作，看起来有不同表现方式，这就是多态。</p><pre><code>多态是面向对象编程的主要特征之一，`C++`中虚函数的唯一用处就是构成多态。</code></pre><p>​    <code>C++</code>提供多态的目的是：<strong>可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问，尤其是成员函数。如果没有多态，我们只能访问成员变量</strong>。</p><p>​    前面我们说过，通过指针调用普通的成员函数时会根据指针的类型（通过哪个类定义的指针）来判断调用哪个类的成员函数，但是通过本节的分析可以发现，这种说法并不适用于虚函数，虚函数是根据指针的指向来调用的，指针指向哪个类的对象就调用哪个类的虚函数。</p><h3 id="引用实现多态"><a href="#引用实现多态" class="headerlink" title="引用实现多态"></a>引用实现多态</h3><p>​    引用在本质上是通过指针的方式实现的，既然借助指针可以实现多态，那么我们就有理由推断：<strong>借助引用也可以实现多态</strong>。</p><p>​    修改上例中<code>main()</code>函数内部的代码，用引用取代指针： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">People <span class="title">p</span><span class="params">(<span class="string">"王志刚"</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">    <span class="function">Teacher <span class="title">t</span><span class="params">(<span class="string">"赵宏佳"</span>, <span class="number">45</span>, <span class="number">8200</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">    People &amp;rp = p;</span><br><span class="line">    People &amp;rt = t;</span><br><span class="line">   </span><br><span class="line">    rp.display();</span><br><span class="line">    rt.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">王志刚今年<span class="number">23</span>岁了，是个无业游民。</span><br><span class="line">赵宏佳今年<span class="number">45</span>岁了，是一名教师，每月有<span class="number">8200</span>元的收入。</span><br></pre></td></tr></table></figure></p><p>​    <strong>由于引用类似于常量，只能在定义的同时初始化，并且以后也要从一而终，不能再引用其他数据，所以本例中必须要定义两个引用变量，一个用来引用基类对象，一个用来引用派生类对象。</strong>从运行结果可以看出，当基类的引用指代基类对象时，调用的是基类的成员，而指代派生类对象时，调用的是派生类的成员。</p><p>​    <strong>不过引用不像指针灵活，指针可以随时改变指向，而引用只能指代固定的对象，在多态性方面缺乏表现力，所以以后我们再谈及多态时一般是说指针。</strong></p><p>​    本例的主要目的是让读者知道，除了指针，引用也可以实现多态。</p><h3 id="多态的用途"><a href="#多态的用途" class="headerlink" title="多态的用途"></a>多态的用途</h3><p>​    通过上面的例子读者可能还未发现多态的用途，不过确实也是，多态在小项目中鲜有有用武之地。</p><p>​    接下来的例子中，我们假设你正在玩一款军事游戏，敌人突然发动了地面战争，于是你命令陆军、空军及其所有现役装备进入作战状态。具体的代码如下所示： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//军队</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Troops</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Strike back!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//陆军</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Army</span>:</span> <span class="keyword">public</span> Troops&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"--Army is fighting!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//99A主战坦克</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _99<span class="title">A</span>:</span> <span class="keyword">public</span> Army&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"----99A(Tank) is fighting!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//武直10武装直升机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WZ_10</span>:</span> <span class="keyword">public</span> Army&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"----WZ-10(Helicopter) is fighting!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//长剑10巡航导弹</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CJ_10</span>:</span> <span class="keyword">public</span> Army&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"----CJ-10(Missile) is fighting!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空军</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirForce</span>:</span> <span class="keyword">public</span> Troops&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"--AirForce is fighting!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//J-20隐形歼击机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">J_20</span>:</span> <span class="keyword">public</span> AirForce&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"----J-20(Fighter Plane) is fighting!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//CH5无人机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CH_5</span>:</span> <span class="keyword">public</span> AirForce&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"----CH-5(UAV) is fighting!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//轰6K轰炸机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H_6K</span>:</span> <span class="keyword">public</span> AirForce&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"----H-6K(Bomber) is fighting!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Troops *p = <span class="keyword">new</span> Troops;</span><br><span class="line">    p -&gt;fight();</span><br><span class="line">    <span class="comment">//陆军</span></span><br><span class="line">    p = <span class="keyword">new</span> Army;</span><br><span class="line">    p -&gt;fight();</span><br><span class="line">    p = <span class="keyword">new</span> _99A;</span><br><span class="line">    p -&gt; fight();</span><br><span class="line">    p = <span class="keyword">new</span> WZ_10;</span><br><span class="line">    p -&gt; fight();</span><br><span class="line">    p = <span class="keyword">new</span> CJ_10;</span><br><span class="line">    p -&gt; fight();</span><br><span class="line">    <span class="comment">//空军</span></span><br><span class="line">    p = <span class="keyword">new</span> AirForce;</span><br><span class="line">    p -&gt; fight();</span><br><span class="line">    p = <span class="keyword">new</span> J_20;</span><br><span class="line">    p -&gt; fight();</span><br><span class="line">    p = <span class="keyword">new</span> CH_5;</span><br><span class="line">    p -&gt; fight();</span><br><span class="line">    p = <span class="keyword">new</span> H_6K;</span><br><span class="line">    p -&gt; fight();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Strike back!</span><br><span class="line">--Army is fighting!</span><br><span class="line">----99A(Tank) is fighting!</span><br><span class="line">----WZ-10(Helicopter) is fighting!</span><br><span class="line">----CJ-10(Missile) is fighting!</span><br><span class="line">--AirForce is fighting!</span><br><span class="line">----J-20(Fighter Plane) is fighting!</span><br><span class="line">----CH-5(UAV) is fighting!</span><br><span class="line">----H-6K(Bomber) is fighting!</span><br></pre></td></tr></table></figure></p><p>​    这个例子中的派生类比较多，如果不使用多态，那么就需要定义多个指针变量，很容易造成混乱；而有了多态，只需要一个指针变量<code>p</code>就可以调用所有派生类的虚函数。</p><p>​    从这个例子中也可以发现，对于具有复杂继承关系的大中型程序，多态可以增加其灵活性，让代码更具有表现力。</p><h3 id="虚函数注意事项"><a href="#虚函数注意事项" class="headerlink" title="虚函数注意事项"></a>虚函数注意事项</h3><p>​    虚函数对于多态具有决定性的作用，有虚函数才能构成多态，这节我们来重点说一下虚函数的注意事项。</p><p> 1) 只需要在虚函数的声明处加上 <code>virtual</code> 关键字，函数定义处可以加也可以不加。</p><p> 2) 为了方便，你可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽（覆盖）关系的同名函数都将自动成为虚函数。</p><p> 3) 当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。</p><p> 4) 只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）。例如基类虚函数的原型为<code>virtual void func();</code>，派生类虚函数的原型为<code>virtual void func(int);</code>，那么当基类指针<code>p</code>指向派生类对象时，语句<code>p -&gt; func(100);</code>将会出错，而语句<code>p -&gt; func();</code>将调用基类的函数。</p><p> 5) 构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。</p><p> 6) 析构函数可以声明为虚函数，而且有时候必须要声明为虚函数。 </p><h3 id="构成多态的条件"><a href="#构成多态的条件" class="headerlink" title="构成多态的条件"></a>构成多态的条件</h3><p>​    站在“学院派”的角度讲，<strong>封装</strong>、<strong>继承</strong>和<strong>多态</strong>是面向对象的三大特征，<strong>多态是指通过基类的指针既可以访问基类的成员，也可以访问派生类的成员</strong>。</p><p> 下面是构成多态的条件：</p><ul><li>必须存在继承关系；</li><li>继承关系中必须有同名的虚函数，并且它们是遮蔽（覆盖）关系。</li><li><p>存在基类的指针，通过该指针调用虚函数。</p><p>下面的例子对各种混乱情形进行了演示： </p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类Base</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Base::func()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"void Base::func()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Base::func(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"void Base::func(int)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类Derived</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Derived::func()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"void Derived::func()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Derived::func(<span class="keyword">char</span> *str)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"void Derived::func(char *)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> Derived();</span><br><span class="line">    p -&gt; func();  <span class="comment">//输出void Derived::func()</span></span><br><span class="line">    p -&gt; func(<span class="number">10</span>);  <span class="comment">//输出void Base::func(int)</span></span><br><span class="line">    p -&gt; func(<span class="string">"http://c.biancheng.net"</span>);  <span class="comment">//compile error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在基类<code>Base</code>中我们将<code>void func()</code>声明为虚函数，这样派生类<code>Derived</code>中的<code>void func()</code>就会自动成为虚函数。<code>p</code>是基类<code>Base</code>的指针，但是指向了派生类<code>Derived</code>的对象。语句<code>p-&gt;func();</code>调用的是派生类的虚函数，构成了多态。语句<code>p -&gt; func(10);</code>调用的是基类的虚函数，因为派生类中没有函数遮蔽它。语句<code>p -&gt; func(&quot;http://c.biancheng.net&quot;);</code>出现编译错误，因为通过基类的指针只能访问从基类继承过去的成员，不能访问派生类新增的成员。 </p><h3 id="什么时候声明虚函数"><a href="#什么时候声明虚函数" class="headerlink" title="什么时候声明虚函数"></a>什么时候声明虚函数</h3><p>​    首先看成员函数所在的类是否会作为基类。然后看成员函数在类的继承后有无可能被更改功能，如果希望更改其功能的，一般应该将它声明为虚函数。如果成员函数在类被继承后功能不需修改，或派生类用不到该函数，则不要把它声明为虚函数。</p><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>​    上节我们讲到，<strong>构造函数不能是虚函数，因为派生类不能继承基类的构造函数，将构造函数声明为虚函数没有意义</strong>。</p><p>​    这是原因之一，另外还有一个原因：<strong><code>C++</code>中的构造函数用于在创建对象时进行初始化工作，在执行构造函数之前对象尚未创建完成，虚函数表尚不存在，也没有指向虚函数表的指针，所以此时无法查询虚函数表，也就不知道要调用哪一个构造函数。</strong></p><p>​    <strong>析构函数用于在销毁对象时进行清理工作，可以声明为虚函数，而且有时候必须要声明为虚函数。</strong></p><p>​    为了说明虚析构函数的必要性，请大家先看下面一个例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base();</span><br><span class="line">    ~Base();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">&#125;;</span><br><span class="line">Base::Base()&#123;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base constructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Base::~Base()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] str;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived();</span><br><span class="line">    ~Derived();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line">Derived::Derived()&#123;</span><br><span class="line">    name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived constructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Derived::~Derived()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] name;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Base *pb = <span class="keyword">new</span> Derived();</span><br><span class="line">   <span class="keyword">delete</span> pb;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"-------------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   Derived *pd = <span class="keyword">new</span> Derived();</span><br><span class="line">   <span class="keyword">delete</span> pd;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Derived constructor</span><br><span class="line">Base destructor</span><br><span class="line">-------------------</span><br><span class="line">Base constructor</span><br><span class="line">Derived constructor</span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br></pre></td></tr></table></figure></p><p>​    本例中定义了两个类，基类<code>Base</code>和派生类<code>Derived</code>，它们都有自己的构造函数和析构函数。在构造函数中，会分配<code>100</code>个<code>char</code>类型的内存空间；在析构函数中，会把这些内存释放掉。</p><p>​    <code>pb</code>、<code>pd</code>分别是基类指针和派生类指针，它们都指向派生类对象，最后使用<code>delete</code> 销毁 <code>pb</code>、<code>pd</code> 所指向的对象。</p><p>​    从运行结果可以看出，语句<code>delete pb;</code>只调用了基类的析构函数，没有调用派生类的析构函数；而语句<code>delete pd;</code>同时调用了派生类和基类的析构函数。</p><p>​    <strong>在本例中，不调用派生类的析构函数会导致<code>name</code>指向的<code>100</code>个<code>char</code>类型的内存空间得不到释放；除非程序运行结束由操作系统回收，否则就再也没有机会释放这些内存。这是典型的内存泄露。</strong></p><p> 1) 为什么<code>delete pb;</code>不会调用派生类的析构函数呢？</p><p>​    因为这里的析构函数是非虚函数，<strong>通过指针访问非虚函数时，编译器会根据指针的类型来确定要调用的函数；也就是说，指针是哪个类就调用哪个类的函数</strong>，这在前面的章节中已经多次强调过。<code>pb</code> 是基类的指针，所以不管它指向基类的对象还是派生类的对象，始终都是调用基类的析构函数。</p><p> 2) 为什么<code>delete pd;</code>会同时调用派生类和基类的析构函数呢？</p><p>​    <code>pd</code>是派生类的指针，编译器会根据它的类型匹配到派生类的析构函数，在执行派生类的析构函数的过程中，又会调用基类的析构函数。派生类析构函数始终会调用基类的析构函数，并且这个过程是隐式完成的，</p><p>​    更改上面的代码，将基类的析构函数声明为虚函数： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base();</span><br><span class="line">    <span class="keyword">virtual</span> ~Base();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Derived constructor</span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br><span class="line">-------------------</span><br><span class="line">Base constructor</span><br><span class="line">Derived constructor</span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br></pre></td></tr></table></figure></p><p>​    将基类的析构函数声明为虚函数后，派生类的析构函数也会自动成为虚函数。这个时候编译器会忽略指针的类型，而根据指针的指向来选择函数；也就是说，指针指向哪个类的对象就调用哪个类的函数。<code>pb</code>、<code>pd</code> 都指向了派生类的对象，所以会调用派生类的析构函数，继而再调用基类的析构函数。如此一来也就解决了内存泄露的问题。</p><p>​    在实际开发中，一旦我们自己定义了析构函数，就是希望在对象销毁时用它来进行清理工作，比如释放内存、关闭文件等，如果这个类又是一个基类，那么我们就必须将该析构函数声明为虚函数，否则就有内存泄露的风险。</p><p>​    也就是说，<strong>大部分情况下都应该将基类的析构函数声明为虚函数。</strong></p><p>​    <strong>注意，这里强调的是基类，如果一个类是最终的类，那就没必要再声明为虚函数了。</strong></p><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>​    在<code>C++</code>中，可以将虚函数声明为<strong>纯虚函数</strong>，语法格式为： </p><blockquote><p><code>virtual</code> 返回值类型 函数名 (函数参数) = 0;</p></blockquote><p>​    纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上<code>=0</code>，表明此函数为纯虚函数。 </p><blockquote><p> 最后的<code>=0</code>并不表示函数返回值为<code>0</code>，它只起形式上的作用，告诉编译系统“这是纯虚函数”。</p></blockquote><p>​    包含纯虚函数的类称为<strong>抽象类（Abstract Class）</strong>。之所以说它抽象，是因为它无法实例化，也就是无法创建对象。原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。</p><p>​    <strong>抽象类通常是作为基类，让派生类去实现纯虚函数。派生类必须实现纯虚函数才能被实例化。</strong></p><pre><code>纯虚函数使用举例： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Line(<span class="keyword">float</span> len);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">volume</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> m_len;</span><br><span class="line">&#125;;</span><br><span class="line">Line::Line(<span class="keyword">float</span> len): m_len(len)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rec</span>:</span> <span class="keyword">public</span> Line&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rec(<span class="keyword">float</span> len, <span class="keyword">float</span> width);</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> m_width;</span><br><span class="line">&#125;;</span><br><span class="line">Rec::Rec(<span class="keyword">float</span> len, <span class="keyword">float</span> width): Line(len), m_width(width)&#123; &#125;</span><br><span class="line"><span class="keyword">float</span> Rec::area()&#123; <span class="keyword">return</span> m_len * m_width; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//长方体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cuboid</span>:</span> <span class="keyword">public</span> Rec&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cuboid(<span class="keyword">float</span> len, <span class="keyword">float</span> width, <span class="keyword">float</span> height);</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">volume</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> m_height;</span><br><span class="line">&#125;;</span><br><span class="line">Cuboid::Cuboid(<span class="keyword">float</span> len, <span class="keyword">float</span> width, <span class="keyword">float</span> height): Rec(len, width), m_height(height)&#123; &#125;</span><br><span class="line"><span class="keyword">float</span> Cuboid::area()&#123; <span class="keyword">return</span> <span class="number">2</span> * ( m_len*m_width + m_len*m_height + m_width*m_height); &#125;</span><br><span class="line"><span class="keyword">float</span> Cuboid::volume()&#123; <span class="keyword">return</span> m_len * m_width * m_height; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正方体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cube</span>:</span> <span class="keyword">public</span> Cuboid&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cube(<span class="keyword">float</span> len);</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">volume</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Cube::Cube(<span class="keyword">float</span> len): Cuboid(len, len, len)&#123; &#125;</span><br><span class="line"><span class="keyword">float</span> Cube::area()&#123; <span class="keyword">return</span> <span class="number">6</span> * m_len * m_len; &#125;</span><br><span class="line"><span class="keyword">float</span> Cube::volume()&#123; <span class="keyword">return</span> m_len * m_len * m_len; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Line *p = <span class="keyword">new</span> Cuboid(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"The area of Cuboid is "</span>&lt;&lt;p-&gt;area()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"The volume of Cuboid is "</span>&lt;&lt;p-&gt;volume()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">    p = <span class="keyword">new</span> Cube(<span class="number">15</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"The area of Cube is "</span>&lt;&lt;p-&gt;area()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"The volume of Cube is "</span>&lt;&lt;p-&gt;volume()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The area of Cuboid is <span class="number">2200</span></span><br><span class="line">The volume of Cuboid is <span class="number">6000</span></span><br><span class="line">The area of Cube is <span class="number">1350</span></span><br><span class="line">The volume of Cube is <span class="number">3375</span></span><br></pre></td></tr></table></figure></p><p>​        本例中定义了四个类，它们的继承关系为：<code>Line --&gt; Rec --&gt; Cuboid --&gt; Cube</code>。</p><p>​        <code>Line</code> 是一个抽象类，也是最顶层的基类，在<code>Line</code>类中定义了两个纯虚函数 <code>area()</code> 和 <code>volume()</code>。</p><p>​        在<code>Rec</code>类中，实现了<code>area()</code>函数；所谓实现，就是定义了纯虚函数的函数体。但这时<code>Rec</code>仍不能被实例化，因为它没有实现继承来的<code>volume()</code>函数，<code>volume()</code>仍然是纯虚函数，所以<code>Rec</code>也仍然是抽象类。</p><p>​        直到<code>Cuboid</code>类，才实现了<code>volume()</code>函数，才是一个完整的类，才可以被实例化。</p><p>​        可以发现，<code>Line</code>类表示“线”，没有面积和体积，但它仍然定义了<code>area()</code>和<code>volume()</code>两个纯虚函数。这样的用意很明显：<code>Line</code>类不需要被实例化，但是它为派生类提供了“约束条件”，派生类必须要实现这两个函数，完成计算面积和体积的功能，否则就不能实例化。</p><p>​        在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现（谁派生谁实现）。这部分未完成的功能，往往是基类不需要的，或者在基类中无法实现的。虽然抽象基类没有完成，但是却强制要求派生类完成，这就是抽象基类的“霸王条款”。</p><p>​        抽象基类除了约束派生类的功能，还可以实现多态。请注意第<code>51</code>行代码，指针<code>p</code>的类型是<code>Line</code>，但是它却可以访问派生类中的<code>area()</code>和<code>volume()</code> 函数，正是由于在<code>Line</code>类中将这两个函数定义为纯虚函数；如果不这样做，<code>51</code>行后面的代码都是错误的。我想，这或许才是<code>C++</code>提供纯虚函数的主要目的。</p><h3 id="纯虚函数的说明"><a href="#纯虚函数的说明" class="headerlink" title="纯虚函数的说明"></a>纯虚函数的说明</h3><p>​     1) 一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。</p><pre><code>2) 只有类中的虚函数才能被声明为**纯虚函数**，普通成员函数和顶层函数均不能声明为纯虚函数。如下例所示： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶层函数不能被声明为纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;   <span class="comment">//compile error</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="comment">//普通成员函数不能被声明为纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">//compile error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前面我们一再强调，当通过指针访问类的成员函数时： </p><ul><li><strong>如果该函数是非虚函数，那么编译器会根据指针的类型找到该函数；也就是说，指针是哪个类的类型就调用哪个类的函数。</strong></li><li><strong>如果该函数是虚函数，并且派生类有同名的函数遮蔽它，那么编译器会根据指针的指向找到该函数；也就是说，指针指向的对象属于哪个类就调用哪个类的函数。这就是多态。</strong></li></ul><p>​     </p><h2 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h2><p>​    编译器之所以能通过指针指向的对象找到虚函数，是因为在创建对象时额外地增加了虚函数表。</p><p>​    如果一个类包含了虚函数，那么在创建该类的对象时就会额外地增加一个数组，数组中的每一个元素都是虚函数的入口地址。不过数组和对象是分开存储的，为了将对象和数组关联起来，编译器还要在对象中安插一个指针，指向数组的起始位置。</p><p>​    这里的数组就是<strong>虚函数表（<code>Virtual function table</code>）</strong>，简写为<strong><code>vtable</code></strong>。</p><p>​    我们以下面的继承关系为例进行讲解： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//People类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    People(<span class="built_in">string</span> name, <span class="keyword">int</span> age);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eating</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line">People::People(<span class="built_in">string</span> name, <span class="keyword">int</span> age): m_name(name), m_age(age)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> People::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class People："</span>&lt;&lt;m_name&lt;&lt;<span class="string">"今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁了。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> People::eating()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class People：我正在吃饭，请不要跟我说话..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">examing</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line">Student::Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score):</span><br><span class="line">    People(name, age), m_score(score)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> Student::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class Student："</span>&lt;&lt;m_name&lt;&lt;<span class="string">"今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁了，考了"</span>&lt;&lt;m_score&lt;&lt;<span class="string">"分。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::examing()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class Student："</span>&lt;&lt;m_name&lt;&lt;<span class="string">"正在考试，请不要打扰T啊！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Senior类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Senior</span>:</span> <span class="keyword">public</span> Student&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Senior(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score, <span class="keyword">bool</span> hasJob);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">partying</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_hasJob;</span><br><span class="line">&#125;;</span><br><span class="line">Senior::Senior(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score, <span class="keyword">bool</span> hasJob):</span><br><span class="line">    Student(name, age, score), m_hasJob(hasJob)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> Senior::display()&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_hasJob)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class Senior："</span>&lt;&lt;m_name&lt;&lt;<span class="string">"以"</span>&lt;&lt;m_score&lt;&lt;<span class="string">"的成绩从大学毕业了，并且顺利找到了工作，Ta今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class Senior："</span>&lt;&lt;m_name&lt;&lt;<span class="string">"以"</span>&lt;&lt;m_score&lt;&lt;<span class="string">"的成绩从大学毕业了，不过找工作不顺利，Ta今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Senior::partying()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class Senior：快毕业了，大家都在吃散伙饭..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    People *p = <span class="keyword">new</span> People(<span class="string">"赵红"</span>, <span class="number">29</span>);</span><br><span class="line">    p -&gt; display();</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">new</span> Student(<span class="string">"王刚"</span>, <span class="number">16</span>, <span class="number">84.5</span>);</span><br><span class="line">    p -&gt; display();</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">new</span> Senior(<span class="string">"李智"</span>, <span class="number">22</span>, <span class="number">92.0</span>, <span class="literal">true</span>);</span><br><span class="line">    p -&gt; display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class People：赵红今年<span class="number">29</span>岁了。</span><br><span class="line">Class Student：王刚今年<span class="number">16</span>岁了，考了<span class="number">84.5</span>分。</span><br><span class="line">Class Senior：李智以<span class="number">92</span>的成绩从大学毕业了，并且顺利找到了工作，Ta今年<span class="number">22</span>岁。</span><br></pre></td></tr></table></figure></p><p> 各个类的对象内存模型如下所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-161029110543X5.jpg" alt></p><p>​        图中左半部分是对象占用的内存，右半部分是虚函数表 <code>vtable</code>。在对象的开头位置有一个指针 <code>vfptr</code>，指向虚函数表，并且这个指针始终位于对象的开头位置。</p><p>​        仔细观察虚函数表，可以发现基类的虚函数在 <code>vtable</code> 中的索引（下标）是固定的，不会随着继承层次的增加而改变，派生类新增的虚函数放在  <code>vtable</code> 的最后。如果派生类有同名的虚函数遮蔽（覆盖）了基类的虚函数，那么将使用派生类的虚函数替换基类的虚函数，这样具有遮蔽关系的虚函数在  <code>vtable</code> 中只会出现一次。</p><p>​        当通过指针调用虚函数时，先根据指针找到 <code>vfptr</code>，再根据 <code>vfptr</code> 找到虚函数的入口地址。以虚函数<code>display()</code>为例，它在 <code>vtable</code> 中的索引为<code>0</code>，通过<code>p</code> 调用时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; display();</span><br></pre></td></tr></table></figure></p><pre><code>编译器内部会发生类似下面的转换： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( *( *(p+<span class="number">0</span>) + <span class="number">0</span> ) )(p);</span><br></pre></td></tr></table></figure><p> 下面我们一步一步来分析这个表达式： </p><ul><li><code>0</code>是 <code>vfptr</code> 在对象中的偏移，<code>p+0</code>是 <code>vfptr</code> 的地址；</li><li><code>*(p+0)</code>是 <code>vfptr</code> 的值，而 <code>vfptr</code> 是指向 <code>vtable</code> 的指针，所以<code>*(p+0)</code>也就是 <code>vtable</code> 的地址；</li><li><code>display()</code>在 <code>vtable</code> 中的索引（下标）是<code>0</code>，所以<code>( *(p+0) + 0 )</code>也就是 <code>display()</code> 的地址；</li><li>知道了 <code>display()</code> 的地址，<code>( *( *(p+0) + 0 ) )(p)</code>也就是对 <code>display()</code> 的调用了，这里的 <code>p</code>就是传递的实参，它会赋值给<code>this</code>指针。</li></ul><p>​       可以看到，转换后的表达式是固定的，只要调用<code>display()</code>函数，不管它是哪个类的，都会使用这个表达式。换句话说，编译器不管<code>p</code>指向哪里，一律转换为相同的表达式。</p><p>​       转换后的表达式没有用到与 <code>p</code>的类型有关的信息，只要知道<code>p</code>的指向就可以调用函数，这跟名字编码（<code>Name Mangling</code>）算法有着本质上的区别。</p><p>​        再来看一下<code>eating()</code>函数，它在 <code>vtable</code> 中的索引为<code>1</code>，通过<code>p</code>调用时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; eating();</span><br></pre></td></tr></table></figure></p><pre><code>编译器内部会发生类似下面的转换： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( *( *(p+<span class="number">0</span>) + <span class="number">1</span> ) )(p);</span><br></pre></td></tr></table></figure><p>​        对于不同的虚函数，仅仅改变索引（下标）即可。</p><p>​        以上是针对单继承进行的讲解。当存在多继承时，虚函数表的结构就会变得复杂，尤其是有虚继承时，还会增加虚基类表，更加让人抓狂，这里我们就不分析了，有兴趣的读者可以自行研究。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++拷贝控制操作</title>
      <link href="/2018/07/23/c++%E5%B0%81%E8%A3%857-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/07/23/c++%E5%B0%81%E8%A3%857-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>  当定义一个类时，我们显式地或隐式地指定了此类型的对象在拷贝、赋值和销毁时做什么。一个类通过定义三种特殊的成员函数来控制这些操作，分别是拷贝构造函数、赋值运算符和析构函数。<br>  拷贝构造函数定义了当用同类型的另一个对象初始化新对象时做什么，赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么，析构函数定义了此类型的对象销毁时做什么。我们将这些操作称为拷贝控制操作。 </p><a id="more"></a><h2 id="拷贝控制操作"><a href="#拷贝控制操作" class="headerlink" title="拷贝控制操作"></a>拷贝控制操作</h2><blockquote><p> ​    由于拷贝控制操作是由三个特殊的成员函数来完成的，所以我们称此为“<code>C++</code>三法则”。在较新的<code>C++11</code>  标准中，为了支持移动语义，又增加了移动构造函数和移动赋值运算符，这样共有五个特殊的成员函数，所以又称为“<code>C++</code>五法则”。也就是说，“三法则”是针对较旧的<code>C++89</code>标准说的，“五法则”是针对较新的 <code>C++11</code>标准说的。为了统一称呼，后来人们干把它叫做“C++ 三/五法则”。</p></blockquote><p>​        如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义默认的操作，因此很多类会忽略这些拷贝控制操作。但是，对于一些持有其他资源（例如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等）的类来说，依赖这些默认的操作会导致灾难，我们必须显式的定义这些操作。</p><p>​        <code>C++</code>并不要求我们定义所有的这些操作，你可以只定义其中的一个或两个。但是，这些操作通常应该被看做一个整体，只需要定义其中一个操作，而不需要定义其他操作的情况很少见。 </p><h3 id="需要析构函数的类也需要拷贝和赋值操作"><a href="#需要析构函数的类也需要拷贝和赋值操作" class="headerlink" title="需要析构函数的类也需要拷贝和赋值操作"></a>需要析构函数的类也需要拷贝和赋值操作</h3><p>​        当我们决定是否要为一个类显式地定义拷贝构造函数和赋值运算符时，一个基本原则是首先确定这个类是否需要一个析构函数。通常，对析构函数的需求要比拷贝构造函数和赋值运算符的需求更加明显。<strong>如果一个类需要定义析构函数，那么几乎可以肯定这个类也需要一个拷贝构造函数和一个赋值运算符。</strong></p><p>​        我们在前面几节中使用过的<code>Array</code>类就是一个典型的例子。这个类在构造函数中动态地分配了一块内存，并用一个成员变量（指针变量）指向它，默认的析构函数不会释放这块内存，所以我们需要显式地定义一个析构函数来释放内存。</p><p>​        「应该怎么做」可能还是有点不清晰，但基本原则告诉我们，<code>Array</code>类也需要一个拷贝构造函数和一个赋值运算符。</p><p>​        如果我们为<code>Array</code>定义了一个析构函数，但却使用默认的拷贝构造函数和赋值运算符，那么将导致不同对象之间相互干扰，修改一个对象的数据会影响另外的对象。此外还可能会导致内存操作错误，请看下面的代码： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Array <span class="title">func</span><span class="params">(Array arr)</span></span>&#123;  <span class="comment">//按值传递，将发生拷贝</span></span><br><span class="line">    Array ret = arr;  <span class="comment">//发生拷贝</span></span><br><span class="line">    <span class="keyword">return</span> ret;  <span class="comment">//ret和arr将被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        当 <code>func()</code>返回时，<code>arr</code> 和 <code>ret</code>都会被销毁，在两个对象上都会调用析构函数，此析构函数会 <code>free()</code>掉 <code>m_p</code> 成员所指向的动态内存。但是，这两个对象的<code>m_p</code>成员指向的是同一块内存，所以该内存会被 <code>free()</code>  两次，这显然是一个错误，将要发生什么是未知的。</p><p>​         此外，<code>func()</code>的调用者还会继续使用传递给<code>func()</code>的对象： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Array <span class="title">arr1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">func(arr1);  <span class="comment">//当 func() 调用结束时，arr1.m_p 指向的内存被释放</span></span><br><span class="line">Array arr2 = arr1;  <span class="comment">//现在 arr2 和 arr1 都指向无效内存</span></span><br></pre></td></tr></table></figure><p>​         <code>arr2</code>（以及 <code>arr1</code>）指向的内存不再有效，在<code>arr</code>（以及 <code>ret</code>）被销毁时系统已经归还给操作系统了。</p><p>​        总之，如果一个类需要定义析构函数，那么几乎可以肯定它也需要定义拷贝构造函数和赋值运算符。 </p><h3 id="需要拷贝操作的类也需要赋值操作，反之亦然"><a href="#需要拷贝操作的类也需要赋值操作，反之亦然" class="headerlink" title="需要拷贝操作的类也需要赋值操作，反之亦然"></a>需要拷贝操作的类也需要赋值操作，反之亦然</h3><p>​        虽然很多类需要定义所有（或是不需要定义任何）拷贝控制成员，但某些类所要完成的工作，只需要拷贝或者赋值操作，不需要析构操作。</p><p>​        作为一个例子，考虑一个类为每个对象分配一个独有的、唯一的编号。这个类除了需要一个拷贝构造函数为每个新创建的对象生成一个新的编号，还需要一个赋值运算符来避免将一个对象的编号赋值给另外一个对象。但是，这个类并不需要析构函数。</p><p>​        这个例子引出了第二个基本原则：<strong>如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个赋值运算符；反之亦然。</strong>然而，无论需要拷贝构造函数还是需要复制运算符，都不必然意味着也需要析构函数。</p><h2 id="自定义类型转换"><a href="#自定义类型转换" class="headerlink" title="自定义类型转换"></a>自定义类型转换</h2><p>​    在<code>C/C++</code>中，不同的数据类型之间可以相互转换。<strong>无需用户指明如何转换的称为自动类型转换（隐式类型转换），需要用户显式地指明如何转换的称为强制类型转换。</strong></p><p>自动类型转换示例： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line">a = <span class="number">7.5</span> + a;</span><br></pre></td></tr></table></figure><p>​    编译器对<code>7.5</code>是作为<code>double</code>类型处理的，在求解表达式时，先将 <code>a</code>转换为<code>double</code>类型，然后与<code>7.5</code>相加，得到和为<code>13.5</code>。在向整型变量<code>a</code>赋值时，将<code>13.5</code>转换为整数<code>13</code>，然后赋给<code>a</code>。整个过程中，我们并没有告诉编译器如何去做，编译器使用内置的规则完成数据类型的转换。</p><p>​    强制类型转换示例： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;n;</span><br><span class="line"><span class="keyword">float</span> *p2 = (<span class="keyword">float</span>*)p1;</span><br></pre></td></tr></table></figure><p>​    <code>p1</code> 是<code>int *</code>类型，它指向的内存里面保存的是整数，<code>p2</code> 是<code>float *</code>类型，将 <code>p1</code> 赋值给 <code>p2</code>后，<code>p2</code>  也指向了这块内存，并把这块内存中的数据作为小数处理。我们知道，整数和小数的存储格式大相径庭，将整数作为小数处理非常荒诞，可能会引发莫名其妙的错误，所以编译器默认不允许将 <code>p1</code>赋值给<code>p2</code>。但是，使用强制类型转换后，编译器就认为我们知道这种风险的存在，并进行了适当的权衡，所以最终还是允许了这种行为。 </p><p>​    不管是自动类型转换还是强制类型转换，前提必须是编译器知道如何转换，例如，将小数转换为整数会抹掉小数点后面的数字，将<code>int *</code>转换为<code>float *</code>只是简单地复制指针的值，这些规则都是编译器内置的，我们并没有告诉编译器。</p><p>​        换句话说，如果编译器不知道转换规则就不能转换，使用强制类型也无用，请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);  <span class="comment">//友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">10.0</span>, <span class="number">20.0</span>)</span></span>;</span><br><span class="line">    a = (Complex)<span class="number">25.5</span>;  <span class="comment">//错误，转换失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <code>25.5</code>是实数，<code>a</code>是复数，将<code>25.5</code> 赋值给<code>a</code>后，我们期望<code>a</code>的实部变为<code>25.5</code>，而虚部为<code>0</code>。但是，编译器并不知道这个转换规则，这超出了编译器的处理能力，所以转换失败，即使加上强制类型转换也无用。</p><p>​        幸运的是，<strong><code>C++</code>允许我们自定义类型转换规则，用户可以将其它类型转换为当前类类型，也可以将当前类类型转换为其它类型。这种自定义的类型转换规则只能以类的成员函数的形式出现，换句话说，这种转换规则只适用于类。</strong></p><p>​        本节我们先讲解如何将其它类型转换为当前类类型，下节再讲解如何将当前类类型转换为其它类型。</p><h3 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h3><p>​        <strong>将其它类型转换为当前类类型需要借助转换构造函数（<code>Conversion constructor</code>）。</strong></p><p>​        转换构造函数也是一种构造函数，它遵循构造函数的一般规则。<strong>转换构造函数只有一个参数。</strong></p><p>​        仍然以<code>Complex</code>类为例，我们为它添加转换构造函数： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real): m_real(real), m_imag(<span class="number">0.0</span>)&#123; &#125;  <span class="comment">//转换构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);  <span class="comment">//友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">10.0</span>, <span class="number">20.0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    a = <span class="number">25.5</span>;  <span class="comment">//调用转换构造函数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>运行结果：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="number">20</span>i</span><br><span class="line"></span><br><span class="line"><span class="number">25.5</span> + <span class="number">0</span>i</span><br></pre></td></tr></table></figure><p>​        <code>Complex(double real);</code>就是转换构造函数，它的作用是将<code>double</code>类型的参数<code>real</code>转换成<code>Complex</code>类的对象，并将<code>real</code>作为复数的实部，将<code>0</code>作为复数的虚部。这样一来，<code>a = 25.5;</code>整体上的效果相当于：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.Complex(<span class="number">25.5</span>);</span><br></pre></td></tr></table></figure></p><p>​        将赋值的过程转换成了函数调用的过程。</p><p>​        在进行数学运算、赋值、拷贝等操作时，如果遇到类型不兼容、需要将<code>double</code>类型转换为<code>Complex</code>类型时，编译器会检索当前的类是否定义了转换构造函数，如果没有定义的话就转换失败，如果定义了的话就调用转换构造函数。</p><p>​        转换构造函数也是构造函数的一种，它除了可以用来将其它类型转换为当前类类型，还可以用来初始化对象，这是构造函数本来的意义。下面创建对象的方式是正确的： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">26.4</span>)</span></span>;  <span class="comment">//创建具名对象</span></span><br><span class="line">Complex c2 = <span class="number">240.3</span>;  <span class="comment">//以拷贝的方式初始化对象</span></span><br><span class="line">Complex(<span class="number">15.9</span>);  <span class="comment">//创建匿名对象</span></span><br><span class="line">c1 = Complex(<span class="number">46.9</span>);  <span class="comment">//创建一个匿名对象并将它赋值给 c1</span></span><br></pre></td></tr></table></figure><p>​        在以拷贝的方式初始化对象时，编译器先调用转换构造函数，将<code>240.3</code>转换为<code>Complex</code>类型（创建一个 <code>Complex</code>类的匿名对象），然后再拷贝给 <code>c2</code>。</p><p>​        如果已经对<code>+</code>运算符进行了重载，使之能进行两个<code>Complex</code>类对象的相加，那么下面的语句也是正确的： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">15.6</span>, <span class="number">89.9</span>)</span></span>;</span><br><span class="line">Complex c2;</span><br><span class="line">c2 = c1 + <span class="number">29.6</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;c2&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>​        在进行加法运算符时，编译器先将<code>29.6</code>转换为<code>Complex</code>类型（创建一个<code>Complex</code>类的匿名对象）再相加。</p><p>​        需要注意的是，为了获得目标类型，编译器会“不择手段”，会综合使用内置的转换规则和用户自定义的转换规则，并且会进行多级类型转换，例如： </p><ul><li>编译器会根据内置规则先将<code>int</code>转换为<code>double</code>，再根据用户自定义规则将<code>double</code>转换为 <code>Complex（int --&gt; double --&gt; Complex）</code>；</li><li>编译器会根据内置规则先将<code>char</code> 转换为<code>int</code>，再将<code>int</code>转换为<code>double</code>，最后根据用户自定义规则将<code>double</code>转换为 <code>Complex（char --&gt; int --&gt; double --&gt; Complex）</code>。</li></ul><p>​        从本例看，只要一个类型能转换为<code>double</code>类型，就能转换为<code>Complex</code>类型。请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Complex c1 = <span class="number">100</span>;  <span class="comment">//int --&gt; double --&gt; Complex</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c1 = <span class="string">'A'</span>;  <span class="comment">//char --&gt; int --&gt; double --&gt; Complex</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c1 = <span class="literal">true</span>;  <span class="comment">//bool --&gt; int --&gt; double --&gt; Complex</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">25.8</span>, <span class="number">0.7</span>)</span></span>;</span><br><span class="line">    <span class="comment">//假设已经重载了+运算符</span></span><br><span class="line">    c1 = c2 + <span class="string">'H'</span> + <span class="literal">true</span> + <span class="number">15</span>;  <span class="comment">//将char、bool、int都转换为Complex类型再运算</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> + <span class="number">0</span>i</span><br><span class="line"><span class="number">65</span> + <span class="number">0</span>i</span><br><span class="line"><span class="number">1</span> + <span class="number">0</span>i</span><br><span class="line"><span class="number">113.8</span> + <span class="number">0.7</span>i</span><br></pre></td></tr></table></figure></p><h4 id="再谈构造函数"><a href="#再谈构造函数" class="headerlink" title="再谈构造函数"></a>再谈构造函数</h4><p>​        构造函数的本意是在创建对象的时候初始化对象，编译器会根据传递的实参来匹配不同的（重载的）构造函数。回顾一下以前的章节，到目前为止我们已经学习了以下几种构造函数。</p><p>​    <strong>1) 默认构造函数。</strong>就是编译器自动生成的构造函数。以<code>Complex</code>类为例，它的原型为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex();  <span class="comment">//没有参数</span></span><br></pre></td></tr></table></figure></p><p>​    <strong>2) 普通构造函数。</strong>就是用户自定义的构造函数。以<code>Complex</code>类为例，它的原型为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag);  <span class="comment">//两个参数</span></span><br></pre></td></tr></table></figure></p><p>​    <strong>3) 拷贝构造函数。</strong>在以拷贝的方式初始化对象时调用。以<code>Complex</code>类为例，它的原型为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex(<span class="keyword">const</span> Complex &amp;c);</span><br></pre></td></tr></table></figure></p><p>​    <strong>4) 转换构造函数。</strong>将其它类型转换为当前类类型时调用。以<code>Complex</code>为例，它的原型为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex(<span class="keyword">double</span> real);</span><br></pre></td></tr></table></figure></p><p>​        不管哪一种构造函数，都能够用来初始化对象，这是构造函数的本意。假设<code>Complex</code>类定义了以上所有的构造函数，那么下面创建对象的方式都是正确的： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">()</span></span>;  <span class="comment">//调用Complex()</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">//调用Complex(double real, double imag)</span></span><br><span class="line"><span class="function">Complex <span class="title">c3</span><span class="params">(c2)</span></span>;  <span class="comment">//调用Complex(const Complex &amp;c)</span></span><br><span class="line"><span class="function">Complex <span class="title">c4</span><span class="params">(<span class="number">25.7</span>)</span></span>;  <span class="comment">//调用Complex(double real)</span></span><br></pre></td></tr></table></figure><p>​        这些代码都体现了构造函数的本意——在创建对象时初始化对象。</p><p>​        除了在创建对象时初始化对象，其他情况下也会调用构造函数，例如，以拷贝的的方式初始化对象时会调用拷贝构造函数，将其它类型转换为当前类类型时会调用转换构造函数。这些在其他情况下调用的构造函数，就成了特殊的构造函数了。特殊的构造函数并不一定能体现出构造函数的本意。 </p><h4 id="对Complex类的进一步精简"><a href="#对Complex类的进一步精简" class="headerlink" title="对Complex类的进一步精简"></a>对<code>Complex</code>类的进一步精简</h4><p>​        上面的<code>Complex</code>类中我们定义了三个构造函数，其中包括两个普通的构造函数和一个转换构造函数。其实，借助函数的默认参数，我们可以将这三个构造函数简化为一个，请看下面的代码： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);  <span class="comment">//友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">10.0</span>, <span class="number">20.0</span>)</span></span>;  <span class="comment">//向构造函数传递 2 个实参，不使用默认参数</span></span><br><span class="line">    <span class="function">Complex <span class="title">b</span><span class="params">(<span class="number">89.5</span>)</span></span>;  <span class="comment">//向构造函数传递 1 个实参，使用 1 个默认参数</span></span><br><span class="line">    Complex c;  <span class="comment">//不向构造函数传递实参，使用全部默认参数</span></span><br><span class="line">    a = <span class="number">25.5</span>;  <span class="comment">//调用转换构造函数（向构造函数传递 1 个实参，使用 1 个默认参数）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        精简后的构造函数包含了两个默认参数，在调用它时可以省略部分或者全部实参，也就是可以向它传递<code>0</code>个、<code>1</code>个、<code>2</code>个实参。转换构造函数就是包含了一个参数的构造函数，恰好能够和其他两个普通的构造函数“融合”在一起。</p><h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><p>​        转换构造函数能够将其它类型转换为当前类类型（例如将<code>double</code>类型转换为<code>Complex</code>类型），但是不能反过来将当前类类型转换为其它类型（例如将<code>Complex</code>类型转换为<code>double</code>类型）。</p><p>​        <code>C++</code>提供了<strong>类型转换函数</strong>（<code>Type conversion function</code>）来解决这个问题。<strong>类型转换函数的作用就是将当前类类型转换为其它类型，它只能以成员函数的形式出现，也就是只能出现在类中。</strong></p><p>​        类型转换函数的语法格式为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​        <code>operator</code>是<code>C++</code>关键字，<code>type</code>是要转换的目标类型，<code>data</code>是要返回的<code>type</code>类型的数据。</p><p>​        因为要转换的目标类型是<code>type</code>，所以返回值<code>data</code>也必须是<code>type</code>类型。既然已经知道了要返回<code>type</code>类型的数据，所以没有必要再像普通函数一样明确地给出返回值类型。这样做导致的结果是：<strong>类型转换函数看起来没有返回值类型，其实是隐式地指明了返回值类型。</strong></p><p>​        <strong>类型转换函数也没有参数，因为要将当前类的对象转换为其它类型，所以参数不言而喻。实际上编译器会把当前对象的地址赋值给<code>this</code>指针，这样在函数体内就可以操作当前对象了。</strong></p><p>​        【示例】为<code>Complex</code> 类添加类型转换函数，使得<code>Complex</code>类型能够转换为<code>double</code>类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//类型转换函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载+运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real + c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag + c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">24.6</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> f = c1;  <span class="comment">//相当于 double f = Complex::operator double(&amp;c1);</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"f = "</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    f = <span class="number">12.5</span> + c1 + <span class="number">6</span>;  <span class="comment">//相当于 f = 12.5 + Complex::operator double(&amp;c1) + 6;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"f = "</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n = Complex(<span class="number">43.2</span>, <span class="number">9.3</span>);  <span class="comment">//先转换为 double，再转换为 int</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"n = "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​        运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="number">24.6</span></span><br><span class="line">f = <span class="number">43.1</span></span><br><span class="line">n = <span class="number">43</span></span><br></pre></td></tr></table></figure></p><p>​        本例中，类型转换函数非常简单，就是返回成员变量<code>m_real</code>的值，所以建议写成<code>inline</code>的形式。</p><p>​        类型转换函数和运算符的重载非常相似，都使用<code>operator</code>关键字，因此也把类型转换函数称为类型转换运算符。</p><h4 id="关于类型转换函数的说明"><a href="#关于类型转换函数的说明" class="headerlink" title="关于类型转换函数的说明"></a>关于类型转换函数的说明</h4><p>​    1) <code>type</code>可以是内置类型、类类型以及由<code>typedef</code>定义的类型别名，任何可作为函数返回类型的类型（<code>void</code>除外）都能够被支持。一般而言，不允许转换为数组或函数类型，转换为指针类型或引用类型是可以的。</p><p>​    2) 类型转换函数一般不会更改被转换的对象，所以通常被定义为 <code>const</code> 成员。</p><p>​    3) 类型转换函数可以被继承，可以是虚函数。</p><p>​    4) 一个类虽然可以有多个类型转换函数（类似于函数重载），但是如果多个类型转换函数要转换的目标类型本身又可以相互转换（类型相近），那么有时候就会产生二义性。以<code>Complex</code>类为例，假设它有两个类型转换函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//转换为double类型</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">int</span>)m_real; &#125;  <span class="comment">//转换为int类型</span></span><br></pre></td></tr></table></figure></p><p>​    那么下面的写法就会引发二义性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">24.6</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">12.5</span> + c1;</span><br></pre></td></tr></table></figure></p><p>​        编译器可以调用<code>operator double()</code>将 <code>c1</code>转换为<code>double</code>类型，也可以调用<code>operator int()</code>将<code>c1</code>转换为<code>int</code>类型，这两种类型都可以跟<code>12.5</code>进行加法运算，并且从<code>Complex</code>转换为<code>double</code>与从<code>Complex</code>转化为<code>int</code>是平级的，没有谁的优先级更高，所以这个时候编译器就不知道该调用哪个函数了，干脆抛出一个二义性错误，让用户解决。</p><h4 id="转换构造函数和类型转换函数异同"><a href="#转换构造函数和类型转换函数异同" class="headerlink" title="转换构造函数和类型转换函数异同"></a>转换构造函数和类型转换函数异同</h4><p>​        转换构造函数和类型转换函数的作用是相反的：<strong>转换构造函数会将其它类型转换为当前类类型，类型转换函数会将当前类类型转换为其它类型。</strong>如果没有这两个函数，<code>Complex</code> 类和 <code>int</code>、<code>double</code>、<code>bool</code>等基本类型的四则运算、逻辑运算都将变得非常复杂，要编写大量的运算符重载函数。</p><p>​        但是，如果一个类同时存在这两个函数，就有可能产生二义性。下面以<code>Complex</code>类为例来演示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;  <span class="comment">//包含了转换构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//类型转换函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载+运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real + c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag + c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">24.6</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> f = c1;  <span class="comment">//①正确，调用类型转换函数</span></span><br><span class="line">    c1 = <span class="number">78.4</span>;  <span class="comment">//②正确，调用转换构造函数</span></span><br><span class="line">    f = <span class="number">12.5</span> + c1;  <span class="comment">//③错误，产生二义性</span></span><br><span class="line">    Complex c2 = c1 + <span class="number">46.7</span>;  <span class="comment">//④错误，产生二义性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    <code>①</code>和<code>②</code>是正确的，相信大家很容易理解。</p><p>​    对于<code>③</code>，进行加法运算时，有两种转换方案：</p><ul><li>第一种方案是先将<code>12.5</code>转换为<code>Complex</code>类型再运算，这样得到的结果也是<code>Complex</code>类型，再调用类型转换函数就可以赋值给<code>f</code>了。</li><li>第二种方案是先将<code>c1</code>转换为<code>double</code>类型再运算，这样得到的结果也是<code>double</code>类型，可以直接赋值给<code>f</code>。</li></ul><p>​      很多人会认为，既然<code>=</code>左边是<code>double</code>类型，很显然应该选择第二种方案，这样才符合“常理”。其实不然，编译器不会根据<code>=</code>左边的数据类型来选择转换方案，编译器只关注<code>12.5 + c1</code>这个表达式本身，站在这个角度考虑，上面的两种转换方案都可以，编译器不知道选择哪一种，所以会抛出二义性错误，让用户自己去解决。</p><p>​        当然，你也可以认为编译器不够智能，没有足够强大的上下文（周边环境）推导能力。反过来说，即使我们假设编译器会根据<code>=</code>左边的数据类型来选择解决方案，那仍然会存在二义性问题，下面就是一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">24.6</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;c1 + <span class="number">46.7</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>​        该语句没有将<code>c1 + 46.7</code>的结果赋值给其他变量，而是直接输出，这种情况应该将<code>c1</code> 转换成<code>double</code>类型呢，还是应该将<code>46.7</code>转换成 <code>Complex</code> 类型呢？很明显都可以，因为转换构造函数和类型转换函数是平级的，没有谁的优先级更高，所以该语句也会产生二义性错误。</p><p>​        解决二义性问题的办法也很简单粗暴，要么只使用转换构造函数，要么只使用类型转换函数。实践证明，用户对转换构造函数的需求往往更加强烈，这样能增加编码的灵活性，例如，可以将一个字符串字面量或者一个字符数组直接赋值给<code>string</code>类的对象，可以将一个<code>int</code>、<code>double</code>、<code>bool</code> 等基本类型的数据直接赋值给 <code>Complex</code>类的对象。</p><p>​        那么，如果我们想把当前类类型转换为其它类型怎么办呢？很简单，增加一个普通的成员函数即可，例如，<code>string</code>类使用<code>c_str()</code>函数转换为<code>C</code>风格的字符串，<code>complex</code>类使用<code>real()</code>和<code>imag()</code>函数来获取复数的实部和虚部。</p><p>​        <code>complex</code>是<code>C++</code>标准库中的复数类，<code>c</code>是小写的，使用时需要引入<code>complex</code>头文件。<code>Complex</code>是我们为了教学而自定义的复数类，<code>C</code>是大写的，<code>Complex</code>类尽量模拟<code>complex</code>类。</p><p>​        下面是重新编写的<code>Complex</code>类，该类只使用了转换构造函数，没有使用类型转换函数，取而代之的是 <code>real()</code> 和<code>imag()</code>两个普通成员函数。一个实用的 <code>Complex</code> 类能够进行四则运算和关系运算，需要重载 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>==</code>、<code>!=</code>这些运算符，不过作为教学演示，这里仅仅重载了 <code>+</code>、<code>+=</code>、<code>==</code>、<code>!=</code>运算符，其它运算符的重载与此类似。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//构造函数</span></span><br><span class="line">    Complex(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;  <span class="comment">//包含了转换构造函数</span></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//运算符重载</span></span><br><span class="line">    <span class="comment">//以全局函数的形式重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);</span><br><span class="line">    <span class="keyword">friend</span> istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;in, Complex &amp;c);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="comment">//以成员函数的形式重载</span></span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_real; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_imag; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载&lt;&lt;运算符</span></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;in, Complex &amp;c)&#123;</span><br><span class="line">    in &gt;&gt; c.m_real &gt;&gt; c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载+运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real + c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag + c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载+=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real += c.m_real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag += c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载==运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">if</span>( c1.m_real == c2.m_real &amp;&amp; c1.m_imag == c2.m_imag )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载!=运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">if</span>( c1.m_real != c2.m_real || c1.m_imag != c2.m_imag )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">12</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 = "</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先调用转换构造函数将 22.8 转换为 Complex 类型，再调用重载过的 + 运算符</span></span><br><span class="line">    Complex c2 = c1 + <span class="number">22.8</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c2 = "</span>&lt;&lt;c2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    Complex c3 = <span class="number">8.3</span> + c1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c3 = "</span>&lt;&lt;c3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先调用转换构造函数将 73 转换为 Complex 类型，再调用重载过的 += 运算符</span></span><br><span class="line">    <span class="function">Complex <span class="title">c4</span><span class="params">(<span class="number">4</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">    c4 += <span class="number">73</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c4 = "</span>&lt;&lt;c4&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用重载过的 += 运算符</span></span><br><span class="line">    <span class="function">Complex <span class="title">c5</span><span class="params">(<span class="number">14.6</span>, <span class="number">26.2</span>)</span></span>;</span><br><span class="line">    c5 += c1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c5 = "</span>&lt;&lt;c5&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//调用重载过的 == 运算符</span></span><br><span class="line">    <span class="keyword">if</span>(c1 == c2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 == c2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 != c2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//先调用转换构造函数将 77 转换为 Complex 类型，再调用重载过的 != 运算符</span></span><br><span class="line">    <span class="keyword">if</span>(c4 != <span class="number">77</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c4 != 77"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c4 == 77"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将 Complex 转换为 double，没有调用类型转换函数，而是调用了 real() 这个普通的成员函数</span></span><br><span class="line">    <span class="keyword">double</span> f = c5.real();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"f = "</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c1 = <span class="number">12</span> + <span class="number">60</span>i</span><br><span class="line">c2 = <span class="number">34.8</span> + <span class="number">60</span>i</span><br><span class="line">c3 = <span class="number">20.3</span> + <span class="number">60</span>i</span><br><span class="line">c4 = <span class="number">77</span> + <span class="number">19</span>i</span><br><span class="line">c5 = <span class="number">26.6</span> + <span class="number">86.2</span>i</span><br><span class="line">c1 != c2</span><br><span class="line">c4 != <span class="number">77</span></span><br><span class="line">f = <span class="number">26.6</span></span><br></pre></td></tr></table></figure><h3 id="类型转换的本质"><a href="#类型转换的本质" class="headerlink" title="类型转换的本质"></a>类型转换的本质</h3><p>​        在<code>C/C++</code>中，不同的数据类型之间可以相互转换：<strong>无需用户指明如何转换的称为自动类型转换（隐式类型转换），需要用户显式地指明如何转换的称为强制类型转换（显式类型转换）。</strong></p><p>​        隐式类型转换利用的是编译器内置的转换规则，或者用户自定义的转换构造函数以及类型转换函数（这些都可以认为是已知的转换规则），例如从<code>int</code>到 <code>double</code>、从派生类到基类、从<code>type *</code>到<code>void *</code>、从<code>double</code>到 <code>Complex</code>等。</p><p>​        <code>type *</code>是一个具体类型的指针，例如<code>int *</code>、<code>double *</code>、<code>Student *</code>等，它们都可以直接赋值给<code>void *</code>指针。而反过来是不行的，必须使用强制类型转换才能将<code>void *</code>转换为<code>type *</code>，例如，<code>malloc()</code> 分配内存后返回的就是一个<code>void *</code>指针，我们必须进行强制类型转换后才能赋值给指针变量。</p><p>​        当隐式转换不能完成类型转换工作时，我们就必须使用强制类型转换了。强制类型转换的语法也很简单，只需要在表达式的前面增加新类型的名称，格式为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(new_type) expression</span><br></pre></td></tr></table></figure></p><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>​        我们知道，数据是放在内存中的，变量（以及指针、引用）是给这块内存起的名字，有了变量就可以找到并使用这份数据。但问题是，该如何使用呢？</p><p>​        诸如数字、文字、符号、图形、音频、视频等数据都是以二进制形式存储在内存中的，它们并没有本质上的区别，那么，<code>00010000</code>该理解为数字<code>16</code>呢，还是图像中某个像素的颜色呢，还是要发出某个声音呢？如果没有特别指明，我们并不知道。也就是说，内存中的数据有多种解释方式，使用之前必须要确定。这种「确定数据的解释方式」的工作就是由数据类型（<code>Data Type</code>）来完成的。例如<code>int a;</code>表明，<code>a</code>这份数据是整数，不能理解为像素、声音、视频等。</p><p>​        顾名思义，数据类型用来说明数据的类型，确定了数据的解释方式，让计算机和程序员不会产生歧义。<code>C/C++</code>支持多种数据类型，包括内置类型（例如<code>int</code>、<code>double</code>、<code>bool</code>等）和自定义类型（结构体类型和类类型）。</p><p>​        <strong>所谓数据类型转换，就是对数据所占用的二进制位做出重新解释。</strong>如果有必要，在重新解释的同时还会修改数据，改变它的二进制位。<strong>对于隐式类型转换，编译器可以根据已知的转换规则来决定是否需要修改数据的二进制位；而对于强制类型转换，由于没有对应的转换规则，所以能做的事情仅仅是重新解释数据的二进制位，但无法对数据的二进制位做出修正。这就是隐式类型转换和强制类型转换最根本的区别。</strong></p><p>​        这里说的修改数据并不是修改原有的数据，而是修改它的副本（先将原有数据拷贝到另外一个地方再修改）。</p><p>​        修改数据的二进制位非常重要，它能把转换后的数据调整到正确的值，所以这种修改时常会发生，例如：</p><p>​    1) 整数和浮点数在内存中的存储形式大相径庭，将浮点数<code>f</code>赋值给整数<code>i</code>时，不能原样拷贝<code>f</code>的二进制位，也不能截取部分二进制位，必须先将<code>f</code>的二进制位读取出来，以浮点数的形式呈现，然后直接截掉小数部分，把剩下的整数部分再转换成二进制形式，拷贝到<code>i</code>所在的内存中。</p><p>​    2) <code>short</code>一般占用两个字节，<code>int</code>一般占用四个字节，将<code>short</code>类型的<code>s</code>赋值给<code>int</code>类型的<code>i</code>时，如果仅仅是将<code>s</code>的二进制位拷贝给<code>i</code>，那么<code>i</code>最后的两个字节会原样保留，这样会导致赋值结束后<code>i</code>的值并不等于<code>s</code>的值，所以这样做是错误的。正确的做法是，先给<code>s</code>添加<code>16</code>个二进制位（两个字节）并全部置为<code>0</code>，然后再拷贝给<code>i</code>所在的内存。</p><p>​    3) 当存在多重继承时，如果把派生类指针<code>pd</code>赋值给基类指针<code>pb</code>，就必须考虑基类子对象在派生类对象中的偏移，偏移不为<code>0</code>时就要调整<code>pd</code>的值，让它加上或减去偏移量，这样赋值后才能让<code>pb</code>恰好指向基类子对象。</p><p>​    4) <code>Complex</code>类型占用<code>16</code>个字节，<code>double</code>类型占用<code>8</code>个字节，将<code>double</code>类型的数据赋值给<code>Complex</code>类型的变量（对象）时，必须调用转换构造函数，否则剩下的<code>8</code>个字节就不知道如何填充了。</p><p>​        以上这些都是隐式类型转换，它对数据的调整都是有益的，能够让程序更加安全稳健地运行。</p><p>​        隐式类型转换必须使用已知的转换规则，虽然灵活性受到了限制，但是由于能够对数据进行恰当地调整，所以更加安全（几乎没有风险）。强制类型转换能够在更大范围的数据类型之间进行转换，例如不同类型指针（引用）之间的转换、从 <code>const</code>到非<code>const</code>的转换、从<code>int</code>到指针的转换（有些编译器也允许反过来）等，这虽然增加了灵活性，但是由于不能恰当地调整数据，所以也充满了风险，程序员要小心使用。</p><p>​        下面的代码演示了不同类型指针之间的转换所带来的风险：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>): m_a(a), m_b(b)&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//风险①：破坏类的封装性</span></span><br><span class="line">    Base *pb = <span class="keyword">new</span> Base(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">int</span> n = *((<span class="keyword">int</span>*)pb + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//风险②：进行无意义的操作</span></span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">56.2</span>;</span><br><span class="line">    <span class="keyword">int</span> *pi = (<span class="keyword">int</span>*)&amp;f;</span><br><span class="line">    *pi = <span class="number">-23</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line">NaN</span><br></pre></td></tr></table></figure></p><blockquote><p><code>NaN</code>是<code>“not a number”</code>的缩写，意思是“不是一个数字”。</p></blockquote><p>​        <code>Base</code>类有两个<code>private</code>属性的成员变量，原则上讲它们不能在类的外部访问，但是当把对象指针进行强制类型转换后，就突破了这种限制，破坏了类的封装性。</p><p>​        <code>f</code>是<code>float</code>类型的变量，用来存储浮点数，但是我们通过指针将一个整数直接放到了<code>f</code>所在的内存，由于整数和浮点数的存储格式不一样，所以直接放入一个整数毫无意义。</p><h4 id="为什么会有隐式类型转换和强制类型转换之分？"><a href="#为什么会有隐式类型转换和强制类型转换之分？" class="headerlink" title="为什么会有隐式类型转换和强制类型转换之分？"></a>为什么会有隐式类型转换和强制类型转换之分？</h4><p>​        隐式类型转换和显式类型转换最根本的区别是：<strong>隐式类型转换除了会重新解释数据的二进制位，还会利用已知的转换规则对数据进行恰当地调整；而显式类型转换只能简单粗暴地重新解释二进制位，不能对数据进行任何调整。</strong></p><p>​        其实，能不能对数据进行调整是显而易见地事情，有转换规则就可以调整，没有转换规则就不能调整，当进行数据类型转换时，编译器明摆着是知道有没有转换规则的。站在这个角度考虑，强制类型转换的语法就是多此一举，编译器完全可以自行判断是否需要调整数据。例如从<code>int *</code>转换到<code>float *</code>，加不加强制类型转换的语法都不能对数据进行调整。</p><p>​        <code>C/C++</code>之所以增加强制类型转换的语法，是为了提醒程序员这样做存在风险，一定要谨慎小心。说得通俗一点，你现在的类型转换存在风险，你自己一定要知道。</p><h4 id="强制类型转换也不是万能的"><a href="#强制类型转换也不是万能的" class="headerlink" title="强制类型转换也不是万能的"></a>强制类型转换也不是万能的</h4><p>​        类型转换只能发生在相关类型或者相近类型之间，两个毫不相干的类型不能相互转换，即使使用强制类型转换也不行。例如，两个没有继承关系的类不能相互转换，基类不能向派生类转换（向下转型），类类型不能向基本类型转换，指针和类类型之间不能相互转换。</p><p>​        下面的代码演示了不相干类型之间的转换：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123; &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    Base obj1;</span><br><span class="line">    Derived obj2;</span><br><span class="line"></span><br><span class="line">    a = (A)b;  <span class="comment">//Error: 两个没有继承关系的类不能相互转换</span></span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)a;  <span class="comment">//Error: 类类型不能向基本类型转换</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)b;  <span class="comment">//Error: 指针和类类型之间不能相互转换</span></span><br><span class="line">    obj2 = (Derived)obj1;  <span class="comment">//Error: 向下转型</span></span><br><span class="line">    obj1 = obj2;  <span class="comment">//Correct: 向上转型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++重载</title>
      <link href="/2018/07/20/c++%E5%B0%81%E8%A3%856-%E9%87%8D%E8%BD%BD/"/>
      <url>/2018/07/20/c++%E5%B0%81%E8%A3%856-%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>  所谓重载，就是赋予新的含义。<strong>函数重载（<code>Function Overloading</code>）</strong>可以让一个函数名有多种功能，在不同情况下进行不同的操作。<strong>运算符重载（<code>Operator Overloading</code>）</strong>也是一个道理，同一个运算符可以有不同的功能。函数重载的目的就是为了方便的使用函数名。</p><a id="more"></a><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="实现函数重载的条件"><a href="#实现函数重载的条件" class="headerlink" title="实现函数重载的条件"></a>实现函数重载的条件</h3><ul><li><p>同一个作用域</p></li><li><p>参数个数不同</p></li><li><p>参数类型不同</p></li><li><p>参数顺序不同  </p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 函数重载条件</span></span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"无参数!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">(<span class="built_in">string</span> b)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"b: "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">string</span> b)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="string">" b:"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">(<span class="built_in">string</span> b, <span class="keyword">int</span> a)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="string">" b:"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.返回值不作为函数重载依据</span></span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">(<span class="built_in">string</span> b, <span class="keyword">int</span> a)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//int MyFunc(string b, int a)&#123;&#125; //无法重载仅按返回值区分的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>注意:</strong> 函数重载和默认参数一起使用，需要额外注意二义性问题的产生。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">(<span class="built_in">string</span> b)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b: "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数重载碰上默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">(<span class="built_in">string</span> b, <span class="keyword">int</span> a = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="string">" b:"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">MyFunc(<span class="string">"hello"</span>); <span class="comment">//这时，两个函数都能匹配调用，产生二义性</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>思考：</strong>为什么函数返回值不作为重载条件呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"无返回值的func(int a ,double b)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值可以作为函数重载的条件吗？？？   不可以</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"有返回值的func(int a ,double b)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">func(<span class="number">1</span>, <span class="number">3.14</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    当编译器能从上下文中确定唯一的函数的时，如<code>int ret = func()</code>,这个当然是没有问题的。然而，我们在编写程序过程中可以忽略他的返回值。那么这个时候,一个函数<code>void func(int x)</code>;另一个为<code>int func(int x)</code>; 当我们直接调用<code>func(10)</code>,这个时候编译器就不确定调用那个函数。所以在<code>c++</code>中禁止使用返回值作为重载的条件。</p><p>​    <strong>注意:</strong> 引用<code>const</code>也是可以作为重载的条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用的重载版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> &amp;a)</span> <span class="comment">//引用必须要引合法的内存空间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" int &amp;a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span>  <span class="comment">//const也是可以作为重载的条件  int tmp = 10; const int &amp;a = tmp;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"const int &amp;a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">func3(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载实现原理"><a href="#函数重载实现原理" class="headerlink" title="函数重载实现原理"></a>函数重载实现原理</h3><p>​    编译器为了实现函数重载，也是默认为我们做了一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，比如<strong><code>void func()</code></strong>; 编译器可能会将函数名修饰成<strong><code>_func</code></strong>；当编译器碰到<strong><code>void func(int x)</code></strong>,编译器可能将函数名修饰为<strong><code>_func_int</code></strong>；当编译器碰到<strong><code>void func(int x,char c)</code></strong>,编译器可能会将函数名修饰为<strong><code>_func_int_char</code></strong>。</p><p>​    我这里使用”可能”这个字眼是因为编译器如何修饰重载的函数名称并没有一个统一的标准，所以不同的编译器可能会产生不同的内部名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">char</span> y)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上三个函数在linux下生成的编译之后的函数名为:</span></span><br><span class="line"></span><br><span class="line"> _Z4funcv <span class="comment">//v 代表void,无参数</span></span><br><span class="line">_Z4funci <span class="comment">//i 代表参数为int类型</span></span><br><span class="line">_Z4funcic <span class="comment">//i 代表第一个参数为int类型，第二个参数为char类型</span></span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="成员函数重载运算符"><a href="#成员函数重载运算符" class="headerlink" title="成员函数重载运算符"></a>成员函数重载运算符</h3><p>​        实际上，我们已经在不知不觉中使用了运算符重载。例如，<code>+</code>号可以对不同类型（<code>int</code>、<code>float</code>等）的数据进行加法操作；<code>&lt;&lt;</code>既是位移运算符，又可以配合 <code>cout</code> 向控制台输出数据。<code>C++</code>本身已经对这些运算符进行了重载。 <code>C++</code>也允许程序员自己重载运算符，这给我们带来了很大的便利。</p><p>​        下面的代码定义了一个复数类，通过运算符重载，可以用<code>+</code>号实现复数的加法运算： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">complex</span>();</span><br><span class="line">    <span class="keyword">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明运算符重载</span></span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">complex</span> &amp;A) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">complex</span>::<span class="keyword">complex</span>(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line"><span class="keyword">complex</span>::<span class="keyword">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现运算符重载</span></span><br><span class="line"><span class="keyword">complex</span> <span class="keyword">complex</span>::<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">complex</span> &amp;A) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">complex</span> B;</span><br><span class="line">    B.m_real = <span class="keyword">this</span>-&gt;m_real + A.m_real;</span><br><span class="line">    B.m_imag = <span class="keyword">this</span>-&gt;m_imag + A.m_imag;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">complex</span>::display() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_real&lt;&lt;<span class="string">" + "</span>&lt;&lt;m_imag&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">5.8</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">c2</span><span class="params">(<span class="number">2.4</span>, <span class="number">3.7</span>)</span></span>;</span><br><span class="line">    <span class="keyword">complex</span> c3;</span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    c3.display();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.7</span> + <span class="number">9.5</span>i</span><br></pre></td></tr></table></figure></p><p>​        本例中义了一个复数类<code>complex</code>，<code>m_real</code> 表示实部，<code>m_imag</code> 表示虚部，第<code>10</code>行声明了运算符重载，第<code>21</code>行进行了实现（定义）。认真观察这两行代码，可以发现运算符重载的形式与函数非常类似。</p><p>​        运算符重载其实就是定义一个函数，在函数体内实现想要的功能，当用到该运算符时，编译器会自动调用这个函数。也就是说，<strong>运算符重载是通过函数实现的，它本质上是函数重载</strong>。</p><p>​         运算符重载的格式为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 <span class="keyword">operator</span> 运算符名称 (形参表列)&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​        <code>operator</code>是关键字，专门用于定义重载运算符的函数。我们可以将<code>operator 运算符名称</code>这一部分看做函数名，对于上面的代码，函数名就是<code>operator+</code>。<strong>运算符重载函数除了函数名有特定的格式，其它地方和普通函数并没有区别</strong>。</p><p>​        上面的例子中，我们在<code>complex</code>类中重载了运算符<code>+</code>，该重载只对<code>complex</code>对象有效。当执行<code>c3 = c1 + c2;</code>语句时，编译器检测到<code>+</code>号左边（<code>+</code>号具有左结合性，所以先检测左边）是一个<code>complex</code>对象，就会调用成员函数<code>operator+()</code>，也就是转换为下面的形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c3 = c1.<span class="keyword">operator</span>+(c2);</span><br></pre></td></tr></table></figure></p><blockquote><p><code>c1</code> 是要调用函数的对象，<code>c2</code> 是函数的实参。</p></blockquote><p>​        上面的运算符重载还可以有更加简练的定义形式： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">complex</span> <span class="keyword">complex</span>::<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">complex</span> &amp;A)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">complex</span>(<span class="keyword">this</span>-&gt;m_real + A.m_real, <span class="keyword">this</span>-&gt;m_imag + A.m_imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <code>return</code>语句中的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">complex</span>(<span class="keyword">this</span>-&gt;m_real + A.m_real, <span class="keyword">this</span>-&gt;m_imag + A.m_imag)</span><br></pre></td></tr></table></figure><p>​        会创建一个临时对象，这个对象没有名称，是一个匿名对象。在创建临时对象过程中调用构造函数，<code>return</code>语句将该临时对象作为函数返回值。 </p><h3 id="全局范围内重载运算符"><a href="#全局范围内重载运算符" class="headerlink" title="全局范围内重载运算符"></a>全局范围内重载运算符</h3><p>​        运算符重载函数不仅可以作为类的成员函数，还可以作为全局函数。</p><p>​        更改上面的代码，在全局范围内重载<code>+</code>，实现复数的加法运算： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">complex</span>();</span><br><span class="line">    <span class="keyword">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//声明为友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">complex</span> &amp;A, <span class="keyword">const</span> <span class="keyword">complex</span> &amp;B);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;</span><br><span class="line">    <span class="keyword">double</span> m_imag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">complex</span> &amp;A, <span class="keyword">const</span> <span class="keyword">complex</span> &amp;B);</span><br><span class="line"></span><br><span class="line"><span class="keyword">complex</span>::<span class="keyword">complex</span>(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line"><span class="keyword">complex</span>::<span class="keyword">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">complex</span>::display() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_real&lt;&lt;<span class="string">" + "</span>&lt;&lt;m_imag&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在全局范围内重载+</span></span><br><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">complex</span> &amp;A, <span class="keyword">const</span> <span class="keyword">complex</span> &amp;B)&#123;</span><br><span class="line">    <span class="keyword">complex</span> C;</span><br><span class="line">    C.m_real = A.m_real + B.m_real;</span><br><span class="line">    C.m_imag = A.m_imag + B.m_imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">5.8</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">c2</span><span class="params">(<span class="number">2.4</span>, <span class="number">3.7</span>)</span></span>;</span><br><span class="line">    <span class="keyword">complex</span> c3;</span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    c3.display();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        运算符重载函数不是 <code>complex</code>类的成员函数，但是却用到了<code>complex</code>类的<code>private</code>成员变量，所以必须在<code>complex</code>类中将该函数声明为友元函数。</p><p>​        当执行<code>c3 = c1 + c2;</code>语句时，编译器检测到<code>+</code>号两边都是<code>complex</code>对象，就会转换为类似下面的函数调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c3 = <span class="keyword">operator</span>+(c1, c2);</span><br></pre></td></tr></table></figure></p><h3 id="运算符重载注意事项"><a href="#运算符重载注意事项" class="headerlink" title="运算符重载注意事项"></a>运算符重载注意事项</h3><p>​        <strong>运算符重载</strong>是通过函数重载实现的，概念上大家都很容易理解，这节我们来说一下运算符重载的注意事项。</p><pre><code>**(1) 并不是所有的运算符都可以重载。**能够重载的运算符包括：</code></pre><p>​        <code>\+  -  *  /  %  ^  &amp;  |  ~  !  =  &lt;  &gt;  +=  -=  *=  /=  %=  ^=   &amp;=  |=  &lt;&lt;  &gt;&gt;  &lt;&lt;=  &gt;&gt;=  ==  !=  &lt;=   &gt;=  &amp;&amp;  ||  ++  --  ,  -&gt;*  -&gt;  ()  []  new  new[]   delete  delete[]</code></p><p>​        上述运算符中，<code>[]</code>是下标运算符，<code>()</code>是函数调用运算符。自增自减运算符的前置和后置形式都可以重载。长度运算符<code>sizeof</code>、条件运算符<code>: ?</code>、成员选择符<code>.</code>和域解析运算符<code>::</code>不能被重载。</p><pre><code>**(2) 重载不能改变运算符的优先级和结合性。**假设上一节的` complex `类中重载了`+`号和`*`·号，并且 `c1`、`c2`、`c3`、`c4` 都是` complex `类的对象，那么下面的语句： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c4 = c1 + c2 * c3;</span><br></pre></td></tr></table></figure><p>​     等价于：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c4 = c1 + ( c2 * c3 );</span><br></pre></td></tr></table></figure></p><p>​     乘法的优先级仍然高于加法，并且它们仍然是二元运算符。</p><pre><code>**(3) 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变。**例如`~`号右边只有一个操作数，`+`号总是出现在两个操作数之间，重载后也必须如此。**(4) 运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的。**</code></pre><p>​    <strong>(5) 运算符重载函数既可以作为类的成员函数，也可以作为全局函数。将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数</strong>。之所以少一个参数，是因为这个参数是隐含的。</p><p>​     例如，上节的 complex 类中重载了加法运算符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">complex</span> &amp; A) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure></p><p>​     当执行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c3 = c1 + c2;</span><br></pre></td></tr></table></figure></p><p>​     会被转换为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c3 = c1.<span class="keyword">operator</span>+(c2);</span><br></pre></td></tr></table></figure></p><p>​    通过<code>this</code>指针隐式的访问 <code>c1</code> 的成员变量。</p><p>​        <strong>将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要一个参数，而且其中必须有一个参数是对象，好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质</strong>。</p><p> 例如，下面这样是不对的： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span> + (<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> (a-b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <code>+</code>号原来是对两个数相加，现在企图通过重载使它的作用改为两个数相减， 如果允许这样重载的话，那么表达式<code>4+3</code>的结果是<code>7</code>还是<code>1</code>呢？显然，这是绝对禁止的。</p><p>​        如果有两个参数，这两个参数可以都是对象，也可以一个是对象，一个是<code>C ++</code>内置类型的数据，例如： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">int</span> a, <span class="keyword">complex</span> &amp;c)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">complex</span>(a+c.real, c.imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        它的作用是使一个整数和一个复数相加。另外，<strong>将运算符重载函数作为全局函数时，一般都需要在类中将该函数声明为友元函数。原因很简单，该函数大部分情况下都需要使用类的<code>private</code>成员。</strong></p><p>​        上节的最后一个例子中，我们在全局范围内重载了<code>+</code>号，并在<code>complex</code>类中将运算符重载函数声明为友元函数，因为该函数使用到了<code>complex</code>类的 <code>m_real</code> 和 <code>m_imag</code> 两个成员变量，它们都是<code>private</code>属性的，默认不能在类的外部访问。</p><p>​     <strong>(6) 箭头运算符<code>-&gt;</code>、下标运算符<code>[ ]</code>、函数调用运算符<code>( )</code>、赋值运算符<code>=</code>只能以成员函数的形式重载。</strong></p><h3 id="重载数学运算符"><a href="#重载数学运算符" class="headerlink" title="重载数学运算符"></a>重载数学运算符</h3><p>​        四则运算符（<code>+、-、*、/、+=、-=、*=、/=</code>）和关系运算符（<code>&gt;、&lt;、&lt;=、&gt;=、==、!=</code>）都是数学运算符，它们在实际开发中非常常见，被重载的几率也很高，并且有着相似的重载格式。本节以复数类<code>Complex</code>为例对它们进行重载，重在演示运算符重载的语法以及规范。</p><p>​        复数能够进行完整的四则运算，但不能进行完整的关系运算：我们只能判断两个复数是否相等，但不能比较它们的大小，所以不能对<code>&gt;</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;=</code>进行重载。下面是具体的代码： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//构造函数</span></span><br><span class="line">    Complex(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//运算符重载</span></span><br><span class="line">    <span class="comment">//以全局函数的形式重载</span></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>/(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="comment">//以成员函数的形式重载</span></span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>-=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>/=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_real; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_imag; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载+运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real + c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag + c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载-运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real - c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag - c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*运算符  (a+bi) * (c+di) = (ac-bd) + (bc+ad)i</span></span><br><span class="line">Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real * c2.m_real - c1.m_imag * c2.m_imag;</span><br><span class="line">    c.m_imag = c1.m_imag * c2.m_real + c1.m_real * c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载/运算符  (a+bi) / (c+di) = [(ac+bd) / (c²+d²)] + [(bc-ad) / (c²+d²)]i</span></span><br><span class="line">Complex <span class="keyword">operator</span>/(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = (c1.m_real*c2.m_real + c1.m_imag*c2.m_imag) / (<span class="built_in">pow</span>(c2.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c2.m_imag, <span class="number">2</span>));</span><br><span class="line">    c.m_imag = (c1.m_imag*c2.m_real - c1.m_real*c2.m_imag) / (<span class="built_in">pow</span>(c2.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c2.m_imag, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载==运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">if</span>( c1.m_real == c2.m_real &amp;&amp; c1.m_imag == c2.m_imag )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载!=运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">if</span>( c1.m_real != c2.m_real || c1.m_imag != c2.m_imag )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载+=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real += c.m_real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag += c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载-=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>-=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real -= c.m_real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag -= c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real = <span class="keyword">this</span>-&gt;m_real * c.m_real - <span class="keyword">this</span>-&gt;m_imag * c.m_imag;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag = <span class="keyword">this</span>-&gt;m_imag * c.m_real + <span class="keyword">this</span>-&gt;m_real * c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载/=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>/=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real = (<span class="keyword">this</span>-&gt;m_real*c.m_real + <span class="keyword">this</span>-&gt;m_imag*c.m_imag) / (<span class="built_in">pow</span>(c.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c.m_imag, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag = (<span class="keyword">this</span>-&gt;m_imag*c.m_real - <span class="keyword">this</span>-&gt;m_real*c.m_imag) / (<span class="built_in">pow</span>(c.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c.m_imag, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">25</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c4</span><span class="params">(<span class="number">4</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c5</span><span class="params">(<span class="number">34</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c6</span><span class="params">(<span class="number">80</span>, <span class="number">90</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">    Complex c7 = c1 + c2;</span><br><span class="line">    Complex c8 = c1 - c2;</span><br><span class="line">    Complex c9 = c1 * c2;</span><br><span class="line">    Complex c10 = c1 / c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c7 = "</span>&lt;&lt;c7.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c7.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c8 = "</span>&lt;&lt;c8.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c8.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c9 = "</span>&lt;&lt;c9.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c9.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c10 = "</span>&lt;&lt;c10.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c10.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    c3 += c1;</span><br><span class="line">    c4 -= c2;</span><br><span class="line">    c5 *= c2;</span><br><span class="line">    c6 /= c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c3 = "</span>&lt;&lt;c3.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c3.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c4 = "</span>&lt;&lt;c4.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c4.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c5 = "</span>&lt;&lt;c5.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c5.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c6 = "</span>&lt;&lt;c6.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c6.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(c1 == c2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 == c2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c1 != c2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 != c2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c7 = <span class="number">35</span> + <span class="number">55</span>i</span><br><span class="line">c8 = <span class="number">15</span> + <span class="number">15</span>i</span><br><span class="line">c9 = <span class="number">-450</span> + <span class="number">850</span>i</span><br><span class="line">c10 = <span class="number">1.9</span> + <span class="number">-0.3</span>i</span><br><span class="line">c3 = <span class="number">26</span> + <span class="number">37</span>i</span><br><span class="line">c4 = <span class="number">-6</span> + <span class="number">-11</span>i</span><br><span class="line">c5 = <span class="number">220</span> + <span class="number">4460</span>i</span><br><span class="line">c6 = <span class="number">5.2</span> + <span class="number">1.592</span>i</span><br><span class="line">c1 != c2</span><br></pre></td></tr></table></figure></p><p>​        需要注意的是，我们以全局函数的形式重载了<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>==</code>、<code>!=</code>，以成员函数的形式重载了 <code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>，而且应该坚持这样做，不能一股脑都写作成员函数或者全局函数，具体原因我们将在下节讲解。</p><h3 id="简单地了解转换构造函数"><a href="#简单地了解转换构造函数" class="headerlink" title="简单地了解转换构造函数"></a>简单地了解转换构造函数</h3><p>​        在上节的例子中，我们以全局函数的形式重载了<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>==</code>、<code>!=</code>，以成员函数的形式重载了 <code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>，而没有一股脑都写成全局函数或者成员函数，这样做是有原因的，这节我们就来分析一下。</p><p>​        在分析以前，我们先来了解一个概念，叫做「转换构造函数」。</p><p>请大家先看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real): m_real(real), m_imag(<span class="number">0.0</span>)&#123; &#125;  <span class="comment">//转换构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_real; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_imag; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载+运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real + c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag + c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">25</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    Complex c2 = c1 + <span class="number">15.6</span>;</span><br><span class="line">    Complex c3 = <span class="number">28.23</span> + c1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c2.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c2.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c3.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c3.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>运行结果：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">40.6</span> + <span class="number">35</span>i</span><br><span class="line"><span class="number">53.23</span> + <span class="number">35</span>i</span><br></pre></td></tr></table></figure><p>​        请读者留意第<code>30</code>、<code>31</code>行代码，它说明<code>Complex</code>类型可以和 <code>double</code>类型相加，这很奇怪，因为我们并没有对针对这两个类型重载<code>+</code>，这究竟是怎么做到的呢？</p><p>​        其实，编译器在检测到<code>Complex</code>和<code>double</code>（小数默认为<code>double</code>类型）相加时，会先尝试将<code>double</code>转换为<code>Complex</code>，或者反过来将<code>Complex</code>转换为<code>double</code>（只有类型相同的数据才能进行<code>+</code>运算），如果都转换失败，或者都转换成功（产生了二义性），才报错。本例中，编译器会先通过构造函数<code>Complex(double real);</code>将<code>double</code>转换为<code>Complex</code>，再调用重载过的<code>+</code>进行计算，整个过程类似于下面的形式：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1F20910091BJ.png" alt></p><p>​        也就是说，小数被转换成了匿名的<code>Complex</code>对象。在这个转换过程中，构造函数<code>Complex(double real);</code>起到了至关重要的作用，如果没有它，转换就会失败，<code>Complex</code>也不能和<code>double</code>相加。</p><p>​        <strong><code>Complex(double real);</code>在作为普通构造函数的同时，还能将  <code>double</code> 类型转换为 <code>Complex</code>  类型，集合了“构造函数”和“类型转换”的功能，所以被称为「转换构造函数」。换句话说，转换构造函数用来将其它类型（可以是  <code>bool</code>、<code>int</code>、<code>double</code> 等基本类型，也可以是数组、指针、结构体、类等构造类型）转换为当前类类型。</strong></p><h3 id="为什么要以全局函数的形式重载"><a href="#为什么要以全局函数的形式重载" class="headerlink" title="为什么要以全局函数的形式重载 +"></a>为什么要以全局函数的形式重载 <code>+</code></h3><p>​        上面的例子中，我们定义的<code>operator+</code>是一个全局函数（一个友元函数），而不是成员函数，<strong>这样做是为了保证<code>+</code>运算符的操作数能够被对称的处理</strong>；换句话说，小数（<code>double</code>类型）在<code>+</code>左边和右边都是正确的。第<code>30</code>行代码中，<code>15.6</code>在<code>+</code>的右边，第<code>31</code>行代码中，<code>28.23</code>在<code>+</code>的左边，它们都能够被顺利地转换为 <code>Complex</code>类型，所以不会出错。</p><p>​        如果将<code>operator+</code>定义为成员函数，根据<code>“+ 运算符具有左结合性”</code>这条原则，<code>Complex c2 = c1 + 15.6;</code>会被转换为下面的形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex c2 = c1.<span class="keyword">operator</span>+(Complex(<span class="number">15.6</span>));</span><br></pre></td></tr></table></figure></p><p>​        这就是通过对象调用成员函数，是正确的。而对于<code>Complex c3 = 28.23 + c1;</code>，编译器会尝试转换为不同的形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex c3 = (<span class="number">28.23</span>).<span class="keyword">operator</span>+(c1);</span><br></pre></td></tr></table></figure></p><p>​        很显然这是错误的，因为<code>double</code>类型并没有以成员函数的形式重载 <code>+</code>。也就是说，以成员函数的形式重载<code>+</code>，只能计算<code>c1 + 15.6</code>，不能计算<code>28.23 + c1</code>，这是不对称的</p><p>​        有读者可能会问，编译器明明可以把<code>28.23</code>先转换成<code>Complex</code>类型再相加呀，也就是下面的形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex c3 = Complex(<span class="number">28.23</span>).<span class="keyword">operator</span>+(c1);</span><br></pre></td></tr></table></figure></p><p>​        为什么就是不转换呢？没错，编译器不会转换，原因在于，<strong><code>C++</code>只会对成员函数的参数进行类型转换，而不会对调用成员函数的对象进行类型转换</strong>。以下面的语句为例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.func(params);</span><br></pre></td></tr></table></figure></p><p>​        编译器不会尝试对<code>obj</code>进行任何类型转换，它有 <code>func()</code> 成员函数就调用，没有就报错。而对于实参 <code>params</code>，编译器会“拼命地”将它转换为形参的类型。</p><h3 id="为什么要以成员函数的形式重载"><a href="#为什么要以成员函数的形式重载" class="headerlink" title="为什么要以成员函数的形式重载+="></a>为什么要以成员函数的形式重载<code>+=</code></h3><p>​        <strong>我们首先要明白，运算符重载的初衷是给类添加新的功能，方便类的运算，它作为类的成员函数是理所应当的，是首选的。</strong></p><p>​        不过，类的成员函数不能对称地处理数据，程序员必须在（参与运算的）所有类型的内部都重载当前的运算符。以上面的情况为例，我们必须在<code>Complex</code>和<code>double</code>内部都重载<code>+</code>运算符，这样做不但会增加运算符重载的数目，还要在许多地方修改代码，这显然不是我们所希望的，所以<code>C++</code> 进行了折中，允许以全局函数（友元函数）的形式重载运算符。</p><p>​        <code>C++</code>创始人 <code>Bjarne Stroustrup</code> 也曾考虑过为内部类型（<code>bool</code>、<code>int</code>、<code>double</code>  等）定义额外运算符的问题，但后来还是放弃了这种想法，因为 <code>Bjarne Stroustrup</code> 不希望改变现有规则：<strong>任何类型（无论是内部类型还是用户自定义类型）都不能在其定义完成以后再增加额外的操作。</strong>这里还有另外的一个原因，<code>C</code>内部类型之间的转换已经够肮脏了，决不能再向里面添乱。而通过成员函数为已存在的类型提供混合运算的方式，从本质上看，比我们所采用的全局函数（友元函数）加转换构造函数的方式还要肮脏许多。</p><p>​        <strong>采用全局函数能使我们定义这样的运算符，它们的参数具有逻辑的对称性。与此相对应的，把运算符定义为成员函数能够保证在调用时对第一个（最左的）运算对象不出现类型转换，也就是上面提到的「<code>C++</code>不会对调用成员函数的对象进行类型转换」。</strong></p><p>​        总起来说，<strong>有一部分运算符重载既可以是成员函数也可以是全局函数，虽然没有一个必然的、不可抗拒的理由选择成员函数，但我们应该优先考虑成员函数，这样更符合运算符重载的初衷；另外有一部分运算符重载必须是全局函数，这样能保证参数的对称性；除了<code>C++</code>规定的几个特定的运算符外，暂时还没有发现必须以成员函数的形式重载的运算符。 </strong></p><blockquote><p> <code>C++</code>规定，箭头运算符<code>-&gt;</code>、下标运算符<code>[ ]</code>、函数调用运算符<code>( )</code>、赋值运算符<code>=</code>只能以成员函数的形式重载。</p></blockquote><h3 id="自增自减-运算符重载"><a href="#自增自减-运算符重载" class="headerlink" title="自增自减(++/--)运算符重载"></a>自增自减(<code>++/--</code>)运算符重载</h3><p>​        重载的<code>++</code>和<code>--</code>运算符有点让人不知所措，因为我们总是希望能根据它们出现在所作用对象的前面还是后面来调用不同的函数。解决办法很简单，例如当编译器看到<code>++a</code>(前置<code>++</code>)，它就调用<code>operator++(a)</code>,当编译器看到<code>a++</code>（后置<code>++</code>），它就会去调用<code>operator++(a,int)</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,Complex&amp; <span class="keyword">complex</span>)&#123;</span><br><span class="line">os &lt;&lt; <span class="string">"A:"</span> &lt;&lt; <span class="keyword">complex</span>.mA &lt;&lt; <span class="string">" B:"</span> &lt;&lt; <span class="keyword">complex</span>.mB &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Complex()&#123;</span><br><span class="line">mA = <span class="number">0</span>;</span><br><span class="line">mB = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载前置++</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">mA++;</span><br><span class="line">mB++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载后置++</span></span><br><span class="line">Complex <span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">Complex temp;</span><br><span class="line">temp.mA = <span class="keyword">this</span>-&gt;mA;</span><br><span class="line">temp.mB = <span class="keyword">this</span>-&gt;mB;</span><br><span class="line">mA++;</span><br><span class="line">mB++;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置--</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">mA--;</span><br><span class="line">mB--;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置--</span></span><br><span class="line">Complex <span class="keyword">operator</span>--(<span class="keyword">int</span>)&#123;</span><br><span class="line">Complex temp;</span><br><span class="line">temp.mA = mA;</span><br><span class="line">temp.mB = mB;</span><br><span class="line">mA--;</span><br><span class="line">mB--;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowComplex</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"A:"</span> &lt;&lt; mA &lt;&lt; <span class="string">" B:"</span> &lt;&lt; mB &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> mA;</span><br><span class="line"><span class="keyword">int</span> mB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Complex <span class="keyword">complex</span>;</span><br><span class="line"><span class="keyword">complex</span>++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">complex</span>;</span><br><span class="line">++<span class="keyword">complex</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">complex</span>;</span><br><span class="line"></span><br><span class="line">Complex ret = <span class="keyword">complex</span>++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ret;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">complex</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ret--;</span><br><span class="line">--ret;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ret:"</span> &lt;&lt; ret;</span><br><span class="line"><span class="keyword">complex</span>--;</span><br><span class="line">--<span class="keyword">complex</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"complex:"</span> &lt;&lt; <span class="keyword">complex</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>优先使用<code>++</code>和<code>--</code>的标准形式，优先调用前置<code>++</code>。</strong></p><p>​    如果定义了<code>++c</code>，也要定义<code>c++</code>，递增操作符比较麻烦，因为他们都有前缀和后缀形式，而两种语义略有不同。重载<code>operator++</code>和<code>operator--</code>时应该模仿他们对应的内置操作符。</p><p>​    对于<code>++</code>和<code>--</code>而言，后置形式是先返回，然后对象<code>++</code>或者<code>--</code>，返回的是对象的原值。前置形式，对象先<code>++</code>或<code>--</code>，返回当前对象，返回的是新对象。其标准形式为:</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/4312432.png" alt></p><p>​    调用代码时候，要优先使用前缀形式，除非确实需要后缀形式返回的原值，前缀和后缀形式语义上是等价的，输入工作量也相当，只是效率经常会略高一些，由于前缀形式少创建了一个临时对象。</p><h3 id="指针运算符-、-gt-重载"><a href="#指针运算符-、-gt-重载" class="headerlink" title="指针运算符(*、-&gt;)重载"></a>指针运算符(<code>*</code>、<code>-&gt;</code>)重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="keyword">int</span> param)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mParam = param;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Param:"</span> &lt;&lt; mParam &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPointer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SmartPointer(Person* person)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pPerson = person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载指针的-&gt;、*操作符</span></span><br><span class="line">Person* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line"><span class="keyword">return</span> pPerson;</span><br><span class="line">&#125;</span><br><span class="line">Person&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line"><span class="keyword">return</span> *pPerson;</span><br><span class="line">&#125;</span><br><span class="line">~SmartPointer()&#123;</span><br><span class="line"><span class="keyword">if</span> (pPerson != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">delete</span> pPerson;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person* pPerson;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person* person = new Person(100);</span></span><br><span class="line"><span class="comment">//如果忘记释放，那么就会造成内存泄漏</span></span><br><span class="line"></span><br><span class="line"><span class="function">SmartPointer <span class="title">pointer</span><span class="params">(<span class="keyword">new</span> Person(<span class="number">100</span>))</span></span>;</span><br><span class="line">pointer-&gt;PrintPerson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赋值-运算符重载"><a href="#赋值-运算符重载" class="headerlink" title="赋值(=)运算符重载"></a>赋值(<code>=</code>)运算符重载</h3><p>​    赋值符常常初学者的混淆。这是毫无疑问的，因为<code>’=’</code>在编程中是最基本的运算符，可以进行赋值操作，也能引起拷贝构造函数的调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="keyword">const</span> Person&amp; person)&#123;</span><br><span class="line">os &lt;&lt; <span class="string">"ID:"</span> &lt;&lt; person.mID &lt;&lt; <span class="string">" Age:"</span> &lt;&lt; person.mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="keyword">int</span> id,<span class="keyword">int</span> age)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mID = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载赋值运算符</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Person&amp; person)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mID = person.mID;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = person.mAge;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> mID;</span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. =号混淆的地方</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">person1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">Person person2 = person1; <span class="comment">//调用拷贝构造</span></span><br><span class="line"><span class="comment">//如果一个对象还没有被创建，则必须初始化，也就是调用构造函数</span></span><br><span class="line"><span class="comment">//上述例子由于person2还没有初始化，所以会调用构造函数</span></span><br><span class="line"><span class="comment">//由于person2是从已有的person1来创建的，所以只有一个选择</span></span><br><span class="line"><span class="comment">//就是调用拷贝构造函数</span></span><br><span class="line">person2 = person1; <span class="comment">//调用operator=函数</span></span><br><span class="line"><span class="comment">//由于person2已经创建，不需要再调用构造函数，这时候调用的是重载的赋值运算符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 赋值重载案例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">person1</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">person2</span><span class="params">(<span class="number">30</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"person1:"</span> &lt;&lt; person1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"person2:"</span> &lt;&lt; person2;</span><br><span class="line">person2 = person1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"person2:"</span> &lt;&lt; person2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常见错误，当准备给两个相同对象赋值时，应该首先检查一下这个对象是否对自身赋值了</span></span><br><span class="line"><span class="comment">//对于本例来讲，无论如何执行这些赋值运算都是无害的，但如果对类的实现进行修改，那么将会出现差异；</span></span><br><span class="line"><span class="comment">//3. 类中指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span>&#123;</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Person2&amp; person)&#123;</span><br><span class="line">os &lt;&lt; <span class="string">"Name:"</span> &lt;&lt; person.pName &lt;&lt; <span class="string">" ID:"</span> &lt;&lt; person.mID &lt;&lt; <span class="string">" Age:"</span> &lt;&lt; person.mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person2(<span class="keyword">char</span>* name,<span class="keyword">int</span> id, <span class="keyword">int</span> age)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, name);</span><br><span class="line"><span class="keyword">this</span>-&gt;mID = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="comment">//重载赋值运算符</span></span><br><span class="line">Person2&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Person2&amp; person)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意:由于当前对象已经创建完毕，那么就有可能pName指向堆内存</span></span><br><span class="line"><span class="comment">//这个时候如果直接赋值，会导致内存没有及时释放</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(person.pName) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName,person.pName);</span><br><span class="line"><span class="keyword">this</span>-&gt;mID = person.mID;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = person.mAge;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~Person2()&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* pName;</span><br><span class="line"><span class="keyword">int</span> mID;</span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person2 <span class="title">person1</span><span class="params">(<span class="string">"John"</span>,<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person2 <span class="title">person2</span><span class="params">(<span class="string">"Edward"</span>,<span class="number">30</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"person1:"</span> &lt;&lt; person1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"person2:"</span> &lt;&lt; person2;</span><br><span class="line">person2 = person1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"person2:"</span> &lt;&lt; person2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​         如果没有重载赋值运算符，编译器会自动创建默认的赋值运算符重载函数。行为类似默认拷贝构造，进行简单值拷贝。  </p><h3 id="等于和不等于-、-运算符重载"><a href="#等于和不等于-、-运算符重载" class="headerlink" title="等于和不等于(==、!=)运算符重载"></a>等于和不等于(<code>==</code>、<code>!=</code>)运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Complex(<span class="keyword">char</span>* name,<span class="keyword">int</span> id,<span class="keyword">int</span> age)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, name);</span><br><span class="line"><span class="keyword">this</span>-&gt;mID = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载==号操作符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex&amp; <span class="keyword">complex</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;pName,<span class="keyword">complex</span>.pName) == <span class="number">0</span> &amp;&amp; </span><br><span class="line">    <span class="keyword">this</span>-&gt;mID == <span class="keyword">complex</span>.mID &amp;&amp; </span><br><span class="line"><span class="keyword">this</span>-&gt;mAge == <span class="keyword">complex</span>.mAge)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载!=操作符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex&amp; <span class="keyword">complex</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;pName, <span class="keyword">complex</span>.pName) != <span class="number">0</span> || </span><br><span class="line">    <span class="keyword">this</span>-&gt;mID != <span class="keyword">complex</span>.mID || </span><br><span class="line"><span class="keyword">this</span>-&gt;mAge != <span class="keyword">complex</span>.mAge)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Complex()&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* pName;</span><br><span class="line"><span class="keyword">int</span> mID;</span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Complex <span class="title">complex1</span><span class="params">(<span class="string">"aaa"</span>, <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Complex <span class="title">complex2</span><span class="params">(<span class="string">"bbb"</span>, <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (complex1 == complex2)&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"相等!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (complex1 != complex2)&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"不相等!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="符号重载总结"><a href="#符号重载总结" class="headerlink" title="符号重载总结"></a>符号重载总结</h3><ul><li><p><strong><code>=</code></strong>, <strong><code>[]</code></strong>, <strong><code>()</code></strong> 和 <strong><code>-&gt;</code></strong> 操作符只能通过成员函数进行重载 </p></li><li><p><strong><code>&lt;&lt;</code></strong> 和 <strong><code>&gt;&gt;</code></strong>只能通过全局函数配合友元函数进行重载 </p></li><li><p>不要重载 <strong><code>&amp;&amp;</code></strong> 和 <strong><code>||</code></strong> 操作符，因为无法实现短路规则</p></li></ul><p>常规建议</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/579563.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++构造和析构</title>
      <link href="/2018/07/15/c++%E5%B0%81%E8%A3%855-%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/"/>
      <url>/2018/07/15/c++%E5%B0%81%E8%A3%855-%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>  对象的初始化和清理也是两个非常重要的安全问题，一个对象或者变量没有初始时，对其使用后果是未知，同样的使用完一个变量，没有及时清理，也会造成一定的安全问题。<code>c++</code>为了给我们提供这种问题的解决方案，<strong>构造函数</strong>和<strong>析构函数</strong>，这两个函数将会被编译器自动调用，完成对象初始化和对象清理工作。</p><p>​    <strong>无论你是否喜欢，对象的初始化和清理工作是编译器强制我们要做的事情，即使你不提供初始化操作和清理操作，编译器也会给你增加默认的操作，只是这个默认初始化操作不会做任何事，所以编写类就应该顺便提供初始化函数。</strong></p><a id="more"></a><h1 id="对象的构造和析构"><a href="#对象的构造和析构" class="headerlink" title="对象的构造和析构"></a>对象的构造和析构</h1><h2 id="构造函数和析构函数的定义"><a href="#构造函数和析构函数的定义" class="headerlink" title="构造函数和析构函数的定义"></a>构造函数和析构函数的定义</h2><p>​    构造函数主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</p><p>​    析构函数主要用于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作</p><p><strong>构造函数语法：</strong></p><ul><li><p>构造函数函数名和类名相同，没有返回值，不能有<code>void</code>，但可以有参数。</p></li><li><p><code>ClassName(){}</code></p></li></ul><p><strong>析构函数语法：</strong></p><ul><li><p>析构函数函数名是在类名前面加<code>”~”</code>组成,没有返回值，不能有<code>void</code>,不能有参数，不能重载。</p></li><li><p><code>~ClassName(){}</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"构造函数调用!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pName = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="string">"John"</span>));</span><br><span class="line"><span class="built_in">strcpy</span>(pName, <span class="string">"John"</span>);</span><br><span class="line">mTall = <span class="number">150</span>;</span><br><span class="line">mMoney = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Person()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数调用!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(pName);</span><br><span class="line">pName = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span>* pName;</span><br><span class="line"><span class="keyword">int</span> mTall;</span><br><span class="line"><span class="keyword">int</span> mMoney;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person person;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; person.pName &lt;&lt; person.mTall &lt;&lt; person.mMoney &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h2><ul><li><p>按参数类型：分为<strong>无参构造函数</strong>和<strong>有参构造函数</strong></p></li><li><p>按类型分类：<strong>普通构造函数</strong>和<strong>拷贝构造函数(复制构造函数)</strong></p></li></ul><h3 id="普通构造函数"><a href="#普通构造函数" class="headerlink" title="普通构造函数"></a>普通构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参构造函数</span></span><br><span class="line">Person()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"no param constructor!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mAge = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line">Person(<span class="keyword">int</span> age)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1 param constructor!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印年龄</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Age:"</span> &lt;&lt; mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 无参构造调用方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line">Person person1; </span><br><span class="line">person1.PrintPerson();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用无参构造函数</span></span><br><span class="line">    Person *person2 = <span class="keyword">new</span> Person();</span><br><span class="line">    person2-&gt;PrintPerson();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用有参构造函数</span></span><br><span class="line">    <span class="function">Person <span class="title">person3</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">person3.PrintPerson();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//无参构造函数错误调用方式</span></span><br><span class="line"><span class="comment">//Person person2();</span></span><br><span class="line"><span class="comment">//person2.PrintPerson();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><h4 id="拷贝构造函数定义"><a href="#拷贝构造函数定义" class="headerlink" title="拷贝构造函数定义"></a>拷贝构造函数定义</h4><p>​        例如，将<code>Word</code>文档拷贝到<code>U</code>盘去复印店打印，将<code>D</code>盘的图片拷贝到桌面以方便浏览，将重要的文件上传到百度网盘以防止丢失等，都是「创建一份新数据」的意思。</p><p>​        在<code>C++</code>中，拷贝并没有脱离它本来的含义，只是将这个含义进行了“特化”，是<strong>指用已经存在的对象创建出一个新的对象。从本质上讲，对象也是一份数据，因为它会占用内存。</strong></p><p>​        严格来说，对象的创建包括两个阶段，首先要<strong>分配内存空间</strong>，然后再进行<strong>初始化</strong>： </p><ul><li><strong>分配内存</strong>很好理解，就是在堆区、栈区或者全局数据区留出足够多的字节。这个时候的内存还比较“原始”，没有被“教化”，它所包含的数据一般是零值或者随机值，没有实际的意义。</li><li><strong>初始化</strong>就是首次对内存赋值，让它的数据有意义。注意是首次赋值，再次赋值不叫初始化。初始化的时候还可以为对象分配其他的资源（打开文件、连接网络、动态分配内存等），或者提前进行一些计算（根据价格和数量计算出总价、根据长度和宽度计算出矩形的面积等）等。说白了，<strong>初始化就是调用构造函数。</strong></li></ul><p>​      <strong>很明显，这里所说的拷贝是在初始化阶段进行的，也就是用其它对象的数据来初始化新对象的内存。</strong></p><p>​        那么，如何用拷贝的方式来初始化一个对象呢？其实这样的例子比比皆是，<code>string</code>类就是一个典型的例子。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"http://c.biancheng.net"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> s3 = s1;</span><br><span class="line">    <span class="built_in">string</span> s4 = s1 + <span class="string">" "</span> + s2;</span><br><span class="line">    func(s1);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s3&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s4&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net http://c.biancheng.net</span></span><br></pre></td></tr></table></figure></p><p>​        <code>s1</code>、<code>s2</code>、<code>s3</code>、<code>s4</code> 以及 <code>func()</code> 的形参<code>str</code>，都是使用拷贝的方式来初始化的。 </p><blockquote><p> 对于<code>s1</code>，表面上看起来是将一个字符串直接赋值给了<code>s1</code>，实际上在内部进行了类型转换，将<code>const char *</code>类型转换为<code>string</code>类型后才赋值的，<code>s4</code>也是类似的道理。</p></blockquote><p>​        对于<code>s1</code>、<code>s2</code>、<code>s3</code>、<code>s4</code>，都是将其它对象的数据拷贝给当前对象，以完成当前对象的初始化。</p><p>​        对于<code>func()</code> 的形参 <code>str</code>，其实在定义时就为它分配了内存，但是此时并没有初始化，只有等到调用<code>func()</code> 时，才会将其它对象的数据拷贝给 <code>str</code>以完成初始化。</p><p>​        <strong>当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是拷贝构造函数（<code>Copy Constructor</code>）。</strong></p><p>​        下面的例子演示了拷贝构造函数的定义和使用： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name = <span class="string">""</span>, <span class="keyword">int</span> age = <span class="number">0</span>, <span class="keyword">float</span> score = <span class="number">0.0f</span>);  <span class="comment">//普通构造函数</span></span><br><span class="line">    Student(<span class="keyword">const</span> Student &amp;stu);  <span class="comment">//拷贝构造函数（声明）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数（定义）</span></span><br><span class="line">Student::Student(<span class="keyword">const</span> Student &amp;stu)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_name = stu.m_name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_age = stu.m_age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_score = stu.m_score;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy constructor was called."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Student::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">    Student stu2 = stu1;  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    <span class="function">Student <span class="title">stu3</span><span class="params">(stu1)</span></span>;  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    stu1.display();</span><br><span class="line">    stu2.display();</span><br><span class="line">    stu3.display();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copy constructor was called.</span><br><span class="line">Copy constructor was called.</span><br><span class="line">小明的年龄是<span class="number">16</span>，成绩是<span class="number">90.5</span></span><br><span class="line">小明的年龄是<span class="number">16</span>，成绩是<span class="number">90.5</span></span><br><span class="line">小明的年龄是<span class="number">16</span>，成绩是<span class="number">90.5</span></span><br></pre></td></tr></table></figure></p><p>​    第<code>8</code>行是拷贝构造函数的声明，第<code>20</code>行是拷贝构造函数的定义。拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 <code>const</code>引用。 </p><h5 id="1-为什么必须是当前类的引用呢？"><a href="#1-为什么必须是当前类的引用呢？" class="headerlink" title="1) 为什么必须是当前类的引用呢？"></a>1) 为什么必须是当前类的引用呢？</h5><p>​        如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。</p><p>​        <strong>只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是<code>C++</code>语法的要求。 </strong></p><h5 id="2-为什么是const引用呢？"><a href="#2-为什么是const引用呢？" class="headerlink" title="2) 为什么是const引用呢？"></a>2) 为什么是<code>const</code>引用呢？</h5><p>​        拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 <code>const</code> 限制后，这个含义更加明确了。</p><p>​        另外一个原因是，添加 <code>const</code> 限制后，可以将 <code>const</code> 对象和非 <code>const</code> 对象传递给形参了，因为非<code>const</code> 类型可以转换为  <code>const</code> 类型。如果没有 <code>const</code> 限制，就不能将 <code>const</code> 对象传递给形参，因为<code>const</code>类型不能转换为非 <code>const</code>类型，这就意味着，不能使用 <code>const</code>对象来初始化当前对象了。</p><p>​        以上面的 Student 类为例，将<code>const</code> 去掉后，拷贝构造函数的原型变为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student::Student(Student &amp;stu);</span><br></pre></td></tr></table></figure></p><p>​        此时，下面的代码就会发生错误： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">Student stu2 = stu1;</span><br><span class="line"><span class="function">Student <span class="title">stu3</span><span class="params">(stu1)</span></span>;</span><br></pre></td></tr></table></figure><p>​        <code>stu1</code> 是 <code>const</code> 类型，在初始化 <code>stu2</code>、<code>stu3</code> 时，编译器希望调用<code>Student::Student(const Student &amp;stu)</code>，但是这个函数却不存在，又不能将 <code>const Student</code> 类型转换为 Student 类型去调用<code>Student::Student(Student &amp;stu)</code>，所以最终调用失败了。</p><p>​        当然，你也可以再添加一个参数为 <code>const</code> 引用的拷贝构造函数，这样就不会出错了。换句话说，一个类可以同时存在两个拷贝构造函数，一个函数的参数为 <code>const</code>引用，另一个函数的参数为非 <code>const</code> 引用。 </p><h4 id="默认拷贝构造函数"><a href="#默认拷贝构造函数" class="headerlink" title="默认拷贝构造函数"></a>默认拷贝构造函数</h4><p>​        在前面的教程中，我们还没有讲解拷贝构造函数，但是却已经在使用拷贝的方式创建对象了，并且也没有引发什么错误。这是因为，<strong>如果程序员没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数。这个默认的拷贝构造函数很简单，就是使用“老对象”的成员变量对“新对象”的成员变量进行一一赋值，和上面  <code>Student</code>类的拷贝构造函数非常类似。</strong></p><p>​        对于简单的类，默认拷贝构造函数一般是够用的，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认拷贝构造函数就不能拷贝这些资源，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据</p><h4 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h4><p>​        当以拷贝的方式初始化对象时会调用拷贝构造函数。这里有两个关键点，分别是<strong>「以拷贝的方式」</strong>和<strong>「初始化对象」</strong>。 </p><h5 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h5><p>​        <strong>初始化对象是指，为对象分配内存后第一次向内存中填充数据，这个过程会调用构造函数。对象被创建后必须立即被初始化，换句话说，只要创建对象，就会调用构造函数。</strong></p><h6 id="初始化和赋值的区别"><a href="#初始化和赋值的区别" class="headerlink" title="初始化和赋值的区别"></a>初始化和赋值的区别</h6><p>​        <strong>初始化</strong>和<strong>赋值</strong>都是将数据写入内存中，并且从表面上看起来，初始化在很多时候都是以赋值的方式来实现的，所以很容易混淆。请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;  <span class="comment">//以赋值的方式初始化</span></span><br><span class="line">a = <span class="number">200</span>;  <span class="comment">//赋值</span></span><br><span class="line">a = <span class="number">300</span>;  <span class="comment">//赋值</span></span><br><span class="line"><span class="keyword">int</span> b;  <span class="comment">//默认初始化</span></span><br><span class="line">b = <span class="number">29</span>;  <span class="comment">//赋值</span></span><br><span class="line">b = <span class="number">39</span>;  <span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><p>​        <strong>在定义的同时进行赋值叫做初始化（<code>Initialization</code>）</strong>，<strong>定义完成以后再赋值（不管在定义的时候有没有赋值）就叫做赋值（<code>Assignment</code>）</strong>。<strong>初始化只能有一次，赋值可以有多次</strong>。</p><p>​        对于基本类型的数据，我们很少会区分「初始化」和「赋值」这两个概念，即使将它们混淆，也不会出现什么错误。但是对于类，它们的区别就非常重要了，因为<strong>初始化对象时会调用构造函数（以拷贝的方式初始化时会调用拷贝构造函数），而赋值时会调用重载过的赋值运算符。</strong>请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name = <span class="string">""</span>, <span class="keyword">int</span> age = <span class="number">0</span>, <span class="keyword">float</span> score = <span class="number">0.0f</span>);  <span class="comment">//普通构造函数</span></span><br><span class="line">    Student(<span class="keyword">const</span> Student &amp;stu);  <span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Student &amp;stu);  <span class="comment">//重载=运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line">Student::Student(<span class="keyword">const</span> Student &amp;stu)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_name = stu.m_name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_age = stu.m_age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_score = stu.m_score;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy constructor was called."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载=运算符</span></span><br><span class="line">Student &amp; Student::<span class="keyword">operator</span>=(<span class="keyword">const</span> Student &amp;stu)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_name = stu.m_name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_age = stu.m_age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_score = stu.m_score;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"operator=() was called."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Student::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//stu1、stu2、stu3都会调用普通构造函数Student(string name, int age, float score)</span></span><br><span class="line">    <span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">stu2</span><span class="params">(<span class="string">"王城"</span>, <span class="number">17</span>, <span class="number">89.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">stu3</span><span class="params">(<span class="string">"陈晗"</span>, <span class="number">18</span>, <span class="number">98.0</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">    Student stu4 = stu1;  <span class="comment">//调用拷贝构造函数Student(const Student &amp;stu)</span></span><br><span class="line">    stu4 = stu2;  <span class="comment">//调用operator=()</span></span><br><span class="line">    stu4 = stu3;  <span class="comment">//调用operator=()</span></span><br><span class="line">   </span><br><span class="line">    Student stu5;  <span class="comment">//调用普通构造函数Student()</span></span><br><span class="line">    stu5 = stu1;  <span class="comment">//调用operator=()</span></span><br><span class="line">    stu5 = stu2;  <span class="comment">//调用operator=()</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>运行结果：</code></pre> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copy constructor was called.</span><br><span class="line"><span class="keyword">operator</span>=() was called.</span><br><span class="line"><span class="keyword">operator</span>=() was called.</span><br><span class="line"><span class="keyword">operator</span>=() was called.</span><br><span class="line"><span class="keyword">operator</span>=() was called.</span><br></pre></td></tr></table></figure><h5 id="以拷贝的方式初始化对象"><a href="#以拷贝的方式初始化对象" class="headerlink" title="以拷贝的方式初始化对象"></a>以拷贝的方式初始化对象</h5><p>​    初始化对象时会调用构造函数，不同的初始化方式会调用不同的构造函数： </p><ul><li><strong>如果用传递进来的实参初始化对象，那么会调用普通的构造函数，我们不妨将此称为普通初始化；</strong></li><li><strong>如果用其它对象（现有对象）的数据来初始化对象，那么会调用拷贝构造函数，这就是以拷贝的方式初始化。</strong></li></ul><p>在实际编程中，具体有哪些情况是以拷贝的方式来初始化对象呢？ </p><h6 id="1-将其它对象作为实参"><a href="#1-将其它对象作为实参" class="headerlink" title="(1) 将其它对象作为实参"></a>(1) 将其它对象作为实参</h6><p>​    以上面的<code>Student</code>类为例，我们可以这样来创建一个新的对象： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;  <span class="comment">//普通初始化</span></span><br><span class="line"><span class="function">Student <span class="title">stu2</span><span class="params">(stu1)</span></span>;  <span class="comment">//以拷贝的方式初始化</span></span><br></pre></td></tr></table></figure><p>​    即使我们不在类中显式地定义拷贝构造函数，这种初始化方式也是有效的，因为编译器会生成默认的拷贝构造函数。 </p><h6 id="2-在创建对象的同时赋值"><a href="#2-在创建对象的同时赋值" class="headerlink" title="(2) 在创建对象的同时赋值"></a>(2) 在创建对象的同时赋值</h6><p>​    接着使用 Student 类，请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;  <span class="comment">//普通初始化</span></span><br><span class="line">Student stu2 = stu1;  <span class="comment">//以拷贝的方式初始化</span></span><br></pre></td></tr></table></figure><p>​    这是最常见的一种以拷贝的方式初始化对象的情况，非常容易理解，我们也已经多次使用。 </p><h6 id="3-函数的形参为类类型"><a href="#3-函数的形参为类类型" class="headerlink" title="(3) 函数的形参为类类型"></a>(3) 函数的形参为类类型</h6><p>​    如果函数的形参为类类型（也就是一个对象），那么调用函数时要将另外一个对象作为实参传递进来赋值给形参，这也是以拷贝的方式初始化形参对象。请看下面的代码： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Student s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;  <span class="comment">//普通初始化</span></span><br><span class="line">func(stu);  <span class="comment">//以拷贝的方式初始化</span></span><br></pre></td></tr></table></figure><pre><code>`func() `函数有一个` Student `类型的形参` s`，将实参 `stu `传递给形参` s `就是以拷贝的方式初始化的过程。</code></pre><p>​    函数是一段可以重复使用的代码，只有等到真正调用函数时才会为局部数据（形参和局部变量）在栈上分配内存。对于上面的<code>func()</code>，虽然它的形参<code>s</code>是一个对象，但在定义函数时<code>s</code>对象并没有被创建，只有等到调用函数时才会真正地创建<code>s</code>对象，并在栈上为它分配内存。而创建<code>s</code>对象，就是以拷贝的方式进行的，它等价于下面的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student s = stu;</span><br></pre></td></tr></table></figure></p><h6 id="4-函数返回值为类类型"><a href="#4-函数返回值为类类型" class="headerlink" title="(4) 函数返回值为类类型"></a>(4) 函数返回值为类类型</h6><p>​    当函数的返回值为类类型时，<code>return</code>语句会返回一个对象，不过为了防止局部对象被销毁，也为了防止通过返回值修改原来的局部对象，编译器并不会直接返回这个对象，而是根据这个对象先创建出一个临时对象（匿名对象），再将这个临时对象返回。而创建临时对象的过程，就是以拷贝的方式进行的，会调用拷贝构造函数。</p><p>​     下面的代码演示了返回一个对象的情形： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student stu = func();</span><br></pre></td></tr></table></figure><p>​        理论上讲，运行代码后会调用两次拷贝构造函数，一次是返回<code>s</code>对象时，另外一次是创建<code>stu</code>对象时。</p><h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>​        <strong>对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存。</strong>例如： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(): m_a(<span class="number">0</span>), m_b(<span class="number">0</span>)&#123; &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = a;  <span class="comment">//拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Base <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    Base obj2 = obj1;  <span class="comment">//拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <code>b</code>和 <code>obj2</code>都是以拷贝的方式初始化的，具体来说，就是将<code>a</code>和 <code>obj1</code>所在内存中的数据按照二进制位<code>（Bit）</code>复制到<code>b</code>和 <code>obj2</code> 所在的内存，这种默认的拷贝行为就是浅拷贝，这和调用 <code>memcpy()</code>函数的效果非常类似。</p><p>​        对于简单的类，默认的拷贝构造函数一般就够用了，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是<strong>当类持有其它资源时，例如动态分配的内存、指向其他数据的指针等，默认的拷贝构造函数就不能拷贝这些资源了，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。</strong></p><p>​        下面我们通过一个具体的例子来说明显式定义拷贝构造函数的必要性。我们知道，有些较老的编译器不支持变长数组，例如 <code>VC6.0</code>、<code>VS2010</code> 等，这有时候会给编程带来不便，下面我们通过自定义的 Array 类来实现变长数组。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变长数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> len);</span><br><span class="line">    Array(<span class="keyword">const</span> Array &amp;arr);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~Array();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（读取）</span></span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（写入）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_len; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">int</span> len): m_len(len)&#123;</span><br><span class="line">    m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">const</span> Array &amp;arr)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::~Array()&#123; <span class="built_in">free</span>(m_p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">const</span> Array &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">arr1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        arr1[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    Array arr2 = arr1;</span><br><span class="line">    arr2[<span class="number">5</span>] = <span class="number">100</span>;</span><br><span class="line">    arr2[<span class="number">3</span>] = <span class="number">29</span>;</span><br><span class="line">   </span><br><span class="line">    printArray(arr1);</span><br><span class="line">    printArray(arr2);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>​        本例中我们显式地定义了拷贝构造函数，它除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来。这样做的结果是，原有对象和新对象所持有的动态内存是相互独立的，更改一个对象的数据不会影响另外一个对象，本例中我们更改了  <code>arr2</code>的数据，就没有影响 <code>arr1</code>。</p><p>​        <strong>这种将对象所持有的其它资源一并拷贝的行为叫做深拷贝，我们必须显式地定义拷贝构造函数才能达到深拷贝的目的</strong>。</p><p>​        深拷贝的例子比比皆是，除了上面的变长数组类，标准模板库（<code>STL</code>）中的<code>string</code>、<code>vector</code>、<code>stack</code>、<code>set</code>、<code>map</code>等也都必须使用深拷贝。</p><p>​        读者如果希望亲眼目睹不使用深拷贝的后果，可以将上例中的拷贝构造函数删除，那么运行结果将变为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>​        可以发现，更改<code>arr2</code> 的数据也影响到了 <code>arr1</code>。这是因为，在创建 <code>arr2</code> 对象时，默认拷贝构造函数将 <code>arr1.m_p</code> 直接赋值给了 <code>arr2.m_p</code>，导致 <code>arr2.m_p</code>和 <code>arr1.m_p</code> 指向了同一块内存，所以会相互影响。</p><p>​        另外需要注意的是，<strong><code>printArray()</code>函数的形参为引用类型，这样做能够避免在传参时调用拷贝构造函数；</strong>又因为 <code>printArray()</code> 函数不会修改任何数组元素，所以我们添加了<code>const</code> 限制，以使得语义更加明确。</p><h5 id="到底是浅拷贝还是深拷贝"><a href="#到底是浅拷贝还是深拷贝" class="headerlink" title="到底是浅拷贝还是深拷贝"></a>到底是浅拷贝还是深拷贝</h5><p>​        <strong>如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深拷贝，因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。如果类的成员变量没有指针，一般浅拷贝足以。</strong></p><p>​        <strong>另外一种需要深拷贝的情况就是在创建对象时进行一些预处理工作，比如统计创建过的对象的数目、记录对象创建的时间等</strong>，请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;  //在Linux和Mac下要换成 unistd.h 头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>);</span><br><span class="line">    Base(<span class="keyword">const</span> Base &amp;obj);  <span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_count; &#125;</span><br><span class="line">    <span class="keyword">time_t</span> getTime() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_time; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">    <span class="keyword">time_t</span> m_time;  <span class="comment">//对象创建时间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_count;  <span class="comment">//创建过的对象的数目</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Base::Base(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123;</span><br><span class="line">    m_count++;</span><br><span class="line">    m_time = time((<span class="keyword">time_t</span>*)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base::Base(<span class="keyword">const</span> Base &amp;obj)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_a = obj.m_a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_b = obj.m_b;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_count++;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_time = time((<span class="keyword">time_t</span>*)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj1: count = "</span>&lt;&lt;obj1.getCount()&lt;&lt;<span class="string">", time = "</span>&lt;&lt;obj1.getTime()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    Sleep(<span class="number">3000</span>);  <span class="comment">//在Linux和Mac下要写作 sleep(3);</span></span><br><span class="line">   </span><br><span class="line">    Base obj2 = obj1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj2: count = "</span>&lt;&lt;obj2.getCount()&lt;&lt;<span class="string">", time = "</span>&lt;&lt;obj2.getTime()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj1: count = <span class="number">1</span>, time = <span class="number">1488344372</span></span><br><span class="line"></span><br><span class="line">obj2: count = <span class="number">2</span>, time = <span class="number">1488344375</span></span><br></pre></td></tr></table></figure></p><p>​        运行程序，先输出第一行结果，等待 3 秒后再输出第二行结果。Base 类中的 m_time 和 m_count  分别记录了对象的创建时间和创建数目，它们在不同的对象中有不同的值，所以需要在初始化对象的时候提前处理一下，这样浅拷贝就不能胜任了，就必须使用深拷贝了。</p><h3 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h3><p>​        我们讲解了初始化和赋值的区别：<strong>在定义的同时进行赋值叫做初始化（<code>Initialization</code>），定义完成以后再赋值（不管在定义的时候有没有赋值）就叫做赋值（<code>Assignment</code>）。初始化只能有一次，赋值可以有多次。</strong></p><p>​        <strong>当以拷贝的方式初始化一个对象时，会调用拷贝构造函数；当给一个对象赋值时，会调用重载过的赋值运算符。</strong></p><p>​        即使我们没有显式的重载赋值运算符，编译器也会以默认地方式重载它。默认重载的赋值运算符功能很简单，就是将原有对象的所有成员变量一一赋值给新对象，这和默认拷贝构造函数的功能类似。</p><p>​        对于简单的类，默认的赋值运算符一般就够用了，我们也没有必要再显式地重载它。但是<strong>当类持有其它资源时，例如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认的赋值运算符就不能处理了，我们必须显式地重载它，这样才能将原有对象的所有数据都赋值给新对象。</strong></p><p>​        仍然以上节的<code>Array</code>类为例，该类拥有一个指针成员，指向动态分配的内存。为了让<code>Array</code>类的对象之间能够正确地赋值，我们必须重载赋值运算符。请看下面的代码： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变长数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> len);</span><br><span class="line">    Array(<span class="keyword">const</span> Array &amp;arr);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~Array();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（读取）</span></span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（写入）</span></span><br><span class="line">    Array &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array &amp;arr);  <span class="comment">//重载赋值运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_len; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">int</span> len): m_len(len)&#123;</span><br><span class="line">    m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">const</span> Array &amp;arr)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::~Array()&#123; <span class="built_in">free</span>(m_p); &#125;</span><br><span class="line"></span><br><span class="line">Array &amp;Array::<span class="keyword">operator</span>=(<span class="keyword">const</span> Array &amp;arr)&#123;  <span class="comment">//重载赋值运算符</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">this</span> != &amp;arr)&#123;  <span class="comment">//判断是否是给自己赋值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;m_p);  <span class="comment">//释放原来的内存</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">        <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">const</span> Array &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">arr1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        arr1[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    printArray(arr1);</span><br><span class="line">   </span><br><span class="line">    <span class="function">Array <span class="title">arr2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">        arr2[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    printArray(arr2);</span><br><span class="line">    arr2 = arr1;  <span class="comment">//调用operator=()</span></span><br><span class="line">    printArray(arr2);</span><br><span class="line">    arr2[<span class="number">3</span>] = <span class="number">234</span>;  <span class="comment">//修改arr1的数据不会影响arr2</span></span><br><span class="line">    arr2[<span class="number">7</span>] = <span class="number">920</span>;</span><br><span class="line">    printArray(arr1);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>​        将 <code>arr1</code> 赋值给 <code>arr2</code>后，修改 <code>arr2</code> 的数据不会影响 <code>arr1</code>。如果把<code>operator=()</code>注释掉，那么运行结果将变为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">234</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">920</span>, <span class="number">8</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure></p><blockquote><p> 去掉<code>operator=()</code>后，由于<code>m_p</code>指向的堆内存会被<code>free()</code>两次，所以还会导致内存错误。</p></blockquote><p>下面我们就来分析一下重载过的赋值运算符。</p><ul><li><code>operator=()</code>的返回值类型为<code>Array &amp;</code>，这样不但能够避免在返回数据时调用拷贝构造函数，还能够达到连续赋值的目的。下面的语句就是连续赋值： </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr4 = arr3 = arr2 = arr1;</span><br></pre></td></tr></table></figure><ul><li><code>if( this != &amp;arr)</code>语句的作用是「判断是否是给同一个对象赋值」：如果是，那就什么也不做；如果不是，那就将原有对象的所有成员变量一一赋值给新对象，并为新对象重新分配内存。下面的语句就是给同一个对象赋值： </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1 = arr1;</span><br><span class="line">arr2 = arr2;</span><br></pre></td></tr></table></figure><ul><li><p><code>return *this</code>表示返回当前对象（新对象）。</p></li><li><p><code>operator=()</code> 的形参类型为<code>const Array &amp;</code>，这样不但能够避免在传参时调用拷贝构造函数，还能够同时接收<code>const</code> 类型和非 <code>const</code> 类型的实参。</p></li><li><p>赋值运算符重载函数除了能有对象引用这样的参数之外，也能有其它参数。但是其它参数必须给出默认值，例如： </p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array &amp;arr, <span class="keyword">int</span> a = <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h2 id="多个对象构造和析构"><a href="#多个对象构造和析构" class="headerlink" title="多个对象构造和析构"></a>多个对象构造和析构</h2><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>​    构造函数和其他函数不同，除了有名字，参数列表，函数体之外还有初始化列表。</p><p>​    初始化列表简单使用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//传统方式初始化</span></span><br><span class="line">Person(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)&#123;</span><br><span class="line">mA = a;</span><br><span class="line">mB = b;</span><br><span class="line">mC = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//初始化列表方式初始化</span></span><br><span class="line">Person(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c):mA(a),mB(b),mC(c)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mA:"</span> &lt;&lt; mA &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mB:"</span> &lt;&lt; mB &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mC:"</span> &lt;&lt; mC &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> mA;</span><br><span class="line"><span class="keyword">int</span> mB;</span><br><span class="line"><span class="keyword">int</span> mC;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​         <strong>注意：初始化成员列表(参数列表)只能在构造函数使用。  </strong></p><h3 id="类对象作为成员"><a href="#类对象作为成员" class="headerlink" title="类对象作为成员"></a>类对象作为成员</h3><h4 id="类对象作为成员-1"><a href="#类对象作为成员-1" class="headerlink" title="类对象作为成员"></a>类对象作为成员</h4><p>​    在类中定义的数据成员一般都是基本的数据类型。但是类中的成员也可以是对象，叫做<strong>对象成员</strong>。</p><p>​    <code>C++</code>中对对象的初始化是非常重要的操作，当创建一个对象的时候，<code>c++</code>编译器必须确保调用了所有子对象的构造函数。如果所有的子对象有默认构造函数，编译器可以自动调用他们。但是如果子对象没有默认的构造函数，或者想指定调用某个构造函数怎么办？</p><p>​    那么是否可以在类的构造函数直接调用子类的属性完成初始化呢？但是如果子类的成员属性是私有的，我们是没有办法访问并完成初始化的。</p><p>​    解决办法非常简单：<strong>对于子类调用构造函数，<code>c++</code>为此提供了专门的语法，即构造函数初始化列表。</strong></p><p>​    <strong>当调用构造函数时，首先会先按各对象成员在类定义中的顺序（和参数列表的顺序无关）依次调用它们的构造函数，再调用自己的构造函数，对这些对象初始化。析构函数和构造函数调用顺序相反。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Phone()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"手机的默认构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Phone(<span class="built_in">string</span> name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"手机的有参构造调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">m_PhoneName = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Phone()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"手机的析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Game()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Game的默认构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Game(<span class="built_in">string</span> name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Game的有参构造调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">m_GameName = name;</span><br><span class="line">&#125;</span><br><span class="line">~Game()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Game的析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_GameName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Person的默认构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="built_in">string</span> phoneName, <span class="built_in">string</span> gameName) : m_Name(name), m_Phone(phoneName), m_Game(gameName)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Person的有参构造调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//m_Name = name;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m_Name &lt;&lt; <span class="string">" 拿着《"</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">"》牌手机 ，玩着《"</span> &lt;&lt; m_Game.m_GameName &lt;&lt; <span class="string">"》游戏"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Person的析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name; <span class="comment">//姓名</span></span><br><span class="line">Phone m_Phone; <span class="comment">//手机</span></span><br><span class="line">Game m_Game; <span class="comment">//游戏</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类对象作为类成员时候，构造顺序先将类对象一一构造，然后构造自己， 析构的顺序是相反的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">"狗蛋"</span>,<span class="string">"苹果"</span>,<span class="string">"切水果"</span>)</span></span>;</span><br><span class="line">p.playGame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出是：<br><code>手机的有参构造调用</code><br><code>Game的有参构造调用</code><br><code>Person的有参构造调用</code><br><code>狗蛋 拿着《苹果》牌手机 ，玩着《切水果》游戏</code><br><code>Person的析构函数调用</code><br><code>Game的析构函数调用</code><br><code>手机的析构函数调用</code></p><h2 id="动态对象创建"><a href="#动态对象创建" class="headerlink" title="动态对象创建"></a>动态对象创建</h2><p>​    当我们创建数组的时候，总是需要提前预定数组的长度，然后编译器分配预定长度的数组空间，在使用数组的时，会有这样的问题，数组也许空间太大了，浪费空间，也许空间不足，所以对于数组来讲，如果能根据需要来分配空间大小再好不过。</p><p>​    所以动态的意思意味着不确定性。</p><p>​    为了解决这个普遍的编程问题，在运行中可以创建和销毁对象是最基本的要求。当然<code>c</code>早就提供了动态内存分配（<code>dynamic memory allocation</code>）,函数<code>malloc</code>和<code>free</code>可以在运行时从堆中分配存储单元。</p><p>​    然而这些函数在<code>c++</code>中不能很好的运行，因为它不能帮我们完成对象的初始化工作。</p><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>当创建一个<code>c++</code>对象时会发生两件事:</p><ul><li><p>为对象分配内存</p></li><li><p>调用构造函数来初始化那块内存</p></li></ul><p>​    第一步我们能保证实现，需要我们确保第二步一定能发生。<code>c++</code>强迫我们这么做是因为使用未初始化的对象是程序出错的一个重要原因。</p><h4 id="new-operator"><a href="#new-operator" class="headerlink" title="new operator"></a><code>new operator</code></h4><p>​    <code>C++</code>中解决动态内存分配的方案是把创建一个对象所需要的操作都结合在一个称为<code>new</code>的运算符里。当用<code>new</code>创建一个对象时，它就在堆里为对象分配内存并调用构造函数完成初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"默认构造调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"有参构造调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Person p1;  栈区开辟</span></span><br><span class="line"></span><br><span class="line">Person * p2 = <span class="keyword">new</span> Person; <span class="comment">//堆区开辟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所有new出来的对象 都会返回该类型的指针</span></span><br><span class="line"><span class="comment">//malloc 返回 void* 还要强转</span></span><br><span class="line"><span class="comment">//malloc会调用构造吗？ 不会  new会调用构造</span></span><br><span class="line"><span class="comment">// new 运算符  malloc 函数</span></span><br><span class="line"><span class="comment">//释放 堆区空间</span></span><br><span class="line"><span class="comment">// delete也是运算符 配合 new用  malloc 配合 free用</span></span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *p = <span class="keyword">new</span> Person(<span class="number">10</span>); </span><br><span class="line"><span class="comment">//当用void* 接受new出来的指针 ，会出现释放的问题</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">//无法释放p ，所以避免这种写法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过new开辟数组 一定会调用默认构造函数,所以一定要提供默认构造</span></span><br><span class="line">Person * pArray = <span class="keyword">new</span> Person[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//Person pArray2[2] = &#123; Person(1), Person(2) &#125;; //在栈上开辟数组，可以指定有参构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放数组 delete []</span></span><br><span class="line"><span class="keyword">delete</span> [] pArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">test03();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete-operator"><a href="#delete-operator" class="headerlink" title="delete operator"></a><code>delete operator</code></h4><p>​    <code>new</code>表达式的反面是<code>delete</code>表达式。<code>delete</code>表达式先调用析构函数，然后释放内存。正如<code>new</code>表达式返回一个指向对象的指针一样，<code>delete</code>需要一个对象的地址。</p><p>​    <code>delete</code>只适用于由<code>new</code>创建的对象。</p><p>​    如果正在删除的对象的指针是<code>NULL</code>,将不发生任何事，因此建议在删除指针后，立即把指针赋值为<code>NULL</code>，以免对它删除两次，对一些对象删除两次可能会产生某些问题。</p><h4 id="delete-void-可能会出错"><a href="#delete-void-可能会出错" class="headerlink" title="delete void*可能会出错"></a><code>delete void*</code>可能会出错</h4><p>​    如果对一个<code>void*</code>指针执行<code>delete</code>操作，这将可能成为一个程序错误，除非指针指向的内容是非常简单的，因为它将不执行析构函数。未调用析构函数，导致可用内存减少。</p><h4 id="用于数组的new和delete"><a href="#用于数组的new和delete" class="headerlink" title="用于数组的new和delete"></a>用于数组的<code>new</code>和<code>delete</code></h4><p>​    使用<code>new</code>和<code>delete</code>在堆上创建数组非常容易。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建字符数组</span></span><br><span class="line"><span class="keyword">char</span>* pStr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//创建整型数组</span></span><br><span class="line"><span class="keyword">int</span>* pArr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>]; </span><br><span class="line"><span class="comment">//创建整型数组并初始化</span></span><br><span class="line"><span class="keyword">int</span>* pArr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放数组内存</span></span><br><span class="line"><span class="keyword">delete</span>[] pStr;</span><br><span class="line"><span class="keyword">delete</span>[] pArr1;</span><br><span class="line"><span class="keyword">delete</span>[] pArr2;</span><br></pre></td></tr></table></figure><p>​    <strong>当创建一个对象数组的时候，必须对数组中的每一个对象调用构造函数，除了在栈上可以聚合初始化，必须提供一个默认的构造函数。</strong></p><h4 id="使用new和delete采用相同形式"><a href="#使用new和delete采用相同形式" class="headerlink" title="使用new和delete采用相同形式"></a>使用<code>new</code>和<code>delete</code>采用相同形式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person* person = <span class="keyword">new</span> Person[<span class="number">10</span>];    </span><br><span class="line"><span class="keyword">delete</span> person;</span><br></pre></td></tr></table></figure><p>​    以上代码有什么问题吗？(<code>vs</code>下直接中断、<code>qt</code>下析构函数调用一次)</p><p>​    使用了<code>new</code>也搭配使用了<code>delete</code>，问题在于<code>Person</code>有<code>10</code>个对象，那么其他<code>9</code>个对象可能没有调用析构函数，也就是说其他<code>9</code>个对象可能删除不完全，因为它们的析构函数没有被调用。</p><p>​    我们现在清楚使用<code>new</code>的时候发生了两件事: 一、分配内存；二、调用构造函数，那么调用<code>delete</code>的时候也有两件事：一、析构函数；二、释放内存。</p><p>​    那么刚才我们那段代码最大的问题在于：<code>person</code>指针指向的内存中到底有多少个对象，因为这个决定应该有多少个析构函数应该被调用。换句话说，<code>person</code>指针指向的是一个单一的对象还是一个数组对象，由于单一对象和数组对象的内存布局是不同的。更明确的说，数组所用的内存通常还包括“数组大小记录”，使得<code>delete</code>的时候知道应该调用几次析构函数。单一对象的话就没有这个记录。单一对象和数组对象的内存布局可理解为下图:</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1111.png" alt></p><p>只是为了说明，编译器不一定如此实现，但是很多编译器是这样做的。</p><p>​    当我们使用一个<code>delete</code>的时候，我们必须让<code>delete</code>知道指针指向的内存空间中是否存在一个“数组大小记录”的办法就是我们告诉它。当我们使用<code>delete[]</code>，那么<code>delete</code>就知道是一个对象数组，从而清楚应该调用几次析构函数。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++const成员变量和函数</title>
      <link href="/2018/07/10/c++%E5%B0%81%E8%A3%854-const%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/"/>
      <url>/2018/07/10/c++%E5%B0%81%E8%A3%854-const%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在类中，如果你不希望某些数据被修改，可以使用<code>const</code>关键字加以限定。<code>const</code>可以用来修饰成员变量和成员函数。</p><a id="more"></a><h2 id="const成员变量"><a href="#const成员变量" class="headerlink" title="const成员变量"></a><code>const</code>成员变量</h2><p>​    <code>const</code>成员变量的用法和普通<code>const</code>变量的用法相似，只需要在声明时加上<code>const</code>关键字。<strong>初始化<code>const</code>成员变量只有一种方法，就是通过构造函数的初始化列表。</strong></p><h2 id="const成员函数（常成员函数）"><a href="#const成员函数（常成员函数）" class="headerlink" title="const成员函数（常成员函数）"></a><code>const</code>成员函数（常成员函数）</h2><p>​    <code>const</code>成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。<code>const</code> 成员函数也称为常成员函数。</p><p>​    我们通常将<code>get</code>函数设置为常成员函数。读取成员变量的函数的名字通常以<code>get</code>开头，后跟成员变量的名字，所以通常将它们称<code>get</code>函数。</p><p>​    常成员函数需要在声明和定义的时候在<strong>函数头部的结尾</strong>加上<code>const</code>关键字，请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//声明常成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getname</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getscore</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> Student::show()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义常成员函数</span></span><br><span class="line"><span class="keyword">char</span> * Student::getname() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Student::getage() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">float</span> Student::getscore() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>getname()</code>、<code>getage()</code>、<code>getscore()</code>三个函数的功能都很简单，仅仅是为了获取成员变量的值，没有任何修改成员变量的企图，所以我们加了<code>const</code>限制，这是一种保险的做法，同时也使得语义更加明显。</p><p>​    <strong>需要强调的是，必须在成员函数的声明和定义处同时加上<code>const</code>关键字。</strong><code>char *getname() const</code>和<code>char *getname()</code>是两个不同的函数原型，如果只在一个地方加<code>const</code>会导致声明和定义处的函数原型冲突。</p><p> 最后再来区分一下<code>const</code>的位置：</p><ul><li>函数开头的<code>const</code>用来修饰函数的返回值，表示返回值是<code>const</code>类型，也就是不能被修改，例如<code>const char * getname()</code>。</li><li>函数头部的结尾加上<code>const</code>表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如<code>char * getname() const</code>。</li></ul><h2 id="const对象（常对象）"><a href="#const对象（常对象）" class="headerlink" title="const对象（常对象）"></a><code>const</code>对象（常对象）</h2><p>​    在<code>C++</code> 中，<code>const</code>也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，就只能调用类的<code>const</code>成员（包括<code>const</code>成员变量和<code>const</code>成员函数）了。</p><p>​    定义常对象的语法和定义常量的语法类似：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> class  <span class="title">object</span><span class="params">(params)</span></span>;</span><br><span class="line"><span class="function">class <span class="keyword">const</span> <span class="title">object</span><span class="params">(params)</span></span>;</span><br></pre></td></tr></table></figure></p><p>当然你也可以定义<code>const</code>指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">class</span> *<span class="title">p</span> = <span class="title">new</span> <span class="title">class</span>(<span class="title">params</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">const</span> *<span class="title">p</span> = <span class="title">new</span> <span class="title">class</span>(<span class="title">params</span>);</span></span><br></pre></td></tr></table></figure></p><p>​    <code>class</code>为类名，<code>object</code>为对象名，<code>params</code>为实参列表，<code>p</code>为指针名。两种方式定义出来的对象都是常对象。</p><p>​    一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被<code>const</code>修饰的成员了（包括<code>const</code>成员变量和<code>const</code>成员函数），因为非<code>const</code>成员可能会修改对象的数据（编译器也会这样假设），<code>C++</code>禁止这样做。</p><p>​    常对象使用举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getname</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getscore</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> Student::show()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> * Student::getname() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Student::getage() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">float</span> Student::getscore() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Student <span class="title">stu</span><span class="params">(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">90.6</span>)</span></span>;</span><br><span class="line">    <span class="comment">//stu.show();  //error</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;stu.getname()&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;stu.getage()&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;stu.getscore()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Student *pstu = <span class="keyword">new</span> Student(<span class="string">"李磊"</span>, <span class="number">16</span>, <span class="number">80.5</span>);</span><br><span class="line">    <span class="comment">//pstu -&gt; show();  //error</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pstu-&gt;getname()&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;pstu-&gt;getage()&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;pstu-&gt;getscore()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    本例中，<code>stu</code>、<code>pstu</code>分别是常对象以及常对象指针，它们都只能调用<code>const</code>成员函数。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++静态成员变量和函数</title>
      <link href="/2018/07/07/c++%E5%B0%81%E8%A3%853-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/"/>
      <url>/2018/07/07/c++%E5%B0%81%E8%A3%853-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="static静态成员变量"><a href="#static静态成员变量" class="headerlink" title="static静态成员变量"></a><code>static</code>静态成员变量</h2><p>​    对象的内存中包含了成员变量，不同的对象占用不同的内存，这使得不同对象的成员变量相互独立，它们的值不受其他对象的影响。例如有两个相同类型的对象<code>a</code>、<code>b</code>，它们都有一个成员变量<code>m_name</code>，那么修改<code>a.m_name</code>的值不会影响<code>b.m_name</code>的值。</p><p>​    可是有时候我们希望在多个对象之间共享数据，对象<code>a</code>改变了某份数据后对象<code>b</code>可以检测到。共享数据的典型使用场景是计数，以前面的<code>Student</code>类为例，如果我们想知道班级中共有多少名学生，就可以设置一份共享的变量，每次创建对象时让该变量加<code>1</code>。</p><a id="more"></a><p>​    在<code>C++</code>中，我们可以使用静态成员变量来实现多个对象共享数据的目标。静态成员变量是一种特殊的成员变量，它被关键字<code>static</code>修饰，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_total;  <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    这段代码声明了一个静态成员变量<code>m_total</code>，用来统计学生的人数。</p><p>​    <code>static</code>成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为<code>m_total</code>分配一份内存，所有对象使用的都是这份内存中的数据。当某个对象修改了<code>m_total</code>，也会影响到其他对象。</p><p>​    <strong><code>static</code>成员变量必须在类声明的外部初始化</strong>，具体形式为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type class::name = value;</span><br></pre></td></tr></table></figure></p><p>​    <code>type</code>是变量的类型，<code>class</code>是类名，<code>name</code>是变量名，<code>value</code>是初始值。将上面的<code>m_total</code>初始化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Student::m_total = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>​    <strong>静态成员变量在初始化时不能再加<code>static</code>，但必须要有数据类型。被<code>private</code>、<code>protected</code>、<code>public</code>修饰的静态成员变量都可以用这种方式初始化。</strong></p><p>​    注意：<strong><code>static</code>成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的<code>static</code>成员变量不能使用。</strong></p><p>​    <code>static</code>成员变量既可以通过对象来访问，也可以通过类来访问。请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过类类访问 static 成员变量</span></span><br><span class="line">Student::m_total = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//通过对象来访问 static 成员变量</span></span><br><span class="line"><span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">92.5f</span>)</span></span>;</span><br><span class="line">stu.m_total = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//通过对象指针来访问 static 成员变量</span></span><br><span class="line">Student *pstu = <span class="keyword">new</span> Student(<span class="string">"李华"</span>, <span class="number">16</span>, <span class="number">96</span>);</span><br><span class="line">pstu -&gt; m_total = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>​    这三种方式是等效的。</p><p>​    注意：<strong><code>static</code>成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。</strong>具体来说，<code>static</code>成员变量和普通的<code>static</code> 变量类似，都在内存分区中的全局数据区分配内存。</p><p> 下面来看一个完整的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_total;  <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化静态成员变量</span></span><br><span class="line"><span class="keyword">int</span> Student::m_total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123;</span><br><span class="line">    m_total++;  <span class="comment">//操作静态成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::show()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="string">"（当前共有"</span>&lt;&lt;m_total&lt;&lt;<span class="string">"名学生）"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建匿名对象</span></span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">90</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"李磊"</span>, <span class="number">16</span>, <span class="number">80</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"张华"</span>, <span class="number">16</span>, <span class="number">99</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"王康"</span>, <span class="number">14</span>, <span class="number">60</span>)) -&gt; show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>小明的年龄是15，成绩是90（当前共有1名学生）</code><br><code>李磊的年龄是16，成绩是80（当前共有2名学生）</code><br><code>张华的年龄是16，成绩是99（当前共有3名学生）</code><br><code>王康的年龄是14，成绩是60（当前共有4名学生）</code></p><p>​    本例中将<code>m_total</code>声明为静态成员变量，每次创建对象时，会调用构造函数使<code>m_total</code>的值加<code>1</code>。</p><p>​    之所以使用匿名对象，是因为每次创建对象后只会使用它的<code>show()</code>函数，不再进行其他操作。不过使用匿名对象无法回收内存，会导致内存泄露，在中大型程序中不建议使用。</p><h3 id="几点说明"><a href="#几点说明" class="headerlink" title="几点说明"></a>几点说明</h3><p>1) 一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。</p><p> 2)<code>static</code>成员变量和普通<code>static</code>变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，<code>static</code>成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。</p><p> 3) 静态成员变量必须初始化，而且只能在类体外进行。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Student::m_total = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p><p>​    初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为<code>0</code>。全局数据区的变量都有默认的初始值<code>0</code>，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。</p><p> 4) <strong>静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循<code>private</code>、<code>protected</code> 和<code>public</code>关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。</strong></p><h2 id="static静态成员函数"><a href="#static静态成员函数" class="headerlink" title="static静态成员函数"></a><code>static</code>静态成员函数</h2><p>​    在类中，<code>static</code>除了可以声明静态成员变量，还可以声明静态成员函数。普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。</p><p>​    编译器在编译一个普通成员函数时，会隐式地增加一个形参<code>this</code>，并把当前对象的地址赋值给<code>this</code>，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参<code>this</code>，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。</p><p>​    <strong>普通成员变量占用对象的内存，静态成员函数没有<code>this</code>指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。</strong></p><p>​    普通成员函数必须通过对象才能调用，而静态成员函数没有<code>this</code>指针，无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数。</p><p>​    静态成员函数与普通成员函数的根本区别在于：<strong>普通成员函数有<code>this</code>指针，可以访问类中的任意成员；而静态成员函数没有<code>this</code>指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</strong></p><p>​    下面是一个完整的例子，该例通过静态成员函数来获得学生的总人数和总成绩：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//声明静态成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getPoints</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_total;  <span class="comment">//总人数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">float</span> m_points;  <span class="comment">//总成绩</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Student::m_total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> Student::m_points = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123;</span><br><span class="line">    m_total++;</span><br><span class="line">    m_points += score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::show()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义静态成员函数</span></span><br><span class="line"><span class="keyword">int</span> Student::getTotal()&#123;</span><br><span class="line">    <span class="keyword">return</span> m_total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">float</span> Student::getPoints()&#123;</span><br><span class="line">    <span class="keyword">return</span> m_points;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">90.6</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"李磊"</span>, <span class="number">16</span>, <span class="number">80.5</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"张华"</span>, <span class="number">16</span>, <span class="number">99.0</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"王康"</span>, <span class="number">14</span>, <span class="number">60.8</span>)) -&gt; show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total = Student::getTotal();</span><br><span class="line">    <span class="keyword">float</span> points = Student::getPoints();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"当前共有"</span>&lt;&lt;total&lt;&lt;<span class="string">"名学生，总成绩是"</span>&lt;&lt;points&lt;&lt;<span class="string">"，平均分是"</span>&lt;&lt;points/total&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>小明的年龄是15，成绩是90.6</code><br><code>李磊的年龄是16，成绩是80.5</code><br><code>张华的年龄是16，成绩是99</code><br><code>王康的年龄是14，成绩是60.8</code><br><code>当前共有4名学生，总成绩是330.9，平均分是82.725</code></p><p>​    总人数<code>m_total</code>和总成绩<code>m_points</code>由各个对象累加得到，必须声明为 static 才能共享；<code>getTotal()</code>、<code>getPoints()</code>分别用来获取总人数和总成绩，为了访问<code>static</code>成员变量，我们将这两个函数也声明为<code>static</code>。</p><p>​    在<code>C++</code>中，静态成员函数的主要目的是访问静态成员。<code>getTotal()</code>、<code>getPoints()</code>当然也可以声明为普通成员函数，但是它们都只对静态成员进行操作，加上<code>static</code>语义更加明确。</p><p>​    和静态成员变量类似，静态成员函数在声明时要加<code>static</code>，在定义时不能加<code>static</code>。静态成员函数可以通过类来调用（一般都是这样做），也可以通过对象来调用，上例仅仅演示了如何通过类来调用。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++对象内存分布和编译实现</title>
      <link href="/2018/07/02/c++%E5%B0%81%E8%A3%852-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%92%8C%E7%BC%96%E8%AF%91%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/07/02/c++%E5%B0%81%E8%A3%852-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%92%8C%E7%BC%96%E8%AF%91%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>  <strong>类</strong>是创建对象的模板，不占用内存空间，不存在于编译后的可执行文件中；而<strong>对象</strong>是实实在在的数据，需要内存来存储。对象被创建时会在栈区或者堆区分配内存。</p><a id="more"></a><h2 id="C-对象内存分布"><a href="#C-对象内存分布" class="headerlink" title="C++对象内存分布"></a>C++对象内存分布</h2><p>​        直观的认识是，如果创建了 10 个对象，就要分别为这 10 个对象的成员变量和成员函数分配内存，如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-150Z9134434637.png" alt></p><p>​        不同对象的成员变量的值可能不同，需要单独分配内存来存储。但是不同对象的成员函数的代码是一样的，上面的内存模型保存了 10 分相同的代码片段，浪费了不少空间，可以将这些代码片段压缩成一份。</p><p>​        事实上编译器也是这样做的，编译器会将成员变量和成员函数分开存储：<strong>分别为每个对象的成员变量分配内存，但是所有对象都共享同一段函数代码</strong>。</p><p>如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-150Z9135223356.png" alt></p><p>​        <strong>成员变量在堆区或栈区分配内存，成员函数在代码区分配内存。</strong></p><p> <strong>【示例】使用<code>sizeof</code>获取对象所占内存的大小</strong>： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setname</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setage</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setscore</span><span class="params">(<span class="keyword">float</span> score)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Student::setname(<span class="keyword">char</span> *name)&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::setage(<span class="keyword">int</span> age)&#123;</span><br><span class="line">    m_age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::setscore(<span class="keyword">float</span> score)&#123;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::show()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//在栈上创建对象</span></span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(stu)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//在堆上创建对象</span></span><br><span class="line">    Student *pstu = <span class="keyword">new</span> Student();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(*pstu)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//类的大小</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Student)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure></p><p>​        <code>Student</code> 类包含三个成员变量，它们的类型分别是<code>char *</code>、<code>int</code>、<code>float</code>，都占用 <code>4</code>个字节的内存，加起来共占用<code>12</code>个字节的内存。通过 <code>sizeof</code> 求得的结果等于<code>12</code>，恰好说明对象所占用的内存仅仅包含了成员变量。</p><p>​        类可以看做是一种复杂的数据类型，也可以使用 <code>sizeof</code> 求得该类型的大小。从运行结果可以看出，在计算类这种类型的大小时，只计算了成员变量的大小，并没有把成员函数也包含在内。</p><p>​        对象的大小只受成员变量的影响，和成员函数没有关系。</p><p>​        假设 <code>stu</code> 的起始地址为 <code>0X1000</code>，那么该对象的内存分布如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-150Z9162122339.png" alt></p><p>​        <code>m_name</code>、<code>m_age</code>、<code>m_score</code> 按照声明的顺序依次排列，和结构体非常类似，也会有内存对齐的问题。</p><p>​        从上节的分析中可以看出，对象的内存中只保留了成员变量，除此之外没有任何其他信息，程序运行时不知道 <code>stu</code> 的类型为  <code>Student</code>，也不知道它还有四个成员函数 <code>setname()</code>、<code>setage()</code>、<code>setscore()</code>、<code>show()</code>，C++  究竟是如何通过对象调用成员函数的呢？ </p><h2 id="C-函数的编译"><a href="#C-函数的编译" class="headerlink" title="C++函数的编译"></a><code>C++</code>函数的编译</h2><p>​        <code>C++</code>和<code>C</code>语言的编译方式不同。<code>C</code>语言中的函数在编译时名字不变，或者只是简单的加一个下划线<code>_</code>（不同的编译器有不同的实现），例如，<code>func()</code> 编译后为 <code>func()</code> 或<code>_func()</code>。</p><p>​        而<strong><code>C++</code>中的函数在编译时会根据它所在的命名空间、它所属的类、以及它的参数列表（也叫参数签名）等信息进行重新命名，形成一个新的函数名。</strong>这个新的函数名只有编译器知道，对用户是不可见的。对函数重命名的过程叫做<strong>名字编码</strong><code>（Name Mangling）</code>，是通过一种特殊的算法来实现的。</p><p>​        <code>Name Mangling</code> 的算法是可逆的，既可以通过现有函数名计算出新函数名，也可以通过新函数名逆向推演出原有函数名。<code>Name  Mangling</code> 可以确保新函数名的唯一性，只要函数所在的命名空间、所属的类、包含的参数列表等有一个不同，最后产生的新函数名也不同。</p><p>​        如果你希望看到经 <code>Name Mangling</code> 产生的新函数名，可以只声明而不定义函数，这样调用函数时就会产生链接错误，从报错信息中就可以看到新函数名。请看下面的代码： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ns&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    display();</span><br><span class="line">    display(<span class="number">1</span>);</span><br><span class="line">    ns::display();</span><br><span class="line">    Demo obj;</span><br><span class="line">    obj.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        该例中声明了四个同名函数，包括两个具有重载关系的全局函数，一个位于命名空间 <code>ns</code>下的函数，以及一个属于类<code>Demo</code>的函数。它们都是只声明而未定义的函数。</p><p>​        在 VS 下编译源代码可以看到类似下面的错误信息：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-150Z91ZU0P1.png" alt></p><p>​        小括号中就是经<code></code> Name Mangling <code>产生的新函数名，它们都以</code>?<code>开始，以区别</code>C<code>语言中的</code>_`。</p><p>​        上图是 <code>VS2010</code> 产生的错误信息，不同的编译器有不同的 <code>Name Mangling</code> 算法，产生的函数名也不一样。 </p><blockquote><p> <code>__thiscall</code>、<code>cdecl</code>是函数调用惯例。</p></blockquote><p>​        除了函数，某些变量也会经 <code>Name Mangling</code> 算法产生新名字，这里不再赘述。 </p><h2 id="成员函数的调用"><a href="#成员函数的调用" class="headerlink" title="成员函数的调用"></a>成员函数的调用</h2><p>​        从上图可以看出，成<strong>员函数最终被编译成与对象无关的全局函数</strong>，如果函数体中没有成员变量，那问题就很简单，不用对函数做任何处理，直接调用即可。</p><p>​        如果成员函数中使用到了成员变量该怎么办呢？<strong>成员变量的作用域不是全局，不经任何处理就无法在函数内部访问。</strong></p><p>​        <strong><code>C++</code>规定，编译成员函数时要额外添加一个参数，把当前对象的指针传递进去，通过指针来访问成员变量。</strong></p><p>​        假设<code>Demo</code>类有两个<code>int</code>型的成员变量，分别是<code>a</code>和<code>b</code>，并且在成员函数<code>display()</code>中使用到了，如下所示： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Demo::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        那么编译后的代码类似于： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_function_name</span><span class="params">(Demo * <span class="keyword">const</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过指针p来访问a、b</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p-&gt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p-&gt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        使用<code>obj.display()</code>调用函数时，也会被编译成类似下面的形式： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_function_name(&amp;obj);</span><br></pre></td></tr></table></figure><p>​        这样通过传递对象指针就完成了成员函数和成员变量的关联。这与我们从表明上看到的刚好相反，通过对象调用成员函数时，不是通过对象找函数，而是通过函数找对象。</p><p>​        这一切都是隐式完成的，对程序员来说完全透明，就好像这个额外的参数不存在一样。</p><p>​        最后需要提醒的是，<code>Demo * const p</code>中的 <code>const</code>表示指针不能被修改，<code>p</code>只能指向当前对象，不能指向其他对象。</p><h2 id="this指针详解"><a href="#this指针详解" class="headerlink" title="this指针详解"></a><code>this</code>指针详解</h2><p>​    <code>this</code>是<code>C++</code>中的一个关键字，也是一个<code>const</code>指针，它指向当前对象，通过它可以访问当前对象的所有成员。</p><p>​    <strong>所谓当前对象，是指正在使用的对象。</strong>例如对于<code>stu.show();</code>，<code>stu</code>就是当前对象，<code>this</code>就指向<code>stu</code>。</p><p>​    下面是使用<code>this</code>的一个完整示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setname</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setage</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setscore</span><span class="params">(<span class="keyword">float</span> score)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Student::setname(<span class="keyword">char</span> *name)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::setage(<span class="keyword">int</span> age)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::setscore(<span class="keyword">float</span> score)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::show()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>-&gt;name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;<span class="keyword">this</span>-&gt;age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;<span class="keyword">this</span>-&gt;score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student *pstu = <span class="keyword">new</span> Student;</span><br><span class="line">    pstu -&gt; setname(<span class="string">"李华"</span>);</span><br><span class="line">    pstu -&gt; setage(<span class="number">16</span>);</span><br><span class="line">    pstu -&gt; setscore(<span class="number">96.5</span>);</span><br><span class="line">    pstu -&gt; show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>李华的年龄是16，成绩是96.5</code></p><p>​    <code>this</code>只能用在类的内部，通过<code>this</code>可以访问类的所有成员，包括<code>private</code>、<code>protected</code>、<code>public</code>属性的。</p><p>​    本例中成员函数的参数和成员变量重名，只能通过<code>this</code>区分。以成员函数<code>setname(char *name)</code>为例，它的形参是<code>name</code>，和成员变量<code>name</code>重名，如果写作<code>name = name;</code>这样的语句，就是给形参<code>name</code>赋值，而不是给成员变量<code>name</code>赋值。而写作<code>this-&gt;name = name;</code>后，<code>=</code>左边的<code>name</code>就是成员变量，右边的<code>name</code>就是形参，一目了然。</p><p>​    注意，<code>this</code>是一个指针，要用<code>-&gt;</code>来访问成员变量或成员函数。</p><p>​    <code>this</code>虽然用在类的内部，但是只有在对象被创建以后才会给<code>this</code>赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给<code>this</code>赋值。本例中，<code>this</code>的值和<code>pstu</code>的值是相同的。</p><p>​    我们不妨来证明一下，给<code>Student</code>类添加一个成员函数<code>printThis()</code>，专门用来输出<code>this</code>的值，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Student::printThis()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>main()</code>函数中创建对象并调用<code>printThis()</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student *pstu1 = <span class="keyword">new</span> Student;</span><br><span class="line">pstu1 -&gt; printThis();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pstu1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Student *pstu2 = <span class="keyword">new</span> Student;</span><br><span class="line">pstu2 -&gt; printThis();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pstu2&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>0x7b17d8</code><br><code>0x7b17d8</code><br><code>0x7b17f0</code><br><code>0x7b17f0</code></p><p>​    可以发现，<code>this</code>确实指向了当前对象，而且对于不同的对象，<code>this</code>的值也不一样。</p><p> 几点注意：</p><ul><li><code>this</code>是<code>const</code> 指针，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。</li><li><code>this</code>只能在成员函数内部使用，用在其他地方没有意义，也是非法的。</li><li>只有当对象被创建后<code>this</code>才有意义，因此不能在<code>static</code>成员函数中使用（后续会讲到<code>static</code>成员）。</li></ul><h3 id="this到底是什么"><a href="#this到底是什么" class="headerlink" title="this到底是什么"></a><code>this</code>到底是什么</h3><p>​    <strong><code>this</code>实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给<code>this</code>。不过 <code>this</code>这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。</strong></p><p>​    <code>this</code>作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给<code>this</code>赋值。</p><p>​    在上节中讲到，成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。<strong>这个额外的参数，实际上就是<code>this</code>，它是成员函数和成员变量关联的桥梁。</strong></p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++类的封装</title>
      <link href="/2018/06/25/c++%E5%B0%81%E8%A3%851-%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/"/>
      <url>/2018/06/25/c++%E5%B0%81%E8%A3%851-%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="类的定义和对象的创建"><a href="#类的定义和对象的创建" class="headerlink" title="类的定义和对象的创建"></a>类的定义和对象的创建</h2><p>​    <strong>类是创建对象的模板，一个类可以创建多个对象，每个对象都是类类型的一个变量；创建对象的过程也叫类的实例化。每个对象都是类的一个具体实例（<code>Instance</code>），拥有类的成员变量和成员函数</strong></p><a id="more"></a><p>一个简单的类的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>class</code>是<code>C++</code>中新增的关键字，专门用来定义类。</li><li><code>Student</code>是类的名称；类名的首字母一般大写，以和其他的标识符区分开。</li><li><code>{ }</code>内部是类所包含的成员变量和成员函数，它们统称为类的成员（<code>Member</code>）；由<code>{ }</code>包围起来的部分有时也称为类体，和函数体的概念类似。</li><li><code>public</code>也是<code>C++</code>的新增关键字。</li><li><strong>类定义的最后有一个分号<code>;</code>，它是类定义的一部分，表示类定义结束了，不能省略。</strong></li></ul><p><strong>类只是一个模板（<code>Template</code>），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。</strong></p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>有了<code>Student</code>类后，就可以通过它来创建对象了，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student liLei;  <span class="comment">//创建对象</span></span><br></pre></td></tr></table></figure><p><code>Student</code>是类名，<code>liLei</code>是对象名。这和使用基本类型定义变量的形式类似：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;  <span class="comment">//定义整型变量</span></span><br></pre></td></tr></table></figure><p>从这个角度考虑，我们<strong>可以把<code>Student</code>看做一种新的数据类型，把<code>liLei</code>看做一个变量。</strong></p><p> 在创建对象时，class 关键字可要可不要，但是出于习惯我们通常会省略掉 class 关键字，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="title">LiLei</span>;</span>  <span class="comment">//正确Student LiLei;  //同样正确</span></span><br></pre></td></tr></table></figure><p>除了创建单个对象，还可以创建对象数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student allStu[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><p>该语句创建了一个<code>allStu</code>数组，它拥有<code>100</code>个元素，每个元素都是 <code>Student</code>类型的对象。</p><h3 id="访问类的成员"><a href="#访问类的成员" class="headerlink" title="访问类的成员"></a>访问类的成员</h3><p><strong>创建对象以后，可以使用点号<code>.</code>来访问成员变量和成员函数，这和通过结构体变量来访问它的成员类似</strong>，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类通常定义在函数外面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//类包含的变量</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="comment">//类包含的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    Student stu;</span><br><span class="line">    stu.name = <span class="string">"小明"</span>;</span><br><span class="line">    stu.age = <span class="number">15</span>;</span><br><span class="line">    stu.score = <span class="number">92.5f</span>;</span><br><span class="line">    stu.say();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>小明的年龄是15，成绩是92.5</code></p><p><code>stu</code>是一个对象，占用内存空间，可以对它的成员变量赋值，也可以读取它的成员变量。</p><h3 id="使用对象指针"><a href="#使用对象指针" class="headerlink" title="使用对象指针"></a>使用对象指针</h3><p>​    <code>C</code>语言中经典的指针在<code>C++</code>中仍然广泛使用，尤其是指向对象的指针，没有它就不能实现某些功能。</p><pre><code>上面代码中创建的对象` stu `在栈上分配内存，需要使用`&amp;`获取它的地址，例如：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student stu;</span><br><span class="line">Student *pStu = &amp;stu;</span><br></pre></td></tr></table></figure><p>​    <code>pStu</code>是一个指针，它指向<code>Student</code>类型的数据，也就是通过<code>Student</code>创建出来的对象。</p><p>​    当然，你也可以在堆上创建对象，这个时候就需要使用前面讲到的<code>new</code>关键字，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student *pStu = <span class="keyword">new</span> Student;</span><br></pre></td></tr></table></figure><p>​    在栈上创建出来的对象都有一个名字，比如<code>stu</code>，使用指针指向它不是必须的。但是通过<code>new</code>创建出来的对象就不一样了，它在堆上分配内存，没有名字，只能得到一个指向它的指针，所以必须使用一个指针变量来接收这个指针，否则以后再也无法找到这个对象了，更没有办法使用它。也就是说，<strong>使用<code>new</code>在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。</strong></p><p>​    栈内存是程序自动管理的，不能使用<code>delete</code>删除在栈上创建的对象；堆内存由程序员管理，对象使用完毕后可以通过<code>delete</code>删除。在实际开发中，<code>new</code>和<code>delete</code>往往成对出现，以保证及时删除不再使用的对象，防止无用内存堆积。</p><p>​    <strong>有了对象指针后，可以通过箭头<code>-&gt;</code>来访问对象的成员变量和成员函数，这和通过结构体指针来访问它的成员类似</strong>，请看下面的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pStu -&gt; name = <span class="string">"小明"</span>;</span><br><span class="line">pStu -&gt; age = <span class="number">15</span>;</span><br><span class="line">pStu -&gt; score = <span class="number">92.5f</span>;</span><br><span class="line">pStu -&gt; say();</span><br></pre></td></tr></table></figure><p>下面是一个完整的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student *pStu = <span class="keyword">new</span> Student;</span><br><span class="line">    pStu -&gt; name = <span class="string">"小明"</span>;</span><br><span class="line">    pStu -&gt; age = <span class="number">15</span>;</span><br><span class="line">    pStu -&gt; score = <span class="number">92.5f</span>;</span><br><span class="line">    pStu -&gt; say();</span><br><span class="line">    <span class="keyword">delete</span> pStu;  <span class="comment">//删除对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>小明的年龄是15，成绩是92.5</code></p><h2 id="类的成员变量和成员函数"><a href="#类的成员变量和成员函数" class="headerlink" title="类的成员变量和成员函数"></a>类的成员变量和成员函数</h2><p>​    类的成员变量和普通变量一样，也有数据类型和名称，占用固定长度的内存。但是，在定义类的时候不能对成员变量赋值，因为类只是一种数据类型或者说是一种模板，本身不占用内存空间，而变量的值则需要内存来存储。</p><p>​    类的成员函数也和普通函数一样，都有返回值和参数列表，它与一般函数的区别是：成员函数是一个类的成员，出现在类体中，它的作用范围由类来决定；而普通函数是独立的，作用范围是全局的，或位于某个命名空间内。</p><p>​    上节我们在示例中给出了<code>Student</code>类的定义，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    这段代码在类体中定义了成员函数。你也可以只在类体中声明函数，而将函数定义放在类体外面，如下图所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="keyword">void</span> Student::say()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在类体中直接定义函数时，不需要在函数名前面加上类名，因为函数属于哪一个类是不言而喻的。</p><p>​    <strong>但当成员函数定义在类外时，就必须在函数名前面加上类名予以限定。<code>::</code>被称为域解析符（也称作用域运算符或作用域限定符），用来连接类名和函数名，指明当前函数属于哪个类。</strong></p><p>​    <strong>成员函数必须先在类体中作原型声明，然后在类外定义，也就是说类体的位置应在函数定义之前。</strong></p><h3 id="在类体中和类体外定义成员函数的区别"><a href="#在类体中和类体外定义成员函数的区别" class="headerlink" title="在类体中和类体外定义成员函数的区别"></a>在类体中和类体外定义成员函数的区别</h3><p>​    在类体中和类体外定义成员函数是有区别的：<strong>在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。当然，在类体内部定义的函数也可以加<code>inline</code>关键字，但这是多余的，因为类体内部定义的函数默认就是内联函数。</strong></p><p>​    内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以我建议在类体内部对成员函数作声明，而在类体外部进行定义，这是一种良好的编程习惯，实际开发中大家也是这样做的。</p><p>​    当然，如果你的函数比较短小，希望定义为内联函数，那也没有什么不妥的。</p><p>​    <strong>如果你既希望将函数定义在类体外部，又希望它是内联函数，那么可以在定义函数时加<code>inline</code>关键字。</strong>当然你也可以在函数声明处加<code>inline</code>，不过这样做没有效果，编译器会忽略函数声明处的<code>inline</code>。</p><p> 下面是一个将内联函数定义在类外部的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;  <span class="comment">//内联函数声明，可以增加 inline 关键字，但编译器会忽略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Student::say()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，<code>say()</code>就会变成内联函数。</p><p>​    <strong>这种在类体外定义<code>inline</code>函数的方式，必须将类的定义和成员函数的定义都放在同一个头文件中（或者同一个源文件中），否则编译时无法进行嵌入（将函数代码的嵌入到函数调用出）。</strong></p><p>​    再次强调，虽然<code>C++</code>支持将内联函数定义在类的外部，但我强烈建议将函数定义在类的内部，这样它会自动成为内联函数，不必费力不讨好地将它定义在类的外部，这样并没有任何优势。</p><h2 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h2><h3 id="C和C-中struct区别"><a href="#C和C-中struct区别" class="headerlink" title="C和C++中struct区别"></a><code>C</code>和<code>C++</code>中<code>struct</code>区别</h3><ul><li><p><code>c</code>语言<code>struct</code>只有变量</p></li><li><p><code>c++</code>语言<code>struct</code>既有变量，也有函数</p></li></ul><h3 id="c语言类的封装"><a href="#c语言类的封装" class="headerlink" title="c语言类的封装"></a><code>c</code>语言类的封装</h3><p>​    我们编写程序的目的是为了解决现实中的问题，而这些问题的构成都是由各种事物组成，我们在计算机中要解决这种问题，首先要做就是要将这个问题的参与者：事和物抽象到计算机程序中，也就是用程序语言表示现实的事物。</p><p>​    那么现在问题是如何用程序语言来表示现实事物？现实世界的事物所具有的共性就是每个事物都具有自身的属性，一些自身具有的行为，所以如果我们能把事物的属性和行为表示出来，那么就可以抽象出来这个事物。</p><p>​    比如我们要表示人这个对象，在<code>c</code>语言中，我们可以这么表示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;Person;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Aninal</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> type; <span class="comment">//动物种类</span></span><br><span class="line">&#125;Ainmal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PersonEat</span><span class="params">(Person* person)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s在吃人吃的饭!\n"</span>,person-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AnimalEat</span><span class="params">(Ainmal* animal)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s在吃动物吃的饭!\n"</span>, animal-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Person person;</span><br><span class="line"><span class="built_in">strcpy</span>(person.name, <span class="string">"小明"</span>);</span><br><span class="line">person.age = <span class="number">30</span>;</span><br><span class="line">AnimalEat(&amp;person);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    定义一个结构体用来表示一个对象所包含的属性，函数用来表示一个对象所具有的行为，这样我们就表示出来一个事物，在<code>c</code>语言中，行为和属性是分开的，也就是说吃饭这个属性不属于某类对象，而属于所有的共同的数据，所以不单单是<code>PeopleEat</code>可以调用<code>Person</code>数据，<code>AnimalEat</code>也可以调用<code>Person</code>数据，那么万一调用错误，将会导致问题发生。</p><p>​    从这个案例我们应该可以体会到，<strong>属性和行为应该放在一起，一起表示一个具有属性和行为的对象。</strong></p><h3 id="c-类的封装"><a href="#c-类的封装" class="headerlink" title="c++类的封装"></a><code>c++</code>类的封装</h3><p>​    假如某对象的某项属性不想被外界获知，比如说漂亮女孩的年龄不想被其他人知道，那么年龄这条属性应该作为女孩自己知道的属性；或者女孩的某些行为不想让外界知道，只需要自己知道就可以。那么这种情况下，封装应该再提供一种机制能够给属性和行为的访问权限控制住。</p><p>​    所以说封装特性包含两个方面，一个是属性和变量合成一个整体，一个是给属性和函数增加访问权限。</p><table><thead><tr><th>访问属性</th><th>属性</th><th>对象内部</th><th>对象外部</th></tr></thead><tbody><tr><td><code>public</code></td><td>公有</td><td>可访问</td><td>可访问</td></tr><tr><td><code>protected</code></td><td>保护</td><td>可访问</td><td>不可访问</td></tr><tr><td><code>private</code></td><td>私有</td><td>可访问</td><td>不可访问</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装两层含义</span></span><br><span class="line"><span class="comment">//1. 属性和行为合成一个整体</span></span><br><span class="line"><span class="comment">//2. 访问控制，现实事物本身有些属性和行为是不对外开放</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="comment">//人具有的行为(函数)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dese</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我有钱，年轻，个子又高，就爱嘚瑟!"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="comment">//人的属性(变量)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> mTall; <span class="comment">//多高，可以让外人知道</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> mMoney; <span class="comment">// 有多少钱,只能儿子孙子知道</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> mAge; <span class="comment">//年龄，不想让外人知道</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">p.mTall = <span class="number">220</span>;</span><br><span class="line"><span class="comment">//p.mMoney 保护成员外部无法访问</span></span><br><span class="line"><span class="comment">//p.mAge 私有成员外部无法访问</span></span><br><span class="line">p.Dese();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong><code>class</code>默认访问权限为<code>private</code>,<code>struct</code>默认访问权限为<code>public</code>. </strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"><span class="comment">//a.mAge; //无法访问私有成员</span></span><br><span class="line">b.mAge; <span class="comment">//可正常外部访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>把变量（属性）和函数（操作）合成一个整体，封装在一个类中</p></li><li><p>对变量和函数进行访问控制</p></li></ul><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ul><li><p>在类的内部(作用域范围内)，没有访问权限之分，所有成员可以相互访问</p></li><li><p>在类的外部(作用域范围外)，访问权限才有意义：<code>public</code>，<code>private</code>，<code>protected</code></p></li><li><p>在类的外部，只有<code>public</code>修饰的成员才能被访问，在没有涉及继承与派生时，<code>private</code>和<code>protected</code>是同等级的，外部不允许访问</p></li></ul><h3 id="将成员变量设置为private"><a href="#将成员变量设置为private" class="headerlink" title="将成员变量设置为private"></a>将成员变量设置为<code>private</code></h3><ul><li><p>可赋予客户端访问数据的一致性。</p><p>​    如果成员变量不是<code>public</code>，客户端唯一能够访问对象的方法就是通过成员函数。如果类中所有<code>public</code>权限的成员都是函数，客户在访问类成员时只会默认访问函数，不需要考虑访问的成员需不需要添加(),这就省下了许多搔首弄耳的时间。</p></li><li><p>可细微划分访问控制。</p><p>​    使用成员函数可使得我们对变量的控制处理更加精细。如果我们让所有的成员变量为<code>public</code>，每个人都可以读写它。如果我们设置为<code>private</code>，我们可以实现“不准访问”、“只读访问”、“读写访问”，甚至你可以写出“只写访问”。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccessLevels</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//对只读属性进行只读访问</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getReadOnly</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> readOnly; &#125;</span><br><span class="line"><span class="comment">//对读写属性进行读写访问</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setReadWrite</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123; readWrite = val; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getReadWrite</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> readWrite; &#125;</span><br><span class="line"><span class="comment">//对只写属性进行只写访问</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWriteOnly</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123; writeOnly = val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> readOnly; <span class="comment">//对外只读访问</span></span><br><span class="line"><span class="keyword">int</span> noAccess; <span class="comment">//外部不可访问</span></span><br><span class="line"><span class="keyword">int</span> readWrite; <span class="comment">//读写访问</span></span><br><span class="line"><span class="keyword">int</span> writeOnly; <span class="comment">//只写访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++向上转型</title>
      <link href="/2018/06/21/c++%E7%BB%A7%E6%89%BF4-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B/"/>
      <url>/2018/06/21/c++%E7%BB%A7%E6%89%BF4-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>在<code>C/C++</code>中经常会发生数据类型的转换，例如将<code>int</code>类型的数据赋值给<code>float</code>类型的变量时，编译器会先把<code>int</code>类型的数据转换为<code>float</code>类型再赋值；反过来，<code>float</code>类型的数据在经过类型转换后也可以赋值给<code>int</code>类型的变量。</p><a id="more"></a><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>​    数据类型转换的前提是，编译器知道如何对数据进行取舍。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10.9</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br></pre></td></tr></table></figure><p>​    输出结果为<code>10</code>，编译器会将小数部分直接丢掉（不是四舍五入）。再如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, b);</span><br></pre></td></tr></table></figure><p>​    输出结果为<code>10.000000</code>，编译器会自动添加小数部分。</p><p>​    <strong>类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这在<code>C++</code>中称为<code>向上转型</code>（<code>Upcasting</code>）。相应地，将基类赋值给派生类称为<code>向下转型</code>（<code>Downcasting</code>）。</strong></p><p>​    向上转型非常安全，可以由编译器自动完成；向下转型有风险，需要程序员手动干预。</p><blockquote><p>向上转型和向下转型是面向对象编程的一种通用概念，它们也存在于<code>Java</code>、<code>C#</code>等编程语言中。</p></blockquote><h3 id="将派生类对象赋值给基类对象"><a href="#将派生类对象赋值给基类对象" class="headerlink" title="将派生类对象赋值给基类对象"></a>将派生类对象赋值给基类对象</h3><p>下面的例子演示了如何将派生类对象赋值给基类对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a): m_a(a)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> A::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class A: m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">B::B(<span class="keyword">int</span> a, <span class="keyword">int</span> b): A(a), m_b(b)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> B::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class B: m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="string">", m_b="</span>&lt;&lt;m_b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">66</span>, <span class="number">99</span>)</span></span>;</span><br><span class="line">    <span class="comment">//赋值前</span></span><br><span class="line">    a.display();</span><br><span class="line">    b.display();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"--------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//赋值后</span></span><br><span class="line">    a = b;</span><br><span class="line">    a.display();</span><br><span class="line">    b.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>Class A: m_a=10</code><br><code>Class B: m_a=66, m_b=99</code><br><code>----------------------------</code><br><code>Class A: m_a=66</code><br><code>Class B: m_a=66, m_b=99</code></p><p>​    本例中<code>A</code>是基类， <code>B</code>是派生类，<code>a</code>、<code>b</code>分别是它们的对象，由于派生类<code>B</code>包含了从基类<code>A</code>继承来的成员，因此可以将派生类对象<code>b</code>赋值给基类对象<code>a</code>。通过运行结果也可以发现，赋值后<code>a</code>所包含的成员变量的值已经发生了变化。</p><p>​    <strong>赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了成员变量，所以对象之间的赋值是成员变量的赋值，成员函数不存在赋值问题。</strong>运行结果也有力地证明了这一点，虽然有<code>a=b;</code>这样的赋值过程，但是<code>a.display()</code>始终调用的都是<code>A</code>类的<code>display()</code>函数。换句话说，对象之间的赋值不会影响成员函数，也不会影响<code>this</code>指针。</p><p>​    将派生类对象赋值给基类对象时，会舍弃派生类新增的成员，也就是“大材小用”，如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1G45K0C-0.png" alt></p><p>​    可以发现，即使将派生类对象赋值给基类对象，基类对象也不会包含派生类的成员，所以依然不同通过基类对象来访问派生类的成员。对于上面的例子，<code>a.m_a</code>是正确的，但<code>a.m_b</code>就是错误的，因为<code>a</code>不包含成员<code>m_b</code>。</p><p>​    <strong>这种转换关系是不可逆的，只能用派生类对象给基类对象赋值，而不能用基类对象给派生类对象赋值。</strong>理由很简单，基类不包含派生类的成员变量，无法对派生类的成员变量赋值。同理，同一基类的不同派生类对象之间也不能赋值。</p><p>​    要理解这个问题，还得从赋值的本质入手。赋值实际上是向内存填充数据，当数据较多时很好处理，舍弃即可；本例中将<code>b</code>赋值给<code>a</code>时（执行<code>a=b;</code>语句），成员<code>m_b</code>是多余的，会被直接丢掉，所以不会发生赋值错误。但当数据较少时，问题就很棘手，编译器不知道如何填充剩下的内存；如果本例中有<code>b= a;</code>这样的语句，编译器就不知道该如何给变量<code>m_b</code>赋值，所以会发生错误。</p><h3 id="将派生类指针赋值给基类指针"><a href="#将派生类指针赋值给基类指针" class="headerlink" title="将派生类指针赋值给基类指针"></a>将派生类指针赋值给基类指针</h3><p>​    <strong>除了可以将派生类对象赋值给基类对象（对象变量之间的赋值），还可以将派生类指针赋值给基类指针（对象指针之间的赋值）。</strong>我们先来看一个多继承的例子，继承关系为：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1G45IP6-1.jpg" alt></p><p> 下面的代码实现了这种继承关系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a): m_a(a)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> A::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class A: m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间派生类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">B::B(<span class="keyword">int</span> a, <span class="keyword">int</span> b): A(a), m_b(b)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> B::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class B: m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="string">", m_b="</span>&lt;&lt;m_b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C(<span class="keyword">int</span> c);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line">C::C(<span class="keyword">int</span> c): m_c(c)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> C::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class C: m_c="</span>&lt;&lt;m_c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终派生类D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line">D::D(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d): B(a, b), C(c), m_d(d)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> D::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class D: m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="string">", m_b="</span>&lt;&lt;m_b&lt;&lt;<span class="string">", m_c="</span>&lt;&lt;m_c&lt;&lt;<span class="string">", m_d="</span>&lt;&lt;m_d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *pa = <span class="keyword">new</span> A(<span class="number">1</span>);</span><br><span class="line">    B *pb = <span class="keyword">new</span> B(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">    C *pc = <span class="keyword">new</span> C(<span class="number">3</span>);</span><br><span class="line">    D *pd = <span class="keyword">new</span> D(<span class="number">4</span>, <span class="number">40</span>, <span class="number">400</span>, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    pa = pd;</span><br><span class="line">    pa -&gt; display();</span><br><span class="line"></span><br><span class="line">    pb = pd;</span><br><span class="line">    pb -&gt; display();</span><br><span class="line"></span><br><span class="line">    pc = pd;</span><br><span class="line">    pc -&gt; display();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"-----------------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pa="</span>&lt;&lt;pa&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pb="</span>&lt;&lt;pb&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pc="</span>&lt;&lt;pc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pd="</span>&lt;&lt;pd&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>Class A: m_a=4</code><br><code>Class B: m_a=4, m_b=40</code><br><code>Class C: m_c=400</code><br><code>-----------------------</code><br><code>pa=0x9b17f8</code><br><code>pb=0x9b17f8</code><br><code>pc=0x9b1800</code><br><code>pd=0x9b17f8</code></p><p>​    本例中定义了多个对象指针，并尝试将派生类指针赋值给基类指针。与对象变量之间的赋值不同的是，对象指针之间的赋值并没有拷贝对象的成员，也没有修改对象本身的数据，仅仅是改变了指针的指向。</p><h4 id="1-通过基类指针访问派生类的成员"><a href="#1-通过基类指针访问派生类的成员" class="headerlink" title="1) 通过基类指针访问派生类的成员"></a>1) 通过基类指针访问派生类的成员</h4><p>​    请读者先关注第<code>68</code>行代码，我们将派生类指针<code>pd</code>赋值给了基类指针<code>pa</code>，从运行结果可以看出，调用<code>display()</code>函数时虽然使用了派生类的成员变量，但是<code>display()</code>函数本身却是基类的。也就是说，将派生类指针赋值给基类指针时，通过基类指针只能使用派生类的成员变量，但不能使用派生类的成员函数，这看起来有点不伦不类，究竟是为什么呢？第<code>71</code>、<code>74</code>行代码也是类似的情况。</p><p>​    <code>pa</code>本来是基类<code>A</code>的指针，现在指向了派生类<code>D</code>的对象，这使得隐式指针<code>this</code> 发生了变化，也指向了<code>D</code>类的对象，所以最终在<code>display()</code>内部使用的是<code>D</code>类对象的成员变量，相信这一点不难理解。</p><p>​    编译器虽然通过指针的指向来访问成员变量，但是却不通过指针的指向来访问成员函数：编译器通过指针的类型来访问成员函数。对于<code>pa</code>，它的类型是<code>A</code>，不管它指向哪个对象，使用的都是<code>A</code>类的成员函数。</p><p>​    概括起来说就是：<strong>编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数。</strong></p><h4 id="2-赋值后值不一致的情况"><a href="#2-赋值后值不一致的情况" class="headerlink" title="2) 赋值后值不一致的情况"></a>2) 赋值后值不一致的情况</h4><p>​    本例中我们将最终派生类的指针<code>pd</code>分别赋值给了基类指针<code>pa</code>、<code>pb</code>、<code>pc</code>，按理说它们的值应该相等，都指向同一块内存，但是运行结果却有力地反驳了这种推论，只有<code>pa</code>、<code>pb</code>、<code>pd</code>三个指针的值相等，<code>pc</code>的值比它们都大。也就是说，执行<code>pc = pd;</code>语句后，<code>pc</code>和<code>pd</code>的值并不相等。</p><p>​    这非常出乎我们的意料，按照我们通常的理解，赋值就是将一个变量的值交给另外一个变量，不会出现不相等的情况，究竟是什么导致了<code>pc</code>和<code>pd</code>不相等呢？我们将在《<code>将派生类指针赋值给基类指针时到底发生了什么？</code>》一节中解开谜底。</p><h3 id="将派生类引用赋值给基类引用"><a href="#将派生类引用赋值给基类引用" class="headerlink" title="将派生类引用赋值给基类引用"></a>将派生类引用赋值给基类引用</h3><p>​    引用在本质上是通过指针的方式实现的，既然基类的指针可以指向派生类的对象，那么我们就有理由推断：<strong>基类的引用也可以指向派生类的对象，并且它的表现和指针是类似的。</strong></p><p>​    修改上例中<code>main()</code>函数内部的代码，用引用取代指针：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    D d(4, 40, 400, 4000);</span><br><span class="line">   </span><br><span class="line">    A &amp;ra = d;</span><br><span class="line">    B &amp;rb = d;</span><br><span class="line">    C &amp;rc = d;</span><br><span class="line">   </span><br><span class="line">    ra.display();</span><br><span class="line">    rb.display();</span><br><span class="line">    rc.display();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>Class A: m_a=4</code><br><code>Class B: m_a=4, m_b=40</code><br><code>Class C: m_c=400</code></p><p>​    <code>ra</code>、<code>rb</code>、<code>rc</code>是基类的引用，它们都引用了派生类对象<code>d</code>，并调用了<code>display()</code>函数，从运行结果可以发现，虽然使用了派生类对象的成员变量，但是却没有使用派生类的成员函数，这和指针的表现是一样的。</p><p>​    引用和指针的表现之所以如此类似，是因为引用和指针并没有本质上的区别，引用仅仅是对指针进行了简单封装。</p><p>​    最后需要注意的是，向上转型后通过基类的对象、指针、引用只能访问从基类继承过去的成员（包括成员变量和成员函数），不能访问派生类新增的成员。</p><h2 id="将派生类指针赋值给基类指针时到底发生了什么？"><a href="#将派生类指针赋值给基类指针时到底发生了什么？" class="headerlink" title="将派生类指针赋值给基类指针时到底发生了什么？"></a>将派生类指针赋值给基类指针时到底发生了什么？</h2><p>​    通过上节最后一个例子我们发现，将派生类的指针赋值给基类的指针后，它们的值有可能相等，也有可能不相等。例如执行<code>pc = pd;</code>语句后，<code>pc</code>的值为<code>0x9b1800</code>，<code>pd</code>的值为<code>0x9b17f8</code>，它们不相等。</p><p>​    我们通常认为，赋值就是将一个变量的值交给另外一个变量，这种想法虽然没错，但是有一点要注意，就是赋值以前编译器可能会对现有的值进行处理。例如将<code>double</code>类型的值赋给<code>int</code>类型的变量，编译器会直接抹掉小数部分，导致赋值运算符两边变量的值不相等。请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="keyword">int</span> n = pi;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pi&lt;&lt;<span class="string">", "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>3.14159, 3</code></p><p>​    <code>pi</code>的值是<code>3.14159</code>，执行<code>int n = pi;</code>后<code>n</code>的值变为<code>3</code>，虽然是赋值，但是<code>pi</code>和<code>n</code>的值并不相等。</p><p>​    将派生类的指针赋值给基类的指针时也是类似的道理，编译器也可能会在赋值前进行处理。要理解这个问题，首先要清楚<code>D</code>类对象的内存模型，如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1G5491A0-0.jpg" alt></p><p>​    首先要明确的一点是，对象的指针必须要指向对象的起始位置。对于<code>A</code>类和<code>B</code>类来说，它们的子对象的起始地址和<code>D</code>类对象一样，所以将<code>pd</code>赋值给<code>pa</code>、<code>pb</code>时不需要做任何调整，直接传递现有的值即可；而<code>C</code>类子对象距离<code>D</code>类对象的开头有一定的偏移，将<code>pd</code>赋值给<code>pc</code>时要加上这个偏移，这样<code>pc</code>才能指向<code>C</code>类子对象的起始位置。也就是说，执行<code>pc = pd;</code>语句时编译器对<code>pd</code>的值进行了调整，才导致<code>pc</code>、<code>pd</code>的值不同。</p><p> 下面的代码演示了将<code>pd</code>赋值给<code>pc</code>时编译器的调整过程：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pc = (C*)( (<span class="keyword">int</span>)pd + <span class="keyword">sizeof</span>(B) );</span><br></pre></td></tr></table></figure></p><p> 如果我们把<code>B</code>、<code>C</code>类的继承顺序调整一下，让<code>C</code>在<code>B</code>前面，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C, <span class="keyword">public</span> B</span><br></pre></td></tr></table></figure></p><p>那么输出结果就会变为：<br><code>pa=0x317fc</code><br><code>pb=0x317fc</code><br><code>pc=0x317f8</code><br><code>pd=0x317f8</code></p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++虚继承和虚基类</title>
      <link href="/2018/06/20/c++%E7%BB%A7%E6%89%BF3-%E8%99%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB/"/>
      <url>/2018/06/20/c++%E7%BB%A7%E6%89%BF3-%E8%99%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>  <strong>多继承（<code>Multiple Inheritance</code>）</strong>是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。</p><a id="more"></a><h2 id="多继承（Multiple-Inheritance）"><a href="#多继承（Multiple-Inheritance）" class="headerlink" title="多继承（Multiple Inheritance）"></a>多继承（<code>Multiple Inheritance</code>）</h2><p>​        多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是菱形继承，如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-16101GG114954.jpg" alt></p><p>​        类<code>A</code>派生出类<code>B</code>和类<code>C</code>，类<code>D</code>继承自类<code>B</code>和类<code>C</code>，这个时候类<code>A</code>中的成员变量和成员函数继承到类<code>D</code>中变成了两份，一份来自 <code>A--&gt;B--&gt;D</code> 这条路径，另一份来自<code>A--&gt;C--&gt;D</code> 这条路径。</p><p>​        在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：<strong>因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突</strong>。假如类<code>A</code> 有一个成员变量<code>a</code>，那么在类<code>D</code>中直接访问<code>a</code>就会产生歧义，编译器不知道它究竟来自 <code>A --&gt;B--&gt;D</code> 这条路径，还是来自 <code>A--&gt;C--&gt;D</code> 这条路径。下面是菱形继承的具体实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//间接基类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接基类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接基类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; m_a = a; &#125;  <span class="comment">//命名冲突</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setb</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123; m_b = b; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setc</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123; m_c = c; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setd</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123; m_d = d; &#125;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​        这段代码实现了上图所示的菱形继承，第<code>25</code>行代码试图直接访问成员变量 <code>m_a</code>，结果发生了错误，因为类<code>B</code>和类<code>C</code>中都有成员变量 <code>m_a</code>（从<code>A</code>类继承而来），编译器不知道选用哪一个，所以产生了歧义。</p><p>​        为了消除歧义，我们可以在<code>m_a</code>的前面指明它具体来自哪个类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; B::m_a = a; &#125;</span><br></pre></td></tr></table></figure></p><p>​        这样表示使用<code>B</code>类的<code>m_a</code>。当然也可以使用<code>C</code>类的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; C::m_a = a; &#125;</span><br></pre></td></tr></table></figure></p><h2 id="虚继承（Virtual-Inheritance）"><a href="#虚继承（Virtual-Inheritance）" class="headerlink" title="虚继承（Virtual Inheritance）"></a>虚继承（<code>Virtual Inheritance</code>）</h2><p>​    为了解决多继承时的命名冲突和冗余数据问题，<code>C++</code>提出了虚继承，使得在派生类中只保留一份间接基类的成员。</p><p>​    <strong>在继承方式前面加上<code>virtual</code>关键字就是虚继承</strong>，请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//间接基类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接基类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;  <span class="comment">//虚继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接基类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;  <span class="comment">//虚继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; m_a = a; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setb</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123; m_b = b; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setc</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123; m_c = c; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setd</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123; m_d = d; &#125;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这段代码使用虚继承重新实现了上图所示的菱形继承，这样在派生类<code>D</code>中就只保留了一份成员变量 <code>m_a</code>，直接访问就不会再有歧义了。</p><p>​        虚继承的<strong>目的是让某个类做出声明，承诺愿意共享它的基类</strong>。其中，这个被共享的基类就称为<strong>虚基类（<code>Virtual Base Class</code>）</strong>，本例中的<code>A</code>就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p><p>​        现在让我们重新梳理一下本例的继承关系，如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-16101G60332440.jpg" alt></p><p>​        观察这个新的继承体系，我们会发现虚继承的一个不太直观的特征：<strong>必须在虚派生的真实需求出现前就已经完成虚派生的操作</strong>。在上图中，当定义<code>D</code>类时才出现了对虚派生的需求，但是如果<code>B</code>类和<code>C</code>类不是从<code>A</code>类虚派生得到的，那么<code>D</code>类还是会保留<code>A</code>类的两份成员。</p><p>​        换个角度讲，<strong>虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。</strong></p><p>​        在实际开发中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题。通常情况下，使用虚继承的类层次是由一个人或者一个项目组一次性设计完成的。对于一个独立开发的类来说，很少需要基类中的某一个类是虚基类，况且新类的开发者也无法改变已经存在的类体系。</p><p>​        <code>C++</code>标准库中的 <code>iostream</code> 类就是一个虚继承的实际应用案例。<code>iostream</code> 从 <code>istream</code> 和 <code>ostream</code> 直接继承而来，而 <code>istream</code> 和 <code>ostream</code> 又都继承自一个共同的名为 <code>base_ios</code> 的类，是典型的菱形继承。此时<code>istream</code> 和 <code>ostream</code> 必须采用虚继承，否则将导致 <code>iostream</code> 类中保留两份 <code>base_ios</code> 类的成员。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-16101GF521302.jpg" alt></p><h2 id="虚基类成员的可见性"><a href="#虚基类成员的可见性" class="headerlink" title="虚基类成员的可见性"></a>虚基类成员的可见性</h2><p>​        因为在虚继承的最终派生类中只保<code>1</code>留了一份虚基类的成员，所以该成员可以被直接访问，不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，那么仍然可以直接访问这个被覆盖的成员。但是如果该成员被两条或多条路径覆盖了，那就不能直接访问了，此时必须指明该成员属于哪个类。</p><p>​        以图<code>2</code>中的菱形继承为例，假设<code>D</code>定义了一个名为<code>x</code>的成员变量，当我们在<code>D</code>中直接访问<code>x</code>时，会有三种可能性：</p><blockquote><p>如果<code>B</code>和<code>C</code>中都没有<code>x</code>的定义，那么<code>x</code>将被解析为<code>D</code>的成员，此时不存在二义性。<br>如果<code>B</code>或<code>C</code>其中的一个类定义了<code>x</code>，也不会有二义性，派生类的<code>x</code>比虚基类的<code>x</code>优先级更高。<br>如果<code>B</code>和<code>C</code>中都定义了<code>x</code>，那么直接访问<code>x</code>将产生二义性问题。</p></blockquote><p>​        可以看到，使用多继承经常会出现二义性问题，必须十分小心。上面的例子是简单的，如果继承的层次再多一些，关系更复杂一些，程序员就很容易陷人迷魂阵，程序的编写、调试和维护工作都会变得更加困难，<strong>因此我不提倡在程序中使用多继承，只有在比较简单和不易出现二义性的情况或实在必要时才使用多继承，能用单一继承解决的问题就不要使用多继承。</strong></p><h2 id="虚继承时的构造函数"><a href="#虚继承时的构造函数" class="headerlink" title="虚继承时的构造函数"></a>虚继承时的构造函数</h2><p>​        在虚继承中，虚基类是由最终的派生类初始化的，换句话说，<strong>最终派生类的构造函数必须要调用虚基类的构造函数。对最终的派生类来说，虚基类是间接基类，而不是直接基类</strong>。这跟普通继承不同，在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。</p><pre><code>下面我们以菱形继承为例来演示构造函数的调用： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚基类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a): m_a(a)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接派生类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">B::B(<span class="keyword">int</span> a, <span class="keyword">int</span> b): A(a), m_b(b)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> B::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="string">", m_b="</span>&lt;&lt;m_b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接派生类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C(<span class="keyword">int</span> a, <span class="keyword">int</span> c);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line">C::C(<span class="keyword">int</span> a, <span class="keyword">int</span> c): A(a), m_c(c)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> C::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="string">", m_c="</span>&lt;&lt;m_c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//间接派生类D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line">D::D(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d): A(a), B(<span class="number">90</span>, b), C(<span class="number">100</span>, c), m_d(d)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> D::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="string">", m_b="</span>&lt;&lt;m_b&lt;&lt;<span class="string">", m_c="</span>&lt;&lt;m_c&lt;&lt;<span class="string">", m_d="</span>&lt;&lt;m_d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    b.display();</span><br><span class="line">   </span><br><span class="line">    <span class="function">C <span class="title">c</span><span class="params">(<span class="number">30</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    c.display();</span><br><span class="line"></span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>)</span></span>;</span><br><span class="line">    d.display();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m_a=<span class="number">10</span>, m_b=<span class="number">20</span></span><br><span class="line">m_a=<span class="number">30</span>, m_c=<span class="number">40</span></span><br><span class="line">m_a=<span class="number">50</span>, m_b=<span class="number">60</span>, m_c=<span class="number">70</span>, m_d=<span class="number">80</span></span><br></pre></td></tr></table></figure></p><p>​        请注意第<code>50</code>行代码，在最终派生类<code>D</code>的构造函数中，除了调用<code>B</code>和<code>C</code>的构造函数，还调用了<code>A</code>的构造函数，这说明<code>D</code>不但要负责初始化直接基类<code>B</code>和<code>C</code>，还要负责初始化间接基类<code>A</code>。<strong>而在以往的普通继承中，派生类的构造函数只负责初始化它的直接基类，再由直接基类的构造函数初始化间接基类，用户尝试调用间接基类的构造函数将导致错误</strong>。</p><p>​        现在采用了虚继承，虚基类<code>A</code>在最终派生类<code>D</code>中只保留了一份成员变量<code>m_a</code>，如果由<code>B</code>和<code>C</code>初始化 <code>m_a</code>，那么<code>B</code>和<code>C</code>在调用<code>A</code>的构造函数时很有可能给出不同的实参，这个时候编译器就会犯迷糊，不知道使用哪个实参初始化<code>m_a</code>。</p><p>​        为了避免出现这种矛盾的情况，<code>C++</code>干脆规定必须由最终的派生类<code>D</code>来初始化虚基类<code>A</code>，直接派生类<code>B</code>和<code>C</code>对 <code>A</code>的构造函数的调用是无效的。在第 <code>50</code>行代码中，调用<code>B</code>的构造函数时试图将<code>m_a</code>初始化为<code>90</code>，调用<code>C</code>的构造函数时试图将<code>m_a</code>初始化为<code>100</code>，但是输出结果有力地证明了这些都是无效的，<code>m_a</code>最终被初始化为<code>50</code>，这正是在<code>D</code>中直接调用<code>A</code>的构造函数的结果。</p><p>​        另外需要关注的是构造函数的执行顺序。虚继承时构造函数的执行顺序与普通继承时不同：<strong>在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何，编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数；而对于普通继承，就是按照构造函数出现的顺序依次调用的</strong>。</p><pre><code>修改本例中第` 50 `行代码，改变构造函数出现的顺序： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D::D(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d): B(<span class="number">90</span>, b), C(<span class="number">100</span>, c), A(a), m_d(d)&#123; &#125;</span><br></pre></td></tr></table></figure><p>​        虽然我们将<code>A()</code>放在了最后，但是编译器仍然会先调用<code>A()</code>，然后再调用<code>B()</code>、<code>C()</code>，因为<code>A()</code>是虚基类的构造函数，比其他构造函数优先级高。如果没有使用虚继承的话，那么编译器将按照出现的顺序依次调用<code>B()</code>、<code>C()</code>、<code>A()</code>。</p><h2 id="虚继承下的内存模型"><a href="#虚继承下的内存模型" class="headerlink" title="虚继承下的内存模型"></a>虚继承下的内存模型</h2><p>​    简单的面向对象，只有单继承或多继承的情况下，内存模型很好理解，编译器实现起来也容易，<code>C++</code>的效率和<code>C</code>的效率不相上下。一旦和<code>virtual</code>关键字扯上关系，使用到虚继承或虚函数，内存模型就变得混乱起来，各种编译器的实现也不一致，让人抓狂。</p><p>​    这是因为<code>C++</code>标准仅对<code>C++</code>的实现做了框架‘性的概述，并没有规定细节如何实现，所以不同厂商的编译器在具体实现方案上会有所差异。</p><p>​    对于普通继承，基类子对象始终位于派生类对象的前面（也即基类成员变量始终在派生类成员变量的前面），而且不管继承层次有多深，它相对于派生类对象顶部的偏移量是固定的。请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a1;</span><br><span class="line">    <span class="keyword">int</span> m_a2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b1;</span><br><span class="line">    <span class="keyword">int</span> b2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> c1;</span><br><span class="line">    <span class="keyword">int</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> d1;</span><br><span class="line">    <span class="keyword">int</span> d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A obj_a;</span><br><span class="line">    B obj_b;</span><br><span class="line">    C obj_c;</span><br><span class="line">    D obj_d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>obj_a</code>、<code>obj_b</code>、<code>obj_c</code>、<code>obj_d</code> 的内存模型如下所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-161019164406212.jpg" alt></p><p>​    <code>A</code>是最顶层的基类，在派生类<code>B</code>、<code>C</code>、<code>D</code>的对象中，<code>A</code>类子对象始终位于最前面，偏移量是固定的，为<code>0</code>。<code>b1</code>、<code>b2</code> 是派生类<code>B</code>的新增成员变量，它们的偏移量也是固定的，分别为<code>8</code>和<code>12</code>。<code>c1</code>、<code>c2</code>、<code>d1</code>、<code>d2</code> 也是同样的道理。</p><p>​    前面我们说过，编译器在知道对象首地址的情况下，通过计算偏移来存取成员变量。<strong>对于普通继承，基类成员变量的偏移是固定的，不会随着继承层级的增加而改变，存取起来非常方便</strong>。</p><p>​    而对于虚继承，恰恰和普通继承相反，<strong>大部分编译器会把基类成员变量放在派生类成员变量的后面，这样随着继承层级的增加，基类成员变量的偏移就会改变，就得通过其他方案来计算偏移量</strong>。</p><p>​    下面我们来一步一步地分析虚继承时的对象内存模型。</p><p> 1) 修改上面的代码，使得<code>A</code>是<code>B</code>的虚基类： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br></pre></td></tr></table></figure><p> 此时<code>obj_b</code>、<code>obj_c</code>、<code>obj_d</code>的内存模型就会发生变化，如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1509151624041K.jpg" alt></p><pre><code>**不管是虚基类的直接派生类还是间接派生类，虚基类的子对象始终位于派生类对象的最后面**。</code></pre><p> 2) 再假设<code>A</code>是<code>B</code>的虚基类，<code>B</code>又是<code>C</code>的虚基类，那么各个对象的内存模型如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-15091520200R52.jpg" alt></p><pre><code>从上面的两张图中可以发现，虚继承时的派生类对象被分成了两部分： </code></pre><ul><li>不带阴影的一部分偏移量固定，不会随着继承层次的增加而改变，称为固定部分；</li><li><p>带有阴影的一部分是虚基类的子对象，偏移量会随着继承层次的增加而改变，称为共享部分。</p><p>当要访问对象的成员变量时，需要知道对象的首地址和变量的偏移，对象的首地址很好获得，关键是变量的偏移。对于固定部分，偏移是不变的，很好计算；而对于共享部分，偏移会随着继承层次的增加而改变，这就需要设计一种方案，在偏移不断变化的过程中准确地计算偏移。各个编译器正是在设计这一方案时出现了分歧，不同的编译器设计了不同的方案来计算共享部分的偏移。 </p></li></ul><blockquote><p> 对于虚继承，将派生类分为<strong>固定部分</strong>和<strong>共享部分</strong>，并把共享部分放在最后，几乎所有的编译器都在这一点上达成了共识。主要的分歧就是如何计算共享部分的偏移，可谓是百花齐放，没有统一标准。</p></blockquote><h3 id="cfront解决方案"><a href="#cfront解决方案" class="headerlink" title="cfront解决方案"></a><code>cfront</code>解决方案</h3><p>​    早期的 <code>cfront</code> 编译器会在派生类对象中安插一些指针，每个指针指向一个虚基类的子对象，要存取继承来的成员变量，可以使用指针间接完成。</p><p> 1) 如果<code>A</code>是<code>B</code>的虚基类，那么各个对象的实际内存模型如下所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1509151J044P3.jpg" alt></p><p>​    编译器会在直接派生类的对象 <code>obj_b</code> 中安插一个指针，指向虚基类<code>A</code>的起始位置，并且这个指针的偏移是固定的，不会随着继承层次的增加而改变。当要访问 <code>a1</code>、<code>a2</code> 时，要先通过对象指针找到<code>pa</code>，再通过<code>pa</code>找到  <code>a1</code>、<code>a2</code>，这样一来就比没有虚继承时多了一层间接。</p><p>​    假设<code>p</code>是<code>obj_d</code>的指针，现在要访问成员变量 <code>a2</code>： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> member_a2 = p -&gt; a2;</span><br></pre></td></tr></table></figure><p>​    那么编译器内部会进行类似下面的转换： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A *pa = (A*)( *(<span class="keyword">int</span>*)( (<span class="keyword">int</span>)p + <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span> ) );</span><br><span class="line"><span class="keyword">int</span> member_a2 = *(<span class="keyword">int</span>*)( (<span class="keyword">int</span>)pa + <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br></pre></td></tr></table></figure><p> 2) 如果<code>A</code>是<code>B</code>的虚基类，同时<code>B</code>也是<code>C</code>的虚基类，那么各个对象的实际内存模型如下所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1509151P15C35.jpg" alt></p><p>​    当要访问 <code>a1</code>、<code>a2</code> 时，要先通过对象指针找到 <code>pb</code>，再通过 <code>pb</code> 找到 <code>pa</code>，最后才能通过 pa 找到 <code>a1</code>、<code>a2</code>，这样一来就比没有虚继承时多了两层间接。</p><p>​    通过上面的分析可以发现，这种方案的一个缺点就是，随着虚继承层次的增加，访问顶层基类需要的间接转换会越来越多，效率越来越低。</p><p>​    这种方案另外的一个缺点是：<strong>当有多个虚基类时，派生类要为每个虚基类都安插一个指针，会增加对象的体积</strong>。</p><p>​    例如，假设<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>类的继承关系为： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1509151S441J0.jpg" alt></p><p>​    <code>obj_d</code> 的内存模型如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1509151T420R4.jpg" alt></p><p>​    <code>D</code>有三个虚基类，所以<code>obj_d</code>对象要额外背负三个指针 <code>pa</code>、<code>pab</code>、<code>pc</code>。 </p><h3 id="VC解决方案"><a href="#VC解决方案" class="headerlink" title="VC解决方案"></a><code>VC</code>解决方案</h3><p>​    <code>cfront</code> 的后来者 <code>VC</code> 尝试对上面的方案进行了改进，一定程度上弥补了它的不足。</p><p>​    <code>VC</code> 引入了<strong>虚基类表</strong>，如果某个派生类有一个或多个虚基类，编译器就会在派生类对象中安插一个指针，指向虚基类表。虚基类表其实就是一个数组，数组中的元素存放的是各个虚基类的偏移。</p><p>​    假设<code>A</code>是<code>B</code>的虚基类，那么各对象的内存模型如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-15091519111R32.jpg" alt></p><p>​    假设<code>A</code>是<code>B</code>的虚基类，同时<code>B</code>又是<code>C</code>的虚基类，那么各对象的内存模型如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-150915201003P8.jpg" alt></p><p>​    虚继承表中保存的是所有虚基类（包括直接继承和间接继承到的）相对于当前对象的偏移，这样通过派生类指针访问虚基类的成员变量时，不管继承层次都多深，只需要一次间接转换就可以。</p><p>​    另外，这种方案还可以避免有多个虚基类时让派生类对象额外背负过多的指针。例如，假设<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>类的继承关系为： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1509151S441J0.jpg" alt></p><p>​    那么 <code>obj_d</code> 的内存模型如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-15091520341C51.jpg" alt></p><p>​    如此一来，<code>D</code>类虽然有三个虚基类，但它的对象<code>obj_d</code>只需要额外背负一个指针。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++单继承和多继承</title>
      <link href="/2018/06/17/c++%E7%BB%A7%E6%89%BF2-%E5%8D%95%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/06/17/c++%E7%BB%A7%E6%89%BF2-%E5%8D%95%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>没有继承时对象内存的分布情况很简单，成员变量和成员函数会分开存储：</p><ul><li>对象的内存中只包含成员变量，存储在栈区或堆区（使用<code>new</code>创建对象）；</li><li>成员函数与对象内存分离，存储在代码区。</li></ul><p>当存在继承关系时，内存模型会稍微复杂一些。</p><a id="more"></a><h3 id="继承时的内存模型"><a href="#继承时的内存模型" class="headerlink" title="继承时的内存模型"></a>继承时的内存模型</h3><p>​    <strong>有继承关系时，派生类的内存模型可以看成是基类成员变量和新增成员变量的总和，而所有成员函数仍然存储在另外一个区域——代码区，由所有对象共享。</strong>请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> A::display()&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"m_a=%d, m_b=%d\n"</span>, m_a, m_b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line">B::B(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c): A(a, b), m_c(c)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> B::display()&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"m_a=%d, m_b=%d, m_c=%d\n"</span>, m_a, m_b, m_c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">obj_a</span><span class="params">(<span class="number">99</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">B <span class="title">obj_b</span><span class="params">(<span class="number">84</span>, <span class="number">23</span>, <span class="number">95</span>)</span></span>;</span><br><span class="line">    obj_a.display();</span><br><span class="line">    obj_b.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>obj_a</code>是基类对象，<code>obj_b</code>是派生类对象。假设<code>obj_a</code>的起始地址为<code>0X1000</code>，那么它的内存分布如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/164629A03-0.jpg" alt></p><p>​    假设<code>obj_b</code>的起始地址为<code>0X1100</code>，那么它的内存分布如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1646293113-1.jpg" alt></p><p>​    可以发现，基类的成员变量排在前面，派生类的排在后面。</p><p>​    为了让大家理解更加透彻，我们不妨再由<code>B</code>类派生出一个<code>C</code>类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明并定义派生类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C(<span class="keyword">char</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line">C::C(<span class="keyword">char</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d): B(a, b, c), m_d(d)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> C::display()&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"m_a=%d, m_b=%d, m_c=%d, m_d=%d\n"</span>, m_a, m_b, m_c, m_d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建C类对象obj_c</span></span><br><span class="line"><span class="function">C <span class="title">obj_c</span><span class="params">(<span class="number">84</span>, <span class="number">23</span>, <span class="number">95</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">obj_c.display();</span><br></pre></td></tr></table></figure><p>​    假设<code>obj_c</code>的起始地址为<code>0X1200</code>，那么它的内存分布如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1646295S0-2.jpg" alt></p><p>​    成员变量按照派生的层级依次排列，新增成员变量始终在最后。</p><h4 id="有成员变量遮蔽时的内存分布"><a href="#有成员变量遮蔽时的内存分布" class="headerlink" title="有成员变量遮蔽时的内存分布"></a>有成员变量遮蔽时的内存分布</h4><p>​    更改上面的<code>C</code> 类，让它的成员变量遮蔽<code>A</code>类和<code>B</code>类的成员变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明并定义派生类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C(<span class="keyword">char</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;  <span class="comment">//遮蔽A类的成员变量</span></span><br><span class="line">    <span class="keyword">int</span> m_c;  <span class="comment">//遮蔽B类的成员变量</span></span><br><span class="line">    <span class="keyword">int</span> m_d;  <span class="comment">//新增成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line">C::C(<span class="keyword">char</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d): B(a, b, c), m_b(b), m_c(c), m_d(d)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> C::display()&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"A::m_a=%d, A::m_b=%d, B::m_c=%d\n"</span>, m_a, A::m_b, B::m_c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"C::m_b=%d, C::m_c=%d, C::m_d=%d\n"</span>, m_b, m_c, m_d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建C类对象obj_c</span></span><br><span class="line"><span class="function">C <span class="title">obj_c</span><span class="params">(<span class="number">84</span>, <span class="number">23</span>, <span class="number">95</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">obj_c.display();</span><br></pre></td></tr></table></figure><p>​    假设<code>obj_c</code>的起始地址为<code>0X1300</code>，那么它的内存分布如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/16462a427-3.jpg" alt></p><p>​    当基类<code>A</code>、<code>B</code>的成员变量被遮蔽时，仍然会留在派生类对象<code>obj_c</code> 的内存中，<code>C</code>类新增的成员变量始终排在基类<code>A</code>、<code>B</code>的后面。</p><p>​    <strong>总结：在派生类的对象模型中，会包含所有基类的成员变量。</strong>这种设计方案的优点是访问效率高，能够在派生类对象中直接访问基类变量，无需经过好几层间接计算。</p><h3 id="继承中的构造和析构"><a href="#继承中的构造和析构" class="headerlink" title="继承中的构造和析构"></a>继承中的构造和析构</h3><h4 id="对象构造和析构的调用原则"><a href="#对象构造和析构的调用原则" class="headerlink" title="对象构造和析构的调用原则"></a>对象构造和析构的调用原则</h4><h5 id="继承中的构造和析构-1"><a href="#继承中的构造和析构-1" class="headerlink" title="继承中的构造和析构"></a>继承中的构造和析构</h5><ul><li>子类对象在创建时会首先调用父类的构造函数</li><li>父类构造函数执行完毕后，才会调用子类的构造函数</li><li>派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。</li><li>当父类构造函数有参数时，需要在子类初始化列表(参数列表)中显示调用父类构造函数</li><li>析构函数调用顺序和构造函数相反</li></ul><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/zvsd.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类People</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    People(<span class="keyword">char</span>*, <span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line">People::People(<span class="keyword">char</span> *name, <span class="keyword">int</span> age): m_name(name), m_age(age)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类Student</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//People(name, age)就是调用基类的构造函数</span></span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): People(name, age), m_score(score)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> Student::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="string">"。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">    stu.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：<br><code>小明的年龄是16，成绩是90.5。</code></p><p>​    请注意第<code>23</code>行代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): People(name, age), m_score(score)&#123; &#125;</span><br></pre></td></tr></table></figure><p>​    <code>People(name, age)</code>就是调用基类的构造函数，并将<code>name</code>和<code>age</code>作为实参传递给它，<code>m_score(score)</code>是派生类的参数初始化表，它们之间以逗号<code>,</code>隔开。</p><p> 也可以将基类构造函数的调用放在参数初始化表后面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_score(score), People(name, age)&#123; &#125;</span><br></pre></td></tr></table></figure><p>​    但是不管它们的顺序如何，派生类构造函数总是先调用基类构造函数再执行其他代码（包括参数初始化表以及函数体中的代码），总体上看和下面的形式类似：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score)&#123;    </span><br><span class="line">    People(name, age);    </span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    当然这段代码只是为了方便大家理解，实际上这样写是错误的，因为基类构造函数不会被继承，不能当做普通的成员函数来调用。换句话说，只能将基类构造函数的调用放在函数头部，不能放在函数体中。</p><h5 id="继承与组合混搭的构造和析构"><a href="#继承与组合混搭的构造和析构" class="headerlink" title="继承与组合混搭的构造和析构"></a>继承与组合混搭的构造和析构</h5><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/xcvas.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">D()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"D类构造函数!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~D()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"D类析构函数!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"A类构造函数!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~A()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"A类析构函数!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"B类构造函数!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~B()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"B类析构函数!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">C()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"C类构造函数!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~C()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"C类析构函数!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">D d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">C c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>​    派生类都只有一个基类，称为<strong>单继承（<code>Single Inheritance</code>）</strong>。除此之外，<code>C++</code>也支持<strong>多继承（<code>Multiple Inheritance</code>）</strong>，即一个派生类可以有两个或多个基类。</p><p>​    多继承的语法也很简单，将多个基类用逗号隔开即可。例如已声明了类<code>A</code>、类<code>B</code>和类<code>C</code>，那么可以这样来声明派生类<code>D</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> A, <span class="keyword">private</span> B, <span class="keyword">protected</span> C&#123;</span><br><span class="line">   <span class="comment">//类D新增加的成员</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>​    <code>D</code>是多继承形式的派生类，它以公有的方式继承<code>A</code>类，以私有的方式继承<code>B</code>类，以保护的方式继承<code>C</code>类。<code>D</code>根据不同的继承方式获取<code>A</code>、<code>B</code>、<code>C</code>中的成员，确定它们在派生类中的访问权限。</p><h3 id="多继承下的构造函数"><a href="#多继承下的构造函数" class="headerlink" title="多继承下的构造函数"></a>多继承下的构造函数</h3><p>​    多继承形式下的构造函数和单继承形式基本相同，只是要在派生类的构造函数中调用多个基类的构造函数。以上面的<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>类为例，<code>D</code>类构造函数的写法为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D(形参列表): A(实参列表), B(实参列表), C(实参列表)&#123;</span><br><span class="line">   <span class="comment">//其他操作</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>​    <strong>基类构造函数的调用顺序和和它们在派生类构造函数中出现的顺序无关，而是和声明派生类时基类出现的顺序相同。</strong>仍然以上面的<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>类为例，即使将<code>D</code>类构造函数写作下面的形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D(形参列表): B(实参列表), C(实参列表), A(实参列表)&#123;</span><br><span class="line">   <span class="comment">//其他操作</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>​    那么也是先调用<code>A</code>类的构造函数，再调用<code>B</code>类构造函数，最后调用<code>C</code>类构造函数。</p><p>​    下面是一个多继承的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseA</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseA(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">    ~BaseA();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">BaseA::BaseA(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"BaseA constructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">BaseA::~BaseA()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"BaseA destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseB</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseB(<span class="keyword">int</span> c, <span class="keyword">int</span> d);</span><br><span class="line">    ~BaseB();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line">BaseB::BaseB(<span class="keyword">int</span> c, <span class="keyword">int</span> d): m_c(c), m_d(d)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"BaseB constructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">BaseB::~BaseB()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"BaseB destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> BaseA, <span class="keyword">public</span> BaseB&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e);</span><br><span class="line">    ~Derived();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_e;</span><br><span class="line">&#125;;</span><br><span class="line">Derived::Derived(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e): BaseA(a, b), BaseB(c, d), m_e(e)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived constructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Derived::~Derived()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Derived::show()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_a&lt;&lt;<span class="string">", "</span>&lt;&lt;m_b&lt;&lt;<span class="string">", "</span>&lt;&lt;m_c&lt;&lt;<span class="string">", "</span>&lt;&lt;m_d&lt;&lt;<span class="string">", "</span>&lt;&lt;m_e&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">obj</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    obj.show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：<br><code>BaseA constructor</code><br><code>BaseB constructor</code><br><code>Derived constructor</code><br><code>1, 2, 3, 4, 5</code><br><code>Derived destructor</code><br><code>BaseB destructor</code><br><code>BaseA destructor</code></p><p>​    从运行结果中还可以发现，多继承形式下析构函数的执行顺序和构造函数的执行顺序相同。</p><h3 id="多继承命名冲突"><a href="#多继承命名冲突" class="headerlink" title="多继承命名冲突"></a>多继承命名冲突</h3><p>​    <strong>当两个或多个基类中有同名的成员时，如果直接访问该成员，就会产生命名冲突，编译器不知道使用哪个基类的成员。这个时候需要在成员名字前面加上类名和域解析符<code>::</code>，以显式地指明到底使用哪个类的成员，消除二义性。</strong></p><p>​    修改上面的代码，为<code>BaseA</code>和<code>BaseB</code>类添加<code>show()</code>函数，并将<code>Derived</code>类的<code>show()</code>函数更名为 <code>display()</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseA</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseA(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">    ~BaseA();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">BaseA::BaseA(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"BaseA constructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">BaseA::~BaseA()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"BaseA destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BaseA::show()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_a = "</span>&lt;&lt;m_a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_b = "</span>&lt;&lt;m_b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseB</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseB(<span class="keyword">int</span> c, <span class="keyword">int</span> d);</span><br><span class="line">    ~BaseB();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line">BaseB::BaseB(<span class="keyword">int</span> c, <span class="keyword">int</span> d): m_c(c), m_d(d)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"BaseB constructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">BaseB::~BaseB()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"BaseB destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BaseB::show()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_c = "</span>&lt;&lt;m_c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_d = "</span>&lt;&lt;m_d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> BaseA, <span class="keyword">public</span> BaseB&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e);</span><br><span class="line">    ~Derived();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_e;</span><br><span class="line">&#125;;</span><br><span class="line">Derived::Derived(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e): BaseA(a, b), BaseB(c, d), m_e(e)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived constructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Derived::~Derived()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Derived::display()&#123;</span><br><span class="line">    BaseA::show();  <span class="comment">//调用BaseA类的show()函数</span></span><br><span class="line">    BaseB::show();  <span class="comment">//调用BaseB类的show()函数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_e = "</span>&lt;&lt;m_e&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">obj</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    obj.display();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    请读者注意第<code>64</code>、<code>65</code>行代码，我们显式的指明了要调用哪个基类的<code>show()</code>函数。</p><h3 id="多继承时的对象内存模型"><a href="#多继承时的对象内存模型" class="headerlink" title="多继承时的对象内存模型"></a>多继承时的对象内存模型</h3><p>​    我们来分析一下多继承时对象的内存模型。请读者先看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> b, <span class="keyword">int</span> c);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line">B::B(<span class="keyword">int</span> b, <span class="keyword">int</span> c): m_b(b), m_c(c)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line">C::C(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d): A(a, b), B(b, c), m_a(a), m_c(c), m_d(d)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> C::display()&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"A::m_a=%d, A::m_b=%d\n"</span>, A::m_a, A::m_b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"B::m_b=%d, B::m_c=%d\n"</span>, B::m_b, B::m_c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"C::m_a=%d, C::m_c=%d, C::m_d=%d\n"</span>, C::m_a, C::m_c, m_d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">obj_c</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    obj_c.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><code>A::m_a=10, A::m_b=20</code><br><code>B::m_b=20, B::m_c=30</code><br><code>C::m_a=10, C::m_c=30, C::m_d=40</code></p><p>​    <code>A</code>、<code>B</code>是基类，<code>C</code>是派生类，假设<code>obj_c</code>的起始地址是<code>0X1000</code>，那么<code>obj_c</code>的内存分布如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1Z61013103M49.gif" alt></p><pre><code>基类对象的排列顺序和继承时声明的顺序相同。</code></pre><h2 id="继承中的静态成员特性"><a href="#继承中的静态成员特性" class="headerlink" title="继承中的静态成员特性"></a>继承中的静态成员特性</h2><p>​    静态成员函数和非静态成员函数的共同点:</p><ul><li><p>他们都可以被继承到派生类中。</p></li><li><p>如果重新定义一个静态成员函数，所有在基类中的其他重载函数会被隐藏。</p></li><li><p>如果我们改变基类中一个函数的特征，所有使用该函数名的基类版本都会被隐藏。</p><p><strong>静态成员函数不能是虚函数</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> sNum; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> param)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sNum + param;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sNum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Base::sNum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sNum; <span class="comment">//基类静态成员属性将被隐藏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//重定义一个函数，基类中重载的函数被隐藏</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> param1, <span class="keyword">int</span> param2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sNum + param1 + param2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//改变基类函数的某个特征，返回值或者参数个数，将会隐藏基类重载的函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> param1, <span class="keyword">int</span> param2)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;  sNum + param1 + param2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Derived::sNum = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++类的继承</title>
      <link href="/2018/06/16/c++%E7%BB%A7%E6%89%BF1-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/06/16/c++%E7%BB%A7%E6%89%BF1-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="继承基本概念"><a href="#继承基本概念" class="headerlink" title="继承基本概念"></a>继承基本概念</h2><p>​    <code>c++</code>最重要的特征是代码重用，通过继承机制可以利用已有的数据类型来定义新的数据类型，新的类不仅拥有旧类的成员，还拥有新定义的成员。</p><a id="more"></a><p>​    一个<code>B</code>类继承于<code>A</code>类，或称从类<code>A</code>派生类<code>B</code>。这样的话，类<code>A</code>成为基类（父类）， 类<code>B</code>成为派生类（子类）。</p><p>​    派生类中的成员，包含两大部分：</p><ul><li><p>一类是从基类继承过来的，一类是自己增加的成员。</p></li><li><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p></li></ul><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/965798hgfgfhd.jpg" alt></p><h2 id="派生类定义"><a href="#派生类定义" class="headerlink" title="派生类定义"></a>派生类定义</h2><h3 id="派生类定义格式"><a href="#派生类定义格式" class="headerlink" title="派生类定义格式"></a>派生类定义格式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class 派生类名 :  继承方式 基类名&#123;</span><br><span class="line">     <span class="comment">//派生类新增的数据成员和成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种继承方式： </p><ul><li><p><code>public</code> ：  公有继承</p></li><li><p><code>private</code> ：  私有继承</p></li><li><p><code>protected</code> ： 保护继承</p></li></ul><p>从继承源上分： </p><ul><li><p>单继承：指每个派生类只直接继承了一个基类的特征</p></li><li><p>多继承：指多个基类派生出一个派生类的继承关系,多继承的派生类直接继承了不止一个基类的特征</p></li></ul><h3 id="派生类访问控制"><a href="#派生类访问控制" class="headerlink" title="派生类访问控制"></a>派生类访问控制</h3><p>​    继承方式是<code>public</code>、<code>protected</code>、<code>private</code> ，不同的继承方式会影响基类成员在派生类中的访问权限。</p><p><strong>1) <code>public</code>继承方式</strong></p><ul><li>基类中所有<code>public</code>成员在派生类中为<code>public</code>属性；</li><li>基类中所有<code>protected</code>成员在派生类中为<code>protected</code>属性；</li><li>基类中所有<code>private</code>成员在派生类中不能使用。</li></ul><p><strong>2) <code>protected</code>继承方式</strong></p><ul><li>基类中的所有<code>public</code>成员在派生类中为<code>protected</code>属性；</li><li>基类中的所有<code>protected</code>成员在派生类中为<code>protected</code>属性；</li><li>基类中的所有<code>private</code>成员在派生类中不能使用。</li></ul><p><strong>3) <code>private</code>继承方式</strong></p><ul><li>基类中的所有<code>public</code>成员在派生类中均为<code>private</code>属性；</li><li>基类中的所有<code>protected</code>成员在派生类中均为<code>private</code>属性；</li><li><p>基类中的所有<code>private</code>成员在派生类中不能使用。</p><p>通过上面的分析可以发现：</p><p><strong>1) 基类成员在派生类中的访问权限不得高于继承方式中指定的权限。</strong>例如，当继承方式为<code>protected</code>时，那么基类成员在派生类中的访问权限最高也为<code>protected</code>，高于<code>protected</code>的会降级为<code>protected</code>，但低于<code>protected</code>不会升级。再如，当继承方式为<code>public</code>时，那么基类成员在派生类中的访问权限将保持不变。<strong>也就是说，继承方式中的<code>public</code>、<code>protected</code>、<code>private</code>是用来指明基类成员在派生类中的最高访问权限的。</strong></p><p>2) 不管继承方式如何，基类中的<code>private</code>成员在派生类中始终不能使用（不能在派生类的成员函数中访问或调用）。</p><p>3) 如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为<code>public</code>或<code>protected</code>；只有那些不希望在派生类中使用的成员才声明为<code>private</code>。</p><p>4) 如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为<code>protected</code>。</p></li></ul><p>​    注意，我们这里说的是基类的<code>private</code>成员不能在派生类中使用，并没有说基类的<code>private</code>成员不能被继承。<strong>实际上，基类的<code>private</code>成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。</strong><code>private</code>成员的这种特性，能够很好的对派生类隐藏基类的实现，以体现面向对象的封装性。</p><table><thead><tr><th>继承方式/基类成员</th><th><code>public</code>成员</th><th><code>protected</code>成员</th><th><code>private</code>成员</th></tr></thead><tbody><tr><td><code>public</code>继承</td><td><code>public</code></td><td><code>protected</code></td><td>不可见</td></tr><tr><td><code>protected</code>继承</td><td><code>protected</code></td><td><code>protected</code></td><td>不可见</td></tr><tr><td><code>private</code>继承</td><td><code>private</code></td><td><code>private</code></td><td>不可见</td></tr></tbody></table><p>​    由于<code>private</code>和<code>protected</code>继承方式会改变基类成员在派生类中的访问权限，导致继承关系复杂，所以实际开发中我们一般使用<code>public</code>。</p><p> 【示例】演示类的继承关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类People</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setname</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setage</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sethobby</span><span class="params">(<span class="keyword">char</span> *hobby)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">gethobby</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_hobby;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> People::setname(<span class="keyword">char</span> *name)&#123; m_name = name; &#125;</span><br><span class="line"><span class="keyword">void</span> People::setage(<span class="keyword">int</span> age)&#123; m_age = age; &#125;</span><br><span class="line"><span class="keyword">void</span> People::sethobby(<span class="keyword">char</span> *hobby)&#123; m_hobby = hobby; &#125;</span><br><span class="line"><span class="keyword">char</span> *People::gethobby()&#123; <span class="keyword">return</span> m_hobby; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类Student</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setscore</span><span class="params">(<span class="keyword">float</span> score)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Student::setscore(<span class="keyword">float</span> score)&#123; m_score = score; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类Pupil</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pupil</span>:</span> <span class="keyword">public</span> Student&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setranking</span><span class="params">(<span class="keyword">int</span> ranking)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_ranking;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Pupil::setranking(<span class="keyword">int</span> ranking)&#123; m_ranking = ranking; &#125;</span><br><span class="line"><span class="keyword">void</span> Pupil::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，考试成绩为"</span>&lt;&lt;m_score&lt;&lt;<span class="string">"分，班级排名第"</span>&lt;&lt;m_ranking&lt;&lt;<span class="string">"，TA喜欢"</span>&lt;&lt;gethobby()&lt;&lt;<span class="string">"。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Pupil pup;</span><br><span class="line">    pup.setname(<span class="string">"小明"</span>);</span><br><span class="line">    pup.setage(<span class="number">15</span>);</span><br><span class="line">    pup.setscore(<span class="number">92.5f</span>);</span><br><span class="line">    pup.setranking(<span class="number">4</span>);</span><br><span class="line">    pup.sethobby(<span class="string">"乒乓球"</span>);</span><br><span class="line">    pup.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>小明的年龄是15，考试成绩为92.5分，班级排名第4，TA喜欢乒乓球。</code></p><p>​    这是一个多级继承的例子，<code>Student</code>继承自<code>People</code>，<code>Pupil</code>又继承自<code>Student</code>，它们的继承关系为<code>People --&gt; Student --&gt; Pupil</code>。<code>Pupil</code>是最终的派生类，它拥有基类的<code>m_name</code>、<code>m_age</code>、<code>m_score</code>、<code>m_hobby</code>成员变量以及<code>setname()</code>、<code>setage()</code>、<code>sethobby()</code>、<code>gethobby()</code>、<code>setscore()</code>成员函数。</p><p>​    注意，在派生类<code>Pupil</code>的成员函数<code>display()</code>中，我们借助基类的<code>public</code>成员函数<code>gethobby()</code>来访问基类的<code>private</code>成员变量<code>m_bobby</code>，因为<code>m_hobby</code>是<code>private</code>属性的，在派生类中不可见，所以只能借助基类的<code>public</code>成员函数<code>sethobby()</code>、<code>gethobby()</code>来访问。</p><p>​    <strong>在派生类中访问基类<code>private</code>成员的唯一方法就是借助基类的非<code>private</code>成员函数，如果基类没有非<code>private</code>成员函数，那么该成员在派生类中将无法访问。</strong></p><h3 id="改变访问权限"><a href="#改变访问权限" class="headerlink" title="改变访问权限"></a>改变访问权限</h3><p>​    使用<code>using</code>关键字可以改变基类成员在派生类中的访问权限，例如将<code>public</code>改为<code>private</code>、将<code>protected</code>改为<code>public</code>。</p><p>​    注意：<code>using</code>只能改变基类中<code>public</code>和<code>protected</code>成员的访问权限，不能改变<code>private</code>成员的访问权限，因为基类中<code>private</code>成员在派生类中是不可见的，根本不能使用，所以基类中的<code>private</code>成员在派生类中无论如何都不能访问。</p><p>​    <code>using</code>关键字使用示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类People</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> People::show() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">"的年龄是"</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类Student</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> People &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">learning</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> People::m_name;  <span class="comment">//将protected改为public</span></span><br><span class="line">    <span class="keyword">using</span> People::m_age;  <span class="comment">//将protected改为public</span></span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> People::show;  <span class="comment">//将public改为private</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Student::learning() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"我是"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"，今年"</span> &lt;&lt; m_age &lt;&lt; <span class="string">"岁，这次考了"</span> &lt;&lt; m_score &lt;&lt; <span class="string">"分！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student stu;</span><br><span class="line">    stu.m_name = <span class="string">"小明"</span>;</span><br><span class="line">    stu.m_age = <span class="number">16</span>;</span><br><span class="line">    stu.m_score = <span class="number">99.5f</span>;</span><br><span class="line">    stu.show();  <span class="comment">//compile error</span></span><br><span class="line">    stu.learning();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    代码中首先定义了基类<code>People</code>，它包含两个<code>protected</code>属性的成员变量和一个<code>public</code>属性的成员函数。定义<code>Student</code>类时采用<code>public</code>继承方式，<code>People</code>类中的成员在<code>Student</code>类中的访问权限默认是不变的。</p><p>​    不过，我们使用<code>using</code>改变了它们的默认访问权限，如代码第<code>21~25</code>行所示，将<code>show()</code>函数修改为<code>private</code>属性的，是降低访问权限，将<code>name</code>、<code>age</code>变量修改为<code>public</code>属性的，是提高访问权限。</p><p>​    因为<code>show()</code>函数是<code>private</code>属性的，所以代码第<code>36</code>行会报错。把该行注释掉，程序输出结果为：<code>我是小明，今年16岁，这次考了99.5分！</code></p><h2 id="非自动继承的函数"><a href="#非自动继承的函数" class="headerlink" title="非自动继承的函数"></a>非自动继承的函数</h2><p>​    不是所有的函数都能自动从基类继承到派生类中。构造函数和析构函数用来处理对象的创建和析构操作，构造和析构函数只知道对它们的特定层次的对象做什么，也就是说构造函数和析构函数不能被继承，必须为每一个特定的派生类分别创建。</p><p>​    另外<code>operator=</code>也不能被继承，因为它完成类似构造函数的行为。也就是说尽管我们知道如何由<code>=</code>右边的对象如何初始化<code>=</code>左边的对象的所有成员，但是这个并不意味着对其派生类依然有效。</p><p>​    在继承的过程中，如果没有创建这些函数，编译器会自动生成它们。</p><h2 id="继承时的名字遮蔽"><a href="#继承时的名字遮蔽" class="headerlink" title="继承时的名字遮蔽"></a>继承时的名字遮蔽</h2><p>​    <strong>如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，那么就会遮蔽从基类继承过来的成员。所谓遮蔽，就是在派生类中使用该成员（包括在定义派生类时使用，也包括通过派生类对象访问该成员）时，实际上使用的是派生类新增的成员，而不是从基类继承来的。</strong></p><p>​    下面是一个成员函数的名字遮蔽的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类People</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> People::show()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"嗨，大家好，我叫"</span>&lt;&lt;m_name&lt;&lt;<span class="string">"，今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类Student</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;  <span class="comment">//遮蔽基类的show()</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score)&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">    m_age = age;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::show()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">    <span class="comment">//使用的是派生类新增的成员函数，而不是从基类继承的</span></span><br><span class="line">    stu.show();</span><br><span class="line">    <span class="comment">//使用的是从基类继承来的成员函数</span></span><br><span class="line">    stu.People::show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>小明的年龄是16，成绩是90.5</code><br><code>嗨，大家好，我叫小明，今年16岁</code></p><p>​    本例中，基类<code>People</code>和派生类<code>Student</code>都定义了成员函数<code>show()</code>，它们的名字一样，会造成遮蔽。第<code>37</code>行代码中，<code>stu</code>是<code>Student</code>类的对象，默认使用<code>Student</code>类的<code>show()</code>函数。</p><p>​    但是，<strong>基类<code>People</code>中的<code>show()</code>函数仍然可以访问，不过要加上类名和域解析符，如第<code>39</code>行代码所示。</strong></p><h3 id="基类成员函数和派生类成员函数不构成重载"><a href="#基类成员函数和派生类成员函数不构成重载" class="headerlink" title="基类成员函数和派生类成员函数不构成重载"></a>基类成员函数和派生类成员函数不构成重载</h3><p>​    基类成员和派生类成员的名字一样时会造成遮蔽，这句话对于成员变量很好理解，对于成员函数要引起注意，不管函数的参数如何，只要名字一样就会造成遮蔽。<strong>换句话说，基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。</strong></p><p>​    下面的例子很好的说明了这一点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类Base</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Base::func()&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::func()"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> Base::func(<span class="keyword">int</span> a)&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::func(int)"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类Derived</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">bool</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Derived::func(<span class="keyword">char</span> *str)&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::func(char *)"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> Derived::func(<span class="keyword">bool</span> is)&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::func(bool)"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.func(<span class="string">"c.biancheng.net"</span>);</span><br><span class="line">    d.func(<span class="literal">true</span>);</span><br><span class="line">    d.func();  <span class="comment">//compile error</span></span><br><span class="line">    d.func(<span class="number">10</span>);  <span class="comment">//compile error</span></span><br><span class="line">    d.Base::func();</span><br><span class="line">    d.Base::func(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    本例中，<code>Base</code>类的<code>func()</code>、<code>func(int)</code>和 Derived 类的<code>func(char *)</code>、<code>func(bool)</code>四个成员函数的名字相同，参数列表不同，它们看似构成了重载，能够通过对象<code>d</code>访问所有的函数，实则不然，<code>Derive</code>类的<code>func</code>遮蔽了<code>Base</code>类的<code>func</code>，导致第<code>26</code>、<code>27</code>行代码没有匹配的函数，所以调用失败。</p><p>​    如果说有重载关系，那么也是<code>Base</code>类的两个<code>func</code>构成重载，而<code>Derive</code>类的两个<code>func</code>构成另外的重载。</p><h2 id="类继承时的作用域嵌套"><a href="#类继承时的作用域嵌套" class="headerlink" title="类继承时的作用域嵌套"></a>类继承时的作用域嵌套</h2><p>​    <strong>类其实也是一种作用域，每个类都会定义它自己的作用域，在这个作用域内我们再定义类的成员。当存在继承关系时，派生类的作用域嵌套在基类的作用域之内，如果一个名字在派生类的作用域内无法找到，编译器会继续到外层的基类作用域中查找该名字的定义。</strong></p><p>​    换句话说，作用域能够彼此包含，被包含（或者说被嵌套）的作用域称为<strong>内层作用域</strong>（<code>inner scope</code>），包含着别的作用域的作用域称为<strong>外层作用域</strong>（<code>outer scope</code>）。一旦在外层作用域中声明（或者定义）了某个名字，那么它所嵌套着的所有内层作用域中都能访问这个名字。同时，允许在内层作用域中重新定义外层作用域中已有的名字。</p><p>​    假设<code>Base</code>是基类，<code>Derived</code>是派生类，那么它们的作用域的嵌套关系如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/16450GS9-0.jpg" alt></p><p>​    派生类的作用域位于基类作用域之内这一事实可能有点出人意料，毕竟在我们的代码中派生类和基类的定义是相互分离的。不过也恰恰因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样来使用基类的成员。</p><p>​    一个类作用域嵌套的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> A::func()&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"c.biancheng.net"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    C obj;</span><br><span class="line">    obj.n;</span><br><span class="line">    obj.func();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(C)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>c.biancheng.net</code><br><code>20</code></p><p> 本例中，<code>B</code>继承自<code>A</code>，<code>C</code>继承自<code>B</code>，它们作用域的嵌套关系如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/16450K5H-1.jpg" alt></p><p>​    <code>obj</code>是<code>C</code>类的对象，通过<code>obj</code>访问成员变量<code>n</code>时，在<code>C</code>类的作用域中就能够找到了<code>n</code>这个名字。虽然<code>A</code>类和<code>B</code>类都有名字<code>n</code>，但编译器不会到它们的作用域中查找，所以是不可见的，也即派生类中的<code>n</code>遮蔽了基类中的<code>n</code>。</p><p>​    通过<code>obj</code>访问成员函数<code>func()</code>时，在<code>C</code>类的作用域中没有找到<code>func</code>这个名字，编译器继续到<code>B</code>类的作用域（外层作用域）中查找，仍然没有找到，再继续到<code>A</code>类的作用域中查找，结果就发现了<code>func</code>这个名字，于是查找结束，编译器决定调用<code>A</code>类作用域中的<code>func()</code>函数。</p><p>​    <strong>这个过程叫做名字查找（<code>name lookup</code>），也就是在作用域链中寻找与所用名字最匹配的声明（或定义）的过程。</strong></p><p>​    对于成员变量这个过程很好理解，对于成员函数要引起注意，编译器仅仅是根据函数的名字来查找的，不会理会函数的参数。换句话说，一旦内层作用域有同名的函数，不管有几个，编译器都不会再到外层作用域中查找，编译器仅把内层作用域中的这些同名函数作为一组候选函数；这组候选函数就是一组重载函数。</p><p>​    说白了，<strong>只有一个作用域内的同名函数才具有重载关系，不同作用域内的同名函数是会造成遮蔽，使得外层函数无效。派生类和基类拥有不同的作用域，所以它们的同名函数不具有重载关系。</strong></p><p>​    我们不妨再来回顾一下上节的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类Base</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Base::func()&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::func()"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> Base::func(<span class="keyword">int</span> a)&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::func(int)"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类Derived</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">bool</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Derived::func(<span class="keyword">char</span> *str)&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::func(char *)"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> Derived::func(<span class="keyword">bool</span> is)&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::func(bool)"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.func(<span class="string">"c.biancheng.net"</span>);</span><br><span class="line">    d.func(<span class="literal">true</span>);</span><br><span class="line">    d.func();  <span class="comment">//compile error</span></span><br><span class="line">    d.func(<span class="number">10</span>);  <span class="comment">//compile error</span></span><br><span class="line">    d.Base::func();</span><br><span class="line">    d.Base::func(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    虽然<code>Derived</code>类和<code>Base</code>类都有同名的<code>func</code>函数，但它们位于不同的作用域，<code>Derived</code>类的<code>func</code>会遮蔽<code>Base</code>类的<code>func</code>。<code>d</code>是<code>Derived</code>类的对象，调用<code>func</code>函数时，编译器会先在<code>Derived</code> 类中查找<code>“func”</code>这个名字，发现有两个，也即<code>void func(char*)</code>和<code>void func(bool)</code>，这就是一组候选函数。</p><p>​    执行到第<code>26</code>、<code>27</code>行代码时，在候选函数中没有找到匹配的函数，所以调用失败，这时编译器会抛出错误信息，而不是再到<code>Base</code>类中查找同名函数。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++引用和指针的异同</title>
      <link href="/2018/06/15/c++%E5%9F%BA%E7%A1%8011-%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%82%E5%90%8C/"/>
      <url>/2018/06/15/c++%E5%9F%BA%E7%A1%8011-%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%82%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<p>  引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样。</p><a id="more"></a><h2 id="引用和指针的异同"><a href="#引用和指针的异同" class="headerlink" title="引用和指针的异同"></a>引用和指针的异同</h2><h3 id="引用的含义"><a href="#引用的含义" class="headerlink" title="引用的含义"></a>引用的含义</h3><p>​    通过上节的讲解，相信各位读者对引用都有了一个概念上的认识，能够简单地使用引用编程了，但又感觉糊里糊涂，不明白它到底是什么，它和指针有点相似，但又不是一个东西。</p><p>​    首先来回顾一下上节的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b = a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">", "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">", "</span>&lt;&lt;&amp;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">99</span>, <span class="number">99</span></span><br><span class="line"><span class="number">0x28ff44</span>, <span class="number">0x28ff44</span></span><br></pre></td></tr></table></figure></p><p>​    我们知道，变量是要占用内存的，虽然我们称<code>b</code>为变量，但是通过<code>&amp;b</code>获取到的却不是<code>b</code>的地址，而是<code>a</code>的地址，<strong>这会让我们觉得<code>b</code>这个变量不占用独立的内存，它和<code>a</code>指代的是同一份内存。</strong></p><h3 id="引用和指针的联系"><a href="#引用和指针的联系" class="headerlink" title="引用和指针的联系"></a>引用和指针的联系</h3><p>​    请读者再继续看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> &amp;r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::A(): n(<span class="number">0</span>), r(num)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//输出A类型的大小</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;hex&lt;&lt;showbase&lt;&lt;*((<span class="keyword">int</span>*)a + <span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//输出r的内容</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;num&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//输出num变量的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">0x442000</span></span><br><span class="line"><span class="number">0x442000</span></span><br></pre></td></tr></table></figure></p><p>​    成员变量<code>r</code>是<code>private</code>属性的，不能直接通过对象来访问，但是借助强大的指针和类型转换，我们依然可以得到它的内容，只不过这种方法有点蹩脚。</p><p>​    第<code>20</code>行代码中，<code>hex</code>表示以十六进制输出，<code>showbase</code>表示添加十六进制前缀<code>0x</code>。</p><p>​    从运行结果可以看出： </p><ul><li>成员变量<code>r</code>是占用内存的，如果不占用的话，<code>sizeof(A)</code>的结果应该为<code>4</code>。</li><li><p><code>r</code>存储的内容是<code>0x442000</code>，也即变量<code>num</code>的地址。</p><p>这说明<code>r</code>的实现和指针非常类似。如果将<code>r</code>定义为<code>int *</code>类型的指针，并在构造函数中让它指向<code>num</code>，那么<code>r</code>占用的内存也是<code>4</code>个字节，存储的内容也是<code>num</code>的地址。</p></li></ul><p>​    其实<strong>引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样，在<code>32</code>位环境下是<code>4</code>个字节，在<code>64</code>位环境下是<code>8</code>个字节，之所以不能获取引用的地址，是因为编译器进行了内部转换。</strong></p><p>​    以下面的语句为例： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = a;</span><br><span class="line">r = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;r&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>​    编译时会被转换成如下的形式： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">int</span> *r = &amp;a;</span><br><span class="line">*r = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>​    使用<code>&amp;r</code>取地址时，编译器会对代码进行隐式的转换，使得代码输出的是<code>r</code>的内容（<code>a</code>的地址），而不是<code>r</code>的地址，这就是为什么获取不到引用变量的地址的原因。</p><p>​    也就是说，不是变量<code>r</code>不占用内存，而是编译器不让获取它的地址。</p><p>​    当引用作为函数参数时，也会有类似的转换。以下面的代码为例： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>, num2 = <span class="number">20</span>;</span><br><span class="line">swap(num1, num2);</span><br></pre></td></tr></table></figure><p>​    编译时会被转换成如下的形式： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>, num2 = <span class="number">20</span>;</span><br><span class="line">swap(&amp;num1, &amp;num2);</span><br></pre></td></tr></table></figure><p>​    引用虽然是基于指针实现的，但它比指针更加易用，从上面的两个例子也可以看出来，通过指针获取数据时需要加<code>*</code>，书写麻烦，而引用不需要，它和普通变量的使用方式一样。</p><p>​    <code>C++</code>的发明人 <code>Bjarne Stroustrup</code> 也说过，他在<code>C++</code>中引入引用的直接目的是为了让代码的书写更加漂亮，尤其是在运算符重载中，不借助引用有时候会使得运算符的使用很麻烦。 </p><h3 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h3><p>​    1) <strong>引用必须在定义时初始化，并且以后也要从一而终，不能再指向其他数据；</strong>而指针没有这个限制，指针在定义时不必赋值，以后也能指向任意数据。</p><p>​    2) <strong>可以有<code>const</code>指针，但是没有<code>const</code>引用。</strong>也就是说，引用变量不能定义为下面的形式： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; <span class="keyword">const</span> r = a;</span><br></pre></td></tr></table></figure><p>​    因为<code>r</code>本来就不能改变指向，加上<code>const</code>是多此一举。</p><p>​    3) <strong>指针可以有多级，但是引用只能有一级。</strong>例如，<code>int **p</code>是合法的，而<code>int &amp;&amp;r</code>是不合法的。如果希望定义一个引用变量来指代另外一个引用变量，那么也只需要加一个<code>&amp;</code>，如下所示： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = a;</span><br><span class="line"><span class="keyword">int</span> &amp;rr = r;</span><br></pre></td></tr></table></figure><p>​    4) <strong>指针和引用的自增（<code>++</code>）自减（<code>--</code>）运算意义不一样。</strong>对指针使用<code>++</code>表示指向下一份数据，对引用使用<code>++</code>表示它所指代的数据本身加<code>1</code>；自减（<code>--</code>）也是类似的道理。请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;r = a;</span><br><span class="line">    r++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">2</span>] = &#123; <span class="number">27</span>, <span class="number">84</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = arr;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">84</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++命名空间</title>
      <link href="/2018/06/13/c++%E5%9F%BA%E7%A1%8010-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
      <url>/2018/06/13/c++%E5%9F%BA%E7%A1%8010-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>一个中大型软件往往由多名程序员共同开发，会使用大量的变量和函数，不可避免地会出现变量或函数的命名冲突。当所有人的代码都测试通过，没有问题时，将它们结合到一起就有可能会出现命名冲突。</p><p>​    例如小李和小韩都参与了一个文件管理系统的开发，它们都定义了一个全局变量<code>fp</code>，用来指明当前打开的文件，将他们的代码整合在一起编译时，很明显编译器会提示<code>fp</code>重复定义（<code>Redefinition</code>）错误。</p><a id="more"></a><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p> 为了解决合作开发时的命名冲突问题，<code>C++</code>引入了<strong>命名空间（<code>Namespace</code>）</strong>的概念。请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Li&#123;  <span class="comment">//小李的变量定义</span></span><br><span class="line">    FILE fp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Han&#123;  <span class="comment">//小韩的变量定义</span></span><br><span class="line">    FILE fp = <span class="literal">NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    小李与小韩各自定义了以自己姓氏为名的命名空间，此时再将他们的<code>fp</code>变量放在一起编译就不会有任何问题。</p><blockquote><p>命名空间有时也被称为名字空间、名称空间。</p></blockquote><p>​    <code>namespace</code>是<code>C++</code>中的关键字，用来定义一个命名空间，语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namespace name&#123;</span><br><span class="line">   //variables, functions, classes</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>​    <code>name</code>是命名空间的名字，它里面可以包含变量、函数、类、<code>typedef</code>、<code>#define</code>等，最后由<code>{ }</code>包围。</p><p>​     使用变量、函数时要指明它们所在的命名空间。以上面的<code>fp</code>变量为例，可以这样来使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Li::fp = fopen(<span class="string">"one.txt"</span>, <span class="string">"r"</span>);  <span class="comment">//使用小李定义的变量 fp</span></span><br><span class="line">Han::fp = fopen(<span class="string">"two.txt"</span>, <span class="string">"rb+"</span>);  <span class="comment">//使用小韩定义的变量 fp</span></span><br></pre></td></tr></table></figure><p>​    <strong><code>::</code>是一个新符号，称为域解析操作符，在C++中用来指明要使用的命名空间。</strong></p><p>​    除了直接使用域解析操作符，还可以采用<code>using</code>关键字声明，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Li::fp;</span><br><span class="line">fp = fopen(<span class="string">"one.txt"</span>, <span class="string">"r"</span>);  <span class="comment">//使用小李定义的变量 fp</span></span><br><span class="line">Han :: fp = fopen(<span class="string">"two.txt"</span>, <span class="string">"rb+"</span>);  <span class="comment">//使用小韩定义的变量 fp</span></span><br></pre></td></tr></table></figure><p>​    在代码的开头用<code>using</code>声明了<code>Li::fp</code>，它的意思是，<code>using</code>声明以后的程序中如果出现了未指明命名空间的<code>fp</code>，就使用<code>Li::fp</code>；但是若要使用小韩定义的<code>fp</code>，仍然需要<code>Han::fp</code>。</p><p>​    <strong><code>using</code>声明不仅可以针对命名空间中的一个变量，也可以用于声明整个命名空间。</strong>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Li;</span><br><span class="line">fp = fopen(<span class="string">"one.txt"</span>, <span class="string">"r"</span>);  <span class="comment">//使用小李定义的变量 fp</span></span><br><span class="line">Han::fp = fopen(<span class="string">"two.txt"</span>, <span class="string">"rb+"</span>);  <span class="comment">//使用小韩定义的变量 fp</span></span><br></pre></td></tr></table></figure><p>​    如果命名空间<code>Li</code>中还定义了其他的变量，那么同样具有<code>fp</code>变量的效果。在<code>using</code>声明后，如果有未具体指定命名空间的变量产生了命名冲突，那么默认采用命名空间<code>Li</code>中的变量。</p><p>​    <strong>命名空间内部不仅可以声明或定义变量，对于其它能在命名空间以外声明或定义的名称，同样也都能在命名空间内部进行声明或定义</strong>，例如类、函数、<code>typedef</code>、<code>#define</code>等都可以出现在命名空间中。</p><p>​    站在编译和链接的角度，代码中出现的变量名、函数名、类名等都是一种符号（<code>Symbol</code>）。有的符号可以指代一个内存位置，例如变量名、函数名；有的符号仅仅是一个新的名称，例如<code>typedef</code>定义的类型别名。</p><p>​    下面来看一个命名空间完整示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将类定义在命名空间中</span></span><br><span class="line"><span class="keyword">namespace</span> Diy&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">float</span> score;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s的年龄是 %d，成绩是 %f\n"</span>, name, age, score);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Diy::Student stu1;</span><br><span class="line">    stu1.name = <span class="string">"小明"</span>;</span><br><span class="line">    stu1.age = <span class="number">15</span>;</span><br><span class="line">    stu1.score = <span class="number">92.5f</span>;</span><br><span class="line">    stu1.say();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>小明的年龄是 15，成绩是 92.500000</code></p><h2 id="C-和C头文件差别"><a href="#C-和C头文件差别" class="headerlink" title="C++和C头文件差别"></a><code>C++</code>和<code>C</code>头文件差别</h2><p>​    <code>C++</code>是在<code>C</code>语言的基础上开发的，早期的<code>C++</code>还不完善，不支持命名空间，没有自己的编译器，而是将<code>C++</code>代码翻译成<code>C</code>代码，再通过<code>C</code>编译器完成编译。这个时候的<code>C++</code>仍然在使用<code>C</code>语言的库，<code>stdio.h</code>、<code>stdlib.h</code>、<code>string.h</code>等头文件依然有效；此外<code>C++</code>也开发了一些新的库，增加了自己的头文件，例如：</p><ul><li><code>iostream.h</code>：用于控制台输入输出头文件。</li><li><code>fstream.h</code>：用于文件操作的头文件。</li><li><code>complex.h</code>：用于复数计算的头文件。</li></ul><p>和<code>C</code>语言一样，<code>C++</code>头文件仍然以<code>.h</code>为后缀，它们所包含的类、函数、宏等都是全局范围的。</p><p>​    后来<code>C++</code>引入了命名空间的概念，计划重新编写库，将类、函数、宏等都统一纳入一个命名空间，这个命名空间的名字就是<code>std</code>。std 是<code>standard</code>的缩写，意思是“标准命名空间”。</p><p>​    但是这时已经有很多用老式<code>C++</code>开发的程序了，它们的代码中并没有使用命名空间，直接修改原来的库会带来一个很严重的后果：程序员会因为不愿花费大量时间修改老式代码而极力反抗，拒绝使用新标准的<code>C++</code>代码。</p><p>​    <strong><code>C++</code>开发人员想了一个好办法，保留原来的库和头文件，它们在<code>C++</code>中可以继续使用，然后再把原来的库复制一份，在此基础上稍加修改，把类、函数、宏等纳入命名空间<code>std</code>下，就成了新版<code>C++</code>标准库。这样共存在了两份功能相似的库，使用了老式<code>C++</code>的程序可以继续使用原来的库，新开发的程序可以使用新版的<code>C++</code>库。</strong></p><p>​    为了避免头文件重名，新版<code>C++</code>库也对头文件的命名做了调整，去掉了后缀<code>.h</code>，所以老式<code>C++</code>的<code>iostream.h</code>变成了<code>iostream</code>，<code>fstream.h</code>变成了<code>fstream</code>。而对于原来<code>C</code>语言的头文件，也采用同样的方法，但在每个名字前还要添加一个<code>c</code>字母，所以C语言的<code>stdio.h</code>变成了<code>cstdio</code>，<code>stdlib.h</code>变成了<code>cstdlib</code>。</p><p>​    需要注意的是，旧的<code>C++</code>头文件是官方所反对使用的，已明确提出不再支持，但旧的<code>C</code>头文件仍然可以使用，以保持对<code>C</code>的兼容性。实际上，编译器开发商不会停止对客户现有软件提供支持，可以预计，旧的<code>C++</code>头文件在未来数年内还是会被支持。</p><p>​    下面是我总结的<code>C++</code> 头文件的现状：<br> 1)、 旧的<code>C++</code>头文件，如<code>iostream.h</code>、<code>fstream.h</code>等将会继续被支持，尽管它们不在官方标准中。这些头文件的内容不在命名空间<code>std</code>中。</p><p> 2)、 新的<code>C++</code>头文件，如<code>iostream</code>、<code>fstream</code>等包含的基本功能和对应的旧版头文件相似，但头文件的内容在命名空间<code>std</code>中。</p><blockquote><p>注意：在标准化的过程中，库中有些部分的细节被修改了，所以旧的头文件和新的头文件不一定完全对应。</p></blockquote><p>3) 、标准<code>C</code>头文件如<code>stdio.h</code>、<code>stdlib.h</code>等继续被支持。头文件的内容不在<code>std</code>中。</p><p> 4) 、具有<code>C</code>库功能的新<code>C++</code>头文件具有如<code>cstdio</code>、<code>cstdlib</code>这样的名字。它们提供的内容和相应的旧的<code>C</code>头文件相同，只是内容在<code>std</code>中。</p><p>​    <strong>可以发现，对于不带<code>.h</code>的头文件，所有的符号都位于命名空间<code>std</code>中，使用时需要声明命名空间<code>std</code>；对于带<code>.h</code>的头文件，没有使用任何命名空间，所有符号都位于全局作用域。这也是<code>C++</code>标准所规定的。</strong></p><p>​     不过现实情况和<code>C++</code>标准所期望的有些不同，对于原来<code>C</code>语言的头文件，即使按照<code>C++</code>的方式来使用，即<code>#include</code>这种形式，那么符号可以位于命名空间<code>std</code>中，也可以位于全局范围中，请看下面的两段代码。</p><p> 1) 、使用命名空间<code>std</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"http://c.biancheng.net\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2) 、不使用命名空间<code>std</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"http://c.biancheng.net\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这两种形式在<code>Microsoft Visual C++</code>和<code>GCC</code>下都能够编译通过，也就是说，大部分编译器在实现时并没有严格遵循<code>C++</code>标准，它们对两种写法都支持，程序员可以使用<code>std</code>也可以不使用。</p><p>​    第<code>1)</code>种写法是标准的，第<code>2)</code>种不标准，虽然它们在目前的编译器中都没有错误，但依然推荐使用第<code>1)</code>种写法，因为标准写法会一直被编译器支持，非标准写法可能会在以后的升级版本中不再支持。</p><h2 id="使用C-的头文件"><a href="#使用C-的头文件" class="headerlink" title="使用C++的头文件"></a>使用<code>C++</code>的头文件</h2><p>​    <strong>虽然<code>C++</code>几乎完全兼容<code>C</code>语言，<code>C</code>语言的头文件在<code>C++</code>中依然被支持，但<code>C++</code>新增的库更加强大和灵活，请读者尽量使用这些<code>C++</code>新增的头文件，例如<code>iostream</code>、<code>fstream</code>、<code>string</code>等。</strong></p><p>​    前面我们使用了<code>C</code>语言的格式输出函数<code>printf</code>，引入了<code>C</code>语言的头文件<code>stdio.h</code>，将<code>C</code>代码和<code>C++</code>代码混合在了一起，不推荐这样做，请尽量使用<code>C++</code>的方式。下面的例子演示了如何使用<code>C++</code>库进行输入输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//声明命名空间std</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//定义字符串变量</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="comment">//定义 int 变量</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//从控制台获取用户输入</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str&gt;&gt;age;</span><br><span class="line">    <span class="comment">//将数据输出到控制台</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="string">"已经成立"</span>&lt;&lt;age&lt;&lt;<span class="string">"年了！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>C语言中文网↙</code><br><code>6↙</code><br><code>C语言中文网已经成立6年了！</code></p><p>​    <code>string</code>是<code>C++</code>中的字符串类，初学者可以将<code>string</code>看做一种内置的数据类型，就像<code>int</code>、<code>float</code>等，可以用来定义变量。<code>cin</code>用于从控制台获取用户输入，<code>cout</code>用于将数据输出到控制台。</p><p>​    读者暂时不需要深入了解这段代码的细节，只需要留意<code>using namespace std;</code>，它声明了命名空间<code>std</code>，后续如果有未指定命名空间的符号，那么默认使用<code>std</code>，代码中的<code>string</code>、<code>cin</code>、<code>cout</code>都位于命名空间 std。</p><p>​    在<code>main()</code>函数中声明命名空间<code>std</code>，它的作用范围就位于<code>main()</code>函数内部，如果在其他函数中又用到了 <code>std</code>，就需要重新声明，请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//必须重新声明</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"http://c.biancheng.net"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//声明命名空间std</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"C语言中文网"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望在所有函数中都使用命名空间<code>std</code>，可以将它声明在全局范围中，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明命名空间std</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"http://c.biancheng.net"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"C语言中文网"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    很多教程中都是这样做的，将<code>std</code>直接声明在所有函数外部，这样虽然使用方便，但在中大型项目开发中是不被推荐的，这样做增加了命名冲突的风险，推荐在函数内部声明<code>std</code>。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++函数的默认参数</title>
      <link href="/2018/06/10/c++%E5%9F%BA%E7%A1%809-%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"/>
      <url>/2018/06/10/c++%E5%9F%BA%E7%A1%809-%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在<code>C++</code>中，定义函数时可以给形参指定一个默认的值，这样调用函数时如果没有给这个形参赋值（没有对应的实参），那么就使用这个默认的值。也就是说，调用函数时可以省略有默认值的参数。如果用户指定了参数的值，那么就使用用户指定的值，否则使用参数的默认值。</p><a id="more"></a><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>​    <strong>所谓默认参数，指的是当函数调用中省略了实参时自动使用的一个值，这个值就是给形参指定的默认值。</strong>下面是一个简单的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带默认参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">float</span> b=<span class="number">1.2</span>, <span class="keyword">char</span> c=<span class="string">'@'</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">", "</span>&lt;&lt;b&lt;&lt;<span class="string">", "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//为所有参数传值</span></span><br><span class="line">    func(<span class="number">10</span>, <span class="number">3.5</span>, <span class="string">'#'</span>);</span><br><span class="line">    <span class="comment">//为n、b传值，相当于调用func(20, 9.8, '@')</span></span><br><span class="line">    func(<span class="number">20</span>, <span class="number">9.8</span>);</span><br><span class="line">    <span class="comment">//只为n传值，相当于调用func(30, 1.2, '@')</span></span><br><span class="line">    func(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>10, 3.5, #</code><br><code>20, 9.8, @</code><br><code>30, 1.2, @</code></p><p>​    本例定义了一个带有默认参数的函数<code>func()</code>，并在<code>main()</code>函数中进行了不同形式的调用。为参数指定默认值非常简单，直接在形参列表中赋值即可，与定义普通变量的形式类似。</p><p>​    指定了默认参数后，调用函数时就可以省略对应的实参了。</p><p>​    默认参数除了使用数值常量指定，也可以使用表达式指定，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> d = <span class="number">10.8</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">float</span> b=d+<span class="number">2.9</span>, <span class="keyword">char</span> c=<span class="string">'@'</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">", "</span>&lt;&lt;b&lt;&lt;<span class="string">", "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong><code>C++</code>规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。实参和形参的传值是从左到右依次匹配的，默认参数的连续性是保证正确传参的前提。</strong></p><p>​    下面的写法是正确的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b=<span class="number">10</span>, <span class="keyword">int</span> c=<span class="number">20</span>)</span></span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c=<span class="number">20</span>)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>​    但这样写不可以：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b=<span class="number">10</span>, <span class="keyword">int</span> c=<span class="number">20</span>, <span class="keyword">int</span> d)</span></span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b=<span class="number">10</span>, <span class="keyword">int</span> c, <span class="keyword">int</span> d=<span class="number">20</span>)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>​    默认参数并非编程方面的重大突破，而只是提供了一种便捷的方式。在以后设计类时你将发现，通过使用默认参数，可以减少要定义的析构函数、方法以及方法重载的数量。</p><p>​    例子中，我们在函数定义处指定了默认参数。除了函数定义，你也可以在函数声明处指定默认参数。</p><h2 id="默认参数指定位置"><a href="#默认参数指定位置" class="headerlink" title="默认参数指定位置"></a>默认参数指定位置</h2><p>​    我们在函数定义处指定了默认参数。除了函数定义，你也可以在函数声明处指定默认参数。不过当出现函数声明时情况会变得稍微复杂，有时候你可以在声明处和定义处同时指定默认参数，有时候你只能在声明处指定，请看下面的例子（示例1）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c = <span class="number">36</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func(<span class="number">99</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c = <span class="number">36</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">", "</span>&lt;&lt;b&lt;&lt;<span class="string">", "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这段代码在编译时会报错，错误信息表明不能在函数定义和函数声明中同时指定默认参数。对代码稍作修改，将 <code>func()</code>函数的定义放到其他源文件中，如下所示（示例2）。</p><p>​    <code>main.cpp</code>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c = <span class="number">36</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func(<span class="number">99</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>module.cpp</code>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c = <span class="number">36</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">", "</span>&lt;&lt;b&lt;&lt;<span class="string">", "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>99, 10, 36</code></p><p>​    修改后的代码是可以编译通过的，这有点让人摸 不着头脑，为什么将<code>func()</code>的定义放到其他源文件中就不一样了呢？</p><p>​    <strong>这是因为<code>C++</code>规定，在给定的作用域中只能指定一次默认参数。</strong></p><p>​    对于示例1，<code>func()</code>的定义和声明位于同一个源文件，它们的作用域也都是整个源文件，这样就导致在同一个文件作用域中指定了两次默认参数，违反了<code>C++</code>的规定。</p><p>​    对于示例2，<code>func()</code>的声明位于<code>main.cpp</code>，作用域也是<code>main.cpp</code>，而<code>func()</code>的定义位于<code>module.cpp</code>，作用域也是<code>module.cpp</code>，<code>func()</code>的声明和定义位于不同的作用域，相互之间不影响。</p><blockquote><p>​    <code>C</code>语言有四种作用域，分别是函数原型作用域、局部作用域（函数作用域）、块作用域、文件作用域（全局作用域），<code>C++</code>也有这几种作用域。</p></blockquote><p>​    <strong>继续对代码进行修改，将<code>func()</code>定义处<code>b</code>、<code>c</code>的默认值分别设置为 5、57，而声明处<code>b</code>、<code>c</code>的默认值不变，依然为  10、36。编译并运行程序，发现输出结果与上面一样，这说明编译器使用的是当前作用域中的默认参数。站在编译器的角度看，它不管当前作用域中是函数声明还是函数定义，只要有默认参数就可以使用。</strong></p><h2 id="多次声明同一函数"><a href="#多次声明同一函数" class="headerlink" title="多次声明同一函数"></a>多次声明同一函数</h2><p>​    在多文件编程时，我们通常的做法是将函数声明放在头文件中，并且一个函数只声明一次，但是多次声明同一函数也是合法的。</p><p>​    <strong>不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认参数。</strong>换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认值，而且该形参右侧的所有形参必须都有默认值。</p><p>​    为了说明问题，我们不妨对<code>main.cpp</code>中的代码稍作修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多次声明同一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c = <span class="number">36</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">5</span>, <span class="keyword">int</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func(<span class="number">99</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这种声明方式是正确的。第一次声明时为<code>c</code>指定了默认值，第二次声明时为<code>b</code>指定了默认值；第二次声明是添加默认参数。需要提醒的是，第二次声明时不能再次给<code>c</code>指定默认参数，否则就是重复声明同一个默认参数。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++bool类型</title>
      <link href="/2018/06/05/c++%E5%9F%BA%E7%A1%808-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8Bbool/"/>
      <url>/2018/06/05/c++%E5%9F%BA%E7%A1%808-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8Bbool/</url>
      
        <content type="html"><![CDATA[<p>在<code>C</code>语言中，关系运算和逻辑运算的结果有两种，真和假：<code>0</code>表示假，非<code>0</code>表示真。</p><a id="more"></a><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, flag;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">    flag = a &gt; b;  <span class="comment">//flag保存关系运算结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"flag = %d\n"</span>, flag);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><code>10 20↙</code><br><code>flag = 0</code></p><p>​    <code>C</code>语言并没有彻底从语法上支持“真”和“假”，只是用<code>0</code>和非<code>0</code>来代表。这点在<code>C++</code>中得到了改善，<code>C++</code>新增了 <strong><code>bool</code>类型（布尔类型）</strong>，它一般占用<code>1</code>个字节长度。<code>bool</code>类型只有两个取值，<code>true</code>和<code>false</code>：<code>true</code>表示“真”，<code>false</code>表示“假”。</p><p>​    <code>bool</code>是类型名字，也是<code>C++</code>中的关键字，它的用法和<code>int</code>、<code>char</code>、<code>long</code>是一样的，请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">bool</span> flag;  <span class="comment">//定义布尔变量</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    flag = a &gt; b;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"flag = "</span>&lt;&lt;flag&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>10 20↙</code><br><code>flag = 0</code></p><p>​    遗憾的是，在<code>C++</code>中使用<code>cout</code>输出<code>bool</code>变量的值时还是用数字<code>1</code>和<code>0</code>表示，而不是<code>true</code>或<code>false</code>。<code>Java</code>、<code>PHP</code>、<code>JavaScript</code>等也都支持布尔类型，但输出结果为<code>true</code>或<code>false</code>。</p><pre><code>你也可以使用` true `或` false `显式地对` bool `变量赋值，例如：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"true"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"false"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"true"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"false"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：<br><code>true</code><br><code>false</code></p><blockquote><p>注意，<code>true</code>和<code>false</code>是<code>C++</code>中的关键字，<code>true</code>表示“真”，<code>false</code>表示“假”。</p></blockquote><p>​    在<code>C++</code>的编码中，推荐使用<code>bool</code>变量来表示逻辑运算、关系运算以及开关变量的值。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++变量定义位置</title>
      <link href="/2018/06/04/c++%E5%9F%BA%E7%A1%807-%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E4%BD%8D%E7%BD%AE/"/>
      <url>/2018/06/04/c++%E5%9F%BA%E7%A1%807-%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><code>C++</code>不但在<code>C</code>语言的基础上进行了很多扩展，而且也对<code>C</code>语言部分做了细节上的改进，变量的定义位置就是其中之一。</p><p>​    <strong><code>C89</code>规定，所有局部变量都必须定义在函数开头，在定义好变量之前不能有其他的执行语句。<code>C99</code>标准取消这这条限制，但是<code>VC/VS</code>对<code>C99</code>的支持很不积极，仍然要求变量定义在函数开头。</strong></p><blockquote><p><code>C89</code>和<code>C99</code>是两套不同的<code>C</code>语言标准，<code>C99</code>是<code>C89</code>的升级版。</p></blockquote><a id="more"></a><p>请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b);</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    将代码保存到源文件<code>main.c</code>，那么它可以在<code>GCC</code>、<code>Xcode</code>下编译通过，但在<code>VC/VS</code>下会报错。<code>GCC</code>、<code>Xcode</code>对<code>C99</code>的支持非常好，可以在函数的任意位置定义变量；但<code>VC/VS</code>对<code>C99</code>的支持寥寥无几，必须在函数开头定义好所有变量。</p><pre><code>将上面的代码再保存到源文件`main.cpp`，那么它在` GCC`、`Xcode`、`VC/VS `下都可以编译通过。这是因为 `C++ `取消了原来的限制，变量只要在使用之前定义好即可，不强制必须在函数开头定义所有变量。</code></pre><blockquote><p>注意源文件的后缀，<code>.c</code>是C语言代码，<code>.cpp</code>是<code>C++</code>代码，它们的编译方式不同。</p></blockquote><p>​    取消限制带来的另外一个好处是，可以在<code>for</code>循环的控制语句中定义变量，请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//在for循环的条件语句内部定义变量i</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n ;i++)&#123;</span><br><span class="line">        total += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Input a interge: "</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Total: "</span>&lt;&lt;sum(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input a interge: 10</span><br><span class="line">Total: 55</span><br></pre></td></tr></table></figure><p>​    在<code>for</code>内部定义循环控制变量<code>i</code>，会让代码看起来更加紧凑，并使得<code>i</code>的作用域被限制在整个<code>for</code>循环语句内部（包括循环条件和循环体），减小了命名冲突的概率。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++new和delete运算符</title>
      <link href="/2018/06/03/c++%E5%9F%BA%E7%A1%806-new%E5%92%8Cdelete%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2018/06/03/c++%E5%9F%BA%E7%A1%806-new%E5%92%8Cdelete%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>在<code>C</code>语言中，动态分配内存用<code>malloc()</code>函数，释放内存用<code>free()</code>函数。如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">10</span> );  <span class="comment">//分配10个int型的内存空间</span></span><br><span class="line"><span class="built_in">free</span>(p);  <span class="comment">//释放内存</span></span><br></pre></td></tr></table></figure><p>​    在<code>C++</code>中，这两个函数仍然可以使用，但是<code>C++</code>又新增了两个关键字，<strong><code>new</code>和<code>delete</code>：<code>new</code>用来动态分配内存，<code>delete</code>用来释放内存。</strong></p><a id="more"></a><p>​    用<code>new</code>和<code>delete</code>分配内存更加简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//分配1个int型的内存空间</span></span><br><span class="line"><span class="keyword">delete</span> p;  <span class="comment">//释放内存</span></span><br></pre></td></tr></table></figure><p>​    <strong><code>new</code>操作符会根据后面的数据类型来推断所需空间的大小。</strong></p><p>​    如果希望分配一组连续的数据，可以使用<code>new[]</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];  <span class="comment">//分配10个int型的内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure><p>​    <strong>用<code>new[]</code>分配的内存需要用<code>delete[]</code>释放，它们是一一对应的。</strong></p><p>​    和<code>malloc()</code>一样，<code>new</code>也是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收。为了避免内存泄露，通常<code>new</code>和<code>delete</code>、<code>new[]</code>和 <code>delete[]</code>操作符应该成对出现，并且不要和<code>C</code>语言中 <code>malloc()</code>、<code>free()</code>一起混用。</p><p>​    在<code>C++</code>中，建议使用<code>new</code>和<code>delete</code>来管理内存，它们可以使用<code>C++</code>的一些新特性，最明显的是可以自动调用构造函数和析构函数，后续我们将会讲解。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++重载、重定义与重载</title>
      <link href="/2018/06/01/c++%E5%9F%BA%E7%A1%805-%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%AE%9A%E4%B9%89%E3%80%81%E9%87%8D%E5%86%99%E5%B7%AE%E5%BC%82/"/>
      <url>/2018/06/01/c++%E5%9F%BA%E7%A1%805-%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%AE%9A%E4%B9%89%E3%80%81%E9%87%8D%E5%86%99%E5%B7%AE%E5%BC%82/</url>
      
        <content type="html"><![CDATA[<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul><li><p>同一个作用域</p></li><li><p>参数个数，参数顺序，参数类型不同</p></li><li><p>和函数返回值，没有关系</p></li><li><p><code>const</code>也可以作为重载条件 </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>(<span class="keyword">const</span> Teacher&amp; t)&#123;&#125; </span><br><span class="line"><span class="keyword">do</span>(Teacher&amp; t)</span><br></pre></td></tr></table></figure></li></ul><h3 id="重定义（隐藏）"><a href="#重定义（隐藏）" class="headerlink" title="重定义（隐藏）"></a>重定义（隐藏）</h3><ul><li><p>有继承</p></li><li><p>子类（派生类）重新定义父类（基类）的同名成员（非<code>virtual</code>函数）</p></li></ul><h3 id="重写（覆盖）"><a href="#重写（覆盖）" class="headerlink" title="重写（覆盖）"></a>重写（覆盖）</h3><ul><li>有继承</li><li>子类（派生类）重写父类（基类）的virtual函数</li><li>函数返回值，函数名字，函数参数，必须和基类中的虚函数一致</li></ul><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//同一作用域下，func1函数重载</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//重定义基类的func2,隐藏了基类的func2方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//重写基类的func3函数，也可以覆盖基类func3</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++内联函数</title>
      <link href="/2018/05/30/c++%E5%9F%BA%E7%A1%803-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline/"/>
      <url>/2018/05/30/c++%E5%9F%BA%E7%A1%803-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline/</url>
      
        <content type="html"><![CDATA[<p>函数是一个可以重复使用的代码块，<code>CPU</code>会一条一条地挨着执行其中的代码。<code>CPU</code>在执行主调函数代码时如果遇到了被调函数，主调函数就会暂停，<code>CPU</code>转而执行被调函数的代码；被调函数执行完毕后再返回到主调函数，主调函数根据刚才的状态继续往下执行。</p><p>​     一个<code>C/C++</code>程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条，这个链条的起点是<code>main()</code>，终点也是<code>main()</code>。当<code>main()</code>调用完了所有的函数，它会返回一个值（例如<code>return 0;</code>）来结束自己的生命，从而结束整个程序。</p><p>​    <strong>函数调用是有时间和空间开销的。</strong>程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。</p><p>​    如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视。</p><a id="more"></a><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><h3 id="消除函数调用"><a href="#消除函数调用" class="headerlink" title="消除函数调用"></a>消除函数调用</h3><p>​    为了消除函数调用的时空开销，<code>C++</code>提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于<code>C</code>语言中的宏展开。<strong>这种在函数调用处直接嵌入函数体的函数称为内联函数（<code>Inline Function</code>），又称内嵌函数或者内置函数。</strong></p><p>​    <strong>指定内联函数的方法很简单，只需要在函数定义处增加<code>inline</code>关键字。</strong>请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内联函数，交换两个数的值</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="string">", "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    swap(&amp;m, &amp;n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="string">", "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>45 99↙</code><br><code>45, 99</code><br><code>99, 45</code></p><p>​    注意，要在函数定义处添加<code>inline</code>关键字，在函数声明处添加<code>inline</code>关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的<code>inline</code>关键字。</p><p>​    当编译器遇到函数调用<code>swap(&amp;m, &amp;n)</code>时，会用<code>swap()</code>函数的代码替换<code>swap(&amp;m, &amp;n)</code>，同时用实参代替形参。这样，程序第<code>16</code>行就被置换成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp = *(&amp;m);</span><br><span class="line">*(&amp;m) = *(&amp;n);</span><br><span class="line">*(&amp;n) = temp;</span><br></pre></td></tr></table></figure><p>​    编译器可能会将<code>*(&amp;m)</code>、<code>*(&amp;n)</code>分别优化为<code>m</code>、<code>n</code>。</p><p>​    当函数比较复杂时，函数调用的时空开销可以忽略，大部分的<code>CPU</code>时间都会花费在执行函数体代码上，所以我们一般是将非常短小的函数声明为内联函数。</p><p>​    由于内联函数比较短小，我们通常的做法是省略函数原型，将整个函数定义（包括函数头和函数体）放在本应该提供函数原型的地方。下面的例子是一个反面教材，这样的写法是不被推荐的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>;  <span class="comment">//也可以添加inline，但编译器会忽略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="string">", "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    swap1(&amp;m, &amp;n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="string">", "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数。</p><p>​    最后需要说明的是，对函数作<code>inline</code>声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为<code>inline</code>编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。</p><h3 id="取代带参数的宏"><a href="#取代带参数的宏" class="headerlink" title="取代带参数的宏"></a>取代带参数的宏</h3><p>​    宏是可以带参数的，它在形式上和函数非常相似。不过不像函数，宏仅仅是字符串替换，不是按值传递，所以在编写宏时要特别注意，一不小心可能就会踩坑。</p><p>​    使用宏的一个经典例子是求一个数的平方，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQ(y) y*y</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, sq;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    sq = SQ(n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sq&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>9↙</code><br><code>81</code></p><p>​    从表面上看这个宏定义是正确的，但当我们将宏调用<code>SQ(n)</code>换成<code>SQ(n+1)</code>后，就会出现意想不到的状况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQ(y) y*y</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, sq;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    sq = SQ(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sq&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>9↙</code> </p><p><code>19</code></p><p>​    我们期望的结果是<code>100</code>，但这里却是<code>19</code>，两者大相径庭。这是因为，宏展开仅仅是字符串的替换，不会进行任何计算或传值，上面的<code>sq = SQ(n+1);</code>在宏展开后会变为<code>sq = n+1*n+1;</code>，这显然是没有道理的。</p><p>​    如果希望得到正确的结果，应该将宏定义改为如下的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQ(y) (y)*(y)</span></span><br></pre></td></tr></table></figure><p>​    这样宏调用<code>sq = SQ(n+1);</code>就会展开为<code>sq = (n+1)*(n+1);</code>，得到的结果就是<code>100</code>。</p><p>​    如果你认为这样就万事大吉了，那下面的结果会让你觉得考虑不周：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQ(y) (y)*(y)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, sq;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    sq = <span class="number">200</span> / SQ(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sq&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>9↙</code><br><code>200</code></p><pre><code>之所以会出现这么奇怪的结果，是因为宏调用`sq = 200 / SQ(n+1);`会被展开为`sq = 200 / (n+1) * (n+1);`，当 n 被赋值 9 后，相当于`sq = 200 / 10 * 10`，结果显然是 200。</code></pre><p>​     要想得到正确的结果，还应该对宏加以限制，在两边增加<code>( )</code>，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQ(y) ( (y)*(y) )</span></span><br></pre></td></tr></table></figure><p>​    这样宏调用<code>sq = 200 / SQ(n+1);</code>就会展开为<code>sq = 200 / ( (n+1) * (n+1) );</code>，得到的结果就是<code>2</code>。</p><p>​    <strong>宏定义是一项“细思极密”的工作，一不小心就会踩坑，而且不一定在编译和运行时发现，给程序埋下隐患。</strong></p><p>​    如果我们将宏替换为内联函数，情况就没有那么复杂了，程序员就会游刃有余，请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SQ</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> y*y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, sq;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="comment">//SQ(n)</span></span><br><span class="line">    sq = SQ(n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sq&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//SQ(n+1)</span></span><br><span class="line">    sq = SQ(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sq&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//200 / SQ(n+1)</span></span><br><span class="line">    sq = <span class="number">200</span> / SQ(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sq&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>9↙</code><br><code>81</code><br><code>100</code><br><code>2</code></p><p>​    看，一切问题迎刃而解！发生函数调用时，编译器会先对实参进行计算，再将计算的结果传递给形参，并且函数执行完毕后会得到一个值，而不是得到一个表达式，这和简单的字符串替换相比省去了很多麻烦，<strong>所以在编写<code>C++</code>代码时我推荐使用内联函数来替换带参数的宏。</strong></p><p>​    <strong>和宏一样，内联函数可以定义在头文件中（不用加<code>static</code>关键字），并且头文件被多次<code>#include</code>后也不会引发重复定义错误。</strong>这一点和非内联函数不同，非内联函数是禁止定义在头文件中的，它所在的头文件被多次<code>#include</code>后会引发重复定义错误。</p><p>​    内联函数在编译时会将函数调用处用函数体替换，编译完成后函数就不存在了，所以在链接时不会引发重复定义错误。这一点和宏很像，宏在预处理时被展开，编译时就不存在了。从这个角度讲，内联函数更像是编译期间的宏。</p><p>​    <strong>可以看到内联函数主要有两个作用，一是消除函数调用时的开销，二是取代带参数的宏。不过我更倾向于后者，取代带参数的宏更能凸显内联函数存在的意义。</strong></p><h4 id="类内部的内联函数"><a href="#类内部的内联函数" class="headerlink" title="类内部的内联函数"></a>类内部的内联函数</h4><p>​    为了定义内联函数，通常必须在函数定义前面放一个<code>inline</code>关键字。但是在类内部定义内联函数时并不是必须的。<strong>任何在类内部定义的函数自动成为内联函数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"构造函数!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPerson</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"输出Person!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    构造函数<code>Person</code>，成员函数<code>PrintPerson</code>在类的内部定义，自动成为内联函数。</p><h3 id="规范使用内联函数"><a href="#规范使用内联函数" class="headerlink" title="规范使用内联函数"></a>规范使用内联函数</h3><p>​    <code>inline</code>关键字可以只在函数定义处添加，也可以只在函数声明处添加，也可以同时添加；但是在函数声明处添加<code>inline</code>关键字是无效的，编译器会忽略函数声明处的<code>inline</code>关键字。也就是说，<code>inline</code>是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。</p><p>​    尽管大多数教科书中在函数声明和函数定义处都增加了<code>inline</code>关键字，但我认为<code>inline</code>关键字不应该出现在函数声明处。这个细节虽然不会影响函数的功能，但是体现了高质量<code>C++</code>程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。</p><p>​    <strong>更为严格地说，内联函数不应该有声明，应该将函数定义放在本应该出现函数声明的地方，这是一种良好的编程风格。</strong></p><p>​    在多文件编程中，我们通常将函数的定义放在源文件中，将函数的声明放在头文件中，希望调用函数时，引入对应的头文件即可，我们鼓励这种将函数定义和函数声明分开的做法。但这种做法不适用于内联函数，将内联函数的声明和定义分散到不同的文件中会出错，请看下面的例子。</p><p>​    <code>main.cpp</code>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内联函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>module.cpp</code>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内联函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"inline function"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上面的代码能够正常编译，但在链接时会出错。<code>func()</code>是内联函数，编译期间会用它来替换函数调用处，编译完成后函数就不存在了，链接器在将多个目标文件（<code>.o</code>或<code>.obj</code>文件）合并成一个可执行文件时找不到<code>func()</code>函数的定义，所以会产生链接错误。</p><p>​    内联函数虽然叫做函数，在定义和声明的语法上也和普通函数一样，但它已经失去了函数的本质。函数是一段可以重复使用的代码，它位于虚拟地址空间中的代码区，也占用可执行文件的体积，而内联函数的代码在编译后就被消除了，不存在于虚拟地址空间中，没法重复使用。</p><p>​    <strong>内联函数看起来简单，但是有很多细节需要注意，从代码重复利用的角度讲，内联函数已经不再是函数了。我认为将内联函数作为带参宏的替代方案更为靠谱，而不是真的当做函数使用。</strong></p><p>​    <strong>在多文件编程时，我建议将内联函数的定义直接放在头文件中，并且禁用内联函数的声明（声明是多此一举）。</strong></p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++引用</title>
      <link href="/2018/05/28/c++%E5%9F%BA%E7%A1%802-%E5%BC%95%E7%94%A8/"/>
      <url>/2018/05/28/c++%E5%9F%BA%E7%A1%802-%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="引用-reference"><a href="#引用-reference" class="headerlink" title="引用(reference)"></a>引用(<code>reference</code>)</h2><h3 id="引用基本用法"><a href="#引用基本用法" class="headerlink" title="引用基本用法"></a>引用基本用法</h3><p>​    <strong>引用是<code>c++</code>对<code>c</code>的重要扩充。</strong></p><p>​    在<code>c/c++</code>中指针的作用基本都是一样的，但是<code>c++</code>增加了另外一种给函数传递地址的途径，这就是按引用传递(<code>pass-by-reference</code>)，它也存在于其他一些编程语言中，并不是<code>c++</code>的发明。</p><ul><li><p>变量名实质上是一段连续内存空间的别名，是一个标号(门牌号)</p></li><li><p>程序中通过变量来申请并命名内存空间</p></li><li><p>通过变量的名字可以使用存储空间</p></li></ul><p>​    <strong>思考：对一段连续的内存空间只能取一个别名吗？</strong></p><p>​    <code>c++</code>中新增了引用的概念，引用可以作为一个已定义变量的别名。</p><a id="more"></a><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type&amp; ref = val;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p><strong><code>&amp;</code>在此不是求地址运算，而是起标识作用。</strong></p></li><li><p>类型标识符是指目标变量的类型</p></li><li><p><strong>必须在声明引用变量时进行初始化。</strong></p></li><li><p><strong>引用初始化之后不能改变。</strong></p></li><li><p><strong>不能有<code>NULL</code>引用。必须确保引用是和一块合法的存储单元关联。</strong></p></li><li><p><strong>可以建立对数组的引用。</strong></p></li></ul><h3 id="变量的引用"><a href="#变量的引用" class="headerlink" title="变量的引用"></a>变量的引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 认识引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//给变量a取一个别名b</span></span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b:"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//操作b就相当于操作a本身</span></span><br><span class="line">b = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b:"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//一个变量可以有n个别名</span></span><br><span class="line"><span class="keyword">int</span>&amp; c = a;</span><br><span class="line">c = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b:"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c:"</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//a,b,c的地址都是相同的</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b:"</span> &lt;&lt; &amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c:"</span> &lt;&lt; &amp;c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 使用引用注意事项</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1) 引用必须初始化</span></span><br><span class="line"><span class="comment">//int&amp; ref; //报错:必须初始化引用</span></span><br><span class="line"><span class="comment">//2) 引用一旦初始化，不能改变引用</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref = a;</span><br><span class="line">ref = b; <span class="comment">//不能改变引用</span></span><br><span class="line"><span class="comment">//3) 不能对数组建立引用</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//int&amp; ref3[10] = arr;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组的引用"><a href="#数组的引用" class="headerlink" title="数组的引用"></a>数组的引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 建立数组引用方法一</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ArrRef[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">ArrRef&amp; aRef = arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i ++)&#123;</span><br><span class="line">aRef[i] = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 建立数组引用方法二</span></span><br><span class="line"><span class="keyword">int</span>(&amp;f)[<span class="number">10</span>] = arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">f[i] = i+<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="函数中的引用"><a href="#函数中的引用" class="headerlink" title="函数中的引用"></a>函数中的引用</h3><p>​    最常见看见引用的地方是在函数参数和返回值中。<strong>当引用被用作函数参数的时，在函数内对任何引用的修改，将对还函数外的参数产生改变。</strong>当然，可以通过传递一个指针来做相同的事情，但引用具有更清晰的语法。</p><p>​    <strong>如果从函数中返回一个引用，必须像从函数中返回一个指针一样对待。当函数返回值时，引用关联的内存一定要存在。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ValueSwap</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = m;</span><br><span class="line">m = n;</span><br><span class="line">n = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PointerSwap</span><span class="params">(<span class="keyword">int</span>* m,<span class="keyword">int</span>* n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = *m;</span><br><span class="line">*m = *n;</span><br><span class="line">*n = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReferenceSwap</span><span class="params">(<span class="keyword">int</span>&amp; m,<span class="keyword">int</span>&amp; n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = m;</span><br><span class="line">m = n;</span><br><span class="line">n = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line">ValueSwap(a, b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="string">" b:"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line">PointerSwap(&amp;a, &amp;b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="string">" b:"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//引用传递</span></span><br><span class="line">ReferenceSwap(a, b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="string">" b:"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单：    </p><ul><li><p>函数调用时传递的实参不必加<code>&amp;</code>符 </p></li><li><p>在被调函数中不必在参数前加<code>*</code>符</p><p>引用作为其它变量的别名而存在，因此在一些场合可以代替指针。<code>C++</code>主张用引用传递取代地址传递的方式，因为引用语法容易且不易出错。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">TestFun01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">TestFunc02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"static int a : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//不能返回局部变量的引用</span></span><br><span class="line"><span class="keyword">int</span>&amp; ret01 = TestFun01();</span><br><span class="line"><span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">TestFunc02();</span><br><span class="line">TestFunc02() = <span class="number">100</span>;</span><br><span class="line">TestFunc02();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>不能返回局部变量的引用。</strong></p></li><li><p><strong>函数当左值，必须返回引用。</strong></p></li></ul><h3 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h3><p><strong>引用的本质在<code>c++</code>内部实现是一个指针常量.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type&amp; ref = val; <span class="comment">// Type* const ref = &amp;val;</span></span><br></pre></td></tr></table></figure><p>​    <code>c++</code>编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同，只是这个过程是编译器内部实现，用户不可见。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testFunc</span><span class="params">(<span class="keyword">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; aRef = a; <span class="comment">//自动转换为 int* const aRef = &amp;a;这也能说明引用为什么必须初始化</span></span><br><span class="line">aRef = <span class="number">20</span>; <span class="comment">//内部发现aRef是引用，自动帮我们转换为: *aRef = 20;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"aRef:"</span> &lt;&lt; aRef &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">testFunc(a);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针引用"><a href="#指针引用" class="headerlink" title="指针引用"></a>指针引用</h3><p>在<code>c</code>语言中如果想改变一个指针的指向而不是它所指向的内容，函数声明可能这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>**)</span></span>;</span><br></pre></td></tr></table></figure><p>给指针变量取一个别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type* pointer = <span class="literal">NULL</span>;  </span><br><span class="line">Type*&amp; = pointer;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//指针间接修改teacher的年龄</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AllocateAndInitByPointer</span><span class="params">(Teacher** teacher)</span></span>&#123;</span><br><span class="line">*teacher = (Teacher*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Teacher));</span><br><span class="line">(*teacher)-&gt;mAge = <span class="number">200</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//引用修改teacher年龄</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AllocateAndInitByReference</span><span class="params">(Teacher*&amp; teacher)</span></span>&#123;</span><br><span class="line">teacher-&gt;mAge = <span class="number">300</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建Teacher</span></span><br><span class="line">Teacher* teacher = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//指针间接赋值</span></span><br><span class="line">AllocateAndInitByPointer(&amp;teacher);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"AllocateAndInitByPointer:"</span> &lt;&lt; teacher-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//引用赋值,将teacher本身传到ChangeAgeByReference函数中</span></span><br><span class="line">AllocateAndInitByReference(teacher);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"AllocateAndInitByReference:"</span> &lt;&lt; teacher-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">free</span>(teacher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    对于<code>c++</code>中的定义那个，语法清晰多了。函数参数变成指针的引用，用不着取得指针的地址。</p><h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><p>​    常量引用的定义格式:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Type&amp; ref = val;</span><br></pre></td></tr></table></figure><p>​    常量引用注意：</p><ul><li><p><strong>字面量不能赋给引用，但是可以赋给<code>const</code>引用</strong></p></li><li><p><strong><code>const</code>修饰的引用，不能修改。</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; aRef = a; <span class="comment">//此时aRef就是a</span></span><br><span class="line"><span class="comment">//aRef = 200; 不能通过aRef的值</span></span><br><span class="line">a = <span class="number">100</span>; <span class="comment">//OK</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"aRef:"</span> &lt;&lt; aRef &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//不能把一个字面量赋给引用</span></span><br><span class="line"><span class="comment">//int&amp; ref = 100;</span></span><br><span class="line"><span class="comment">//但是可以把一个字面量赋给常引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = <span class="number">100</span>; <span class="comment">//int temp = 200; const int&amp; ret = temp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="const引用使用场景"><a href="#const引用使用场景" class="headerlink" title="const引用使用场景"></a><code>const</code>引用使用场景</h4><p>​    常量引用主要用在函数的形参，尤其是类的拷贝/复制构造函数。</p><p>​    将函数的形参定义为常量引用的好处:</p><ul><li><p>引用不产生新的变量，减少形参与实参传递时的开销。</p></li><li><p>由于引用可能导致实参随形参改变而改变，将其定义为常量引用可以消除这种副作用。</p></li></ul><p>​    如果希望实参随着形参的改变而改变，那么使用一般的引用，如果不希望实参随着形参改变，那么使用常引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const int&amp; param防止函数中意外修改数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowVal</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; param)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"param:"</span> &lt;&lt; param &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++const和c的异同</title>
      <link href="/2018/05/25/c++%E5%9F%BA%E7%A1%801-const%E5%92%8Cc%E7%9A%84%E5%BC%82%E5%90%8C/"/>
      <url>/2018/05/25/c++%E5%9F%BA%E7%A1%801-const%E5%92%8Cc%E7%9A%84%E5%BC%82%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<p><code>c</code>语言中，<code>const</code>修饰的变量称为伪常量，编译器会分配内存，可以通过指针修改。</p><p> <code>c++</code>中，<code>const</code>修饰的变量是真正的常量，以<code>key-value</code>键值对的方式保存，不会分配内存。</p><a id="more"></a><h3 id="C语言的const"><a href="#C语言的const" class="headerlink" title="C语言的const"></a><code>C</code>语言的<code>const</code></h3><p><strong>修饰的变量称为伪常量，不能直接修改，但可以通过指针修改。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line">    <span class="comment">//int const a = 10;</span></span><br><span class="line">    <span class="comment">//a = 11;//err</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;s;</span><br><span class="line">    <span class="comment">//*p = 10;//err 改变p所指向的内容</span></span><br><span class="line">    p = <span class="literal">NULL</span>;<span class="comment">//改变p是可以的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;s;</span><br><span class="line">    <span class="comment">//p1 = NULL;err </span></span><br><span class="line">    *p1 = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    不是指针变量的表达式，<code>const</code>放在类型的前后都没关系，但是在指针变量中，<code>const</code>的位置就有讲究了，此时要分清楚是指针变量的值是只读的还是指针所指向的内存空间是只读的。而且，C语言中，<code>const</code>是个假<code>const</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line">    <span class="comment">//int const a = 10;</span></span><br><span class="line">    <span class="comment">//a = 11;//err</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//看似不能改变a的值，其实只是不能直接更改而已，但可以间接修改</span></span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;<span class="comment">//C语言中这种类型不符合是可以被接受的，c++中不行</span></span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果显示a的值被改变。所以，在<code>C</code>语言中，<code>const</code>不是真正的常量，只是不能直接修改而已，因此，在那些必须要常量的场合，不能用<code>const</code>定义的变量。比如数组的维数，虽然在<code>C99</code>中支持了变长数组，但是很多时候我们使用的都不是<code>VLA</code>，因为<code>VLA</code>局限性比较大，不能初始化，还必须是局部变量。那么，<code>C</code>语言中的常量只有<code>define</code>和直接数字值还有就是枚举。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="keyword">enum</span> test</span><br><span class="line">&#123;</span><br><span class="line">    saturday,</span><br><span class="line">    sunday = <span class="number">0</span>,</span><br><span class="line">    monday,</span><br><span class="line">    tuesday,</span><br><span class="line">    wednesday,</span><br><span class="line">    thursday,</span><br><span class="line">    friday</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a[friday] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    枚举类型可以编译通过，因为它是真正的常量。这是在没有支持<code>C99</code>的前提下测试的。<code>define</code>自然支持就不再测试了。</p><p>​    那么，其实在很多时候，<code>C</code>语言中的代码加上了<code>const</code>修饰，也还是不安全的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> *p2 = &amp;a;</span><br><span class="line">    <span class="keyword">int</span> * p1 = p2;</span><br><span class="line">    *p1 = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上述代码还是会改变a的值，但这个例子一般我们不会这样写，不过从上面的代码中，我们可能会像下面这样写程序，因为很多时候，我们想用<code>const</code>指针修饰的形参。目的是不想实参被改变，但是如果不注意，还是达不到想要的效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p1 = p;</span><br><span class="line">    *p1 = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    test(&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    我们把形参的指针所指向的内存空间设置成const的，就是不想实参被改变，但是还是可能会被间接修改，所以，在编写代码的时候，我们不要使用上述代码的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = p;</span><br></pre></td></tr></table></figure><p>​    因为就算你形参用<code>const</code>保护了，后续忘记了用<code>const</code>去接这样的变量，还是无用的。这提醒我们注意，应该这样去写这句话：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p1 = p;</span><br><span class="line">保证接它的变量也要是<span class="keyword">const</span>的。</span><br></pre></td></tr></table></figure></p><h3 id="c-中的const"><a href="#c-中的const" class="headerlink" title="c++中的const"></a><code>c++</code>中的<code>const</code></h3><h4 id="用常量初始化const变量"><a href="#用常量初始化const变量" class="headerlink" title="用常量初始化const变量"></a>用常量初始化<code>const</code>变量</h4><p><code>c++</code>中，<code>const</code>是升级过的了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//int *p = &amp;a;c++中，不允许这样的转换，而C语言中是可以的，c++对类型检查更为严格</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)&amp;a;</span><br><span class="line">　　*p=<span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用普通变量初始化const变量"><a href="#用普通变量初始化const变量" class="headerlink" title="用普通变量初始化const变量"></a>用普通变量初始化<code>const</code>变量</h4><p>​    此时，<code>c++</code>不再允许我们对此进行更改，这证明了，<code>c++</code>中<code>const</code>修饰的变量是真正的常量，是不是<code>const</code>修饰的就如果简单了呢？那么我们再试试换个方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> a = b;<span class="comment">//会分配内存</span></span><br><span class="line">    <span class="comment">//int *p = &amp;a;c++中，不允许这样的转换，而C语言中是可以的，c++对类型检查更为严格</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)&amp;a;</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>​    可以清楚地看到，我们改变了<code>a</code>的值，这也就是说，在<code>c++</code>中，如果用一个字面值给<code>const</code>修饰的变量赋值，例如<code>int  const a=10;</code>这样的<code>a</code>就是常量，可以用来当做数组的维数。</p><p>​    如果用一个变量给<code>const</code>修饰的变量赋值，例如<code>int const  a=b;</code>这样的<code>a</code>就是只读变量，不能直接修改，但可以间接修改，和<code>c</code>中一样了。</p><p>​    另外注意，由于<code>c++</code>中严格检查类型匹配问题，所以我们要知道，在<code>const</code>修饰的指针变量中，顶层<code>const</code>在有赋值效果的操作中将被忽略。</p><p>​    以下说下<code>c</code>和<code>c++</code>中<code>const</code>定义的常量的一些区别：</p><p>​    <code>c++</code>中用<code>const</code>定义了一个常量后，不会分配一个空间给它，而是将其写入符号表<code>(symbol  table)</code>,这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。但是<code>const</code>定义的常量本质上也是一个变量，是变量就会有地址，那么什么时候会分配内存？看看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a  = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)(&amp;a);  <span class="comment">//会分配临时内存 等于 int tmp=a; int *p=(int *)(&amp;tmp);</span></span><br><span class="line">    *p = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x28ff08</span></span><br><span class="line"><span class="number">0x28ff08</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure></p><p>​    我们看到，通过<code>int *p = (int*)(&amp;a);</code>这种方法，可以直接修改<code>const</code>常量对应的内存空间中的值，但是这种修改不会影响到常量本身的值，因为用到<code>a</code>的时候，编译器根本不会去进行内存空间的读取。这就是<code>c++</code>的<strong>常量折叠（<code>constant folding</code>），即将<code>const</code>常量放在符号表中，而并不给其分配内存。</strong>编译器直接进行替换优化。除非需要用到<code>a</code>的存储空间的时候，编译器迫不得已才会分配一个空间给<code>a</code>，但之后<code>a</code>的值仍旧从符号表中读取，不管<code>a</code>的存储空间中的值如何变化，都不会对常量<code>a</code>产生影响。</p><p>​    但是在<code>c</code>中却不是这样。<code>c</code>没有<code>constant folding</code>的概念，用<code>const</code>定义一个常量的时候，编译器会直接开辟一个内存空间存放该常量。不会进行优化。同样的例子在<code>c</code>下面会产生不同的结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 2 </span>&#123;</span><br><span class="line"> <span class="number">3</span>     <span class="keyword">const</span> <span class="keyword">int</span> a  = <span class="number">2</span>;</span><br><span class="line"> <span class="number">4</span>     <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)(&amp;a);</span><br><span class="line"> <span class="number">5</span>     *p = <span class="number">30</span>;</span><br><span class="line"> <span class="number">6</span>     <span class="built_in">printf</span>(<span class="string">"%x\n"</span>,&amp;a);</span><br><span class="line"> <span class="number">7</span>     <span class="built_in">printf</span>(<span class="string">"%x\n"</span>,p);</span><br><span class="line"> <span class="number">8</span>     <span class="built_in">printf</span>(<span class="string">"%i\n"</span>,a);</span><br><span class="line"> <span class="number">9</span>     <span class="built_in">printf</span>(<span class="string">"%i\n"</span>,*p);</span><br><span class="line"><span class="number">10</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">11</span> &#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">28f</span>f18</span><br><span class="line"><span class="number">28f</span>f18</span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure></p><p>​    我们看到，在<code>c</code>里面，一个被<code>const</code>定义为常量的值，堂而皇之地被修改了，而且编译器没有报任何错误 ！</p><p>​    如果我们进一步深入可以发现，对于以上两个例子来说，<code>a</code>都是定义在某个函数之内的(比如<code>main()</code>函数)，不管是<code>c</code>还是<code>c++</code>，本质上都只是将其当成一个普通的局部变量来对待，都只是在栈上分配空间。所以<code>const</code>根本就不能起到阻止修改其内存空间的作用，一个合法的强制类型转换就可以轻松搞定。<code>c++</code>比<code>c</code>好的地方就在于使用了<code>constant  folding</code>的机制，使得常量的值跟对应的内存空间无关，从而保护了该常量值。</p><p>​    以上的例子是针对局部的<code>const</code>常量而言，对全局的<code>const</code>变量，<code>c++</code>仍旧采用<code>constant folding</code>策略，故以下代码是行得通的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//global variable</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> arr[a];</span><br></pre></td></tr></table></figure><p>​    但是c会报错： <code>error: variably modified &#39;arr&#39; at file scope,</code>  原因在于<code>gcc</code>认为<code>a</code>只是一个普通的全局变量，而变量是不能用来指定数组的长度的。当然，这是针对全局数组而言，如果是局部的数组的话，就算是<code>int a = 3; int arr[a];</code>这种都是可以的，因为<code>c</code>里面还有一种叫变长数组的东西。</p><p>​    另外，对于<code>a</code>，在<code>c</code>和<code>c++</code>中如果我们仍然用<code>int *p = (int*)(&amp;a);</code>这种方法来修改它内存中的值，编译时不会报错，但是运行时会报段错误，因为<code>a</code>是放在只读的全局数据区中，修改该区中的数据会引发段错误。</p>]]></content>
      
      
      <categories>
          
          <category> c++_language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++_language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell模块化</title>
      <link href="/2018/05/15/shell12-%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2018/05/15/shell12-%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><strong>所谓模块化，就是把代码分散到多个文件或者文件夹。对于大中型项目，模块化是必须的，否则会在一个文件中堆积成千上万行代码，这简直是一种灾难。</strong></p><a id="more"></a><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>​    基本上所有的编程语言都支持模块化，以达到代码复用的效果，比如，<code>Java</code>和<code>Python</code>中有<code>import</code>，<code>C/C++</code>中有<code>#include</code>。在<code>Shell</code>中，我们可以使用<code>source</code>命令来实现类似的效果。</p><p>​    <code>source</code>命令的用法为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source filename</span><br></pre></td></tr></table></figure><p>也可以简写为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. filename</span><br></pre></td></tr></table></figure><p>两种写法的效果相同。对于第二种写法，<strong>注意点号<code>.</code>和文件名中间有一个空格。</strong></p><p>​    <code>source</code>是<code>Shell 内置命令</code>的一种，它会读取<code>filename</code>文件中的代码，并依次执行所有语句。你也可以理解为，<code>source</code>命令会强制执行脚本文件中的全部命令，而忽略脚本文件的权限。</p><p><strong>【实例】创建两个脚本文件<code>func.sh</code>和<code>main.sh</code>：<code>func.sh</code>中包含了若干函数，<code>main.sh</code>是主文件，<code>main.sh</code>中会包含<code>func.sh</code>。</strong></p><p><code>func.sh</code>文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>计算所有参数的和</span><br><span class="line">function sum()&#123;</span><br><span class="line">    local total=0</span><br><span class="line"></span><br><span class="line">    for n in $@</span><br><span class="line">    do</span><br><span class="line">         ((total+=n))</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    echo $total</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.sh</code>文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">source func.sh</span><br><span class="line"></span><br><span class="line">echo $(sum 10 20 55 15)</span><br></pre></td></tr></table></figure><p>运行<code>main.sh</code>，输出结果为：<br><code>100</code></p><p><code>source</code>后边可以使用相对路径，也可以使用绝对路径，这里我们使用的是相对路径。</p><h3 id="避免重复引入"><a href="#避免重复引入" class="headerlink" title="避免重复引入"></a>避免重复引入</h3><p>​    熟悉<code>C/C++</code>的读者都知道，<code>C/C++</code>中的头文件可以避免被重复引入；换句话说，即使被多次引入，效果也相当于一次引入。这并不是<code>#include</code>的功劳，而是我们在头文件中进行了特殊处理。</p><p>​    <code>Shell source</code>命令和<code>C/C++</code>中的<code>#include</code>类似，都没有避免重复引入的功能，只要你使用一次<code>source</code>，它就引入一次脚本文件中的代码。</p><p>​    如果想在<code>shell</code>里避免重复引入，<strong>我们可以在模块中额外设置一个变量，使用<code>if</code>语句来检测这个变量是否存在，如果发现这个变量存在，就<code>return</code>出去。</strong></p><p>​    这里需要强调一下<code>return</code>关键字。<code>return</code>在<code>C++</code>、<code>C#</code>、<code>Java</code>等大部分编程语言中只能退出函数，除此以外再无他用；但是在<code>Shell</code>中，<code>return</code>除了可以退出函数，还能退出由<code>source</code>命令引入的脚本文件。</p><p>​    所谓退出脚本文件，就是在被<code>source</code>引入的脚本文件（子文件）中，一旦遇到<code>return</code>关键字，后面的代码都不会再执行了，而是回到父脚本文件中继续执行<code>source</code>命令后面的代码。</p><p>​    <code>return</code>只能退出由<code>source</code>命令引入的脚本文件，对其它引入脚本的方式无效。</p><p>​    下面我们通过一个实例来演示如何避免脚本文件被重复引入。本例会涉及到两个脚本文件，分别是主文件 <code>main.sh</code>和 模块文件<code>module.sh</code>。</p><p>​    模块文件<code>module.sh</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if [ -n "$__MODULE_SH__" ]; then</span><br><span class="line">    return</span><br><span class="line">fi</span><br><span class="line">__MODULE_SH__='module.sh'</span><br><span class="line"></span><br><span class="line">echo "http://c.biancheng.net/shell/"</span><br></pre></td></tr></table></figure><p>注意第一行代码，一定要是使用双引号把<code>$__MODULE_SH__</code>包围起来。</p><p> 主文件<code>main.sh</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">source module.sh</span><br><span class="line">source module.sh</span><br><span class="line"></span><br><span class="line">echo "here executed"</span><br></pre></td></tr></table></figure><p><code>./</code>表示当前文件，你也可以直接写作<code>source module.sh</code>。</p><p> 运行<code>main.sh</code>，输出结果为：<br><code>http://c.biancheng.net/shell/</code><br><code>here executed</code></p><p> 我们在<code>main.sh</code>中两次引入<code>module.sh</code>，但是只执行了一次，说明第二次引入是无效的。</p><p><code>main.sh</code>中的最后一条<code>echo</code>语句产生了输出结果，说明<code>return</code>只是退出了子文件，对父文件没有影响。</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell多命令组合</title>
      <link href="/2018/05/12/shell11-%E5%A4%9A%E5%91%BD%E4%BB%A4%E7%BB%84%E5%90%88/"/>
      <url>/2018/05/12/shell11-%E5%A4%9A%E5%91%BD%E4%BB%A4%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="组命令"><a href="#组命令" class="headerlink" title="组命令"></a>组命令</h2><p>​    <strong>所谓组命令，就是将多个命令划分为一组，或者看成一个整体。</strong></p><p>​    <code>Shell</code>组命令的写法有两种：</p><p><code>{ command1; command2; command3; ... }</code><br><code>(command1; command2; command3;... )</code></p><a id="more"></a><p>​    两种写法的区别在于：<strong>由花括号<code>{}</code>包围起来的组命名在当前 Shell 进程中执行，而由小括号<code>()</code>包围起来的组命令会创建一个子 Shell，所有命令都在子 Shell 中执行。</strong></p><p>​    对于第一种写法，<strong>花括号和命令之间必须有一个空格，并且最后一个命令必须用一个分号或者一个换行符结束。</strong></p><p>​    组命令可以将多条命令的输出结果合并在一起，在使用重定向和管道时会特别方便。</p><p>​    例如，下面的代码将多个命令的输出重定向到<code>out.txt</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -l &gt; out.txt  #&gt;表示覆盖</span><br><span class="line">echo "http://c.biancheng.net/shell/" &gt;&gt; out.txt  #&gt;&gt;表示追加</span><br><span class="line">cat readme.txt &gt;&gt; out.txt</span><br></pre></td></tr></table></figure><p>​    本段代码共使用了三次重定向。</p><p>​    借助组命令，我们可以将以上三条命令合并在一起，简化成一次重定向：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; ls -l; echo "http://c.biancheng.net/shell/"; cat readme.txt; &#125; &gt; out.txt</span><br></pre></td></tr></table></figure></p><p>​    或者写作：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ls -l; echo "http://c.biancheng.net/shell/"; cat readme.txt) &gt; out.txt</span><br></pre></td></tr></table></figure></p><p>​    使用组命令技术，我们节省了一些打字时间。</p><p>​    类似的道理，我们也可以将组命令和管道结合起来：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; ls -l; echo "http://c.biancheng.net/shell/"; cat readme.txt; &#125; | lpr</span><br></pre></td></tr></table></figure></p><p>​    这里我们把三个命令的输出结果合并在一起，并把它们用管道输送给命令<code>lpr</code>的输入，以便产生一个打印报告。</p><h3 id="两种组命令形式的对比"><a href="#两种组命令形式的对比" class="headerlink" title="两种组命令形式的对比"></a>两种组命令形式的对比</h3><p>​    虽然两种<code>Shell</code>组命令形式看起来相似，它们都能用在重定向中合并输出结果，但两者之间有一个很重要的不同：<strong>由<code>{}</code>包围的组命令在当前<code>Shell</code>进程中执行，由<code>()</code>包围的组命令会创建一个子<code>Shell</code>，所有命令都会在这个子<code>Shell</code>中执行。</strong></p><p>​    在子<code>Shell</code>中执行意味着，运行环境被复制给了一个新的<code>shell</code>进程，当这个子<code>Shell</code>退出时，新的进程也会被销毁，环境副本也会消失，所以在子<code>Shell</code>环境中的任何更改都会消失（包括给变量赋值）。因此，在大多数情况下，除非脚本要求一个子<code>Shell</code>，否则使用<code>{}</code>比使用<code>()</code>更受欢迎，并且<code>{}</code>的进行速度更快，占用的内存更少。</p><h2 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h2><p>​    进程替换和命令替换非常相似。<strong>命令替换是把一个命令的输出结果赋值给另一个变量</strong>，例如<code>dir_files</code>=`ls -l`或<code>date_time=$(date)</code>；而<strong>进程替换则是把一个命令的输出结果传递给另一个（组）命令</strong>。</p><p>​    为了说明进程替换的必要性，我们先来看一个使用管道的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo "http://c.biancheng.net/shell/" | read</span><br><span class="line">echo $REPLY</span><br></pre></td></tr></table></figure><p>​    以上代码输出结果总是为空，因为<code>echo</code>命令在父<code>Shell</code>中执行，而<code>read</code>命令在子<code>Shell</code>中执行，当<code>read</code>执行结束时，子<code>Shell</code>被销毁，<code>REPLY</code>变量也就消失了。管道中的命令总是在子<code>Shell</code>中执行的，任何给变量赋值的命令都会遭遇到这个问题。</p><blockquote><p>使用 read 读取数据时，如果没有提供变量名，那么读取到的数据将存放到环境变量 REPLY 中。</p></blockquote><p>​    <code>Shell</code>进程替换有两种写法：</p><p>​    一种用来产生标准输出，借助输入重定向，它的输出结果可以作为另一个命令的输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;(commands)</span><br></pre></td></tr></table></figure><p>​    另一种用来接受标准输入，借助输出重定向，它可以接收另一个命令的输出结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>(commands)</span><br></pre></td></tr></table></figure></p><p>commands 是一组命令列表，多个命令之间以分号<code>;</code>分隔。注意，<code>&lt;</code>或<code>&gt;</code>与圆括号之间是没有空格的。</p><p> 例如，为了解决上面遇到的问题，我们可以像下面这样使用进程替换：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read &lt; &lt;(echo "http://c.biancheng.net/shell/")</span><br><span class="line">echo $REPLY</span><br></pre></td></tr></table></figure><p>输出结果：<br><code>http://c.biancheng.net/shell/</code></p><p>​    整体上来看，<code>Shell</code>把<code>echo &quot;http://c.biancheng.net/shell/&quot;</code>的输出结果作为<code>read</code>的输入。<code>&lt;()</code>用来捕获<code>echo</code>命令的输出结果，<code>&lt;</code>用来将该结果重定向到<code>read</code>。</p><blockquote><p><strong>注意，两个<code>&lt;</code>之间是有空格的，第一个<code>&lt;</code>表示输入重定向，第二个<code>&lt;</code>和<code>()</code>连在一起表示进程替换。</strong></p></blockquote><p>​    本例中的<code>read</code>命令和第二个<code>echo</code>命令都在当前<code>Shell</code>进程中运行，读取的数据也会保存到当前进程的 <code>REPLY</code>变量，大家都在一个进程中，所以使用<code>echo</code>能够成功输出。</p><p>​    而在前面的例子中我们使用了管道，<code>echo</code>命令在父进程中运行，<code>read</code>命令在子进程中运行，读取的数据也保存在子进程的<code>REPLY</code>变量中，<code>echo</code>命令和<code>REPLY</code>变量不在一个进程中，而子进程的环境变量对父进程是不可见的，所以读取失败。</p><p>​    再来看一个进程替换用作「接受标准输入」的例子：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "C语言中文网" &gt; &gt;(read; echo "你好，$REPLY")</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><code>你好，C语言中文网</code></p><p> 因为使用了重定向，<code>read</code>命令从<code>echo &quot;C语言中文网&quot;</code>的输出结果中读取数据。</p><h3 id="进程替换的本质"><a href="#进程替换的本质" class="headerlink" title="进程替换的本质"></a>进程替换的本质</h3><p>为了能够在不同进程之间传递数据，实际上进程替换会跟系统中的文件关联起来，这个文件的名字为<code>/dev/fd/n</code>（n 是一个整数）。该文件会作为参数传递给<code>()</code>中的命令，<code>()</code>中的命令对该文件是读取还是写入取决于进程替换格式是<code>&lt;</code>还是<code>&gt;</code>：</p><ul><li>如果是<code>&gt;()</code>，那么该文件会给<code>()</code>中的命令提供输入；借助输出重定向，要输入的内容可以从其它命令而来。</li><li>如果是<code>&lt;()</code>，那么该文件会接收<code>()</code>中命令的输出结果；借助输入重定向，可以将该文件的内容作为其它命令的输入。</li></ul><p>使用<code>echo</code> 命令可以查看进程替换对应的文件名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ echo &gt;(true)</span><br><span class="line">/dev/fd/63</span><br><span class="line">[c.biancheng.net]$ echo &lt;(true)</span><br><span class="line">/dev/fd/63</span><br><span class="line">[c.biancheng.net]$ echo &gt;(true) &lt;(true)</span><br><span class="line">/dev/fd/63 /dev/fd/62</span><br></pre></td></tr></table></figure><p>​    <code>/dev/fd/</code>目录下有很多序号文件，进程替换一般用的是<code>63</code>号文件，该文件是系统内部文件，我们一般查看不到。</p><p>​    我们通过下面的语句进行实例分析：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "shellscript" &gt; &gt;(read; echo "hello, $REPLY")</span><br></pre></td></tr></table></figure></p><p>​    第一个<code>&gt;</code>表示输出重定向，它把第一个<code>echo</code>命令的输出结果重定向到<code>/dev/fd/63</code>文件中。</p><p>​    <code>&gt;()</code>中的第一个命令是<code>read</code>，它需要从标准输入中读取数据，此时就用<code>/dev/fd/63</code>作为输入文件，把该文件的内容交给<code></code> read <code>命令，接着使用</code> echo <code>命令输出</code> read `读取到的内容。</p><p>​    可以看到，<code>/dev/fd/63</code>文件起到了数据中转或者数据桥梁的作用，借助重定向，它将<code>&gt;()</code>内部的命令和外部的命令联系起来，使得数据能够在这些命令之间流通。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>​    <code>Shell</code>可以将两个或者多个命令（程序或者进程）连接到一起，把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了<strong>管道（pipe）</strong>。</p><p>​    <strong><code>Linux</code>管道使用竖线<code>|</code>连接多个命令，这被称为管道符。</strong><code>Linux</code>管道的具体语法格式如下：</p><p><code>command1 | command2</code><br><code>command1 | command2 [ | commandN... ]</code></p><p>​    当在两个命令之间设置管道时，管道符<code>|</code>左边命令的输出就变成了右边命令的输入。只要第一个命令向标准输出写入，而第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道。大部分的<code>Linux</code>命令都可以用来形成管道。</p><blockquote><p>这里需要注意，<code>command1</code>必须有正确输出，而 <code>command2</code>必须可以处理<code>command2</code>的输出结果；而且 <code>command2</code>只能处理<code>command1</code>的正确输出结果，不能处理<code>command1</code> 的错误信息。</p></blockquote><h3 id="为何使用管道"><a href="#为何使用管道" class="headerlink" title="为何使用管道"></a>为何使用管道</h3><p>我们先看下面一组命令，使用<code>mysqldump</code>（一个数据库备份程序）来备份一个叫做<code>wiki</code>的数据库：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p '123456' wiki &gt; /tmp/wikidb.backup</span><br><span class="line">gzip -9 /tmp/wikidb.backup</span><br><span class="line">scp /tmp/wikidb.backup username@remote_ip:/backup/mysql/</span><br></pre></td></tr></table></figure></p><p>上述这组命令主要做了如下任务：</p><ul><li><code>mysqldump</code>命令用于将名为<code>wike</code>的数据库备份到文件<code>/tmp/wikidb.backup</code>；其中<code>-u</code>和<code>-p</code>选项分别指出数据库的用户名和密码。</li><li><code>gzip</code>命令用于压缩较大的数据库文件以节省磁盘空间；其中<code>-9</code>表示最慢的压缩速度最好的压缩效果。</li><li><code>scp</code>命令（<code>secure copy</code>，安全拷贝）用于将数据库备份文件复制到<code>IP</code>地址为<code>remote_ip</code>的备份服务器的<code>/backup/mysql/</code>目录下。其中<code>username</code>是登录远程服务器的用户名，命令执行后需要输入密码。</li></ul><p>上述三个命令依次执行。然而，如果使用管道的话，你就可以将<code>mysqldump</code>、<code>gzip</code>、<code>ssh</code>命令相连接，这样就避免了创建临时文件<code>/tmp/wikidb.backup</code>，而且可以同时执行这些命令并达到相同的效果。</p><p> 使用管道后的命令如下所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p '123456' wiki | gzip -9 | ssh username@remote_ip "cat &gt; /backup/wikidb.gz"</span><br></pre></td></tr></table></figure></p><p>这些使用了管道的命令有如下特点：</p><ul><li>命令的语法紧凑并且使用简单。</li><li>通过使用管道，将三个命令串联到一起就完成了远程<code>mysql</code>备份的复杂任务。</li><li>从管道输出的标准错误会混合到一起。</li></ul><p> 上述命令的数据流如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1Z4161052294c.gif" alt></p><h3 id="重定向和管道的区别"><a href="#重定向和管道的区别" class="headerlink" title="重定向和管道的区别"></a>重定向和管道的区别</h3><p>​    管道改变了数据输入输出的方向，也有重定向的作用。那么，管道和重定向之间到底有什么不同呢？</p><p>​    简单地说，重定向操作符<code>&gt;</code>将命令与文件连接起来，用文件来接收命令的输出；</p><p>​    而管道符|将命令与命令连接起来，用第二个命令来接收第一个命令的输出。如下所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command &gt; file</span><br><span class="line">command1 | command1</span><br></pre></td></tr></table></figure></p><p>有些读者在学习管道时会尝试如下的命令，我们来看一下会发生什么：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &gt; command2</span><br></pre></td></tr></table></figure></p><p>答案是，有时尝试的结果将会很糟糕。这是一个实际的例子，一个<code>Linux</code>系统管理员以超级用户（<code>root</code>用户）的身份执行了如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/bin</span><br><span class="line">ls &gt; less</span><br></pre></td></tr></table></figure><p>第一条命令将当前目录切换到了大多数程序所存放的目录，第二条命令是告诉<code>Shell</code>用<code>ls</code>命令的输出重写文件<code>less</code>。因为<code>/usr/bin</code>目录已经包含了名称为<code>less</code>（<code>less</code>程序）的文件，第二条命令用<code>ls</code>输出的文本重写了<code>less</code>程序，因此破坏了文件系统中的<code>less</code>程序。</p><p> 这是使用重定向操作符错误重写文件的一个教训，所以在使用它时要谨慎。</p><h3 id="管道实例"><a href="#管道实例" class="headerlink" title="管道实例"></a>管道实例</h3><p><strong>【实例1】将<code>ls</code>命令的输出发送到<code>grep</code>命令</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ls | grep log.txt</span><br><span class="line">log.txt</span><br></pre></td></tr></table></figure><p>上述命令是查看文件<code>log.txt</code>是否存在于当前目录下。</p><p> 我们可以在命令的后面使用选项，例如使用<code>-al</code>选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ls -al | grep log.txt</span><br><span class="line">-rw-rw-r--.  1 mozhiyan mozhiyan    0 4月  15 17:26 log.txt</span><br></pre></td></tr></table></figure><p>管道符<code>|</code>与两侧的命令之间也可以不存在空格，例如将上述命令写作<code>ls -al|grep log.txt</code>；然而我还是推荐在管道符<code>|</code>和两侧的命令之间使用空格，以增加代码的可读性。</p><p> 我们也可以重定向管道的输出到一个文件，比如将上述管道命令的输出结果发送到文件<code>output.txt</code>中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ls -al | grep log.txt &gt;output.txt</span><br><span class="line">[c.biancheng.net]$ cat output.txt</span><br><span class="line">-rw-rw-r--.  1 mozhiyan mozhiyan    0 4月  15 17:26 log.txt</span><br></pre></td></tr></table></figure><p><strong>【实例2】使用管道将<code>cat</code>命令的输出作为<code>less</code>命令的输入</strong>，这样就可以将<code>cat</code>命令的输出每次按照一个屏幕的长度显示，这对于查看长度大于一个屏幕的文件内容很有帮助。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/message | less</span><br></pre></td></tr></table></figure><p><strong>【实例3】查看指定程序的进程运行状态，并将输出重定向到文件中。</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ps aux | grep httpd &gt; /tmp/ps.output</span><br><span class="line">[c.biancheng.net]$ cat /tem/ps.output</span><br><span class="line">mozhiyan  <span class="number">4101</span>     <span class="number">13776</span>  <span class="number">0</span>   <span class="number">10</span>:<span class="number">11</span> pts/<span class="number">3</span>  <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> grep httpd</span><br><span class="line">root      <span class="number">4578</span>     <span class="number">1</span>      <span class="number">0</span>   Dec09 ?      <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /usr/sbin/httpd</span><br><span class="line">apache    <span class="number">19984</span>    <span class="number">4578</span>   <span class="number">0</span>   Dec29 ?      <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /usr/sbin/httpd</span><br><span class="line">apache    <span class="number">19985</span>    <span class="number">4578</span>   <span class="number">0</span>   Dec29 ?      <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /usr/sbin/httpd</span><br><span class="line">apache    <span class="number">19986</span>    <span class="number">4578</span>   <span class="number">0</span>   Dec29 ?      <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /usr/sbin/httpd</span><br><span class="line">apache    <span class="number">19987</span>    <span class="number">4578</span>   <span class="number">0</span>   Dec29 ?      <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /usr/sbin/httpd</span><br><span class="line">apache    <span class="number">19988</span>    <span class="number">4578</span>   <span class="number">0</span>   Dec29 ?      <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /usr/sbin/httpd</span><br><span class="line">apache    <span class="number">19989</span>    <span class="number">4578</span>   <span class="number">0</span>   Dec29 ?      <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /usr/sbin/httpd</span><br><span class="line">apache    <span class="number">19990</span>    <span class="number">4578</span>   <span class="number">0</span>   Dec29 ?      <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /usr/sbin/httpd</span><br><span class="line">apache    <span class="number">19991</span>    <span class="number">4578</span>   <span class="number">0</span>   Dec29 ?      <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /usr/sbin/httpd</span><br></pre></td></tr></table></figure><p><strong>【实例4】显示按用户名排序后的当前登录系统的用户的信息。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ who | sort</span><br><span class="line">mozhiyan :0           2019-04-16 12:55 (:0)</span><br><span class="line">mozhiyan pts/0        2019-04-16 13:16 (:0)</span><br></pre></td></tr></table></figure><p>​    <code>who</code>命令的输出将作为<code>sort</code>命令的输入，所以这两个命令通过管道连接后会显示按照用户名排序的已登录用户的信息。</p><p><strong>【实例5】统计系统中当前登录的用户数。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ who | wc -l</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="管道与输入重定向"><a href="#管道与输入重定向" class="headerlink" title="管道与输入重定向"></a>管道与输入重定向</h3><p><strong>输入重定向操作符<code>&lt;</code>可以在管道中使用，以用来从文件中获取输入</strong>，其语法类似下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 &lt; input.txt | command2</span><br><span class="line">command1 &lt; input.txt | command2 -option | command3</span><br></pre></td></tr></table></figure><p> 例如，使用 tr 命令从<code>os.txt</code>文件中获取输入，然后通过管道将输出发送给<code>sort</code>或<code>uniq</code>等命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ cat os.txt</span><br><span class="line">redhat</span><br><span class="line">suse</span><br><span class="line">centos</span><br><span class="line">ubuntu</span><br><span class="line">solaris</span><br><span class="line">hp-ux</span><br><span class="line">fedora</span><br><span class="line">centos</span><br><span class="line">redhat</span><br><span class="line">hp-ux</span><br><span class="line">[c.biancheng.net]$ tr a-z A-Z &lt;os.txt | sort</span><br><span class="line">CENTOS</span><br><span class="line">CENTOS</span><br><span class="line">FEDORA</span><br><span class="line">HP-UX</span><br><span class="line">HP-UX</span><br><span class="line">REDHAT</span><br><span class="line">REDHAT</span><br><span class="line">SOLARIS</span><br><span class="line">SUSE</span><br><span class="line">UBUNTU</span><br><span class="line">[c.biancheng.net]$ tr a-z A-Z &lt;os.txt | sort | uniq</span><br><span class="line">CENTOS</span><br><span class="line">FEDORA</span><br><span class="line">HP-UX</span><br><span class="line">REDHAT</span><br><span class="line">SOLARIS</span><br><span class="line">SUSE</span><br><span class="line">UBUNTU</span><br></pre></td></tr></table></figure><h3 id="管道与输出重定向"><a href="#管道与输出重定向" class="headerlink" title="管道与输出重定向"></a>管道与输出重定向</h3><p><strong>你也可以使用重定向操作符<code>&gt;</code>或<code>&gt;&gt;</code>将管道中的最后一个命令的标准输出进行重定向</strong>，其语法如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2 | ... | commandN &gt; output.txt</span><br><span class="line">command1 &lt; input.txt | command2 | ... | commandN &gt; output.txt</span><br></pre></td></tr></table></figure><p><strong>【实例1】使用<code>mount</code>命令显示当前挂载的文件系统的信息，并使用<code>column</code>命令格式化列的输出，最后将输出结果保存到一个文件中。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ mount | column -t &gt;mounted.txt</span><br><span class="line">[c.biancheng.net]$ cat mounted.txt</span><br><span class="line">proc         on  /proc                  type  proc        (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">sysfs        on  /sys                   type  sysfs       (rw,nosuid,nodev,noexec,relatime,seclabel)</span><br><span class="line">devtmpfs     on  /dev                   type  devtmpfs    (rw,nosuid,seclabel,size=496136k,nr_inodes=124034,mode=755)</span><br><span class="line">securityfs   on  /sys/kernel/security   type  securityfs  (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">tmpfs        on  /dev/shm               type  tmpfs       (rw,nosuid,nodev,seclabel)</span><br><span class="line">devpts       on  /dev/pts               type  devpts      (rw,nosuid,noexec,relatime,seclabel,gid=5,mode=620,ptmxmode=000)</span><br><span class="line">tmpfs        on  /run                   type  tmpfs       (rw,nosuid,nodev,seclabel,mode=755)</span><br><span class="line">tmpfs        on  /sys/fs/cgroup         type  tmpfs       (rw,nosuid,nodev,noexec,seclabel,mode=755)</span><br><span class="line"><span class="meta">#</span>####此处省略部分内容#####</span><br></pre></td></tr></table></figure><p><strong>【实例2】使用<code>tr</code>命令将<code>os.txt</code>文件中的内容转化为大写，并使用<code>sort</code>命令将内容排序，使用<code>uniq</code>命令去除重复的行，最后将输出重定向到文件<code>ox.txt.new</code>。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ cat os.txt</span><br><span class="line">redhat</span><br><span class="line">suse</span><br><span class="line">centos</span><br><span class="line">ubuntu</span><br><span class="line">solaris</span><br><span class="line">hp-ux</span><br><span class="line">fedora</span><br><span class="line">centos</span><br><span class="line">redhat</span><br><span class="line">hp-ux</span><br><span class="line">[c.biancheng.net]$ tr a-z A-Z &lt;os.txt | sort | uniq &gt;os.txt.new</span><br><span class="line">[c.biancheng.net]$ cat os.txt.new</span><br><span class="line">CENTOS</span><br><span class="line">FEDORA</span><br><span class="line">HP-UX</span><br><span class="line">REDHAT</span><br><span class="line">SOLARIS</span><br><span class="line">SUSE</span><br><span class="line">UBUNTU</span><br></pre></td></tr></table></figure><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>​    我们己经知道，将几个命令通过管道符组合在一起就形成一个管道。通常，通过这种方式使用的命令就被称为过滤器。过滤器会获取输入，通过某种方式修改其内容，然后将其输出。</p><p>​    简单地说，过滤器可以概括为以下两点：</p><ul><li>如果一个<code>Linux</code>命令是从标准输入接收它的输入数据，并在标准输出上产生它的输出数据（结果），那么这个命令就被称为过滤器。</li><li>过滤器通常与<code>Linux</code>管道一起使用。</li></ul><p>常用的被作为过滤器使用的命令如下所示：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>awk</code></td><td>用于文本处理的解释性程序设计语言，通常被作为数据提取和报告的工具。</td></tr><tr><td><code>cut</code></td><td>用于将每个输入文件（如果没有指定文件则为标准输入）的每行的指定部分输出到标准输出。</td></tr><tr><td><code>grep</code></td><td>用于搜索一个或多个文件中匹配指定模式的行。</td></tr><tr><td><code>tar</code></td><td>用于归档文件的应用程序。</td></tr><tr><td><code>head</code></td><td>用于读取文件的开头部分（默认是<code>10</code>行）。如果没有指定文件，则从标准输入读取。</td></tr><tr><td><code>paste</code></td><td>用于合并文件的行。</td></tr><tr><td><code>sed</code></td><td>用于过滤和转换文本的流编辑器。</td></tr><tr><td><code>sort</code></td><td>用于对文本文件的行进行排序。</td></tr><tr><td><code>split</code></td><td>用于将文件分割成块。</td></tr><tr><td><code>strings</code></td><td>用于打印文件中可打印的字符串。</td></tr><tr><td><code>tac</code></td><td>与 cat 命令的功能相反，用于倒序地显示文件或连接文件。</td></tr><tr><td><code>tail</code></td><td>用于显示文件的结尾部分。</td></tr><tr><td><code>tee</code></td><td>用于从标准输入读取内容并写入到标准输出和文件。</td></tr><tr><td><code>tr</code></td><td>用于转换或删除字符。</td></tr><tr><td><code>uniq</code></td><td>用于报告或忽略重复的行。</td></tr><tr><td><code>wc</code></td><td>用于打印文件中的总行数、单词数或字节数。</td></tr></tbody></table><p> 接下来，我们通过几个实例来演示一下过滤器的使用。</p><h3 id="在管道中使用awk命令"><a href="#在管道中使用awk命令" class="headerlink" title="在管道中使用awk命令"></a>在管道中使用<code>awk</code>命令</h3><p>​    我们通过几个简单的实例来了解一下<code>awk</code>命令在管道中的使用。</p><p><strong>【实例1】查看系统中的所有的账号名称，并按名称的字母顺序排序。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ awk -F: '&#123;print $1&#125;' /etc/passwd | sort</span><br><span class="line">adm</span><br><span class="line">apache</span><br><span class="line">avahi</span><br><span class="line">avahi-autoipd</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line">dbus</span><br><span class="line">ftp</span><br><span class="line">games</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>​    在上例中，使用冒号<code>:</code>作为列分隔符，将文件<code>/etc/passwd</code>的内容分为了多列，并打印了第一列的信息（即用户名），然后将输出通过管道发送到了<code>sort</code>命令。</p><p><strong>【实例2】列出当前账号最常使用的<code>10</code>个命令。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ history | awk '&#123;print $2&#125;' | sort | uniq -c | sort -rn | head</span><br><span class="line">140 echo</span><br><span class="line"> 75 man</span><br><span class="line"> 71 cat</span><br><span class="line"> 63 su</span><br><span class="line"> 53 ls</span><br><span class="line"> 50 vi</span><br><span class="line"> 47 cd</span><br><span class="line"> 40 date</span><br><span class="line"> 26 let</span><br><span class="line"> 25 paste</span><br></pre></td></tr></table></figure><p>​    在上例中，<code>history</code>命令将输出通过管道发送到<code>awk</code>命令，<code>awk</code>命令默认使用空格作为列分隔符，将<code>history</code>的输出分为了两列，并把第二列内容作为输出通过管道发送到了<code>sort</code>命令，使用<code>sort</code>命令进行排序后，再将输出通过管道发送到了<code>uniq</code>命令，使用<code>uniq</code>命令统计了历史命令重复出现的次数，再用<code>sort</code>命令将<code>uniq</code>命令的输出按照重复次数从高到低排序，最后使用<code>head</code>命令默认列出前<code>10</code>个的信息。</p><p><strong>【实例3】显示当前系统的总内存大小，单位为<code>KB</code>。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ free | grep Mem | awk '&#123;print $2&#125;'</span><br><span class="line">2029860</span><br></pre></td></tr></table></figure><h3 id="在管道中使用cut命令"><a href="#在管道中使用cut命令" class="headerlink" title="在管道中使用cut命令"></a>在管道中使用<code>cut</code>命令</h3><p>​    <code>cut</code>命令被用于文本处理。你可以使用这个命令来提取文件中指定列的内容。</p><p><strong>【实例1】查看系统中登录<code>Shell</code>是<code>“/bin/bash”</code>的用户名和对应的用户主目录的信息：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ grep "bin/bash" /etc/passwd | cut -d: -f1,6</span><br><span class="line">root:/root</span><br><span class="line">mozhiyan:/home/mozhiyan</span><br></pre></td></tr></table></figure><p>​    如果你对<code>Linux</code>系统有所了解，你会知道，<code>/ctc/passwd</code>文件被用来存放用户账号的信息，此文件中的每一行会记录一个账号的信息，每个字段之间用冒号分隔，第一个字段即是账号的账户名，而第六个字段就是账号的主目录的路径。</p><p><strong>【实例2】查看当前机器的<code>CPU</code>类型。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ cat /proc/cpuinfo | grep name | cut -d: -f2 | uniq</span><br><span class="line">Intel(R) Core(TM) i5-2520M CPU @ 2.50GHz</span><br></pre></td></tr></table></figure><p>​    上例中，执行命令<code>cat /proc/cpuinfo | grep name</code>得到的内容如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ cat /proc/cpuinfo | grep name</span><br><span class="line">model name    : Intel(R) Core(TM) i5-2520M CPU @ 2.50GHz</span><br><span class="line">model name    : Intel(R) Core(TM) i5-2520M CPU @ 2.50GHz</span><br><span class="line">model name    : Intel(R) Core(TM) i5-2520M CPU @ 2.50GHz</span><br><span class="line">model name    : Intel(R) Core(TM) i5-2520M CPU 0 2.50GHz</span><br></pre></td></tr></table></figure><p>​    然后，我们使用<code>cut</code>命令将上述输出内容以冒号作为分隔符，将内容分为了两列， 并显示第二列的内容，最后使用<code>uniq</code>命令去掉了重复的行。</p><p><strong>【实例3】查看当前目录下的子目录数。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ls -l | cut -c 1 | grep d | wc -l</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>上述管道命令主要做了如下操作：</p><ul><li>命令<code>ls -l</code>输出的内容中，每行的第一个字符表示文件的类型，如果第一个字符是<code>d</code>，就表示文件的类型是目录。</li><li>命令<code>cut -c 1</code>是截取每行的第一个字符。</li><li>命令<code>grep d</code>来获取文件类型是目录的行。</li><li>命令<code>wc -l</code>用来获得<code>grep</code>命令输出结果的行数，即目录个数。</li></ul><h3 id="在管道中使用grep命令"><a href="#在管道中使用grep命令" class="headerlink" title="在管道中使用grep命令"></a>在管道中使用<code>grep</code>命令</h3><p>​    <code>grep</code>命令是在管道中比较常用的一个命令。</p><p><strong>【实例1】查看系统日志文件中的错误信息。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ grep -i "error:" /var/log/messages | less</span><br></pre></td></tr></table></figure><p><strong>【实例2】查看系统中<code>HTTP</code>服务的进程信息。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ps auxwww | grep httpd</span><br><span class="line">apache 18968 0.0 0.0 26472 10404 ?    S    Dec15    0:01 /usr/sbin/httpd</span><br><span class="line">apache 18969 0.0 0.0 25528  8308 ?    S    Dec15    0:01 /usr/sbin/httpd</span><br><span class="line">apache 18970 0.0 0.0 26596 10524 ?    S    Dec15    0:01 /usr/sbin/httpd</span><br></pre></td></tr></table></figure><p><strong>【实例3】查找我们的程序列表中所有命令名中包含关键字<code>zip</code>的命令。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ls /bin /usr/bin | sort | uniq | grep zip</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line">bzip2recover</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br></pre></td></tr></table></figure><p><strong>【实例4】查看系统安装的<code>kernel</code>版本及相关的<code>kernel</code>软件包。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ rpm -qa | grep kernel</span><br><span class="line">kernel-2.6.18-92.e15</span><br><span class="line">kernel-debuginfo-2.6.18-92.e15</span><br><span class="line">kernel-debuginfo-common-2.6.18-92.e15</span><br><span class="line">kernel-devel-2.6.18-92.e15</span><br></pre></td></tr></table></figure><p><strong>【实例5】查找<code>/etc</code>目录下所有包含<code>IP</code>地址的文件。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ find /etc -type f -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' &#123;&#125; \;</span><br></pre></td></tr></table></figure><h3 id="在管道中使用tar命令"><a href="#在管道中使用tar命令" class="headerlink" title="在管道中使用tar命令"></a>在管道中使用<code>tar</code>命令</h3><p>​    <code>tar</code>命令是<code>Linux</code>系统中最常用的打包文件的程序。</p><p><strong>【实例1】你可以使用<code>tar</code>命令复制一个目录的整体结构。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ tar cf - /home/mozhiyan | ( cd /backup/; tar xf - )</span><br></pre></td></tr></table></figure><p><strong>【实例2】跨网络地复制一个目录的整体结构。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ tar cf - /home/mozhiyan | ssh remote_host "( cd /backup/; tar xf - )"</span><br></pre></td></tr></table></figure><p><strong>【实例3】跨网络地压缩复制一个目录的整体结构。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ tar czf - /home/mozhiyan | ssh remote_host "( cd /backup/; tar xzf - )"</span><br></pre></td></tr></table></figure><p><strong>【实例4】检査<code>tar</code>归档文件的大小，单位为字节。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ cd /; tar cf - etc | wc -c</span><br><span class="line">215040</span><br></pre></td></tr></table></figure><p><strong>【实例5】检查<code>tar</code>归档文件压缩为<code>tar.gz</code>归裆文件后所占的大小。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ tar czf - etc.tar | wc -c</span><br><span class="line">58006</span><br></pre></td></tr></table></figure><p><strong>【实例6】检查<code>tar</code>归档文件压缩为<code>tar.bz2</code>归裆文件后所占的大小。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ tar cjf - etc.tar | wc -c</span><br><span class="line">50708</span><br></pre></td></tr></table></figure><h3 id="在管道中使用head命令"><a href="#在管道中使用head命令" class="headerlink" title="在管道中使用head命令"></a>在管道中使用<code>head</code>命令</h3><p>​    有时，你不需要一个命令的全部输出，可能只需要命令的前几行输出。这时，就可以使用<code>head</code>命令，它只打印命令的前几行输出。默认的输出行数为<code>10</code>行。</p><p><strong>【实例1】显示<code>ls</code>命令的前<code>10</code>行输出。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ls /usr/bin | head</span><br><span class="line">addftinfo</span><br><span class="line">afmtodit</span><br><span class="line">apropos</span><br><span class="line">arch</span><br><span class="line">ash</span><br><span class="line">awk</span><br><span class="line">base64</span><br><span class="line">basename</span><br><span class="line">bash</span><br><span class="line">bashbug</span><br></pre></td></tr></table></figure><p><strong>【实例2】显示<code>ls</code>命令的前<code>5</code>行内容。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ls / | head -n 5</span><br><span class="line">bin</span><br><span class="line">cygdrive</span><br><span class="line">Cygwin.bat</span><br><span class="line">Cygwin.ico</span><br><span class="line">Cygwin-Terminal.ico</span><br></pre></td></tr></table></figure><h3 id="在管道中使用uniq命令"><a href="#在管道中使用uniq命令" class="headerlink" title="在管道中使用uniq命令"></a>在管道中使用<code>uniq</code>命令</h3><p>​    <code>uniq</code>命令用于报告或删除重复的行。我们将使用一个测试文件进行管道中使用 <code>uniq</code>命令的实例讲解，其内容如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ cat testfile</span><br><span class="line">This line occurs only once.</span><br><span class="line">This line occurs twice.</span><br><span class="line">This line occurs twice.</span><br><span class="line">This line occurs three times.</span><br><span class="line">This line occurs three times.</span><br><span class="line">This line occurs three times.</span><br></pre></td></tr></table></figure><p><strong>【实例1】去掉输出中重复的行。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ sort testfile | uniq</span><br><span class="line">This line occurs only once.</span><br><span class="line">This line occurs three times.</span><br><span class="line">This line occurs twice.</span><br></pre></td></tr></table></figure><p><strong>【实例2】显示输出中各重复的行出现的次数，并按次数多少倒序显示。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ sort testfile | uniq -c | sort -nr</span><br><span class="line">3 This line occurs three times.</span><br><span class="line">2 This line occurs twice.</span><br><span class="line">1 This line occurs only once.</span><br></pre></td></tr></table></figure><h3 id="在管道中使用wc命令"><a href="#在管道中使用wc命令" class="headerlink" title="在管道中使用wc命令"></a>在管道中使用<code>wc</code>命令</h3><p>​    <code>wc</code>命令用于统计包含在文本流中的字符数、单同数和行数。</p><p><strong>【实例1】统计当前登录到系统的用户数。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ who | wc -l</span><br></pre></td></tr></table></figure><p><strong>【实例2】统计当前的<code>Linux</code>系统中的进程数。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ps -ef | wc -l</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell重定向</title>
      <link href="/2018/05/11/shell10-%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>/2018/05/11/shell10-%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>​    <code>Linux Shell</code>重定向分为两种，一种输入重定向，一种是输出重定向；从字面上理解，输入输出重定向就是「改变输入与输出的方向」的意思。</p><p>其实输入输出方向就是数据的流动方向：</p><ul><li>输入方向就是数据从哪里流向程序。数据默认从键盘流向程序，如果改变了它的方向，数据就从其它地方流入，这就是输入重定向。</li><li>输出方向就是数据从程序流向哪里。数据默认从程序流向显示器，如果改变了它的方向，数据就流向其它地方，这就是输出重定向。</li></ul><a id="more"></a><h3 id="硬件设备和文件描述符"><a href="#硬件设备和文件描述符" class="headerlink" title="硬件设备和文件描述符"></a>硬件设备和文件描述符</h3><p>​    计算机的硬件设备有很多，常见的输入设备有键盘、鼠标、麦克风、手写板等，输出设备有显示器、投影仪、打印机等。<strong>不过，在<code>Linux</code>中，标准输入设备指的是键盘，标准输出设备指的是显示器。</strong></p><p>​    <code>Linux</code>中一切皆文件，包括标准输入设备（键盘）和标准输出设备（显示器）在内的所有计算机硬件都是文件。</p><p> 为了表示和区分已经打开的文件，<code>Linux</code>会给每个文件分配一个<code>ID</code>，这个<code>ID</code>就是一个整数，被称为文件描述符（<code>File Descriptor</code>）。</p><table><thead><tr><th>文件描述符</th><th>文件名</th><th>类型</th><th>硬件</th></tr></thead><tbody><tr><td><code>0</code></td><td><code>stdin</code></td><td>标准输入文件</td><td>键盘</td></tr><tr><td><code>1</code></td><td><code>stdout</code></td><td>标准输出文件</td><td>显示器</td></tr><tr><td><code>2</code></td><td><code>stderr</code></td><td>标准错误输出文件</td><td>显示器</td></tr></tbody></table><p>​    <code>Linux</code>程序在执行任何形式的<code>I/O</code>操作时，都是在读取或者写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、<code>FIFO</code>、管道、终端、键盘、显示器，甚至是一个网络连接。</p><p>​    <code>stdin</code>、<code>stdout</code>、<code>stderr</code>默认都是打开的，在重定向的过程中，<code>0</code>、<code>1</code>、<code>2</code>这三个文件描述符可以直接使用。</p><h3 id="Shell输出重定向"><a href="#Shell输出重定向" class="headerlink" title="Shell输出重定向"></a><code>Shell</code>输出重定向</h3><p>​    输出重定向是指命令的结果不再输出到显示器上，而是输出到其它地方，一般是文件中。这样做的最大好处就是把命令的结果保存起来，当我们需要的时候可以随时查询。<code>Bash</code>支持的输出重定向符号如下表所示。</p><table><thead><tr><th>类 型</th><th>符 号</th><th>作 用</th></tr></thead><tbody><tr><td>标准输出重定向</td><td><code>command &gt;file</code></td><td>以覆盖的方式，把<code>command</code>的正确输出结果输出到<code>file</code>文件中。</td></tr><tr><td></td><td><code>command &gt;&gt;file</code></td><td>以追加的方式，把<code>command</code>的正确输出结果输出到<code>file</code>文件中。</td></tr><tr><td>标准错误输出重定向</td><td><code>command 2&gt;file</code></td><td>以覆盖的方式，把<code>command</code>的错误信息输出到<code>file</code>文件中。</td></tr><tr><td></td><td><code>command 2&gt;&gt;file</code></td><td>以追加的方式，把<code>command</code>的错误信息输出到<code>file</code>文件中。</td></tr><tr><td>正确输出和错误信息同时保存</td><td><code>command &gt;file 2&gt;&amp;1</code></td><td>以覆盖的方式，把正确输出和错误信息同时保存到同一个文件（<code>file</code>）中。</td></tr><tr><td></td><td><code>command &gt;&gt;file 2&gt;&amp;1</code></td><td>以追加的方式，把正确输出和错误信息同时保存到同一个文件（<code>file</code>）中。</td></tr><tr><td></td><td><code>command &gt;file1 2&gt;file2</code></td><td>以覆盖的方式，把正确的输出结果输出到<code>file1</code>文件中，把错误信息输出到<code>file2</code>文件中。</td></tr><tr><td></td><td><code>command &gt;&gt;file1 2&gt;&gt;file2</code></td><td>以追加的方式，把正确的输出结果输出到<code>file1</code>文件中，把错误信息输出到<code>file2</code>文件中。</td></tr><tr><td></td><td><code>command &gt;file 2&gt;file</code></td><td>【<strong>不推荐</strong>】这两种写法会导致<code>file</code>被打开两次，引起资源竞争，所以<code>stdout</code>和<code>stderr</code>会互相覆盖。</td></tr><tr><td></td><td><code>command &gt;&gt;file 2&gt;&gt;file</code></td><td>【<strong>不推荐</strong>】这两种写法会导致 <code>file</code>被打开两次，引起资源竞争，所以<code>stdout</code>和<code>stderr</code>会互相覆盖。</td></tr></tbody></table><blockquote><p><strong>在输出重定向中，<code>&gt;</code>代表的是覆盖，<code>&gt;&gt;</code>代表的是追加。</strong></p></blockquote><p><strong>注意</strong></p><blockquote><p>输出重定向的完整写法其实是<code>fd&gt;file</code>或者<code>fd&gt;&gt;file</code>，其中<code>fd</code>表示文件描述符，如果不写，默认为<code>1</code>，也就是标准输出文件。</p></blockquote><p>​    <strong>当是输出重定向时，文件描述符为<code>1</code>，一般都省略不写，<code>command &gt;file</code>等同于<code>command 1&gt;file</code>。当文件描述符为大于 1 的值时，比如 2，就必须写上。</strong></p><p>​    需要重点说明的是，<strong><code>fd</code>和<code>&gt;</code>之间不能有空格，否则 Shell 会解析失败；<code>&gt;</code>和<code>file</code>之间的空格可有可无。</strong>为了保持一致，我习惯在<code>&gt;</code>两边都不加空格。</p><p>​    下面的语句是一个反面教材：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "c.biancheng.net" 1 &gt;log.txt</span><br></pre></td></tr></table></figure><p>注意<code>1</code>和<code>&gt;</code>之间的空格。<code>echo</code>命令的输出结果是<code>c.biancheng.net</code>，我们的初衷是将输出结果重定向到 <code>log.txt</code>，但是当你打开<code>log.txt</code>文件后，发现文件的内容为<code>c.biancheng.net 1</code>，这就是多余的空格导致的解析错误。也就是说，<code>Shell</code>将该条语句理解成了下面的形式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "c.biancheng.net" 1 1&gt;log.txt</span><br></pre></td></tr></table></figure><h4 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h4><p><strong>【实例1】将<code>echo</code>命令的输出结果以追加的方式写入到<code>demo.txt</code>文件中。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">for str in "C语言中文网" "http://c.biancheng.net/" "成立7年了" "日IP数万"</span><br><span class="line">do</span><br><span class="line">    echo $str &gt;&gt;demo.txt  #将输入结果以追加的方式重定向到文件</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行以上脚本，使用<code>cat demo.txt</code>查看文件内容，显示如下：<br><code>C语言中文网</code><br><code>http://c.biancheng.net/</code><br><code>成立7年了</code><br><code>日IP数万</code></p><p><strong>【实例2】将<code>ls -l</code>命令的输出结果重定向到文件中。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ls -l  #先预览一下输出结果</span><br><span class="line">总用量 16</span><br><span class="line">drwxr-xr-x. 2 root     root      21 7月   1 2016 abc</span><br><span class="line">-rw-r--r--. 1 mozhiyan mozhiyan 399 3月  11 17:12 demo.sh</span><br><span class="line">-rw-rw-r--. 1 mozhiyan mozhiyan  67 3月  22 17:16 demo.txt</span><br><span class="line">-rw-rw-r--. 1 mozhiyan mozhiyan 278 3月  16 17:17 main.c</span><br><span class="line">-rwxr-xr-x. 1 mozhiyan mozhiyan 187 3月  22 17:16 test.sh</span><br><span class="line">[c.biancheng.net]$ ls -l &gt;demo.txt  #重定向</span><br><span class="line">[c.biancheng.net]$ cat demo.txt  #查看文件内容</span><br><span class="line">总用量 12</span><br><span class="line">drwxr-xr-x. 2 root     root      21 7月   1 2016 abc</span><br><span class="line">-rw-r--r--. 1 mozhiyan mozhiyan 399 3月  11 17:12 demo.sh</span><br><span class="line">-rw-rw-r--. 1 mozhiyan mozhiyan   0 3月  22 17:21 demo.txt</span><br><span class="line">-rw-rw-r--. 1 mozhiyan mozhiyan 278 3月  16 17:17 main.c</span><br><span class="line">-rwxr-xr-x. 1 mozhiyan mozhiyan 187 3月  22 17:16 test.sh</span><br></pre></td></tr></table></figure><h4 id="错误输出重定向"><a href="#错误输出重定向" class="headerlink" title="错误输出重定向"></a>错误输出重定向</h4><p><strong>命令正确执行是没有错误信息的，我们必须刻意地让命令执行出错</strong>，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ls java  #先预览一下错误信息</span><br><span class="line">ls: 无法访问java: 没有那个文件或目录</span><br><span class="line">[c.biancheng.net]$ ls java 2&gt;err.log  #重定向</span><br><span class="line">[c.biancheng.net]$ cat err.log  #查看文件</span><br><span class="line">ls: 无法访问java: 没有那个文件或目录</span><br></pre></td></tr></table></figure><h4 id="正确输出和错误信息同时保存"><a href="#正确输出和错误信息同时保存" class="headerlink" title="正确输出和错误信息同时保存"></a>正确输出和错误信息同时保存</h4><p><strong>【实例1】把正确结果和错误信息都保存到一个文件中</strong>，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ls -l &gt;out.log 2&gt;&amp;1</span><br><span class="line">[c.biancheng.net]$ ls java &gt;&gt;out.log 2&gt;&amp;1</span><br><span class="line">[c.biancheng.net]$ cat out.log</span><br><span class="line">总用量 12</span><br><span class="line">drwxr-xr-x. 2 root     root      21 7月   1 2016 abc</span><br><span class="line">-rw-r--r--. 1 mozhiyan mozhiyan 399 3月  11 17:12 demo.sh</span><br><span class="line">-rw-rw-r--. 1 mozhiyan mozhiyan 278 3月  16 17:17 main.c</span><br><span class="line">-rw-rw-r--. 1 mozhiyan mozhiyan   0 3月  22 17:39 out.log</span><br><span class="line">-rwxr-xr-x. 1 mozhiyan mozhiyan 187 3月  22 17:16 test.sh</span><br><span class="line">ls: 无法访问java: 没有那个文件或目录</span><br></pre></td></tr></table></figure><p><code>out.log</code>的最后一行是错误信息，其它行都是正确的输出结果。</p><p>【实例2】把<strong>正确结果和错误信息分开保存到不同的文件中</strong>，也即写成下面的形式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ ls -l &gt;&gt;out.log 2&gt;&gt;err.log</span><br></pre></td></tr></table></figure><p>这样一来，正确的输出结果会写入到<code>out.log</code>，而错误的信息则会写入到<code>err.log</code>。</p><h4 id="dev-null文件"><a href="#dev-null文件" class="headerlink" title="/dev/null文件"></a><code>/dev/null</code>文件</h4><p>如果你既不想把命令的输出结果保存到文件，也不想把命令的输出结果显示到屏幕上，干扰命令的执行，那么可以把命令的所有结果重定向到<code>/dev/null</code>文件中。如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$  ls -l &amp;&gt;/dev/null</span><br></pre></td></tr></table></figure><p>大家可以把<code>/dev/null</code>当成<code>Linux</code>系统的垃圾箱，任何放入垃圾箱的数据都会被丢弃，不能恢复。</p><h3 id="Shell输入重定向"><a href="#Shell输入重定向" class="headerlink" title="Shell输入重定向"></a><code>Shell</code>输入重定向</h3><p>输入重定向就是改变输入的方向，不再使用键盘作为命令输入的来源，而是使用文件作为命令的输入。</p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>command &lt;file</code></td><td>将<code>file</code>文件中的内容作为<code>command</code>的输入。</td></tr><tr><td><code>command &lt;&lt;END</code></td><td>从标准输入（键盘）中读取数据，直到遇见分界符<code>END</code>才停止（分界符可以是任意的字符串，用户自己定义）。</td></tr><tr><td><code>command &lt;file1 &gt;file2</code></td><td>将<code>file1</code>作为<code>command</code>的输入，并将<code>command</code>的处理结果输出到<code>file2</code>。</td></tr></tbody></table><p><strong>注意</strong></p><blockquote><p>输入重定向的完整写法其实是<code>fd&lt;file</code>，其中<code>fd</code>表示文件描述符，如果不写，默认为<code>0</code>，也就是标准输入文件。</p></blockquote><p>​    <strong>当是输入重定向时，文件描述符为<code>0</code>，一般都省略不写，<code>command &lt;file</code>等同于<code>command 0&lt;file</code>。</strong></p><h4 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h4><p><strong>【示例1】统计文档中有多少行文字。</strong></p><p><code>Linux wc</code>命令可以用来对文本进行统计，包括单词个数、行数、字节数，它的用法如下：</p><p><code>wc [选项] [文件名]</code></p><p>其中，<code>-c</code>选项统计字节数，<code>-w</code>选项统计单词数，<code>-l</code>选项统计行数。</p><p>统计<code>readme.txt</code>文件中有多少行文本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ cat readme.txt  #预览一下文件内容</span><br><span class="line">C语言中文网</span><br><span class="line">http://c.biancheng.net/</span><br><span class="line">成立7年了</span><br><span class="line">日IP数万</span><br><span class="line">[c.biancheng.net]$ wc -l &lt;readme.txt  #输入重定向</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>【实例2】逐行读取文件内容。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">while read str; do</span><br><span class="line">    echo $str</span><br><span class="line">done &lt;readme.txt</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>C语言中文网</code><br><code>http://c.biancheng.net/</code><br><code>成立7年了</code><br><code>日IP数万</code></p><p><strong>【实例3】统计用户在终端输入的文本的行数。</strong></p><p>​    此处我们使用输入重定向符号<code>&lt;&lt;</code>，这个符号的作用是使用特定的分界符作为命令输入的结束标志，而不使用 <code>Ctrl+D</code>键。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ wc -l &lt;&lt;END</span><br><span class="line"><span class="meta">&gt;</span> 123</span><br><span class="line"><span class="meta">&gt;</span> 789</span><br><span class="line"><span class="meta">&gt;</span> abc</span><br><span class="line"><span class="meta">&gt;</span> xyz</span><br><span class="line"><span class="meta">&gt;</span> END</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><code>wc</code>命令会一直等待用输入，直到遇见分界符<code>END</code>才结束读取。</p><p><strong><code>&lt;&lt;</code>之后的分界符可以自由定义，只要再碰到相同的分界符，两个分界符之间的内容将作为命令的输入。</strong></p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>​    一个<code>Linux</code>进程启动后，会在内核空间中创建一个<code>PCB</code>控制块，<code>PCB</code>内部有一个文件描述符表（<code>File descriptor table</code>），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件。</p><p>除了文件描述符表，系统还需要维护另外两张表：</p><ul><li><strong>打开文件表</strong>（<code>Open file table</code>）</li><li><strong><code>i-node</code>表</strong>（<code>i-node table</code>）</li></ul><p>文件描述符表每个进程都有一个，打开文件表和<code>i-node</code>表整个系统只有一个，它们三者之间的关系如下图所示。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1Z4101H45S13.gif" alt></p><p>​    从本质上讲，这三种表都是结构体数组，<code>0</code>、<code>1</code>、<code>2</code>、<code>73</code>、<code>1976</code>等都是数组下标。表头只是注释，数组本身是没有的。实线箭头表示指针的指向，虚线箭头是注释。</p><p>​    <strong>从上图看文件描述符只是一个数组下标</strong></p><p> 通过文件描述符，可以找到文件指针，从而进入打开文件表。该表存储了以下信息：</p><ul><li>文件偏移量，也就是文件内部指针偏移量。调用<code>read()</code>或者<code>write()</code>函数时，文件偏移量会自动更新，当然也可以使用<code>lseek()</code>直接修改。</li><li>状态标志，比如只读模式、读写模式、追加模式、覆盖模式等。</li><li><code>i-node</code>表指针。</li></ul><p> 然而，要想真正读写文件，还得通过打开文件表的<code>i-node</code>指针进入<code>i-node</code>表，该表包含了诸如以下的信息：</p><ul><li>文件类型，例如常规文件、套接字或<code>FIFO</code>。</li><li>文件大小。</li><li>时间戳，比如创建时间、更新时间。</li><li>文件锁。</li></ul><p> 对上图的进一步说明：</p><ul><li>在进程<code>A</code>中，文件描述符<code>1</code>和<code>20</code>都指向了同一个打开文件表项，标号为<code>23</code>（指向了打开文件表中下标为<code>23</code>的数组元素），这可能是通过调用<code>dup()</code>、<code>dup2()</code>、<code>fcntl()</code>或者对同一个文件多次调用了<code>open()</code>函数形成的。</li><li>进程<code>A</code>的文件描述符<code>2</code>和进程<code>B</code>的文件描述符<code>2</code>都指向了同一个文件，这可能是在调用<code>fork()</code>后出现的（即进程<code>A</code>、<code>B</code>是父子进程关系），或者是不同的进程独自去调用<code>open()</code>函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。</li><li>进程<code>A</code>的描述符<code>0</code>和进程<code>B</code>的描述符<code>3</code>分别指向不同的打开文件表项，但这些表项均指向<code>i-node</code>表的同一个条目（标号为<code>1976</code>）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了<code>open()</code>调用。同一个进程两次打开同一个文件，也会发生类似情况。 </li></ul><p> 有了以上对文件描述符的认知，我们很容易理解以下情形：</p><ul><li><strong>同一个进程的不同文件描述符可以指向同一个文件；</strong></li><li><strong>不同进程可以拥有相同的文件描述符；</strong></li><li><strong>不同进程的同一个文件描述符可以指向不同的文件</strong>（一般也是这样，除了<code>0</code>、<code>1</code>、<code>2</code>这三个特殊的文件）；</li><li><strong>不同进程的不同文件描述符也可以指向同一个文件。</strong></li></ul><h3 id="重定向本质"><a href="#重定向本质" class="headerlink" title="重定向本质"></a>重定向本质</h3><p>​    本章我们探索<code>Shell</code>是如何借助文件描述符实现重定向的。</p><p>​    <code>Linux</code>系统每次读写文件的时候，都从文件描述符下手，通过文件描述符找到文件指针，然后进入打开文件表和<code>i-node</code>表，这两个表里面才真正保存了与打开文件相关的各种信息。</p><p>​    如果我们改变了文件指针的指向，那就可以改变文件描述符对应的真实文件。比如文件描述符<code>1</code>本来对应显示器，但是我们偷偷将文件指针指向了<code>log.txt</code>文件，那么文件描述符<code>1</code>也就和<code>log.txt</code>对应起来了。</p><p>​    <code>Linux</code>系统提供的函数可以修改文件指针，比如<code>dup()</code>、<code>dup2()</code>；<code>Shell</code>也能修改文件指针，输入输出重定向就是这么干的。</p><p>​    <strong>因此，可以知道输入输出重定向就是通过修改文件指针实现的。</strong>更准确地说，发生重定向时，<code>Linux</code>会用文件描述符表（一个结构体数组）中的一个元素给另一个元素赋值，或者用一个结构体变量给数组元素赋值，整体上的资源开销相当低。</p><p>​    发生重定向的时候，文件描述符并没有改变，改变的是文件描述符对应的文件指针。对于标准输出，<code>Linux</code>系统始终向文件描述符<code>1</code>中输出内容，而不管它的文件指针指向哪里；只要我们修改了文件指针，就能向任意文件中输出内容。</p><p> 以下面的语句为例来说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ echo "c.biancheng.net" 1&gt;log.txt</span><br></pre></td></tr></table></figure><p>​    文件描述符表本质上是一个结构体数组，假设这个结构体的名字叫做<code>FD</code>。发生重定向时，<code>Linux</code>系统首先会打开<code>log.txt</code>文件，并把各种信息添加到<code>i-node</code>表和文件打开表，然后再创建一个<code>FD</code>变量（通过这个变量其实就能读写文件了），并用这个变量给下标为<code>1</code>的数组元素赋值，覆盖原来的内容，这样就改变了文件指针的指向，完成了重定向。</p><h4 id="Shell-对文件描述符的操作"><a href="#Shell-对文件描述符的操作" class="headerlink" title="Shell 对文件描述符的操作"></a>Shell 对文件描述符的操作</h4><p>前面提到，<strong><code>&gt;</code>是输出重定向符号，<code>&lt;</code>是输入重定向符号</strong>；更准确地说，它们应该叫做<strong>文件描述符操作符</strong>。<code>&gt;</code>和<code>&lt;</code>通过修改文件描述符改变了文件指针的指向，所以能够实现重定向的功能。</p><p> 除了<code>&gt;</code>和<code>&lt;</code>，<code>Shell</code>还是支持<code>&lt;&gt;</code>，它的效果是前面两者的总和。</p><table><thead><tr><th>分类</th><th>用法</th><th>说明</th></tr></thead><tbody><tr><td>输出</td><td><code>n&gt;filename</code></td><td>以输出的方式打开文件<code>filename</code>，并绑定到文件描述符<code>n</code>。<code>n</code>可以不写，默认为<code>1</code>，也即标准输出文件。</td></tr><tr><td></td><td><code>n&gt;&amp;m</code></td><td>用文件描述符<code>m</code>修改文件描述符<code>n</code>，或者说用文件描述符<code>m</code>的内容覆盖文件描述符<code>n</code>，结果就是<code>n</code>和 <code>m</code>都代表了同一个文件，因为<code>n</code>和<code>m</code>的文件指针都指向了同一个文件。因为使用的是<code>&gt;</code>，所以<code>n</code>和<code>m</code>只能用作命令的输出文件。<code>n</code>可以不写，默认为<code>1</code>。</td></tr><tr><td></td><td><code>n&gt;&amp;-</code></td><td>关闭文件描述符<code>n</code>及其代表的文件。<code>n</code>可以不写，默认为<code>1</code>。</td></tr><tr><td></td><td><code>&amp;&gt;filename</code></td><td>将正确输出结果和错误信息全部重定向到<code>filename</code>。</td></tr><tr><td>输入</td><td><code>n&lt;filename</code></td><td>以输入的方式打开文件<code>filename</code>，并绑定到文件描述符<code>n</code>。<code>n</code>可以不写，默认为<code>0</code>，也即标准输入文件。</td></tr><tr><td></td><td><code>n&lt;&amp;m</code></td><td>类似于<code>n&gt;&amp;m</code>，但是因为使用的是<code>&lt;</code>，所以<code>n</code>和<code>m</code>只能用作命令的输入文件。<code>n</code>可以不写，默认为<code>0</code>。</td></tr><tr><td></td><td><code>n&lt;&amp;-</code></td><td>关闭文件描述符<code>n</code>及其代表的文件。<code>n</code>可以不写，默认为<code>0</code>。</td></tr><tr><td>输入和输出</td><td><code>n&lt;&gt;filename</code></td><td>同时以输入和输出的方式打开文件<code>filename</code>，并绑定到文件描述符<code>n</code>，相当于 <code>n&gt;filename</code>和<code>n&lt;filename</code>的总和。<code>n</code>可以不写，默认为<code>0</code>。</td></tr></tbody></table><p><strong>【实例1】前面的文章中提到了下面这种用法：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &gt;file 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>​    它省略了文件描述符<code>1</code>，所以等价于：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command 1&gt;file 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p><p>​    这个语句可以分成两步：先执行<code>1&gt;file</code>，让文件描述符<code>1</code>指向<code>file</code>；再执行<code>2&gt;&amp;1</code>，用文件描述符<code>1</code>修改文件描述符<code>2</code>，让<code>2</code>和<code>1</code>的内容一样。最终<code>1</code>和<code>2</code>都指向了同一个文件，也就是<code>file</code>。所以不管是向<code>1</code>还是向<code>2</code>中输出内容，最终都输出到<code>file</code>文件中。</p><p>​    这里需要注意执行顺序，<strong>多个操作符在一起会从左往右依次执行</strong>。对于上面的语句，就是先执行<code>1&gt;file</code>，再执行<code>2&gt;&amp;1</code>；如果写作下面的形式，那就南辕北辙了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command 2&gt;&amp;1 1&gt;file</span><br></pre></td></tr></table></figure></p><p><code>Shell</code>会先执行<code>2&gt;&amp;1</code>，这样<code>1</code>和<code>2</code>都指向了标准错误输出文件，也即显示器；接着执行<code>1&gt;file</code>，这样 1 就指向了<code>file</code>文件，但是<code>2</code>依然指向显示器。最终的结果是，正确的输出结果输出到了<code>file</code>文件，错误信息却还是输出到显示器。</p><p><strong>【实例2】一个比较奇葩的重定向写法。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ echo "C语言中文网" 10&gt;log.txt &gt;&amp;10</span><br></pre></td></tr></table></figure><p>先执行<code>10&gt;log.txt</code>，打开<code>log.txt</code>，并给它分配文件描述符<code>10</code>；接着执行<code>&gt;&amp;10</code>，用文件描述符<code>10</code>来修改文件描述符<code>1</code>（对于<code>&gt;</code>，省略不写的话默认为<code>1</code>），让<code>1</code>和<code>10</code>都指向<code>log.txt</code>文件，最终的结果是向<code>log.txt</code>文件中输出内容。</p><p> 这条语句其实等价于<code>echo &quot;C语言中文网&quot; &gt;log.txt</code>，我之所以写得这么绕，是为了让大家理解各种操作符的用法。</p><p> 文件描述符 10 只用了一次，我们在末尾最好将它关闭，这是一个好习惯。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ echo "C语言中文网" 10&gt;log.txt &gt;&amp;10 10&gt;&amp;-</span><br></pre></td></tr></table></figure><h3 id="永久性地重定向"><a href="#永久性地重定向" class="headerlink" title="永久性地重定向"></a>永久性地重定向</h3><p>​    <code>exec</code>是<code>Shell</code>内置命令，它有两种用法，一种是执行<code>Shell</code>命令，一种是操作文件描述符。</p><p>​    <strong>使用<code>exec</code>命令可以永久性地重定向，后续命令的输入输出方向也被确定了，直到再次遇到<code>exec</code>命令才会改变重定向的方向；换句话说，一次重定向，永久有效。</strong></p><p> 请看下面的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ echo "c.biancheng.net" &gt; log.txt</span><br><span class="line">[mozhiyan@localhost ~]$ echo "C语言中文网"</span><br><span class="line">C语言中文网</span><br><span class="line">[mozhiyan@localhost ~]$ cat log.txt</span><br><span class="line">c.biancheng.net</span><br></pre></td></tr></table></figure><p>​    第一个<code>echo</code>命令使用了重定向，将内容输出到<code>log.txt</code>文件；第二个<code>echo</code>命令没有再次使用重定向，内容就直接输出到显示器上了。很明显，重定向只对第一个<code>echo</code>有效，对第二个<code>echo</code>无效。</p><p>​    有些脚本文件的输出内容很多，我们不希望直接输出到显示器上，或者我们需要把输出内容备份到文件中，方便以后检索，按照以前的思路，必须在每个命令后面都使用一次重定向，写起来非常麻烦。如果以后想修改重定向的方向，那工作量也是不小的。</p><p>​    <code>exec</code>命令就是为解决这种困境而生的，它可以让重定向对当前<code>Shell</code>进程中的所有命令有效，它的用法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec 文件描述符操作</span><br></pre></td></tr></table></figure><p>在上章节讲到的所有对文件描述符的操作方式<code>exec</code>都支持，请看下面的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ echo "重定向未发生"</span><br><span class="line">重定向未发生</span><br><span class="line">[mozhiyan@localhost ~]$ exec &gt;log.txt</span><br><span class="line">[mozhiyan@localhost ~]$ echo "c.biancheng.net"</span><br><span class="line">[mozhiyan@localhost ~]$ echo "C语言中文网"</span><br><span class="line">[mozhiyan@localhost ~]$ exec &gt;&amp;2</span><br><span class="line">[mozhiyan@localhost ~]$ echo "重定向已恢复"</span><br><span class="line">重定向已恢复</span><br><span class="line">[mozhiyan@localhost ~]$ cat log.txt</span><br><span class="line">c.biancheng.net</span><br><span class="line">C语言中文网</span><br></pre></td></tr></table></figure><p>对代码的说明：</p><ul><li><code>exec &gt;log.txt</code>将当前<code>Shell</code>进程的所有标准输出重定向到<code>log.txt</code>文件，它等价于<code>exec 1&gt;log.txt</code>。</li><li>后面的两个<code>echo</code>命令都没有在显示器上输出，而是输出到了<code>log.txt</code>文件。</li><li><code>exec &gt;&amp;2</code>用来恢复重定向，让标准输出重新回到显示器，它等价于<code>exec 1&gt;&amp;2</code>。<code>2</code>是标准错误输出的文件描述符，它也是输出到显示器，并且没有遭到破坏，我们用<code>2</code>来覆盖<code>1</code>，就能修复<code>1</code>，让<code>1</code>重新指向显示器。</li><li>接下来的<code>echo</code>命令将结果输出到显示器上，证明<code>exec &gt;&amp;2</code>奏效了。</li><li>最后我们用<code>cat</code>命令来查看<code>log.txt</code>文件的内容，发现就是中间两个<code>echo</code>命令的输出。</li></ul><h3 id="重定向的恢复"><a href="#重定向的恢复" class="headerlink" title="重定向的恢复"></a>重定向的恢复</h3><p>​    类似<code>echo &quot;1234&quot; &gt;log.txt</code>这样的重定向只是临时的，当前命名执行完毕后会自动恢复到显示器，我们不用担心。但是诸如<code>exec &gt;log.txt</code>这种使用<code>exec</code>命令的重定向都是持久的，如果我们想再次回到显示器，就必须手动恢复。</p><p>​    以输出重定向为例，手动恢复的方法有两种：</p><ul><li><code>/dev/tty</code>文件代表的就是显示器，将标准输出重定向到<code>/dev/tty</code>即可，也就是<code>exec &gt;/dev/tty</code>。</li><li>如果还有别的文件描述符指向了显示器，那么也可以别的文件描述符来恢复标号为<code>1</code>的文件描述符，例如 <code>exec &gt;&amp;2</code>。注意，如果文件描述符<code>2</code>也被重定向了，那么这种方式就无效了。</li></ul><p> 下面的例子演示了输入重定向的恢复：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">exec 6&lt;&amp;0  #先将0号文件描述符保存</span><br><span class="line">exec &lt;nums.txt  #输入重定向</span><br><span class="line"></span><br><span class="line">sum=0</span><br><span class="line">while read n; do</span><br><span class="line">    ((sum += n))</span><br><span class="line">done</span><br><span class="line">echo "sum=$sum"</span><br><span class="line"></span><br><span class="line">exec 0&lt;&amp;6 6&lt;&amp;-  #恢复输入重定向，并关闭文件描述符6</span><br><span class="line"></span><br><span class="line">read -p "请输入名字、网址和年龄：" name url age</span><br><span class="line">echo "$name已经$age岁了，它的网址是 $url"</span><br></pre></td></tr></table></figure><p>将代码保存到<code>test.txt</code>，并执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ cat nums.txt</span><br><span class="line">80</span><br><span class="line">33</span><br><span class="line">129</span><br><span class="line">71</span><br><span class="line">100</span><br><span class="line">222</span><br><span class="line">8</span><br><span class="line">[mozhiyan@localhost ~]$ bash ./test.sh</span><br><span class="line">sum=643</span><br><span class="line">请输入名字、网址和年龄：C语言中文网 http://c.biancheng.net 7</span><br><span class="line">C语言中文网已经7岁了，它的网址是 http://c.biancheng.net</span><br></pre></td></tr></table></figure><h2 id="代码块重定向"><a href="#代码块重定向" class="headerlink" title="代码块重定向"></a>代码块重定向</h2><p>​    所谓代码块，就是由多条语句组成的一个整体；<code>for</code>、<code>while</code>、<code>until</code>循环，或者<code>if...else</code>、<code>case...in</code>选择结构，或者由<code>{ }</code>包围的命令都可以称为代码块。</p><p>​    <strong>将重定向命令放在代码块的结尾处，就可以对代码块中的所有命令实施重定向。</strong></p><p><strong>【实例1】使用 while 循环不断读取<code>nums.txt</code>中的数字，计算它们的总和。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">sum=0</span><br><span class="line">while read n; do</span><br><span class="line">    ((sum += n))</span><br><span class="line">done &lt;nums.txt  #输入重定向</span><br><span class="line">echo "sum=$sum"</span><br></pre></td></tr></table></figure><p>将代码保存到<code>test.sh</code>并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ cat nums.txt</span><br><span class="line">80</span><br><span class="line">33</span><br><span class="line">129</span><br><span class="line">71</span><br><span class="line">100</span><br><span class="line">222</span><br><span class="line">8</span><br><span class="line">[c.biancheng.net]$ . ./test.sh</span><br><span class="line">sum=643</span><br></pre></td></tr></table></figure><p> 对上面的代码进行改进，记录<code>while</code>的读取过程，并将输出结果重定向到<code>log.txt</code>文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">sum=0</span><br><span class="line">while read n; do</span><br><span class="line">    ((sum += n))</span><br><span class="line">    echo "this number: $n"</span><br><span class="line">done &lt;nums.txt &gt;log.txt  #同时使用输入输出重定向</span><br><span class="line">echo "sum=$sum"</span><br></pre></td></tr></table></figure><p>将代码保存到<code>test.sh</code>并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ . ./test.sh</span><br><span class="line">sum=643</span><br><span class="line">[c.biancheng.net]$ cat log.txt</span><br><span class="line">this number: 80</span><br><span class="line">this number: 33</span><br><span class="line">this number: 129</span><br><span class="line">this number: 71</span><br><span class="line">this number: 100</span><br><span class="line">this number: 222</span><br><span class="line">this number: 8</span><br></pre></td></tr></table></figure><p> <strong>【实例2】对<code>{}</code>包围的代码使用重定向。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    echo "C语言中文网";</span><br><span class="line">    echo "http://c.biancheng.net";</span><br><span class="line">    echo "7"</span><br><span class="line">&#125; &gt;log.txt  #输出重定向</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    read name;</span><br><span class="line">    read url;</span><br><span class="line">    read age</span><br><span class="line">&#125; &lt;log.txt  #输入重定向</span><br><span class="line"></span><br><span class="line">echo "$name已经$age岁了，它的网址是 $url"</span><br></pre></td></tr></table></figure><p>将代码保存到 <code>test.sh</code>并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ . ./test.sh</span><br><span class="line">C语言中文网已经7岁了，它的网址是 http://c.biancheng.net</span><br><span class="line">[c.biancheng.net]$ cat log.txt</span><br><span class="line">C语言中文网</span><br><span class="line">http://c.biancheng.net</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="内嵌文档-Here-Document"><a href="#内嵌文档-Here-Document" class="headerlink" title="内嵌文档(Here Document)"></a>内嵌文档(Here Document)</h2><p>​    <code>Shell</code>还有一种特殊形式的重定向叫做<code>“Here Document”</code>，目前没有统一的翻译，你可以将它理解为“嵌入文档”“内嵌文档”“立即文档”。</p><p>​    <strong>所谓文档，就是命令需要处理的数据或者字符串；所谓嵌入，就是把数据和代码放在一起，而不是分开存放（比如将数据放在一个单独的文件中）</strong>。有时候命令需要处理的数据量很小，将它放在一个单独的文件中有点“大动干戈”，不如直接放在代码中来得方便。</p><p>​    <code>Here Document</code>的基本用法为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command &lt;&lt;END</span><br><span class="line">   document</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>​    <code>command</code>是<code>Shell</code>命令，<code>&lt;&lt;END</code>是开始标志，<code>END</code>是结束标志，<code>document</code>是输入的文档（也就是一行一行的字符串）。</p><p>​    <strong>这种写法告诉<code>Shell</code>把<code>document</code>部分作为命令需要处理的数据，直到遇见终止符<code>END</code>为止（终止符<code>END</code>不会被读取）。</strong></p><p>​    <strong>注意，终止符<code>END</code>必须独占一行，并且要定顶格写。</strong></p><p>​    <strong>分界符（终止符）可以是任意的字符串，由用户自己定义，比如 END、MARKER 等。分界符可以出现在正常的数据流中，只要它不是顶格写的独立的一行，就不会被作为结束标志。</strong></p><p><strong>【实例1】cat 命令一般是从文件中读取内容，并将内容输出到显示器上，借助 Here Document，cat 命令可以从键盘上读取内容。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ cat &lt;&lt;END</span><br><span class="line"><span class="meta">&gt;</span> Shell教程</span><br><span class="line"><span class="meta">&gt;</span> http://c.biancheng.net/shell/</span><br><span class="line"><span class="meta">&gt;</span> 已经进行了三次改版</span><br><span class="line"><span class="meta">&gt;</span> END</span><br><span class="line">Shell教程</span><br><span class="line">http://c.biancheng.net/shell/</span><br><span class="line">已经进行了三次改版</span><br></pre></td></tr></table></figure><p><code>&lt;</code>是第二层命令提示符。</p><p> 正文中也可以出现结束标志<code>END</code>，只要它不是独立的一行，并且不顶格写，就没问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ cat &lt;&lt;END</span><br><span class="line"><span class="meta">&gt;</span> END可以出现在行首</span><br><span class="line"><span class="meta">&gt;</span> 出现在行尾的END</span><br><span class="line"><span class="meta">&gt;</span> 出现在中间的END也是允许的</span><br><span class="line"><span class="meta">&gt;</span> END</span><br><span class="line">END可以出现在行首</span><br><span class="line">出现在行尾的END</span><br><span class="line">出现在中间的END也是允许的</span><br></pre></td></tr></table></figure><p><strong>【实例2】在脚本文件中使用<code>Here Document</code>，并将<code>document</code>中的内容转换为大写。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>在脚本文件中使用立即文档</span><br><span class="line"></span><br><span class="line">tr a-z A-Z &lt;&lt;END</span><br><span class="line">one two three</span><br><span class="line">Here Document</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>将代码保存到<code>test.sh</code>并运行，结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ONE TWO THREE</span><br><span class="line">HERE DOCUMENT</span><br></pre></td></tr></table></figure><h3 id="忽略命令替换"><a href="#忽略命令替换" class="headerlink" title="忽略命令替换"></a>忽略命令替换</h3><p>默认情况下，正文中出现的变量和命令也会被求值或运行，<code>Shell</code>会先将它们替换以后再交给<code>command</code>，请看下面的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ name=C语言中文网</span><br><span class="line">[mozhiyan@localhost ~]$ url=http://c.biancheng.net</span><br><span class="line">[mozhiyan@localhost ~]$ age=7</span><br><span class="line">[mozhiyan@localhost ~]$ cat &lt;&lt;END</span><br><span class="line"><span class="meta">&gt;</span> $&#123;name&#125;已经$&#123;age&#125;岁了，它的网址是 $&#123;url&#125;</span><br><span class="line"><span class="meta">&gt;</span> END</span><br><span class="line">C语言中文网已经7岁了，它的网址是 http://c.biancheng.net</span><br></pre></td></tr></table></figure><p> 你<strong>可以将分界符用单引号或者双引号包围起来使<code>Shell</code>替换失效</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ name=C语言中文网</span><br><span class="line">[mozhiyan@localhost ~]$ url=http://c.biancheng.net</span><br><span class="line">[mozhiyan@localhost ~]$ age=7</span><br><span class="line">[mozhiyan@localhost ~]$ cat &lt;&lt;'END'  #使用单引号包围</span><br><span class="line"><span class="meta">&gt;</span> $&#123;name&#125;已经$&#123;age&#125;岁了，它的网址是 $&#123;url&#125;</span><br><span class="line"><span class="meta">&gt;</span> END</span><br><span class="line"><span class="meta">$</span>&#123;name&#125;已经$&#123;age&#125;岁了，它的网址是 $&#123;url&#125;</span><br></pre></td></tr></table></figure><h3 id="忽略制表符"><a href="#忽略制表符" class="headerlink" title="忽略制表符"></a>忽略制表符</h3><p>默认情况下，行首的制表符也被当做正文的一部分。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;END</span><br><span class="line">    Shell教程</span><br><span class="line">    http://c.biancheng.net/shell/</span><br><span class="line">    已经进行了三次改版</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>将代码保存到 test.sh 并运行，结果如下：</p><p>​        <code>Shell教程</code><br>​        <code>http://c.biancheng.net/shell/</code><br>​        <code>已经进行了三次改版</code></p><p> 这里的制表符仅仅是为了格式对齐，我们并不希望它作为正文的一部分，为了达到这个目的，你可以在<code>&lt;&lt;</code>和<code>END</code>之间增加<code>-</code>，请看下面的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>增加了减号-</span><br><span class="line">cat &lt;&lt;-END</span><br><span class="line">    Shell教程</span><br><span class="line">    http://c.biancheng.net/shell/</span><br><span class="line">    已经进行了三次改版</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>这次的运行结果为：<br><code>Shell教程</code><br><code>http://c.biancheng.net/shell/</code><br><code>已经进行了三次改版</code></p><blockquote><p>如果你尝试在脚本嵌入一小块多行数据，使用<code>Here Document</code>是很有用的，而嵌入很大的数据块是一个不好的习惯。你应该保持你的逻辑（你的代码）和你的输入（你的数据）分离，最好是在不同的文件中，除非是输入一个很小的数据集。</p></blockquote><p><strong><code>Here Document</code>最常用的功能还是向用户显示命令或者脚本的用法信息</strong>，例如类似下面的函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">usage()&#123;</span><br><span class="line">    cat &lt;&lt;-END</span><br><span class="line">        usage: command [-x] [-v] [-z] [file ...]</span><br><span class="line">        A short explanation of the operation goes here.</span><br><span class="line">        It might be a few lines long, but shouldn't be excessive.</span><br><span class="line">END</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内嵌字符串-Here-String"><a href="#内嵌字符串-Here-String" class="headerlink" title="内嵌字符串(Here String)"></a>内嵌字符串(<code>Here String</code>)</h2><p>​    <code>Here String</code>是<code>Here Document</code>的一个变种，它的用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &lt;&lt;&lt; string</span><br></pre></td></tr></table></figure><p>​    <code>command</code>是 <code>Shell</code>命令，<code>string</code>是字符串（它只是一个普通的字符串，并没有什么特别之处）。</p><p>​     这种写法告诉<code>Shell</code>把<code>string</code>部分作为命令需要处理的数据。例如，将小写字符串转换为大写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ tr a-z A-Z &lt;&lt;&lt; one</span><br><span class="line">ONE</span><br></pre></td></tr></table></figure><p>​    <code>Here String</code>对于这种发送较短的数据到进程是非常方便的，它比<code>Here Document</code>更加简洁。</p><h3 id="双引号和单引号"><a href="#双引号和单引号" class="headerlink" title="双引号和单引号"></a>双引号和单引号</h3><p>​    一个单词不需要使用引号包围，但<strong>如果<code>string</code>中带有空格，则必须使用双引号或者单引号包围</strong>，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ tr a-z A-Z &lt;&lt;&lt; "one two three"</span><br><span class="line">ONE TWO THREE</span><br></pre></td></tr></table></figure><p>​    <strong>双引号和单引号是有区别的，双引号会解析其中的变量（当然不写引号也会解析），单引号不会。</strong></p><p>请看下面的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ var=two</span><br><span class="line">[mozhiyan@localhost ~]$ tr a-z A-Z &lt;&lt;&lt;"one $var there"</span><br><span class="line">ONE TWO THERE</span><br><span class="line">[mozhiyan@localhost ~]$ tr a-z A-Z &lt;&lt;&lt;'one $var there'</span><br><span class="line">ONE $VAR THERE</span><br><span class="line">[mozhiyan@localhost ~]$ tr a-z A-Z &lt;&lt;&lt;one$&#123;var&#125;there</span><br><span class="line">ONETWOTHERE</span><br></pre></td></tr></table></figure><p> 有了引号的包围，<code>Here String</code>还可以接收多行字符串作为命令的输入，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ tr a-z A-Z &lt;&lt;&lt;"one two there</span><br><span class="line"><span class="meta">&gt;</span> four five six</span><br><span class="line"><span class="meta">&gt;</span> seven eight"</span><br><span class="line">ONE TWO THERE</span><br><span class="line">FOUR FIVE SIX</span><br><span class="line">SEVEN EIGHT</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell函数</title>
      <link href="/2018/05/09/shell9-%E5%87%BD%E6%95%B0/"/>
      <url>/2018/05/09/shell9-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><code>Shell</code> 函数的本质是一段可以重复使用的脚本代码，这段代码被提前编写好了，放在了指定的位置，使用时直接调取即可。 </p><p>​    <code>Shell</code>函数定义的语法格式如下：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function name() &#123;</span><br><span class="line">    statements</span><br><span class="line">    [return value]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对各个部分的说明： </p><ul><li><code>function</code>是 Shell 中的关键字，专门用来定义函数；</li><li><code>name</code>是函数名；</li><li><code>statements</code>是函数要执行的代码，也就是一组语句；</li><li><code>return value</code>表示函数的返回值，其中<code>return</code> 是<code>Shell</code>关键字，专门用在函数中返回一个值；这一部分可以写也可以不写。</li></ul><p>由<code>{ }</code>包围的部分称为<strong>函数体</strong>，调用一个函数，实际上就是执行函数体中的代码。 </p><a id="more"></a><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p> 调用<code>Shell</code>函数时可以给它传递参数，也可以不传递。如果不传递参数，直接给出函数名字即可：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name</span><br></pre></td></tr></table></figure><p> 如果传递参数，那么多个参数之间以空格分隔：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name param1 param2 param3</span><br></pre></td></tr></table></figure><p> 不管是哪种形式，函数名字后面都不需要带括号。 </p><h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><p>1) 定义一个函数，输出 Shell 教程的地址： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>函数定义</span><br><span class="line">function url()&#123;</span><br><span class="line">    echo "http://c.biancheng.net/shell/"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>函数调用</span><br><span class="line">url</span><br></pre></td></tr></table></figure><p>运行结果：<br> <code>http://c.biancheng.net/shell/</code></p><p> 你可以将调用放在定义的前面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>函数调用</span><br><span class="line">url</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>函数定义</span><br><span class="line">function url()&#123;</span><br><span class="line">    echo "http://c.biancheng.net/shell/"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 定义一个函数，计算所有参数的和： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">function getsum()&#123;</span><br><span class="line">    local sum=0</span><br><span class="line"></span><br><span class="line">    for n in $@</span><br><span class="line">    do</span><br><span class="line">         ((sum+=n))</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    return $sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getsum 10 20 55 15  #调用函数并传递参数</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure><p>​    <code>$@</code>表示函数的所有参数，<code>$?</code>表示函数的退出状态（返回值）。 </p><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>​    函数参数是<strong><code>Shell</code>位置参数</strong>的一种，在函数内部可以使用<code>$n</code>来接收，例如，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数，依次类推。 </p><p>​    除了<code>$n</code> ，还有另外三个比较重要的变量：  </p><ul><li><code>$#</code>可以获取传递的参数的个数；</li><li><code>$@</code>或者<code>$*</code>可以一次性获取所有的参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>定义函数</span><br><span class="line">function show()&#123;</span><br><span class="line">    echo "Tutorial: $1"</span><br><span class="line">    echo "URL: $2"</span><br><span class="line">    echo "Author: "$3</span><br><span class="line">    echo "Total $# parameters"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>调用函数</span><br><span class="line">show C# http://c.biancheng.net/csharp/ Tom</span><br></pre></td></tr></table></figure><p>运行结果：<br>    <code>Tutorial: C#</code><br>    <code>URL: http://c.biancheng.net/csharp/</code><br>    <code>Author: Tom</code><br>    <code>Total 3 parameters</code></p><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>​    在<code>C++</code>、<code>Java</code>、<code>C#</code>、<code>Python</code>等大部分编程语言中，返回值是指函数被调用之后，执行函数体中的代码所得到的结果，这个结果就通过<code>return</code>语句返回。</p><p>​    但是<code>Shell</code>中的返回值表示的是函数的退出状态：<strong>返回值为 0 表示函数执行成功了，返回值为非 0 表示函数执行失败（出错）了。</strong><code>if</code>、<code>while</code>、<code>for</code>等语句都是根据函数的退出状态来判断条件是否成立。</p><p>​    <strong><code>Shell</code>函数的返回值只能是一个介于<code>0~255</code>之间的整数，其中只有 0 表示成功，其它值都表示失败。</strong> </p><p>​    如果函数体中没有<code>return</code>语句，那么使用默认的退出状态，也就是最后一条命令的退出状态。如果这就是你想要的，那么更加严谨的写法为：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return $?</span><br></pre></td></tr></table></figure><p>​    <code>$?</code>是一个特殊变量，用来获取上一个命令的退出状态，或者上一个函数的返回值。</p><h2 id="得到函数的处理结果"><a href="#得到函数的处理结果" class="headerlink" title="得到函数的处理结果"></a>得到函数的处理结果</h2><p>这个问题有两种解决方案： </p><ul><li>一种是借助全局变量，将得到的结果赋值给全局变量；</li><li>一种是在函数内部使用<code>echo</code>、<code>printf</code>命令将结果输出，在函数外部使用<code>$()</code>捕获结果。</li></ul><p>定义一个函数<code>getsum</code>，计算从<code>m</code>加到<code>n</code>的和，并使用以上两种解决方案。</p><p>【实例1】将函数处理结果赋值给一个全局变量。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">sum=0  #全局变量</span><br><span class="line"></span><br><span class="line">function getsum()&#123;</span><br><span class="line">    for((i=$1; i&lt;=$2; i++)); do</span><br><span class="line">        ((sum+=i))  #改变全局变量</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    return $?  #返回上一条命令的退出状态</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read m</span><br><span class="line">read n</span><br><span class="line"></span><br><span class="line">if getsum $m $n; then</span><br><span class="line">    echo "The sum is $sum"  #输出全局变量</span><br><span class="line">else</span><br><span class="line">    echo "Error!"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>运行结果：<br> <code>1</code><br> <code>100</code><br> <code>The sum is 5050</code> </p><p>【实例2】在函数内部使用<code>echo</code>输出结果。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">function getsum()&#123;</span><br><span class="line">    local sum=0  #局部变量</span><br><span class="line">    for((i=$1; i&lt;=$2; i++)); do</span><br><span class="line">        ((sum+=i))</span><br><span class="line">    done</span><br><span class="line">   </span><br><span class="line">    echo $sum</span><br><span class="line">    return $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read m</span><br><span class="line">read n</span><br><span class="line"></span><br><span class="line">total=$(getsum $m $n)</span><br><span class="line">echo "The sum is $total"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>也可以省略 total 变量，直接写成下面的形式</span><br><span class="line"><span class="meta">#</span>echo "The sum is "$(getsum $m $n)</span><br></pre></td></tr></table></figure><p> 运行结果：<br> <code>1↙</code><br> <code>100↙</code><br> <code>The sum is 5050</code> </p><p>​    代码中总共执行了两次<code>echo</code>命令，但是却只输出一次，这是因为<code>$()</code>捕获了第一个<code>echo</code>的输出结果，它并没有真正输出到终端上。 </p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell循环</title>
      <link href="/2018/05/07/shell8-%E5%BE%AA%E7%8E%AF/"/>
      <url>/2018/05/07/shell8-%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a><code>while</code>循环</h2><p><code>while</code>循环是<code>Shell</code>脚本中最简单的一种循环，当条件满足时，<code>while</code>重复地执行一组语句，当条件不满足时，就退出<code>while</code>循环。 </p><a id="more"></a><p>​    <code>while</code>循环的用法如下：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>​    <code>condition</code>表示判断条件，<code>statements</code>表示要执行的语句（可以只有一条，也可以有多条），<code>do</code>和<code>done</code>都是 <code>Shell</code>中的关键字。 </p><p><code>while</code>循环的执行流程为： </p><ul><li>先对<code>condition</code>进行判断，如果该条件成立，就进入循环，执行<code>while</code>循环体中的语句，也就是<code>do</code>和<code>done</code>之间的语句。这样就完成了一次循环。</li><li>每一次执行到<code>done</code>的时候都会重新判断<code>condition</code>是否成立，如果成立，就进入下一次循环，继续执行<code>do</code>和<code>done</code>之间的语句，如果不成立，就结束整个<code>while</code>循环，执行<code>done</code>后面的其它<code>Shell</code>代码。</li><li>如果一开始<code>condition</code>就不成立，那么程序就不会进入循环体，<code>do</code>和<code>done</code>之间的语句就没有执行的机会。</li></ul><p><strong>注意，在<code>while</code>循环体中必须有相应的语句使得<code>condition</code>越来越趋近于“不成立”，只有这样才能最终退出循环，否则<code>while</code>就成了死循环，会一直执行下去，永无休止。 </strong></p><p>【实例1】计算从 1 加到 100 的和。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">sum=0</span><br><span class="line"></span><br><span class="line">while ((i &lt;= 100))</span><br><span class="line">do</span><br><span class="line">    ((sum += i))</span><br><span class="line">    ((i++))</span><br><span class="line">done</span><br><span class="line">echo "The sum is: $sum"</span><br></pre></td></tr></table></figure><p>​    运行结果：<br>​    <code>The sum is: 5050</code></p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h2><h3 id="C语言风格的for循环"><a href="#C语言风格的for循环" class="headerlink" title="C语言风格的for循环"></a><code>C</code>语言风格的<code>for</code>循环</h3><p><code>C</code>语言风格的<code>for</code>循环的用法如下：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for((exp1; exp2; exp3))</span><br><span class="line">do</span><br><span class="line">    statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>几点说明： </p><ul><li><code>exp1</code>、<code>exp2</code>、<code>exp3</code>是三个表达式，其中<code>exp2</code>是判断条件，<code>for</code>循环根据<code>exp2</code>的结果来决定是否继续下一次循环；</li><li><code>statements</code>是循环体语句，可以有一条，也可以有多条；</li><li><code>do</code>和<code>done</code>是<code>Shell</code>中的关键字。</li></ul><p>它的运行过程为：<br> 1) 先执行<code>exp1</code>。</p><p> 2) 再执行<code>exp2</code>，如果它的判断结果是成立的，则执行循环体中的语句，否则结束整个<code>for</code>循环。</p><p> 3) 执行完循环体后再执行<code>exp3</code>。</p><p> 4) 重复执行步骤<code>2)</code>和<code>3)</code>，直到<code>exp2</code>的判断结果不成立，就结束循环。 </p><p>​    <code>exp1</code>仅在第一次循环时执行，以后都不会再执行，可以认为这是一个初始化语句。<code>exp2</code>一般是一个关系表达式，决定了是否还要继续下次循环，称为“循环条件”。<code>exp3</code>很多情况下是一个带有自增或自减运算的表达式，以使循环条件逐渐变得“不成立”。 </p><p>​    计算从 1 加到 100 的和。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">sum=0</span><br><span class="line"></span><br><span class="line">for ((i=1; i&lt;=100; i++))</span><br><span class="line">do</span><br><span class="line">    ((sum += i))</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "The sum is: $sum"</span><br></pre></td></tr></table></figure><p>​    运行结果：<br>​    <code>The sum is: 5050</code></p><h4 id="for-循环中的三个表达式"><a href="#for-循环中的三个表达式" class="headerlink" title="for 循环中的三个表达式"></a>for 循环中的三个表达式</h4><p>​    <code>for</code>循环中的<code>exp1</code>（初始化语句）、<code>exp2</code>（判断条件）和<code>exp3</code>（自增或自减）都是可选项，都可以省略（但分号<code>;</code>必须保留）。 </p><p>1) 修改“从<code>1</code>加到<code>100</code>的和”的代码，省略<code>exp1</code>：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">sum=0</span><br><span class="line">i=1</span><br><span class="line"></span><br><span class="line">for ((; i&lt;=100; i++))</span><br><span class="line">do</span><br><span class="line">    ((sum += i))</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "The sum is: $sum"</span><br></pre></td></tr></table></figure><p>2) 省略<code>exp2</code>，就没有了判断条件，如果不作其他处理就会成为死循环，我们可以在循环体内部使用<code>break</code>关键字强制结束循环：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">sum=0</span><br><span class="line"></span><br><span class="line">for ((i=1; ; i++))</span><br><span class="line">do</span><br><span class="line">    if(( i&gt;100 )); then</span><br><span class="line">        break</span><br><span class="line">    fi</span><br><span class="line">    ((sum += i))</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "The sum is: $sum"</span><br></pre></td></tr></table></figure><p>3) 省略了<code>exp3</code>，就不会修改<code>exp2</code>中的变量，这时可在循环体中加入修改变量的语句。例如：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">sum=0</span><br><span class="line">for ((i=1; i&lt;=100; ))</span><br><span class="line">do</span><br><span class="line">    ((sum += i))</span><br><span class="line">    ((i++))</span><br><span class="line">done</span><br><span class="line">echo "The sum is: $sum"</span><br></pre></td></tr></table></figure><h3 id="Python风格的for-in循环"><a href="#Python风格的for-in循环" class="headerlink" title="Python风格的for in循环"></a><code>Python</code>风格的<code>for in</code>循环</h3><p>​    <code>Python</code>风格的<code>for in</code>循环的用法如下：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for variable in value_list</span><br><span class="line">do</span><br><span class="line">    statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>​    <code>variable</code>表示变量，<code>value_list</code>表示取值列表，<code>in</code>是<code>Shell</code>中的关键字。 </p><blockquote><p> <code>in value_list</code>部分可以省略，省略后的效果相当于<code>in $@</code>。</p></blockquote><p>​    每次循环都会从<code>value_list</code>中取出一个值赋给变量<code>variable</code>，然后进入循环体（<code>do</code>和<code>done</code>之间的部分），执行循环体中的<code>statements</code>。直到取完<code>value_list</code>中的所有值，循环就结束了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">sum=0</span><br><span class="line"></span><br><span class="line">for n in 1 2 3 4 5 6</span><br><span class="line">do</span><br><span class="line">    echo $n</span><br><span class="line">     ((sum+=n))</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "The sum is "$sum</span><br></pre></td></tr></table></figure></p><p>​    运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">The sum is 21</span><br></pre></td></tr></table></figure></p><h4 id="对value-list的说明"><a href="#对value-list的说明" class="headerlink" title="对value_list的说明"></a>对<code>value_list</code>的说明</h4><h5 id="1-直接给出具体的值"><a href="#1-直接给出具体的值" class="headerlink" title="1) 直接给出具体的值"></a>1) 直接给出具体的值</h5><p>​    可以在 in 关键字后面直接给出具体的值，多个值之间以空格分隔，比如<code>1 2 3 4 5</code>、<code>&quot;abc&quot; &quot;390&quot; &quot;tom&quot;</code>等。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">for str in "C语言中文网" "http://c.biancheng.net/" "成立7年了" "日IP数万"</span><br><span class="line">do</span><br><span class="line">    echo $str</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行结果：<br>     C语言中文网<br>     <code>http://c.biancheng.net/</code><br>     成立7年了<br>     日<code>IP</code>数万  </p><h5 id="2-给出一个取值范围"><a href="#2-给出一个取值范围" class="headerlink" title="2) 给出一个取值范围"></a>2) 给出一个取值范围</h5><p>给出一个取值范围的具体格式为： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;start..end&#125;</span><br></pre></td></tr></table></figure><p>​    <code>start</code>表示起始值，<code>end</code>表示终止值；注意中间用两个点号相连，而不是三个点号。这种形式只支持数字和字母。 </p><p>​    例如，计算从 1 加到 100 的和：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">sum=0</span><br><span class="line"></span><br><span class="line">for n in &#123;1..100&#125;</span><br><span class="line">do</span><br><span class="line">    ((sum+=n))</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure><p>​    运行结果：<code>5050</code></p><h5 id="3-使用命令的执行结果"><a href="#3-使用命令的执行结果" class="headerlink" title="3) 使用命令的执行结果"></a>3) 使用命令的执行结果</h5><p>​    使用<code>$()</code>都可以取得命令的执行结果。</p><p>​    计算从 1 到 100 之间所有偶数的和：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">sum=0</span><br><span class="line"></span><br><span class="line">for n in $(seq 2 2 100)  # seq 2 2 100表示从 2 开始，每次增加 2，到 100 结束。</span><br><span class="line">do</span><br><span class="line">    ((sum+=n))</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br><span class="line"></span><br><span class="line">for filename in $(ls *.sh)</span><br><span class="line">do</span><br><span class="line">    echo $filename</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>​    运行结果：<br>​    <code>2550</code><br>​    <code>demo.sh</code><br>​    <code>test.sh</code><br>​    <code>abc.sh</code></p><h5 id="4-使用Shell通配符"><a href="#4-使用Shell通配符" class="headerlink" title="4) 使用Shell通配符"></a>4) 使用<code>Shell</code>通配符</h5><p>​    <code>Shell</code>通配符可以认为是一种精简化的正则表达式，通常用来匹配目录或者文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">for filename in *.sh</span><br><span class="line">do</span><br><span class="line">    echo $filename</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行结果：<br>    <code>demo.sh</code><br>    <code>test.sh</code><br>    <code>abc.sh</code> </p><h5 id="5-使用特殊变量"><a href="#5-使用特殊变量" class="headerlink" title="5) 使用特殊变量"></a>5) 使用特殊变量</h5><p>​    <code>Shell</code>中有多个特殊的变量，在<code>value_list</code>中就可以使用它们。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">function func()&#123;</span><br><span class="line">    for str in $@</span><br><span class="line">    do</span><br><span class="line">        echo $str</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func C++ Java Python C#</span><br></pre></td></tr></table></figure><p>运行结果：<br>    <code>C++</code><br>    <code>Java</code><br>    <code>Python</code><br>    <code>C#</code></p><h2 id="select-in循环"><a href="#select-in循环" class="headerlink" title="select in循环"></a><code>select in</code>循环</h2><p>​    <code>select in</code>循环用来增强交互性，它可以显示出带编号的菜单，用户输入不同的编号就可以选择不同的菜单，并执行不同的功能。 </p><p>​    <code>select in</code>循环的用法如下：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select variable in value_list</span><br><span class="line">do</span><br><span class="line">    statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>​    <code>variable</code>表示变量，<code>value_list</code>表示取值列表，<code>in</code>是<code>Shell</code>中的关键字。</p><p>​    <code>select in</code>循环的例子： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">echo "What is your favourite OS?"</span><br><span class="line">select name in "Linux" "Windows" "Mac OS" "UNIX" "Android"</span><br><span class="line">do</span><br><span class="line">    echo "You have selected $&#123;name&#125;"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p> 运行结果：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">What is your favourite OS?</span><br><span class="line">1) Linux</span><br><span class="line">2) Windows</span><br><span class="line">3) Mac OS</span><br><span class="line">4) UNIX</span><br><span class="line">5) Android</span><br><span class="line"><span class="meta">#</span>? 4↙</span><br><span class="line">You have selected UNIX</span><br><span class="line"><span class="meta">#</span>? 1↙</span><br><span class="line">You have selected Linux</span><br><span class="line"><span class="meta">#</span>? 9↙</span><br><span class="line">You have selected</span><br><span class="line"><span class="meta">#</span>? 2↙</span><br><span class="line">You have selected Windows</span><br><span class="line"><span class="meta">#</span>?^D</span><br></pre></td></tr></table></figure><p>​    <code>#?</code>用来提示用户输入菜单编号；<code>^D</code>表示按下<code>Ctrl+D</code>组合键，它的作用是结束<code>select in</code>循环。  </p><ul><li>运行到<code>select</code>语句后，取值列表<code>value_list</code>中的内容会以菜单的形式显示出来。</li><li>用户输入菜单编号，就表示选中了某个值，这个值就会赋给变量<code>variable</code>，然后再执行循环体中的 <code>statements</code>（<code>do</code>和<code>done</code>之间的部分）。 </li><li>如果用户输入的菜单编号不在范围之内，例如上面我们输入的 9，那么就会给 variable 赋一个空值；如果用户输入一个空值（什么也不输入，直接回车），会重新显示一遍菜单。 </li></ul><p><strong>注意，<code>select</code>是无限循环（死循环），输入空值，或者输入的值无效，都不会结束循环，只有遇到<code>break</code>语句，或者按下<code>Ctrl+D</code>组合键才能结束循环。</strong> </p><h4 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h4><p>​    <code>select in</code>通常和<code>case in</code>一起使用，在用户输入不同的编号时可以做出不同的反应。 </p><p>​    修改上面的代码，加入 case in 语句： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">echo "What is your favourite OS?"</span><br><span class="line">select name in "Linux" "Windows" "Mac OS" "UNIX" "Android"</span><br><span class="line">do</span><br><span class="line">    case $name in</span><br><span class="line">        "Linux")</span><br><span class="line">            echo "Linux是一个类UNIX操作系统，它开源免费，运行在各种服务器设备和嵌入式设备。"</span><br><span class="line">            break</span><br><span class="line">            ;;</span><br><span class="line">        "Windows")</span><br><span class="line">            echo "Windows是微软开发的个人电脑操作系统，它是闭源收费的。"</span><br><span class="line">            break</span><br><span class="line">            ;;</span><br><span class="line">        "Mac OS")</span><br><span class="line">            echo "Mac OS是苹果公司基于UNIX开发的一款图形界面操作系统，只能运行与苹果提供的硬件之上。"</span><br><span class="line">            break</span><br><span class="line">            ;;</span><br><span class="line">        "UNIX")</span><br><span class="line">            echo "UNIX是操作系统的开山鼻祖，现在已经逐渐退出历史舞台，只应用在特殊场合。"</span><br><span class="line">            break</span><br><span class="line">            ;;</span><br><span class="line">        "Android")</span><br><span class="line">            echo "Android是由Google开发的手机操作系统，目前已经占据了70%的市场份额。"</span><br><span class="line">            break</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            echo "输入错误，请重新输入"</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shellIF条件</title>
      <link href="/2018/05/04/shell7-IF%E6%9D%A1%E4%BB%B6/"/>
      <url>/2018/05/04/shell7-IF%E6%9D%A1%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><code>Shell</code> 也支持选择结构，并且有两种形式，分别是<code>if else</code>语句和<code>case in</code>语句。 </p><a id="more"></a><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a><code>if</code>语句</h2><p>​    最简单的用法就是只使用<code>if</code>语句，它的语法格式为： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if  condition</span><br><span class="line">then</span><br><span class="line">    statement(s)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line">if  condition;  then</span><br><span class="line">    statement(s)</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>​    <code>condition</code>是判断条件，如果<code>condition</code>成立（返回“真”），那么<code>then</code>后边的语句将会被执行；如果<code>condition</code>不成立（返回“假”），那么不会执行任何语句。 </p><p>​    当<code>if</code>和<code>then</code>位于同一行的时候， 请注意<code>condition</code>后边的分号<code>;</code>， 这个分号是必须的，否则会有语法错误。  </p><blockquote><p> 从本质上讲，<code>if</code>检测的是命令的退出状态 。</p><p> 注意，最后必须以<code>fi</code>来闭合，<code>fi</code>就是<code>if</code>倒过来拼写。 </p></blockquote><p>​    使用<code>if</code>语句来比较两个数字的大小： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">a=50</span><br><span class="line">b=50</span><br><span class="line"></span><br><span class="line">if (( $a == $b ))</span><br><span class="line">then</span><br><span class="line">    echo "a和b相等"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>​    运行结果：<code>a</code>和<code>b</code>相等 </p><h2 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a><code>if else</code>语句</h2><p>​    如果有两个分支，就可以使用<code>if else</code>语句，它的格式为： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if  condition</span><br><span class="line">then</span><br><span class="line">   statement1</span><br><span class="line">else</span><br><span class="line">   statement2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>​    如果<code>condition</code>成立，那么 then 后边的<code>statement1</code>语句将会被执行；否则，执行<code>else</code>后边的<code>statement2</code>语句。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">a=45</span><br><span class="line">b=50</span><br><span class="line"></span><br><span class="line">if (( $a == $b ))</span><br><span class="line">then</span><br><span class="line">    echo "a和b相等"</span><br><span class="line">else</span><br><span class="line">    echo "a和b不相等，输入错误"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>​    运行结果：<code>a</code>和<code>b</code>不相等，输入错误 </p><h2 id="if-elif-else语句"><a href="#if-elif-else语句" class="headerlink" title="if elif else语句"></a><code>if elif else</code>语句</h2><p>​    <code>Shell</code>支持任意数目的分支，当分支比较多时，可以使用<code>if elif else</code>结构，它的格式为：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if  condition1</span><br><span class="line">then</span><br><span class="line">   statement1</span><br><span class="line">elif condition2</span><br><span class="line">then</span><br><span class="line">    statement2</span><br><span class="line">elif condition3</span><br><span class="line">then</span><br><span class="line">    statement3</span><br><span class="line">……</span><br><span class="line">else</span><br><span class="line">   statementn</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>整条语句的执行逻辑为： </p><ul><li>如果<code>condition1</code>成立，那么就执行<code>if</code>后边的<code>statement1</code>；如果<code>condition1</code>不成立，那么继续执行<code>elif</code>，判断<code>condition2</code>。</li><li>如果<code>condition2</code>成立，那么就执行<code>statement2</code>；如果<code>condition2</code>不成立，那么继续执行后边的<code>elif</code>，判断<code>condition3</code>。</li><li>如果<code>condition3</code>成立，那么就执行<code>statement3</code>；如果<code>condition3</code>不成立，那么继续执行后边的<code>elif</code>。</li><li>如果所有的<code>if</code>和<code>elif</code>判断都不成立，就进入最后的<code>else</code>，执行<code>statementn</code>。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">age=19</span><br><span class="line"></span><br><span class="line">if (( $age &lt;= 2 )); then</span><br><span class="line">    echo "婴儿"</span><br><span class="line">elif (( $age &gt;= 3 &amp;&amp; $age &lt;= 8 )); then</span><br><span class="line">    echo "幼儿"</span><br><span class="line">elif (( $age &gt;= 9 &amp;&amp; $age &lt;= 17 )); then</span><br><span class="line">    echo "少年"</span><br><span class="line">elif (( $age &gt;= 18 &amp;&amp; $age &lt;=25 )); then</span><br><span class="line">    echo "成年"</span><br><span class="line">elif (( $age &gt;= 26 &amp;&amp; $age &lt;= 40 )); then</span><br><span class="line">    echo "青年"</span><br><span class="line">elif (( $age &gt;= 41 &amp;&amp; $age &lt;= 60 )); then</span><br><span class="line">    echo "中年"</span><br><span class="line">else</span><br><span class="line">    echo "老年"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>​    运行结果：成年 </p><h2 id="退出状态"><a href="#退出状态" class="headerlink" title="退出状态"></a>退出状态</h2><p>​    每一条<code>Shell</code>命令，不管是<code>Bash</code>内置命令（例如<code>cd</code>、<code>echo</code>），还是外部的<code>Linux 命令</code>（例如<code>ls</code>、<code>awk</code>），还是自定义的<code>Shell</code>函数，当它退出（运行结束）时，都会返回一个比较小的整数值给调用（使用）它的程序，这就是命令的<strong>退出状态（<code>exit statu</code>）</strong>。  </p><p>​    <strong><code>if</code>语句的判断条件，从本质上讲，判断的就是命令的退出状态。  按照惯例来说，退出状态为<code>0</code>表示“成功”；也就是说，程序执行完成并且没有遇到任何问题。除<code>0</code>以外的其它任何退出状态都为“失败”。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">read a</span><br><span class="line">read b</span><br><span class="line"></span><br><span class="line">(( $a == $b ));</span><br><span class="line"></span><br><span class="line">echo "退出状态："$?</span><br></pre></td></tr></table></figure><p> 运行结果1：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">26</span><br><span class="line">26</span><br><span class="line">退出状态：0</span><br></pre></td></tr></table></figure></p><p> 运行结果2：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">17</span><br><span class="line">39</span><br><span class="line">退出状态：1</span><br></pre></td></tr></table></figure></p><h3 id="退出状态和逻辑运算符的组合"><a href="#退出状态和逻辑运算符的组合" class="headerlink" title="退出状态和逻辑运算符的组合"></a>退出状态和逻辑运算符的组合</h3><p>​    <code>Shell if</code>语句的一个神奇之处是允许我们使用逻辑运算符将多个退出状态组合起来，这样就可以一次判断多个条件了。 </p><table><thead><tr><th>运算符</th><th>使用格式</th><th>说明</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td><code>expression1 &amp;&amp; expression2</code></td><td>逻辑与运算符，当<code>expression1</code>和<code>expression2</code> 同时成立时，整个表达式才成立。    如果检测到<code>expression1</code>的退出状态为 0，就不会再检测<code>expression2</code>了，因为不管<code>expression2</code>的退出状态是什么，整个表达式必然都是不成立的，检测了也是多此一举。</td></tr><tr><td>`</td><td></td><td>`</td><td>` expression1</td><td></td><td>expression2`</td><td>逻辑或运算符，<code>expression1</code>和<code>expression2</code>两个表达式中只要有一个成立，整个表达式就成立。    如果检测到<code>expression1</code>的退出状态为 1，就不会再检测<code>expression2</code>了，因为不管<code>expression2</code>的退出状态是什么，整个表达式必然都是成立的，检测了也是多此一举。</td></tr><tr><td><code>!</code></td><td><code>!expression</code></td><td>逻辑非运算符，相当于“取反”的效果。如果<code>expression</code>成立，那么整个表达式就不成立；如果<code>expression</code>不成立，那么整个表达式就成立。</td></tr></tbody></table><p>【实例】将用户输入的<code>URL</code>写入到文件中。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">read filename</span><br><span class="line">read url</span><br><span class="line"></span><br><span class="line">if test -w $filename &amp;&amp; test -n $url</span><br><span class="line">then</span><br><span class="line">    echo $url &gt; $filename</span><br><span class="line">    echo "写入成功"</span><br><span class="line">else</span><br><span class="line">    echo "写入失败"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>​    在<code>Shell</code>脚本文件所在的目录新建一个文本文件并命名为<code>urls.txt</code>，然后运行<code>Shell</code>脚本，运行结果为：<br> <code>urls.txt</code>↙<br> <code>http://c.biancheng.net/shell/</code>↙<br> 写入成功 </p><h2 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a><code>test</code>命令</h2><p>​    <code>test</code>是<code>Shell</code>内置命令，用来检测某个条件是否成立。<code>test</code>通常和<code>if</code>语句一起使用，并且大部分<code>if</code>语句都依赖<code>test</code>。 </p><p>​    <code>Shell test</code>命令的用法为：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test expression</span><br><span class="line">[ expression ]</span><br></pre></td></tr></table></figure><p>​    当<code>test</code>判断<code>expression</code>成立时，退出状态为<code>0</code>，否则为非<code>0</code>值。<code>test</code>命令也可以简写为<code>[]</code>，  注意<code>[]</code>和<code>expression</code>之间的空格，这两个空格是必须的，否则会导致语法错误。<code>[]</code>的写法更加简洁，比<code>test</code>使用频率高。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">read age</span><br><span class="line"></span><br><span class="line">if test $age -le 2; then</span><br><span class="line">    echo "婴儿"</span><br><span class="line">elif test $age -ge 3 &amp;&amp; test $age -le 8; then</span><br><span class="line">    echo "幼儿"</span><br><span class="line">elif [ $age -ge 9 ] &amp;&amp; [ $age -le 17 ]; then</span><br><span class="line">    echo "少年"</span><br><span class="line">elif [ $age -ge 18 ] &amp;&amp; [ $age -le 25 ]; then</span><br><span class="line">    echo "成年"</span><br><span class="line">elif test $age -ge 26 &amp;&amp; test $age -le 40; then</span><br><span class="line">    echo "青年"</span><br><span class="line">elif test $age -ge 41 &amp;&amp; [ $age -le 60 ]; then</span><br><span class="line">    echo "中年"</span><br><span class="line">else</span><br><span class="line">    echo "老年"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="1-与文件检测相关的test选项"><a href="#1-与文件检测相关的test选项" class="headerlink" title="1) 与文件检测相关的test选项"></a>1) 与文件检测相关的<code>test</code>选项</h3><table><thead><tr><th><strong>文件类型判断</strong></th><th></th></tr></thead><tbody><tr><td>选 项</td><td>作 用</td></tr><tr><td><code>-b filename</code></td><td>判断文件是否存在，并且是否为块设备文件。</td></tr><tr><td><code>-c filename</code></td><td>判断文件是否存在，并且是否为字符设备文件。</td></tr><tr><td><code>-d filename</code></td><td>判断文件是否存在，并且是否为目录文件。</td></tr><tr><td><code>-e filename</code></td><td>判断文件是否存在。</td></tr><tr><td><code>-f filename</code></td><td>判断文件是否存在，井且是否为普通文件。</td></tr><tr><td><code>-L filename</code></td><td>判断文件是否存在，并且是否为符号链接文件。</td></tr><tr><td><code>-p filename</code></td><td>判断文件是否存在，并且是否为管道文件。</td></tr><tr><td><code>-s filename</code></td><td>判断文件是否存在，并且是否为非空。</td></tr><tr><td><code>-S filename</code></td><td>判断该文件是否存在，并且是否为套接字文件。</td></tr><tr><td><strong>文件权限判断</strong></td><td></td></tr><tr><td>选 项</td><td>作 用</td></tr><tr><td><code>-r filename</code></td><td>判断文件是否存在，并且是否拥有读权限。</td></tr><tr><td><code>-w filename</code></td><td>判断文件是否存在，并且是否拥有写权限。</td></tr><tr><td><code>-x filename</code></td><td>判断文件是否存在，并且是否拥有执行权限。</td></tr><tr><td><code>-u filename</code></td><td>判断文件是否存在，并且是否拥有<code>SUID</code>权限。</td></tr><tr><td><code>-g filename</code></td><td>判断文件是否存在，并且是否拥有<code>SGID</code>权限。</td></tr><tr><td><code>-k filename</code></td><td>判断该文件是否存在，并且是否拥有<code>SBIT</code>权限。</td></tr><tr><td><strong>文件比较</strong></td><td></td></tr><tr><td>选 项</td><td>作 用</td></tr><tr><td><code>filename1 -nt filename2</code></td><td>判断<code>filename1</code>的修改时间是否比<code>filename2</code>的新。</td></tr><tr><td><code>filename -ot filename2</code></td><td>判断<code>filename1</code>的修改时间是否比<code>filename2</code>的旧。</td></tr><tr><td><code>filename1 -ef filename2</code></td><td>判断<code>filename1</code>是否和<code>filename2</code>的<code>inode</code>号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法</td></tr></tbody></table><p>​    文件检测举例： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">read filename</span><br><span class="line">read url</span><br><span class="line"></span><br><span class="line">if test -w $filename &amp;&amp; test -n $url</span><br><span class="line">then</span><br><span class="line">    echo $url &gt; $filename</span><br><span class="line">    echo "写入成功"</span><br><span class="line">else</span><br><span class="line">    echo "写入失败"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>​    在<code>Shell 脚本</code>文件所在的目录新建一个文本文件并命名为<code>urls.txt</code>，然后运行<code>Shell</code>脚本，运行结果为：<br>​    <code>urls.txt</code>↙<br>​    <code>http://c.biancheng.net/shell/</code>↙<br>​    写入成功 </p><h3 id="2-与数值比较相关的test选项"><a href="#2-与数值比较相关的test选项" class="headerlink" title="2) 与数值比较相关的test选项"></a>2) 与数值比较相关的<code>test</code>选项</h3><p> 注意，<strong><code>test</code>只能用来比较整数</strong>，小数相关的比较还得依赖<code>bc 命令</code>。 </p><table><thead><tr><th>选 项</th><th>作 用</th></tr></thead><tbody><tr><td><code>num1 -eq num2</code></td><td>判断<code>num1</code>是否和<code>num2</code> 相等。</td></tr><tr><td><code>num1 -ne num2</code></td><td>判断<code>num1</code>是否和<code>num2</code>不相等。</td></tr><tr><td><code>num1 -gt num2</code></td><td>判断<code>num1</code>是否大于<code>num2</code> 。</td></tr><tr><td><code>num1 -lt num2</code></td><td>判断<code>num1</code>是否小于<code>num2</code>。</td></tr><tr><td><code>num1 -ge num2</code></td><td>判断<code>num1</code>是否大于等于<code>num2</code>。</td></tr><tr><td><code>num1 -le num2</code></td><td>判断<code>num1</code>是否小于等于<code>num2</code>。</td></tr></tbody></table><p> 数值比较举例： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">read a b</span><br><span class="line"></span><br><span class="line">if test $a -eq $b</span><br><span class="line">then</span><br><span class="line">    echo "两个数相等"</span><br><span class="line">else</span><br><span class="line">    echo "两个数不相等"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>运行结果1：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 10</span><br><span class="line">两个数相等</span><br></pre></td></tr></table></figure></p><p>运行结果2：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 20</span><br><span class="line">两个数不相等</span><br></pre></td></tr></table></figure></p><h3 id="3-与字符串判断相关的test选项"><a href="#3-与字符串判断相关的test选项" class="headerlink" title="3) 与字符串判断相关的test选项"></a>3) 与字符串判断相关的<code>test</code>选项</h3><table><thead><tr><th>选 项</th><th>作 用</th></tr></thead><tbody><tr><td><code>-z str</code></td><td>判断字符串<code>str</code>是否为空。</td></tr><tr><td><code>-n str</code></td><td>判断宇符串<code>str</code>是否为非空。</td></tr><tr><td><code>str1 = str2  str1 == str2</code></td><td><code>=</code>和<code>==</code>是等价的，都用来判断<code>str1</code>是否和<code>str2</code>相等。</td></tr><tr><td><code>str1 != str2</code></td><td>判断<code>str1</code>是否和<code>str2</code>不相等。</td></tr><tr><td><code>str1 \&gt; str2</code></td><td>判断<code>str1</code>是否大于<code>str2</code>。<code>\&gt;</code>是<code>&gt;</code>的转义字符，这样写是为了防止<code>&gt;</code>被误认为成重定向运算符。</td></tr><tr><td><code>str1 \&lt; str2</code></td><td>判断<code>str1</code>是否小于<code>str2</code>。同样，<code>\&lt;</code>也是转义字符。</td></tr></tbody></table><p>​    <strong>有<code>C语言</code>、<code>C++</code>、<code>Python</code>、<code>Java</code>等编程经验的读者请注意，<code>==</code>、<code>&gt;</code>、<code>&lt;</code>在大部分编程语言中都用来比较数字，而在<code>Shell</code>中，它们只能用来比较字符串，不能比较数字，这是非常奇葩的，大家要习惯。</strong><br>​    <strong>其次，不管是比较数字还是字符串，<code>Shell</code>都不支持<code>&gt;=</code>和<code>&lt;=</code>运算符，切记。</strong> </p><p>​    字符串比较举例：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">read str1</span><br><span class="line">read str2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>检测字符串是否为空</span><br><span class="line">if [ -z "$str1" ] || [ -z "$str2" ]</span><br><span class="line">then</span><br><span class="line">    echo "字符串不能为空"</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>比较字符串</span><br><span class="line">if [ $str1 = $str2 ]</span><br><span class="line">then</span><br><span class="line">    echo "两个字符串相等"</span><br><span class="line">else</span><br><span class="line">    echo "两个字符串不相等"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p> 运行结果：<br> <code>http://c.biancheng.net/</code><br> <code>http://c.biancheng.net/shell/</code><br> 两个字符串不相等 </p><h3 id="4-与逻辑运算相关的test选项"><a href="#4-与逻辑运算相关的test选项" class="headerlink" title="4) 与逻辑运算相关的test选项"></a>4) 与逻辑运算相关的<code>test</code>选项</h3><table><thead><tr><th>选 项</th><th>作 用</th></tr></thead><tbody><tr><td><code>expression1 -a expression</code></td><td>逻辑与，表达式<code>expression1</code>和<code>expression2</code>都成立，最终的结果才是成立的。</td></tr><tr><td><code>expression1 -o expression2</code></td><td>逻辑或，表达式<code>expression1</code>和<code>expression2</code> 有一个成立，最终的结果就成立。</td></tr><tr><td><code>!expression</code></td><td>逻辑非，对 <code>expression</code>进行取反。</td></tr></tbody></table><p> 改写上面的代码，使用逻辑运算选项：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">read str1</span><br><span class="line">read str2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>检测字符串是否为空</span><br><span class="line">if [ -z "$str1" -o -z "$str2" ]  #使用 -o 选项取代之前的 ||</span><br><span class="line">then</span><br><span class="line">    echo "字符串不能为空"</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>比较字符串</span><br><span class="line">if [ $str1 = $str2 ]</span><br><span class="line">then</span><br><span class="line">    echo "两个字符串相等"</span><br><span class="line">else</span><br><span class="line">    echo "两个字符串不相等"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="在test中使用变量建议用双引号包围起来"><a href="#在test中使用变量建议用双引号包围起来" class="headerlink" title="在test中使用变量建议用双引号包围起来"></a>在<code>test</code>中使用变量建议用双引号包围起来</h3><p>​    <code>test</code>和<code>[]</code>都是命令，一个命令本质上对应一个程序或者一个函数。即使是一个程序，它也有入口函数，例如C语言程序的入口函数是<code>main()</code>，运行<code>C</code>语言程序就从<code>main()</code>函数开始，所以也可以将一个程序等效为一个函数，这样我们就不用再区分函数和程序了，直接将一个命令和一个函数对应起来即可。</p><p>​    <strong>使用一个命令其实就是调用一个函数，命令后面附带的选项和参数最终都会作为实参传递给函数。</strong> </p><p>假设 test 命令对应的函数是<code>func()</code>，使用<code>test -z $str1</code></p><ul><li>如果<code>$str1</code>是一个正常的字符串，比如<code>abc123</code>，那么替换后的效果就是<code>test -z abc123</code>，调用<code>func()</code>函数的形式就是<code>func(&quot;-z abc123&quot;)</code>。test 命令后面附带的所有选项和参数会被看成一个整体，并作为实参传递进函数。</li><li>如果<code>$str1</code>是一个空字符串，那么替换后的效果就是<code>test -z</code>，调用<code>func()</code>函数的形式就是<code>func(&quot;-z &quot;)</code>，这就比较奇怪了，因为<code>-z</code>选项没有和参数成对出现，<code>func()</code>在分析时就会出错。</li></ul><p>如果我们给<code>$str1</code> 变量加上双引号，当<code>$str1</code>是空字符串时，<code>test -z &quot;$str1&quot;</code>就会被替换为<code>test -z &quot;&quot;</code>，调用<code>func()</code>函数的形式就是<code>func(&quot;-z \&quot;\&quot;&quot;)</code>，很显然，<code>-z</code>选项后面跟的是一个空字符串（<code>\&quot;</code>表示转义字符），这样<code>func()</code>在分析时就不会出错了。 </p><p>​    <strong>所以，当你在 test 命令中使用变量时，我强烈建议将变量用双引号<code>&quot;&quot;</code>包围起来，这样能避免变量为空值时导致的很多奇葩问题。 </strong></p><h2 id="详解：检测某个条件是否成立"><a href="#详解：检测某个条件是否成立" class="headerlink" title="[[]]详解：检测某个条件是否成立"></a><code>[[]]</code>详解：检测某个条件是否成立</h2><p>​    <code>[[ ]]</code>是<code>Shell</code>内置关键字，它和<code>test</code> 命令类似，也用来检测某个条件是否成立。可以认为<code>[[ ]]</code>是 test 的升级版，对细节进行了优化，并且扩展了一些功能。</p><p>​    <code>[[ ]]</code>的用法为：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ expression ]]</span><br></pre></td></tr></table></figure><p>​    当<code>[[ ]]</code>判断<code>expression</code>成立时，退出状态为<code>0</code>，否则为非<code>0</code>值。注意<code>[[ ]]</code>和<code>expression</code>之间的空格，这两个空格是必须的，否则会导致语法错误。  </p><h3 id="不需要注意某些细枝末节"><a href="#不需要注意某些细枝末节" class="headerlink" title="[[]]不需要注意某些细枝末节"></a><code>[[]]</code>不需要注意某些细枝末节</h3><p>​    <code>[[]]</code>是<code>Shell</code>内置关键字，不是命令，在使用时没有给函数传递参数的过程，所以<code>test</code>命令的某些注意事项在<code>[[ ]]</code>中就不存在了，具体包括： </p><ul><li>不需要把变量名用双引号<code>&quot;&quot;</code>包围起来，即使变量是空值，也不会出错。</li><li>不需要、也不能对<code>&gt;</code>、<code>&lt;</code>进行转义，转义后会出错。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">read str1</span><br><span class="line">read str2</span><br><span class="line"></span><br><span class="line">if [[ -z $str1 ]] || [[ -z $str2 ]]  #不需要对变量名加双引号</span><br><span class="line">then</span><br><span class="line">    echo "字符串不能为空"</span><br><span class="line">elif [[ $str1 &lt; $str2 ]]  #不需要也不能对 &lt; 进行转义</span><br><span class="line">then</span><br><span class="line">    echo "str1 &lt; str2"</span><br><span class="line">else</span><br><span class="line">    echo "str1 &gt;= str2"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p> 运行结果：<br> <code>http://c.biancheng.net/shell/</code><br> <code>http://data.biancheng.net/</code><br> <code>str1</code> &lt; <code>str2</code> </p><h3 id="支持逻辑运算符"><a href="#支持逻辑运算符" class="headerlink" title="[[]]支持逻辑运算符"></a><code>[[]]</code>支持逻辑运算符</h3><p>​    对多个表达式进行逻辑运算时，可以使用逻辑运算符将多个 test 命令连接起来，例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ -z "$str1" ] || [ -z "$str2" ]</span><br><span class="line">[ -z "$str1" -o -z "$str2" ]</span><br></pre></td></tr></table></figure></p><p>​    <code>[[]]</code>支持<code>&amp;&amp;</code>、<code>||</code>和<code>!</code>三种逻辑运算符。  完美的写法是在<code>[[]]</code>命令中使用逻辑运算符将多个表达式连接起来。使用<code>[[]]</code>对上面的语句进行改进：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[ -z $str1 || -z $str2 ]]</span><br><span class="line">[[ -z $str1 ]] || [[ -z $str2 ]]</span><br></pre></td></tr></table></figure><h3 id="支持正则表达式"><a href="#支持正则表达式" class="headerlink" title="[[]]支持正则表达式"></a><code>[[]]</code>支持正则表达式</h3><p> 在<code>Shell [[]]</code>中，可以使用<code>=~</code> 来检测字符串是否符合某个正则表达式，它的用法为：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ str =~ regex ]]</span><br></pre></td></tr></table></figure><p>​    <code>str</code>表示字符串，<code>regex</code>表示正则表达式。 </p><p>​    下面的代码检测一个字符串是否是手机号：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">read tel</span><br><span class="line"></span><br><span class="line">if [[ $tel =~ ^1[0-9]&#123;10&#125;$ ]]</span><br><span class="line">then</span><br><span class="line">    echo "你输入的是手机号码"</span><br><span class="line">else</span><br><span class="line">    echo "你输入的不是手机号码"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>​    运行结果1：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">13203451100</span><br><span class="line">你输入的是手机号码</span><br></pre></td></tr></table></figure></p><p>​    运行结果2：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">132034511009</span><br><span class="line">你输入的不是手机号码</span><br></pre></td></tr></table></figure></p><p>对<code>^1[0-9]{10}$</code> 的说明：  </p><ul><li><code>^</code>匹配字符串的开头（一个位置）；</li><li><code>[0-9]{10}</code>匹配连续的十个数字；</li><li><code>$</code>匹配字符串的末尾（一个位置）。</li></ul><h2 id="case-in语句"><a href="#case-in语句" class="headerlink" title="case in语句"></a><code>case in</code>语句</h2><p>​    当分支较多，并且判断条件比较简单时，使用<code>case in</code>语句就比较方便了。<code>case in</code>的基本格式如下：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case expression in</span><br><span class="line">    pattern1)</span><br><span class="line">        statement1</span><br><span class="line">        ;;</span><br><span class="line">    pattern2)</span><br><span class="line">        statement2</span><br><span class="line">        ;;</span><br><span class="line">    pattern3)</span><br><span class="line">        statement3</span><br><span class="line">        ;;</span><br><span class="line">    ……</span><br><span class="line">    *)</span><br><span class="line">        statementn</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p><code>case</code>、<code>in</code>和<code>esac</code>都是<code>Shell</code>关键字，<code>expression</code>表示表达式，<code>pattern</code>表示匹配模式。 </p><ul><li><code>expression</code>既可以是一个变量、一个数字、一个字符串，还可以是一个数学计算表达式，或者是命令的执行结果，只要能够得到<code>expression</code>的值就可以。</li><li><code>pattern</code>可以是一个数字、一个字符串，甚至是一个简单的正则表达式。</li></ul><p><code>case</code>会将<code>expression</code> 的值与<code>pattern1</code>、<code>pattern2</code>、<code>pattern3</code>逐个进行匹配： </p><ul><li>如果<code>expression</code>和某个模式（比如<code>pattern2</code>）匹配成功，就会执行这模式（比如<code>pattern2</code>）后面对应的所有语句（该语句可以有一条，也可以有多条），直到遇见双分号<code>;;</code>才停止；然后整个<code>case</code>语句就执行完了，程序会跳出整个<code>case</code>语句，执行<code>esac</code>后面的其它语句。</li><li>如果<code>expression</code>没有匹配到任何一个模式，那么就执行<code>*)</code>后面的语句（<code>*</code>表示其它所有值），直到遇见双分号<code>;;</code>或者<code>esac</code>才结束。<code>*)</code>相当于多个<code>if</code>分支语句中最后的<code>else</code>部分。</li></ul><blockquote><p> 如果你有<code>C语言</code>、<code>C++</code>、<code>Java</code>等编程经验，这里的<code>;;</code>和<code>*)</code>就相当于其它编程语言中的<code>break</code>和<code>default</code>。 </p></blockquote><p>对<code>*)</code> 的几点说明：  </p><ul><li><code>Shell case in</code>语句中的<code>*)</code>用来“托底”，万一<code>expression</code>没有匹配到任何一个模式，<code>*)</code>部分可以做一些“善后”工作，或者给用户一些提示。</li><li>可以没有<code>*)</code>部分。如果<code>expression</code>没有匹配到任何一个模式，那么就不执行任何操作。</li></ul><ul><li><p>最后一个分支可以写<code>;;</code>，也可以不写，因为无论如何，执行到<code>esac</code>都会结束整个<code>case in</code>语句。 </p><p>代码如下所示 ：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">printf "Input integer number: "</span><br><span class="line">read num</span><br><span class="line"></span><br><span class="line">case $num in</span><br><span class="line">    1)</span><br><span class="line">        echo "Monday"</span><br><span class="line">        ;;</span><br><span class="line">    2)</span><br><span class="line">        echo "Tuesday"</span><br><span class="line">        ;;</span><br><span class="line">    3)</span><br><span class="line">        echo "Wednesday"</span><br><span class="line">        ;;</span><br><span class="line">    4)</span><br><span class="line">        echo "Thursday"</span><br><span class="line">        ;;</span><br><span class="line">    5)</span><br><span class="line">        echo "Friday"</span><br><span class="line">        ;;</span><br><span class="line">    6)</span><br><span class="line">        echo "Saturday"</span><br><span class="line">        ;;</span><br><span class="line">    7)</span><br><span class="line">        echo "Sunday"</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo "error"</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p> 运行结果：<br> <code>Input integer number:</code>3↙<br> <code>Wednesday</code> </p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell数学计算方法</title>
      <link href="/2018/05/03/shell6-%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/05/03/shell6-%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在<code>Bash Shell</code>中，如果不特别指明，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ echo 2+8</span><br><span class="line">2+8</span><br><span class="line">[c.biancheng.net]$ a=23</span><br><span class="line">[c.biancheng.net]$ b=$a+55</span><br><span class="line">[c.biancheng.net]$ echo $b</span><br><span class="line">23+55</span><br><span class="line">[c.biancheng.net]$ b=90</span><br><span class="line">[c.biancheng.net]$ c=$a+$b</span><br><span class="line">[c.biancheng.net]$ echo $c</span><br><span class="line">23+90</span><br></pre></td></tr></table></figure><p>​    默认情况下，<code>Shell</code>不会直接进行算术运算，而是把<code>+</code>两边的数据（数值或者变量）当做字符串，把<code>+</code>当做字符串连接符，最终的结果是把两个字符串拼接在一起形成一个新的字符串。 </p><a id="more"></a><h2 id="：对整数进行数学运算"><a href="#：对整数进行数学运算" class="headerlink" title="(())：对整数进行数学运算"></a><code>(())</code>：对整数进行数学运算</h2><p>​    双小括号<code>(( ))</code>是<code>Bash Shell</code>中专门用来进行整数运算的命令，<strong>注意：<code>(( ))</code>只能进行整数运算，不能对小数（浮点数）或者字符串进行运算。后续讲到的<code>bc</code>命令可以用于小数运算。 </strong></p><h3 id="的用法"><a href="#的用法" class="headerlink" title="(( )) 的用法"></a>(( )) 的用法</h3><p>​    双小括号 (( )) 的语法格式为： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((表达式))</span><br></pre></td></tr></table></figure><p>​    表达式可以只有一个，也可以有多个，多个表达式之间以逗号<code>,</code>分隔。对于多个表达式的情况，以最后一个表达式的值作为整个<code>(( ))</code>命令的执行结果。 </p><p>​    可以使用<code>$</code>获取<code>(( ))</code>命令的结果，这和使用<code>$</code>获得变量值是类似的。 </p><table><thead><tr><th>运算操作符/运算命令</th><th>说明</th></tr></thead><tbody><tr><td><code>((a=10+66))((b=a-15))  ((c=a+b))</code></td><td>这种写法可以在计算完成后给变量赋值。以<code>((b=a-15))</code>为例，即将<code>a-15</code>的运算结果赋值给变量 c。    注意，使用变量时不用加<code>$</code>前缀，<code>(( ))</code>会自动解析变量名。</td></tr><tr><td><code>a=$((10+66)  b=$((a-15))  c=$((a+b))</code></td><td>可以在 (( )) 前面加上<code>$</code>符号获取<code>(( ))</code>命令的执行结果，也即获取整个表达式的值。以<code>c=$((a+b))</code>为例，即将<code>a+b</code>这个表达式的运算结果赋值给变量 c。                                         <strong>注意，类似<code>c=((a+b))</code>这样的写法是错误的，不加<code>$</code>就不能取得表达式的结果。</strong></td></tr><tr><td><code>((a&gt;7 &amp;&amp; b==c))</code></td><td><code>(( ))</code>也可以进行逻辑运算，在<code>if</code>语句中常会使用逻辑运算。</td></tr><tr><td><code>echo $((a+10))</code></td><td>需要立即输出表达式的运算结果时，可以在<code>(( ))</code>前面加<code>$</code>符号。</td></tr><tr><td><code>((a=3+5, b=a+10))</code></td><td>对多个表达式同时进行计算。</td></tr></tbody></table><p>​    <strong>在 (( )) 中使用变量无需加上<code>$</code>前缀，(( )) 会自动解析变量名。</strong></p><h3 id="实例演示"><a href="#实例演示" class="headerlink" title="(( )) 实例演示"></a>(( )) 实例演示</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ echo $((6-3))</span><br><span class="line">3</span><br><span class="line">[c.biancheng.net]$ i=5</span><br><span class="line">[c.biancheng.net]$ ((i=i*2))  #可以简写为 ((i*=2))。</span><br><span class="line">[c.biancheng.net]$ echo $i   #使用 echo 输出变量结果时要加 $。</span><br><span class="line">10</span><br><span class="line">[c.biancheng.net]$ a=$((100*(100+1)/2)) #利用公式计算1+2+3+...+100的和。</span><br><span class="line">[c.biancheng.net]$ echo $a</span><br><span class="line">5050</span><br><span class="line">[c.biancheng.net]$ echo $((100*(100+1)/2)) #也可以直接输出表达式的结果。</span><br><span class="line">5050</span><br><span class="line">[c.biancheng.net]$ echo $((8==8)) #判断是否相等。</span><br><span class="line">1</span><br><span class="line">[c.biancheng.net]$ if ((8&gt;7&amp;&amp;5==5))</span><br><span class="line"><span class="meta">&gt;</span> then</span><br><span class="line"><span class="meta">&gt;</span> echo yes</span><br><span class="line"><span class="meta">&gt;</span> fi</span><br><span class="line">yes</span><br><span class="line">[c.biancheng.net]$ a=10</span><br><span class="line">[c.biancheng.net]$ echo $((a++))  #如果++在a的后面，那么在输出整个表达式时，会输出a的值,因为a为10，所以表达式的值为10。</span><br><span class="line">10</span><br><span class="line">[c.biancheng.net]$ ((a=3+5, b=a+10))  #先计算第一个表达式，再计算第二个表达式</span><br><span class="line">[c.biancheng.net]$ echo $a $b</span><br><span class="line">8 18</span><br><span class="line">[c.biancheng.net]$ c=$((4+8, a+b))  #以最后一个表达式的结果作为整个(())命令的执行结果</span><br><span class="line">[c.biancheng.net]$ echo $c</span><br><span class="line">26</span><br></pre></td></tr></table></figure><h2 id="let命令：对整数进行数学运算"><a href="#let命令：对整数进行数学运算" class="headerlink" title="let命令：对整数进行数学运算"></a><code>let</code>命令：对整数进行数学运算</h2><p>​    <code>let</code>命令和双小括号<code>(( ))</code>的用法是类似的，它们都是用来对整数进行运算。<strong>注意：和双小括号<code>(( ))</code>一样，<code>let</code>命令也只能进行整数运算，不能对小数（浮点数）或者字符串进行运算。 </strong></p><p>​    <code>Shell let</code>命令的语法格式为： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let 表达式</span><br><span class="line">let "表达式"</span><br><span class="line">let '表达式'</span><br></pre></td></tr></table></figure><p>​    它们都等价于<code>((表达式))</code>。当表达式中含有 Shell 特殊字符（例如 |）时，需要用双引号<code>&quot; &quot;</code>或者单引号<code>&#39; &#39;</code>将表达式包围起来。 </p><p>​    和<code>(( ))</code>类似，<code>let</code>命令也支持一次性计算多个表达式，并且以最后一个表达式的值作为整个<code>let</code>命令的执行结果。但是，对于多个表达式之间的分隔符，<code>let</code>和<code>(( ))</code>是有区别的： </p><ul><li><code>let</code>命令以空格来分隔多个表达式；</li><li><code>(( ))</code>以逗号<code>,</code>来分隔多个表达式。</li></ul><h3 id="let命令实例演示"><a href="#let命令实例演示" class="headerlink" title="let命令实例演示"></a><code>let</code>命令实例演示</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ i=2</span><br><span class="line">[c.biancheng.net]$ let i+=8</span><br><span class="line">[c.biancheng.net]$ echo $i</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">[c.biancheng.net]$ a=10 b=35</span><br><span class="line">[c.biancheng.net]$ let a+=6 c=a+b  #多个表达式以空格为分隔</span><br><span class="line">[c.biancheng.net]$ echo $a $c</span><br><span class="line">16 51</span><br></pre></td></tr></table></figure><h2 id="：对整数进行数学运算-1"><a href="#：对整数进行数学运算-1" class="headerlink" title="$[]：对整数进行数学运算"></a><code>$[]</code>：对整数进行数学运算</h2><p>​    <code>$[]</code>也只能进行整数运算。 </p><p>​    <code>Shell $[]</code>的用法如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$[表达式]</span><br></pre></td></tr></table></figure><p>​    <code>$[]</code>会对<code>表达式</code>进行计算，并取得计算结果。如果<code>表达式</code>中包含了变量，那么你可以加<code>$</code>，也可以不加。  </p><p>​    举例： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ echo $[3*5]  #直接输出结算结果</span><br><span class="line">15</span><br><span class="line">[c.biancheng.net]$ echo $[(3+4)*5]  #使用()</span><br><span class="line">35</span><br><span class="line">[c.biancheng.net]$ n=6</span><br><span class="line">[c.biancheng.net]$ m=$[n*2]  #将计算结果赋值给变量</span><br><span class="line">[c.biancheng.net]$ echo $[m+n]</span><br><span class="line">18</span><br><span class="line">[c.biancheng.net]$ echo $[$m*$n]  #在变量前边加$也是可以的</span><br><span class="line">72</span><br><span class="line">[c.biancheng.net]$ echo $[4*(m+n)]</span><br><span class="line">72</span><br><span class="line"></span><br><span class="line">[c.biancheng.net]$ $[3+4]</span><br><span class="line">bash: 7: 未找到命令...</span><br><span class="line">[c.biancheng.net]$ $[m+3]</span><br><span class="line">bash: 15: 未找到命令...</span><br></pre></td></tr></table></figure><h2 id="expr命令：对整数进行运算"><a href="#expr命令：对整数进行运算" class="headerlink" title="expr命令：对整数进行运算"></a><code>expr</code>命令：对整数进行运算</h2><p>​    <code>expr</code>是一个功能强大，并且比较复杂的命令，它除了可以实现整数计算，还可以结合一些选项对字符串进行处理。</p><p>​    <code>Shell expr</code>对于整数计算的用法为：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr 表达式</span><br></pre></td></tr></table></figure><p>​    <code>expr</code>对表达式的格式有几点特殊的要求： </p><ul><li>出现在<code>表达式</code>中的运算符、数字、变量和小括号的左右两边至少要有一个空格，否则会报错。</li><li>有些特殊符号必须用反斜杠<code>\</code>进行转义（屏蔽其特殊含义），比如乘号<code>*</code>和小括号<code>()</code>，如果不用<code>\</code>转义，那么<code>Shell</code>会把它们误解为正则表达式中的符号（<code>*</code>对应通配符，<code>()</code>对应分组）。</li><li>使用变量时要加<code>$</code>前缀。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ expr 2 +3  #错误：加号和 3 之前没有空格</span><br><span class="line">expr: 语法错误</span><br><span class="line">[c.biancheng.net]$ expr 2 + 3  #这样才是正确的</span><br><span class="line">5</span><br><span class="line">[c.biancheng.net]$ expr 4 * 5  #错误：乘号没有转义</span><br><span class="line">expr: 语法错误</span><br><span class="line">[c.biancheng.net]$ expr 4 \* 5  #使用 \ 转义后才是正确的</span><br><span class="line">20</span><br><span class="line">[c.biancheng.net]$ expr ( 2 + 3 ) \* 4  #小括号也需要转义</span><br><span class="line">bash: 未预期的符号 `2' 附近有语法错误</span><br><span class="line">[c.biancheng.net]$ expr \( 2 + 3 \) \* 4  #使用 \ 转义后才是正确的</span><br><span class="line">20</span><br><span class="line">[c.biancheng.net]$ n=3</span><br><span class="line">[c.biancheng.net]$ expr n + 2  #使用变量时要加 $</span><br><span class="line">expr: 非整数参数</span><br><span class="line">[c.biancheng.net]$ expr $n + 2  #加上 $ 才是正确的</span><br><span class="line">5</span><br><span class="line">[c.biancheng.net]$ m=7</span><br><span class="line">[c.biancheng.net]$ expr $m \* \( $n + 5 \)</span><br><span class="line">56</span><br></pre></td></tr></table></figure><h2 id="bc命令：一款数学计算器"><a href="#bc命令：一款数学计算器" class="headerlink" title="bc命令：一款数学计算器"></a><code>bc</code>命令：一款数学计算器</h2><p>​    <code>bc</code>命令可以很方便的进行浮点运算 </p><p>​    在<code>Shell</code>脚本中，我们可以借助管道或者输入重定向来使用<code>bc</code>计算器。 </p><ul><li>管道是<code>Linux</code>进程间的一种通信机制，它可以将前一个命令（进程）的输出作为下一个命令（进程）的输入，两个命令之间使用竖线<code>|</code>分隔。</li><li>通常情况下，一个命令从终端获得用户输入的内容，如果让它从其他地方（比如文件）获得输入，那么就需要重定向。</li></ul><h3 id="借助管道使用bc计算器"><a href="#借助管道使用bc计算器" class="headerlink" title="借助管道使用bc计算器"></a>借助管道使用<code>bc</code>计算器</h3><p>​    如果读者希望直接输出<code>bc</code>的计算结果，那么可以使用下面的形式： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo "expression" | bc</span><br><span class="line">variable=$(echo "expression" | bc) # variable 就是变量名,可以将 bc 的计算结果赋值给 Shell 变量</span><br></pre></td></tr></table></figure><p>​    <code>expression</code>就是希望计算的数学表达式，它必须符合<code>bc</code>的语法，上面我们已经进行了介绍。在<code>expression</code>中，还可以使用<code>Shell</code>脚本中的变量。 </p><h4 id="最简单的形式"><a href="#最简单的形式" class="headerlink" title="最简单的形式"></a>最简单的形式</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ echo "3*8"|bc</span><br><span class="line">24</span><br><span class="line">[c.biancheng.net]$ ret=$(echo "4+9"|bc)</span><br><span class="line">[c.biancheng.net]$ echo $ret</span><br><span class="line">13</span><br></pre></td></tr></table></figure><h4 id="使用bc中的变量"><a href="#使用bc中的变量" class="headerlink" title="使用bc中的变量"></a>使用<code>bc</code>中的变量</h4><table><thead><tr><th>变量名</th><th>作 用</th></tr></thead><tbody><tr><td><code>scale</code></td><td>指定精度，也即小数点后的位数；默认为<code>0</code>，也即不使用小数部分。</td></tr><tr><td><code>ibase</code></td><td>指定输入的数字的进制，默认为十进制。</td></tr><tr><td><code>obase</code></td><td>指定输出的数字的进制，默认为十进制。</td></tr><tr><td><code>last</code>或者<code>.</code></td><td>表示最近打印的数字</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ echo "scale=4;3*8/7"|bc</span><br><span class="line">3.4285</span><br><span class="line">[c.biancheng.net]$ echo "scale=4;3*8/7;last*5"|bc</span><br><span class="line">3.4285</span><br><span class="line">17.1425</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>十进制转十六进制</span><br><span class="line">[mozhiyan@localhost ~]$ m=31</span><br><span class="line">[mozhiyan@localhost ~]$ n=$(echo "obase=16;$m"|bc)</span><br><span class="line">[mozhiyan@localhost ~]$ echo $n</span><br><span class="line">1F</span><br><span class="line"><span class="meta">#</span>十六进制转十进制</span><br><span class="line">[mozhiyan@localhost ~]$ m=1E</span><br><span class="line">[mozhiyan@localhost ~]$ n=$(echo "obase=10;ibase=16;$m"|bc)</span><br><span class="line">[mozhiyan@localhost ~]$ echo $n</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h4 id="使用bc中的内置函数"><a href="#使用bc中的内置函数" class="headerlink" title="使用bc中的内置函数"></a>使用<code>bc</code>中的内置函数</h4><p>​    除了内置变量，<code>bc</code>还有一些内置函数， 要想使用这些数学函数，在输入<code>bc</code>命令时需要使用<code>-l</code>选项，表示启用数学库 。如下表所示： </p><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td><code>s(x)</code></td><td>计算<code>x</code>的正弦值，<code>x</code>是弧度值。</td></tr><tr><td><code>c(x)</code></td><td>计算<code>x</code>的余弦值，<code>x</code>是弧度值。</td></tr><tr><td><code>a(x)</code></td><td>计算<code>x</code>的反正切值，返回弧度值。</td></tr><tr><td><code>l(x)</code></td><td>计算<code>x</code>的自然对数。</td></tr><tr><td><code>e(x)</code></td><td>求<code>e</code>的<code>x</code>次方。</td></tr><tr><td><code>j(n, x)</code></td><td>贝塞尔函数，计算从<code>n</code>到<code>x</code>的阶数</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ x=4</span><br><span class="line">[c.biancheng.net]$ echo "scale=5;n=$x+2;e(n)"|bc -l</span><br><span class="line">403.42879</span><br></pre></td></tr></table></figure><h3 id="借助输入重定向使用bc计算器"><a href="#借助输入重定向使用bc计算器" class="headerlink" title="借助输入重定向使用bc计算器"></a>借助输入重定向使用<code>bc</code>计算器</h3><p>​    可以使用下面的形式将<code>bc</code>的计算结果赋值给<code>Shell</code>变量：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variable=$(bc &lt;&lt; EOF</span><br><span class="line">expressions</span><br><span class="line">EOF</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>​    其中，<code>variable</code>是 Shell 变量名，<code>express</code>是要计算的数学表达式（可以换行，和进入<code>bc</code>以后的书写形式一样），<code>EOF</code>是数学表达式的开始和结束标识（你也可以换成其它的名字，比如<code>aaa</code>、<code>bbb</code>等）。 </p><p> 请看下面的例子：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ m=1E</span><br><span class="line">[c.biancheng.net]$ n=$(bc &lt;&lt; EOF</span><br><span class="line"><span class="meta">&gt;</span> obase=10;</span><br><span class="line"><span class="meta">&gt;</span> ibase=16;</span><br><span class="line"><span class="meta">&gt;</span> print $m</span><br><span class="line"><span class="meta">&gt;</span> EOF</span><br><span class="line"><span class="meta">&gt;</span> )</span><br><span class="line">[c.biancheng.net]$ echo $n</span><br><span class="line">30</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell内建命令</title>
      <link href="/2018/05/03/shell5-%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/05/03/shell5-%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>所谓<code>Shell</code>内建命令，就是由<code>Bash</code>自身提供的命令，而不是文件系统中的某个可执行文件 </p><a id="more"></a><h2 id="alias：给命令创建别名"><a href="#alias：给命令创建别名" class="headerlink" title="alias：给命令创建别名"></a><code>alias</code>：给命令创建别名</h2><p>​    <code>alisa</code>用来给命令<strong>创建一个别名</strong>。若直接输入该命令且不带任何参数，则列出当前<code>Shell</code>进程中使用了哪些别名。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ alias</span><br><span class="line">alias cp='cp -i'</span><br><span class="line">alias l.='ls -d .* --color=tty'</span><br><span class="line">alias ll='ls -l --color=tty'</span><br><span class="line">alias ls='ls --color=tty'</span><br><span class="line">alias mv='mv -i'</span><br><span class="line">alias rm='rm -i'</span><br><span class="line">alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'</span><br></pre></td></tr></table></figure><h3 id="alias命令自定义别名"><a href="#alias命令自定义别名" class="headerlink" title="alias命令自定义别名"></a><code>alias</code>命令自定义别名</h3><p>​    使用<code>alias</code>命令自定义别名的语法格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias new_name=&apos;command&apos;</span><br></pre></td></tr></table></figure></p><p>​    通过<code>date</code>命令可以获得当前的<code>UNIX</code>时间戳，具体写法为<code>date +%s</code>，如果你嫌弃它太长或者不容易记住，那可以给它定义一个别名。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">alias timestamp='date +%s'</span><br><span class="line"></span><br><span class="line">begin=`timestamp`  </span><br><span class="line">sleep 20s</span><br><span class="line">finish=$(timestamp)</span><br><span class="line">difference=$((finish - begin))</span><br><span class="line"></span><br><span class="line">echo "run time: $&#123;difference&#125;s"</span><br></pre></td></tr></table></figure><p>​    运行脚本，20 秒后看到输出结果：<code>run time: 20s</code></p><h3 id="unalias命令删除别名"><a href="#unalias命令删除别名" class="headerlink" title="unalias命令删除别名"></a><code>unalias</code>命令删除别名</h3><p>使用<code>unalias</code>内建命令可以删除当前<code>Shell</code>进程中的别名。<code>unalias</code>有两种使用方法： </p><ul><li>第一种用法是在命令后跟上某个命令的别名，用于删除指定的别名。</li><li>第二种用法是在命令后接<code>-a</code>参数，删除当前<code>Shell</code>进程中所有的别名。</li></ul><h2 id="echo命令：输出字符串"><a href="#echo命令：输出字符串" class="headerlink" title="echo命令：输出字符串"></a><code>echo</code>命令：输出字符串</h2><p>​    <code>echo</code>是一个<code>Shell</code>内建命令，<strong>用来在终端输出字符串，并在最后默认加上换行符</strong>。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">name="Shell教程"</span><br><span class="line">url="http://c.biancheng.net/shell/"</span><br><span class="line"></span><br><span class="line">echo "读者，你好！"  #直接输出字符串</span><br><span class="line">echo $url  #输出变量</span><br><span class="line">echo "$&#123;name&#125;的网址是：$&#123;url&#125;"  #双引号包围的字符串中可以解析变量</span><br><span class="line">echo '$&#123;name&#125;的网址是：$&#123;url&#125;'  #单引号包围的字符串中不能解析变量</span><br></pre></td></tr></table></figure><p>​    运行结果：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">读者，你好！</span><br><span class="line">http://c.biancheng.net/shell/</span><br><span class="line">Shell教程的网址是：http://c.biancheng.net/shell/</span><br><span class="line"><span class="meta">$</span>&#123;name&#125;的网址是：$&#123;url&#125;</span><br></pre></td></tr></table></figure><h2 id="exit命令：退出当前进程"><a href="#exit命令：退出当前进程" class="headerlink" title="exit命令：退出当前进程"></a>exit命令：退出当前进程</h2><p>​    <code>exit</code>是一个<code>Shell</code>内置命令，用来退出当前<code>Shell</code>进程，并返回一个退出状态；使用<code>$?</code>可以接收这个退出状态。</p><p>​    <code>exit</code>命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。 一般情况下，退出状态为 0 表示成功，退出状态为非 0 表示执行失败（出错）了。<code>exit</code>退出状态只能是一个介于<code>0~255</code>之间的整数，其中只有 0 表示成功，其它值都表示失败。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">echo "befor exit"</span><br><span class="line">exit 8</span><br><span class="line">echo "after exit"</span><br></pre></td></tr></table></figure><p> 运行该脚本：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ bash ./test.sh</span><br><span class="line">befor exit</span><br></pre></td></tr></table></figure><p> 可以看到，<code>&quot;after exit&quot;</code>并没有输出，这说明遇到<code>exit</code>命令后，<code>test.sh</code>执行就结束了。</p><h2 id="declare命令：设置变量属性"><a href="#declare命令：设置变量属性" class="headerlink" title="declare命令：设置变量属性"></a><code>declare</code>命令：设置变量属性</h2><p>​    <code>declare</code>是<code>Shell</code>内建命令，用来<strong>设置变量的属性</strong>。<br>​    <code>declare</code>命令的用法如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare [+/-] [aAfFgilprtux] [变量名=变量值]</span><br></pre></td></tr></table></figure><p>​    其中，<code>-</code>表示设置属性，<code>+</code>表示取消属性，<code>aAfFgilprtux</code>都是具体的选项，它们的含义如下表所示： </p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-f [name]</code></td><td>列出之前由用户在脚本中定义的函数名称和函数体。</td></tr><tr><td><code>-F [name]</code></td><td>仅列出自定义函数名称。</td></tr><tr><td><code>-g name</code></td><td>在 Shell 函数内部创建全局变量。</td></tr><tr><td><code>-p [name]</code></td><td>显示指定变量的属性和值。</td></tr><tr><td><code>-a name</code></td><td>声明变量为普通数组。</td></tr><tr><td><code>-A name</code></td><td>声明变量为关联数组（支持索引下标为字符串）。</td></tr><tr><td><code>-i name</code></td><td>将变量定义为整数型。</td></tr><tr><td><code>-r name[=value]</code></td><td>将变量定义为只读（不可修改和删除），等价于<code>readonly name</code>。</td></tr><tr><td><code>-x name[=value]</code></td><td>将变量设置为环境变量，等价于<code>export name[=value]</code>。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">declare -i m n ret  #将多个变量声明为整数</span><br><span class="line">m=10</span><br><span class="line">n=30</span><br><span class="line">ret=$m+$n</span><br><span class="line">echo $ret  # 40</span><br><span class="line"></span><br><span class="line">declare -r n=10</span><br><span class="line">n=20  # bash: n: 只读变量</span><br><span class="line">echo $n # 10</span><br><span class="line"></span><br><span class="line">declare -r n=10</span><br><span class="line">declare -p n # declare -r n="10"</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell数组</title>
      <link href="/2018/05/02/shell4-%E6%95%B0%E7%BB%84/"/>
      <url>/2018/05/02/shell4-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><code>Shell</code>并且没有限制数组的大小，理论上可以存放无限量的数据。<code>Shell</code>数组元素的下标也是从 0 开始计数。获取数组中的元素要使用下标<code>[ ]</code>，下标可以是一个整数，也可以是一个结果为整数的表达式；当然，下标必须大于等于 0。 常用的<code>Bash Shell</code>只支持一维数组，不支持多维数组。  </p><a id="more"></a><h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><p>​    在 Shell 中，用括号<code>( )</code>来表示数组，数组元素之间用空格来分隔。由此，定义数组的一般形式为：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(ele1  ele2  ele3 ... elen)</span><br></pre></td></tr></table></figure><p>​    注意，赋值号<code>=</code>两边不能有空格，必须紧挨着数组名和数组元素。</p><p>​    Shell 是弱类型的，它并不要求所有数组元素的类型必须相同。 此外，你也无需逐个元素地给数组赋值，可以只给特定元素赋值。</p><p>​    定义数组的实例： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums=(29 100 13 8 91 44)</span><br><span class="line">arr=(20 56 "http://c.biancheng.net/shell/")</span><br><span class="line">ages=([3]=24 [5]=19 [10]=12)  # 只给第 3、5、10 个元素赋值，所以数组长度是 3</span><br></pre></td></tr></table></figure><p>​    <code>Shell</code>数组的长度不是固定的，定义之后还可以增加元素。例如，对于上面的<code>nums</code>数组，它的长度是 6，使用下面的代码会在最后增加一个元素，使其长度扩展到 7：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums[6]=88</span><br></pre></td></tr></table></figure></p><h2 id="获取数组元素"><a href="#获取数组元素" class="headerlink" title="获取数组元素"></a>获取数组元素</h2><p>​    获取数组元素的值，一般使用下面的格式：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&#123;array_name[index]&#125;</span><br></pre></td></tr></table></figure><p>​    其中，<code>array_name</code>是数组名，<code>index</code>是下标。例如：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n=$&#123;nums[2]&#125;  # 表示获取 nums 数组的第二个元素，然后赋值给变量 n。</span><br><span class="line">echo $&#123;nums[3]&#125;  # 表示输出 nums 数组的第 3 个元素。</span><br><span class="line"><span class="meta">$</span>&#123;nums[*]&#125;  # 使用@或*可以获取数组中的所有元素</span><br><span class="line"><span class="meta">$</span>&#123;nums[@]&#125;  # 使用@或*可以获取数组中的所有元素</span><br></pre></td></tr></table></figure><p>​    完整的演示： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">nums=(29 100 13 8 91 44)</span><br><span class="line">echo $&#123;nums[@]&#125;  #输出所有数组元素</span><br><span class="line">nums[10]=66  #给第10个元素赋值（此时会增加数组长度）</span><br><span class="line">echo $&#123;nums[*]&#125;  #输出所有数组元素</span><br><span class="line">echo $&#123;nums[4]&#125;  #输出第4个元素</span><br></pre></td></tr></table></figure><p>​    运行结果： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">29 100 13 8 91 44</span><br><span class="line">29 100 13 8 91 44 66</span><br><span class="line">91</span><br></pre></td></tr></table></figure><h2 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h2><p>​    所谓数组长度，就是数组元素的个数。  利用<code>@</code>或<code>*</code>，可以将数组扩展成列表，然后使用<code>#</code>来获取数组元素的个数，格式如下：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&#123;#array_name[@]&#125;</span><br><span class="line"><span class="meta">$</span>&#123;#array_name[*]&#125;</span><br><span class="line"><span class="meta">$</span>&#123;#arr[2]&#125;   # 获取 arr 数组的第 2 个元素（假设它是字符串）的长度。</span><br></pre></td></tr></table></figure><p>​    其中<code>array_name</code>表示数组名。两种形式是等价的，选择其一即可。 </p><h2 id="数组拼接"><a href="#数组拼接" class="headerlink" title="数组拼接"></a>数组拼接</h2><p>​    所谓<code>Shell</code>数组拼接（数组合并），就是将两个数组连接成一个数组。</p><p>​    拼接数组的思路是：<strong>先利用<code>@</code>或<code>*</code>，将数组扩展成列表，然后再合并到一起。</strong>具体格式如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array_new=($&#123;array1[@]&#125;  $&#123;array2[@]&#125;)</span><br><span class="line">array_new=($&#123;array1[*]&#125;  $&#123;array2[*]&#125;)</span><br></pre></td></tr></table></figure><p>​    <code>array1</code>和<code>array2</code>是需要拼接的数组，<code>array_new</code>是拼接后形成的新数组。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">array1=(23 56)</span><br><span class="line">array2=(99 "http://c.biancheng.net/shell/")</span><br><span class="line">array_new=($&#123;array1[@]&#125; $&#123;array2[*]&#125;)</span><br><span class="line"></span><br><span class="line">echo $&#123;array_new[@]&#125;  #也可以写作 $&#123;array_new[*]&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23 56 99 http://c.biancheng.net/shell/</span><br></pre></td></tr></table></figure><h2 id="删除数组元素"><a href="#删除数组元素" class="headerlink" title="删除数组元素"></a>删除数组元素</h2><p>​    在<code>Shell</code>中，使用<strong><code>unset</code></strong>关键字来删除数组元素，具体格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unset array_name[index]</span><br><span class="line">unset array_name</span><br></pre></td></tr></table></figure></p><p>​    其中，<code>array_name</code>表示数组名，<code>index</code>表示数组下标。  如果不写下标，  就是删除整个数组，所有元素都会消失。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">arr=(23 56 99 "http://c.biancheng.net/shell/")</span><br><span class="line">unset arr[1]</span><br><span class="line">echo $&#123;arr[@]&#125;</span><br><span class="line"></span><br><span class="line">unset arr</span><br><span class="line">echo $&#123;arr[*]&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23 99 http://c.biancheng.net/shell/</span><br></pre></td></tr></table></figure><h2 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h2><p>​    关联数组也称为“键值对（<code>key-value</code>）”数组，键（<code>key</code>）也即字符串形式的数组下标，值（<code>value</code>）也即元素值。 </p><p>​     <strong>不同于普通数组，关联数组必须使用带有<code>-A</code>选项的<code>declare</code>命令创建。</strong>我们可以创建一个叫做 color 的关联数组，并用颜色名字作为下标；也可以在定义的同时赋值：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">declare -A color</span><br><span class="line">color["red"]="#ff0000"</span><br><span class="line">color["green"]="#00ff00"</span><br><span class="line">color["blue"]="#0000ff"</span><br><span class="line"></span><br><span class="line">declare -A color=(["red"]="#ff0000", ["green"]="#00ff00", ["blue"]="#0000ff")</span><br></pre></td></tr></table></figure><h3 id="访问关联数组元素"><a href="#访问关联数组元素" class="headerlink" title="访问关联数组元素"></a>访问关联数组元素</h3><p> 访问关联数组元素的方式几乎与普通数组相同，具体形式为：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array_name["index"]</span><br><span class="line"><span class="meta">$</span>&#123;array_name["index"]&#125;   # 加上$&#123;&#125;即可获取数组元素的值</span><br></pre></td></tr></table></figure><p> 例如： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">color["white"]="#ffffff"</span><br><span class="line">color["black"]="#000000"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 加上$&#123;&#125;即可获取数组元素的值</span><br><span class="line">echo $&#123;color["white"]&#125;</span><br><span class="line">white=$&#123;color["black"]&#125;</span><br></pre></td></tr></table></figure><h3 id="获取所有元素的下标和值"><a href="#获取所有元素的下标和值" class="headerlink" title="获取所有元素的下标和值"></a>获取所有元素的下标和值</h3><p>​    使用下面的形式可以获得关联数组的所有元素值：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&#123;array_name[@]&#125;</span><br><span class="line"><span class="meta">$</span>&#123;array_name[*]&#125;</span><br></pre></td></tr></table></figure></p><p>​    使用下面的形式可以获取关联数组的所有下标值：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&#123;!array_name[@]&#125;</span><br><span class="line"><span class="meta">$</span>&#123;!array_name[*]&#125;</span><br></pre></td></tr></table></figure></p><h3 id="获取关联数组长度"><a href="#获取关联数组长度" class="headerlink" title="获取关联数组长度"></a>获取关联数组长度</h3><p>​    使用下面的形式可以获得关联数组的长度：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&#123;#array_name[*]&#125;</span><br><span class="line"><span class="meta">$</span>&#123;#array_name[@]&#125;</span><br></pre></td></tr></table></figure></p><p>​    关联数组实例演示：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">declare -A color</span><br><span class="line">color["red"]="#ff0000"</span><br><span class="line">color["green"]="#00ff00"</span><br><span class="line">color["blue"]="#0000ff"</span><br><span class="line">color["white"]="#ffffff"</span><br><span class="line">color["black"]="#000000"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>获取所有元素值</span><br><span class="line">for value in $&#123;color[*]&#125;</span><br><span class="line">do</span><br><span class="line">    echo $value</span><br><span class="line">done</span><br><span class="line">echo "****************"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>获取所有元素下标（键）</span><br><span class="line">for key in $&#123;!color[*]&#125;</span><br><span class="line">do</span><br><span class="line">    echo $key</span><br><span class="line">done</span><br><span class="line">echo "****************"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>列出所有键值对</span><br><span class="line">for key in $&#123;!color[@]&#125;</span><br><span class="line">do</span><br><span class="line">    echo "$&#123;key&#125; -&gt; $&#123;color[$key]&#125;"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>ff0000</span><br><span class="line"><span class="meta">#</span>0000ff</span><br><span class="line"><span class="meta">#</span>ffffff</span><br><span class="line"><span class="meta">#</span>000000</span><br><span class="line"><span class="meta">#</span>00ff00</span><br><span class="line">***************</span><br><span class="line">red</span><br><span class="line">blue</span><br><span class="line">white</span><br><span class="line">black</span><br><span class="line">green</span><br><span class="line">***************</span><br><span class="line">red -&gt; #ff0000</span><br><span class="line">blue -&gt; #0000ff</span><br><span class="line">white -&gt; #ffffff</span><br><span class="line">black -&gt; #000000</span><br><span class="line">green -&gt; #00ff00</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell字符串</title>
      <link href="/2018/04/29/shell3-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/04/29/shell3-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>字符串（<code>String</code>）就是一系列字符的组合。字符串可以由单引号<code>&#39; &#39;</code>包围，也可以由双引号<code>&quot; &quot;</code>包围，也可以不用引号。 </p><a id="more"></a><h2 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h2><p>​    字符串举例： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1=c.biancheng.net</span><br><span class="line">str2="shell script"</span><br><span class="line">str3='C语言中文网'</span><br></pre></td></tr></table></figure><p>下面我们说一下三种形式的区别：</p><p> 1) 由单引号<code>&#39; &#39;</code>包围的字符串：  </p><ul><li>任何字符都会原样输出，在<strong>其中使用变量是无效</strong>的。</li><li><p><strong>字符串中不能出现单引号</strong>，即使对单引号进行转义也不行。</p><p>2) 由双引号<code>&quot; &quot;</code>包围的字符串：  </p></li><li><p>如果其中包含了某个变量，那么<strong>该变量会被解析</strong>（得到该变量的值），而不是原样输出。</p></li><li>字符串中<strong>可以出现双引号</strong>，只要它被转义了就行。</li></ul><p>3) 不被引号包围的字符串 </p><ul><li>不被引号包围的字符串中<strong>出现变量时也会被解析</strong>，这一点和双引号<code>&quot; &quot;</code>包围的字符串一样。</li><li><p>字符串中<strong>不能出现空格</strong>，否则空格后边的字符串会作为其他变量或者命令解析。</p><p>我们通过代码来演示一下三种形式的区别：  </p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">n=74</span><br><span class="line">str1=c.biancheng.net$n </span><br><span class="line">str2="shell \"script\" $n"</span><br><span class="line">str3='C语言中文网 $n'</span><br><span class="line"></span><br><span class="line">echo $str1</span><br><span class="line">echo $str2</span><br><span class="line">echo $str3</span><br></pre></td></tr></table></figure><p> 运行结果：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.biancheng.net74</span><br><span class="line">shell "script" 74</span><br><span class="line">C语言中文网 $n</span><br></pre></td></tr></table></figure><p>​    <code>str1</code>中包含了<code>$n</code>，它被解析为变量<code>n</code>的引用。<code>$n</code>后边有空格，紧随空格的是<code>str2</code>；Shell 将<code>str2</code>解释为一个新的变量名，而不是作为字符串<code>str1</code>的一部分。 </p><p>​    <code>str2</code>中包含了引号，但是被转义了（由反斜杠<code>\</code>开头的表示转义字符）。<code>str2</code>中也包含了<code>$n</code>，它也被解析为变量<code>n</code>的引用。 </p><p>​    <code>str3</code>中也包含了<code>$n</code>，但是仅仅是作为普通字符，并没有解析为变量<code>n</code>的引用。  </p><h2 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h2><p> 在<code>Shell</code>中获取字符串长度很简单，具体方法如下：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&#123;#string_name&#125;</span><br></pre></td></tr></table></figure><p>​    <code>string_name</code>表示字符串名字。 </p><p>​    下面是具体的演示：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">str="http://c.biancheng.net/shell/"</span><br><span class="line">echo $&#123;#str&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：<code>29</code></p><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>​    在<code>Shell</code>中你不需要使用任何运算符，将两个字符串并排放在一起就能实现拼接，非常简单粗暴。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">name="Shell"</span><br><span class="line">url="http://c.biancheng.net/shell/"</span><br><span class="line"></span><br><span class="line">str1=$name$url  #中间不能有空格</span><br><span class="line">str2="$name $url"  #如果被双引号包围，那么中间可以有空格</span><br><span class="line">str3=$name": "$url  #中间可以出现别的字符串</span><br><span class="line">str4="$name: $url"  #这样写也可以</span><br><span class="line">str5="$&#123;name&#125;Script: $&#123;url&#125;index.html"  #这个时候需要给变量名加上大括号</span><br><span class="line"></span><br><span class="line">echo $str1</span><br><span class="line">echo $str2</span><br><span class="line">echo $str3</span><br><span class="line">echo $str4</span><br><span class="line">echo $str5</span><br></pre></td></tr></table></figure><p> 运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Shellhttp://c.biancheng.net/shell/</span><br><span class="line">Shell http://c.biancheng.net/shell/</span><br><span class="line">Shell: http://c.biancheng.net/shell/</span><br><span class="line">Shell: http://c.biancheng.net/shell/</span><br><span class="line">ShellScript: http://c.biancheng.net/shell/index.html</span><br></pre></td></tr></table></figure><h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><p>​    <code>Shell</code>截取字符串通常有两种方式：从指定位置开始截取和从指定字符（子字符串）开始截取。  </p><h3 id="从指定位置开始截取"><a href="#从指定位置开始截取" class="headerlink" title="从指定位置开始截取"></a>从指定位置开始截取</h3><p>​    这种方式需要两个参数：除了指<strong>定起始位置</strong>，还需要<strong>截取长度</strong>，才能最终确定要截取的字符串。 </p><h4 id="1-从字符串左边开始计数"><a href="#1-从字符串左边开始计数" class="headerlink" title="1) 从字符串左边开始计数"></a>1) 从字符串左边开始计数</h4><p>​    如果想从字符串的左边开始计数，那么截取字符串的具体格式如下： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&#123;string: start :length&#125;</span><br></pre></td></tr></table></figure><p>​    其中，<code>string</code>是要截取的字符串，<code>start</code>是起始位置（从左边开始，从<code>0</code>开始计数），<code>length</code>是要截取的长度（省略的话表示直到字符串的末尾）。 </p><p>​    例如：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url="c.biancheng.net"</span><br><span class="line">echo $&#123;url: 2: 9&#125;</span><br><span class="line">echo $&#123;url: 2&#125;  #省略 length，截取到字符串末尾</span><br></pre></td></tr></table></figure><p> 结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">biancheng</span><br><span class="line">biancheng.net</span><br></pre></td></tr></table></figure><h4 id="2-从右边开始计数"><a href="#2-从右边开始计数" class="headerlink" title="2) 从右边开始计数"></a>2) 从右边开始计数</h4><p>​    如果想从字符串的右边开始计数，那么截取字符串的具体格式如下： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&#123;string: 0-start :length&#125;</span><br></pre></td></tr></table></figure><p>​    同第 1) 种格式相比，第 2) 种格式仅仅多了<code>0-</code>，这是固定的写法，专门用来表示从字符串右边开始计数。 </p><p>​    这里需要强调两点： </p><ul><li><p><strong>从左边开始计数时，起始数字是 0</strong>（这符合程序员思维）；<strong>从右边开始计数时，起始数字是 1</strong>。计数方向不同，起始数字也不同。</p></li><li><p>不管从哪边开始计数，截取<strong>方向都是从左到右</strong>。</p></li></ul><p>例如： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url="c.biancheng.net"</span><br><span class="line">echo $&#123;url: 0-13: 9&#125;</span><br><span class="line">echo $&#123;url: 0-13&#125;  #省略 length，直接截取到字符串末尾</span><br></pre></td></tr></table></figure><p> 结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">biancheng</span><br><span class="line">biancheng.net</span><br></pre></td></tr></table></figure><h3 id="从指定字符（子字符串）开始截取"><a href="#从指定字符（子字符串）开始截取" class="headerlink" title="从指定字符（子字符串）开始截取"></a>从指定字符（子字符串）开始截取</h3><p>​    这种截取方式无法指定字符串长度，只能从指定字符（子字符串）截取到字符串末尾。 </p><h4 id="1-使用-号截取右边字符"><a href="#1-使用-号截取右边字符" class="headerlink" title="1) 使用#号截取右边字符"></a>1) 使用<code>#</code>号截取右边字符</h4><p>​    使用<code>#</code> 号可以截取指定字符（或者子字符串）右边的所有字符，具体格式如下：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&#123;string#*chars&#125;   # 从第一个指定字符（子字符串）匹配结束</span><br><span class="line"><span class="meta">$</span>&#123;string##*chars&#125;  # 直到最后一个指定字符（子字符串）再匹配结束</span><br></pre></td></tr></table></figure><p>​    其中，<code>string</code>表示要截取的字符，<code>chars</code>是指定的字符（或者子字符串），<code>*</code>是通配符的一种，表示任意长度的字符串。<code>*chars</code>连起来使用的意思是：忽略左边的所有字符，直到遇见<code>chars</code>（<code>chars</code>不会被截取）。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">url="http://c.biancheng.net/index.html"</span><br><span class="line">echo $&#123;url#*:&#125;   # 结果为//c.biancheng.net/index.html</span><br><span class="line">echo $&#123;url#*p:&#125;  # 结果为//c.biancheng.net/index.html</span><br><span class="line">echo $&#123;url#*ttp:&#125;  # 结果为//c.biancheng.net/index.html</span><br><span class="line">echo $&#123;url#http://&#125;  # 结果为c.biancheng.net/index.html</span><br><span class="line">echo $&#123;url#*/&#125;  # 结果为/c.biancheng.net/index.html。url 字符串中有三个/，输出结果表明，Shell 遇到第一个/就匹配结束了。</span><br><span class="line">echo $&#123;url##*/&#125;   # 结果为 index.html</span><br><span class="line"></span><br><span class="line">str="---aa+++aa@@@"</span><br><span class="line">echo $&#123;str#*aa&#125;   #结果为 +++aa@@@</span><br><span class="line">echo $&#123;str##*aa&#125;  #结果为 @@@</span><br></pre></td></tr></table></figure><h4 id="2-使用-截取左边字符"><a href="#2-使用-截取左边字符" class="headerlink" title="2) 使用%截取左边字符"></a>2) 使用<code>%</code>截取左边字符</h4><p>​    使用<code>%</code>号可以截取指定字符（或者子字符串）左边的所有字符，具体格式如下：      </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&#123;string%chars*&#125;</span><br></pre></td></tr></table></figure><p>​    请注意<code>*</code>的位置，因为要截取<code>chars</code>左边的字符，而忽略<code>chars</code>右边的字符，所以<code>*</code>应该位于<code>chars</code>的右侧。其他方面<code>%</code>和<code>#</code>的用法相同，这里不再赘述，仅举例说明：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">url="http://c.biancheng.net/index.html"</span><br><span class="line">echo $&#123;url%/*&#125;  #结果为 http://c.biancheng.net</span><br><span class="line">echo $&#123;url%%/*&#125;  #结果为 http:</span><br><span class="line"></span><br><span class="line">str="---aa+++aa@@@"</span><br><span class="line">echo $&#123;str%aa*&#125;  #结果为 ---aa+++</span><br><span class="line">echo $&#123;str%%aa*&#125;  #结果为 ---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell特殊变量</title>
      <link href="/2018/04/25/shell2-%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F/"/>
      <url>/2018/04/25/shell2-%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Shell位置参数"><a href="#Shell位置参数" class="headerlink" title="Shell位置参数"></a><code>Shell</code>位置参数</h2><p>​        运行<code>Shell</code>脚本文件时我们可以给它传递一些参数，这些参数在脚本文件内部可以使用<code>$n</code>的形式来接收，例如，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数，依次类推。</p><a id="more"></a><p>​        同样，在调用函数时也可以传递参数。<code>Shell</code>函数参数的传递和其它编程语言不同，没有所谓的形参和实参，在定义函数时也不用指明参数的名字和数目。换句话说，定义<code>Shell</code>函数时不能带参数，但是在调用函数时却可以传递参数，这些传递进来的参数，在函数内部就也使用<code>$n</code>的形式接收，例如，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数，依次类推。 </p><p>​        这种通过<code>$n</code>的形式来接收的参数，在<code>Shell</code>中称为位置参数。</p><p>​        在讲解<code>变量的命名</code>时，我们提到：变量的名字必须以字母或者下划线开头，不能以数字开头；但是位置参数却偏偏是数字，这和变量的命名规则是相悖的，所以我们将它们视为“特殊变量”。除了<code>$n</code>，Shell 中还有<code>$#</code>、<code>$*</code>、<code>$@</code>、<code>$?</code>、<code>$$</code>几个特殊参数，我们将在下节讲解。 </p><h3 id="1-给脚本文件传递位置参数"><a href="#1-给脚本文件传递位置参数" class="headerlink" title="1) 给脚本文件传递位置参数"></a>1) 给脚本文件传递位置参数</h3><p>请编写下面的代码，并命名为<code>test.sh</code>： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">echo "Language: $1"</span><br><span class="line">echo "URL: $2"</span><br></pre></td></tr></table></figure><p>运行<code>test.sh</code>，并附带参数： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ cd demo</span><br><span class="line">[mozhiyan@localhost demo]$ . ./test.sh Shell http://c.biancheng.net/shell/</span><br><span class="line">Language: Shell</span><br><span class="line">URL: http://c.biancheng.net/shell/</span><br></pre></td></tr></table></figure><p> 其中<code>Shell</code>是第一个位置参数，<code>http://c.biancheng.net/shell/</code>是第二个位置参数，两者之间以空格分隔。 </p><h3 id="2-给函数传递位置参数"><a href="#2-给函数传递位置参数" class="headerlink" title="2) 给函数传递位置参数"></a>2) 给函数传递位置参数</h3><p> 请编写下面的代码，并命名为<code>test.sh</code>： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>定义函数</span><br><span class="line">function func()&#123;</span><br><span class="line">echo "Language: $1"    </span><br><span class="line">echo "URL: $2"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>调用函数</span><br><span class="line">func C++ http://c.biancheng.net/cplus/</span><br></pre></td></tr></table></figure><p> 运行<code>test.sh</code>： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ cd demo</span><br><span class="line">[mozhiyan@localhost demo]$ . ./test.sh</span><br><span class="line">Language: C++</span><br><span class="line">URL: http://c.biancheng.net/cplus/</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>​        如果参数个数太多，达到或者超过了 10 个，那么就得用<code>${n}</code>的形式来接收了，例如 <code>${10}</code>、<code>${23}</code>。<code>{ }</code>的作用是为了帮助解释器识别参数的边界，这跟使用变量时加<code>{ }</code>是一样的效果。  </p><h2 id="Shell特殊变量"><a href="#Shell特殊变量" class="headerlink" title="Shell特殊变量"></a>Shell特殊变量</h2><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td><code>$0</code></td><td>当前脚本的文件名。</td></tr><tr><td><code>$n</code>（n≥1）</td><td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是<code>$1</code>，第二个参数是<code>$2</code>。</td></tr><tr><td><code>$#</code></td><td>传递给脚本或函数的参数个数。</td></tr><tr><td><code>$*</code></td><td>传递给脚本或函数的所有参数。</td></tr><tr><td><code>$@</code></td><td>传递给脚本或函数的所有参数。当被双引号<code>&quot; &quot;</code>包含时，<code>$@</code>与<code>$*</code>稍有不同。</td></tr><tr><td><code>$?</code></td><td>上个命令的退出状态，或函数的返回值。</td></tr><tr><td><code>$$</code></td><td>当前 Shell 进程<code>ID</code>。对于<code>Shell</code>脚本，就是这些脚本所在的进程 ID。</td></tr></tbody></table><h3 id="1-给脚本文件传递参数"><a href="#1-给脚本文件传递参数" class="headerlink" title="1) 给脚本文件传递参数"></a>1) 给脚本文件传递参数</h3><p> 编写下面的代码，并保存为<code>test.sh</code>： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">echo "Process ID: $$"</span><br><span class="line">echo "File Name: $0"</span><br><span class="line">echo "First Parameter : $1"</span><br><span class="line">echo "Second Parameter : $2"</span><br><span class="line">echo "All parameters 1: $@"</span><br><span class="line">echo "All parameters 2: $*"</span><br><span class="line">echo "Total: $#"</span><br></pre></td></tr></table></figure><p> 运行<code>test.sh</code>，并附带参数： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost demo]$ . ./test.sh Shell Linux</span><br><span class="line">Process ID: 5943</span><br><span class="line">File Name: bash</span><br><span class="line">First Parameter : Shell</span><br><span class="line">Second Parameter : Linux</span><br><span class="line">All parameters 1: Shell Linux</span><br><span class="line">All parameters 2: Shell Linux</span><br><span class="line">Total: 2</span><br></pre></td></tr></table></figure><h3 id="2-给函数传递参数"><a href="#2-给函数传递参数" class="headerlink" title="2) 给函数传递参数"></a>2) 给函数传递参数</h3><p>编写下面的代码，并保存为<code>test.sh</code>： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>定义函数</span><br><span class="line">function func()&#123;    </span><br><span class="line">echo "Language: $1"    </span><br><span class="line">echo "URL: $2"    </span><br><span class="line">echo "First Parameter : $1"    </span><br><span class="line">echo "Second Parameter : $2"    </span><br><span class="line">echo "All parameters 1: $@"    </span><br><span class="line">echo "All parameters 2: $*"    </span><br><span class="line">echo "Total: $#"</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span>调用函数</span><br><span class="line">func Java http://c.biancheng.net/java/</span><br></pre></td></tr></table></figure><p>运行结果为：<br> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Language: Java</span><br><span class="line">URL: http://c.biancheng.net/java/</span><br><span class="line">First Parameter : Java</span><br><span class="line">Second Parameter : http://c.biancheng.net/java/</span><br><span class="line">All parameters 1: Java http://c.biancheng.net/java/</span><br><span class="line">All parameters 2: Java http://c.biancheng.net/java/</span><br><span class="line">Total: 2</span><br></pre></td></tr></table></figure></p><h2 id="命令-和-的区别"><a href="#命令-和-的区别" class="headerlink" title="命令$*和$@的区别"></a>命令<code>$*</code>和<code>$@</code>的区别</h2><p>​        当<code>$*</code>和<code>$@</code>不被双引号<code>&quot; &quot;</code>包围时，它们之间没有任何区别，都是将接收到的每个参数看做一份数据，彼此之间以空格来分隔。 </p><p>​        但是当它们被双引号<code>&quot; &quot;</code> 包含时，就会有区别了：  </p><ul><li><code>&quot;$*&quot;</code>会将所有的参数从整体上看做一份数据，而不是把每个参数都看做一份数据。</li><li><code>&quot;$@&quot;</code>仍然将每个参数都看作一份数据，彼此之间是独立的。</li></ul><p>比如传递了 5 个参数，那么对于<code>&quot;$*&quot;</code>来说，这 5 个参数会合并到一起形成一份数据，它们之间是无法分割的；而对于<code>&quot;$@&quot;</code>来说，这 5 个参数是相互独立的，它们是 5 份数据。 </p><p>​        如果使用 echo 直接输出<code>&quot;$*&quot;</code>和<code>&quot;$@&quot;</code>做对比，是看不出区别的；但如果使用 for 循环来逐个输出数据，立即就能看出区别来。  </p><p>编写下面的代码，并保存为<code>test.sh</code>： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">echo "print each param from \"\$*\""</span><br><span class="line"></span><br><span class="line">for var in "$*"</span><br><span class="line">do    </span><br><span class="line">echo "$var"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "print each param from \"\$@\""</span><br><span class="line">for var in "$@"</span><br><span class="line">do   </span><br><span class="line">echo "$var"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p> 运行<code>test.sh</code>，并附带参数： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost demo]$ . ./test.sh a b c d</span><br><span class="line">print each param from "$*"</span><br><span class="line">a b c d</span><br><span class="line">print each param from "$@"</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure><p>​        从运行结果可以发现，对于<code>&quot;$*&quot;</code>，只循环了 1 次，因为它只有 1 分数据；对于<code>&quot;$@&quot;</code>，循环了 5 次，因为它有 5 份数据。 </p><h2 id="命令-的含义"><a href="#命令-的含义" class="headerlink" title="命令$?的含义"></a>命令<code>$?</code>的含义</h2><p>​        <code>$?</code>是一个特殊变量，用来获取上一个命令的退出状态，或者上一个函数的返回值。</p><p>​        所谓退出状态，就是上一个命令执行后的返回结果。退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1，这和<code>C语言</code>的<code>main()</code>函数是类似的。 </p><h3 id="1-获取上一个命令的退出状态"><a href="#1-获取上一个命令的退出状态" class="headerlink" title="1) $?获取上一个命令的退出状态"></a>1) <code>$?</code>获取上一个命令的退出状态</h3><p> 编写下面的代码，并保存为<code>test.sh</code>： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">if [ "$1" == 100 ]</span><br><span class="line">then   </span><br><span class="line">exit 0  #参数正确，退出状态为0</span><br><span class="line">else   </span><br><span class="line">exit 1  #参数错误，退出状态1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><code>exit</code>表示退出当前<code>shell</code>进程，我们必须在新进程中运行<code>test.sh</code>，否则当前<code>Shell</code>会话（终端窗口）会被关闭，我们就无法取得它的退出状态了。</p><p>例如，运行<code>test.sh</code>时传递参数 100： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ cd demo</span><br><span class="line">[mozhiyan@localhost demo]$ bash ./test.sh 100  #作为一个新进程运行</span><br><span class="line">[mozhiyan@localhost demo]$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>再如，运行<code>test.sh</code>时传递参数 89： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost demo]$ bash ./test.sh 89  #作为一个新进程运行</span><br><span class="line">[mozhiyan@localhost demo]$ echo $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="2-获取函数的返回值"><a href="#2-获取函数的返回值" class="headerlink" title="2)$?获取函数的返回值"></a>2)<code>$?</code>获取函数的返回值</h3><p> 编写下面的代码，并保存为<code>test.sh</code>： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>得到两个数相加的和</span><br><span class="line">function add()&#123;    </span><br><span class="line">return `expr $1 + $2`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>调用函数</span><br><span class="line">add 23 50 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>获取函数返回值</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure><p>运行结果：73</p><p>​    严格来说，<code>Shell</code>函数中的<code>return</code>关键字用来表示函数的退出状态，而不是函数的返回值；<code>Shell</code>不像其它编程语言，没有专门处理返回值的关键字。 </p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell变量</title>
      <link href="/2018/04/22/shell1-%E5%8F%98%E9%87%8F/"/>
      <url>/2018/04/22/shell1-%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>变量是任何一种编程语言都必不可少的组成部分，变量用来存放各种数据。脚本语言在定义变量时通常不需要指明类型，直接赋值就可以，<code>Shell</code>变量也遵循这个规则。</p><p>​        在<code>Bash shell</code>中，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。</p><p>​        这意味着，<code>Bash shell</code>在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串，这一点和大部分的编程语言不同。例如在<code>C语言</code>或者<code>C++</code>中，变量分为整数、小数、字符串、布尔等多种类型。</p><p>​        当然，如果有必要，你也可以使用<code>Shell declare</code>关键字显式定义变量的类型，但在一般情况下没有这个需求，<code>Shell</code>开发者在编写代码时自行注意值的类型即可。</p><a id="more"></a><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p><code>Shell</code>支持以下三种定义变量的方式： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable=value</span><br><span class="line">variable='value'</span><br><span class="line">variable="value"</span><br></pre></td></tr></table></figure><p>​        <code>variable</code>是变量名，<code>value</code>是赋给变量的值。如果<code>value</code>不包含任何空白符（例如空格、<code>Tab</code>缩进等），那么可以不使用引号；如果<code>value</code>包含了空白符，那么就必须使用引号包围起来。使用单引号和使用双引号也是有区别的，稍后我们会详细说明。</p><blockquote><p><strong>注意，赋值号<code>=</code>的周围不能有空格，这可能和你熟悉的大部分编程语言都不一样。</strong></p></blockquote><ul><li>变量名由数字、字母、下划线组成；</li><li>必须以字母或者下划线开头；</li><li>不能使用<code>Shell</code>里的关键字（通过<code>help</code>命令可以查看保留关键字）。</li></ul><p> 变量定义举例： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url=http://c.biancheng.net/shell/</span><br><span class="line">echo $url</span><br><span class="line">name='C语言中文网'</span><br><span class="line">echo $name</span><br><span class="line">author="严长生"</span><br><span class="line">echo $author</span><br></pre></td></tr></table></figure><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>​        使用一个定义过的变量，只要在变量名前面加美元符号<code>$</code> 即可，如：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">author="严长生"</span><br><span class="line">echo $author</span><br><span class="line">echo $&#123;author&#125;</span><br></pre></td></tr></table></figure><p>​        变量名外面的花括号<code>{ }</code>是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">skill="Java"</span><br><span class="line">echo "I am good at $&#123;skill&#125;Script"</span><br></pre></td></tr></table></figure><p>​        如果不给<code>skill</code>变量加花括号，写成<code>echo &quot;I am good at $skillScript&quot;</code> ，解释器就会把<code>$skillScript</code>当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p>​        推荐给所有变量加上花括号<code>{ }</code>，这是个良好的编程习惯。</p><h2 id="修改变量的值"><a href="#修改变量的值" class="headerlink" title="修改变量的值"></a>修改变量的值</h2><p>​        已定义的变量，可以被重新赋值，如： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url="http://c.biancheng.net"</span><br><span class="line">echo $&#123;url&#125;</span><br><span class="line">url="http://c.biancheng.net/shell/"</span><br><span class="line">echo $&#123;url&#125;</span><br></pre></td></tr></table></figure><p>​        第二次对变量赋值时不能在变量名前加<code>$</code>，只有在使用变量时才能加<code>$</code>。  </p><h2 id="单引号和双引号的区别"><a href="#单引号和双引号的区别" class="headerlink" title="单引号和双引号的区别"></a>单引号和双引号的区别</h2><p>​        前面我们还留下一个疑问，定义变量时，变量的值可以由单引号<code>&#39; &#39;</code>包围，也可以由双引号<code>&quot; &quot;</code>包围，它们到底有什么区别呢？不妨以下</p><p>面的代码为例来说明：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">url="http://c.biancheng.net"</span><br><span class="line">website1='C语言中文网：$&#123;url&#125;'</span><br><span class="line">website2="C语言中文网：$&#123;url&#125;"</span><br><span class="line">echo $website1</span><br><span class="line">echo $website2</span><br></pre></td></tr></table></figure><p>​    运行结果：<br>C语言中文网：<code>${url}</code><br>C语言中文网：<code>http://c.biancheng.net</code></p><p>​        以单引号<code>&#39; &#39;</code>包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。</p><p>​        以双引号<code>&quot; &quot;</code>包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。</p><p>​        我的建议：如果变量的内容是数字，那么可以不加引号；如果真的需要原样输出就加单引号；其他没有特别要求的字符串等最好都加上双引号，定义变量时加双引号是最常见的使用场景。 </p><h2 id="将命令的结果赋值给变量"><a href="#将命令的结果赋值给变量" class="headerlink" title="将命令的结果赋值给变量"></a>将命令的结果赋值给变量</h2><p>​        <code>Shell</code>也支持将命令的执行结果赋值给变量，常见的有以下两种方式： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variable=`command`</span><br><span class="line">variable=$(command)</span><br></pre></td></tr></table></figure><p>​        第一种方式把命令用反引号（位于<code>Esc</code>键的下方）包围起来，反引号和单引号非常相似，容易产生混淆，所以不推荐使用这种方式；第二种方式把命令用<code>$()</code>包围起来，区分更加明显，所以推荐使用这种方式。</p><p>​        例如，我在<code>demo</code>目录中创建了一个名为<code>log.txt</code>的文本文件，用来记录我的日常工作。下面的代码中，使用 <code>cat</code>命令将<code>log.txt</code>的内容读取出来，并赋值给一个变量，然后使用 echo 命令输出。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ cd demo</span><br><span class="line">[mozhiyan@localhost demo]$ log=$(cat log.txt)</span><br><span class="line">[mozhiyan@localhost demo]$ echo $log</span><br><span class="line">严长生正在编写Shell教程，教程地址：http://c.biancheng.net/shell/</span><br><span class="line">[mozhiyan@localhost demo]$ log=`cat log.txt`</span><br><span class="line">[mozhiyan@localhost demo]$ echo $log</span><br><span class="line">严长生正在编写Shell教程，教程地址：http://c.biancheng.net/shell/</span><br></pre></td></tr></table></figure><h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>​        使用 <strong><code>readonly</code></strong> 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><p> 下面的例子尝试更改只读变量，结果报错：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">myUrl="http://c.biancheng.net/shell/"</span><br><span class="line">readonly myUrl</span><br><span class="line">myUrl="http://c.biancheng.net/shell/"</span><br></pre></td></tr></table></figure><p> 运行脚本，结果如下： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash: myUrl: This variable is read only.</span><br></pre></td></tr></table></figure><h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>​        使用 <strong><code>unset</code></strong> 命令可以删除变量。语法：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset variable_name</span><br></pre></td></tr></table></figure><p>​        变量被删除后不能再次使用；<code>unset</code>命令不能删除只读变量。</p><p>​        举个例子：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line"></span><br><span class="line">myUrl="http://c.biancheng.net/shell/"</span><br><span class="line"></span><br><span class="line">unset myUrl</span><br><span class="line">echo $myUrl</span><br></pre></td></tr></table></figure><p>​        上面的脚本没有任何输出。</p><p><code>Shell</code>变量的作用域（<code>Scope</code>） ，就是<code>Shell</code>变量的有效范围（可以使用的范围）。</p><p>​        在不同的作用域中，同名的变量不会相互干涉，就好像 A 班有个叫小明的同学，B  班也有个叫小明的同学，虽然他们都叫小明（对应于变量名），但是由于所在的班级（对应于作用域）不同，所以不会造成混乱。但是如果同一个班级中有两个叫小明的同学，就必须用类似于“大小明”、“小小明”这样的命名来区分他们。</p><p>​        <code>Shell</code>变量的作用域可以分为三种：  </p><ul><li>有的变量只能在函数内部使用，这叫做局部变量（<code>local variable</code>）；</li><li>有的变量可以在当前<code>Shell</code>进程中使用，这叫做全局变量（<code>global variable</code>）；</li><li>而有的变量还可以在子进程中使用，这叫做环境变量（<code>environment variable</code>）。</li></ul><h2 id="Shell局部变量"><a href="#Shell局部变量" class="headerlink" title="Shell局部变量"></a><code>Shell</code>局部变量</h2><p>​        <code>Shell</code>也支持自定义函数，但是<code>Shell</code>函数和<code>C++</code>、<code>Java</code>、<code>C#</code>等其他编程语言函数的一个不同点就是：在 Shell 函数中定义的变量默认也是全局变量，它和在函数外部定义变量拥有一样的效果。请看下面的代码： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>定义函数</span><br><span class="line">function func()&#123;</span><br><span class="line">    a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span>调用函数</span><br><span class="line">func</span><br><span class="line"><span class="meta">#</span>输出函数内部的变量</span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure><p>​        输出结果：<br>​        <code>99</code></p><p>​        <code>a</code>是在函数内部定义的，但是在函数外部也可以得到它的值，证明它的作用域是全局的，而不是仅限于函数内部。要想变量的作用域仅限于函数内部，可以在定义时加上<code>local</code>命令，此时该变量就成了局部变量。请看下面的代码：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>定义函数</span><br><span class="line">function func()&#123;</span><br><span class="line">    local a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span>调用函数</span><br><span class="line">func</span><br><span class="line"><span class="meta">#</span>输出函数内部的变量</span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure><p>​        输出结果为空，表明变量<code>a</code>在函数外部无效，是一个局部变量。</p><p>​        <code>Shell</code>变量的这个特性和<code>JavaScript</code>中的变量是类似的。在<code>JavaScript</code>函数内部定义的变量，默认也是全局变量，只有加上<code>var</code>关键字，它才会变成局部变量。</p><h2 id="Shell全局变量"><a href="#Shell全局变量" class="headerlink" title="Shell全局变量"></a><code>Shell</code>全局变量</h2><p>​        所谓全局变量，就是指变量在当前的整个<code>Shell</code>进程中都有效。每个<code>Shell</code>进程都有自己的作用域，彼此之间互不影响。在<code>Shell</code>中定义的变量，默认就是全局变量。</p><p>​        想要实际演示全局变量在不同<code>Shell</code>进程中的互不相关性，可在图形界面下同时打开两个<code>Shell</code>，或使用两个终端远程连接到服务器（<code>SSH</code>）。</p><p>​        首先打开一个<code>Shell</code>窗口，定义一个变量<code>a</code>并赋值为<code>99</code>，然后打印，这时在同一个<code>Shell</code>窗口中是可正确打印变量<code>a</code>的值的。然后再打开一个新的<code>Shell</code>窗口，同样打印变量<code>a</code>的值，但结果却为空，如图 1 所示。 </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1P930113JUZ.png" alt></p><p>​        这说明全局变量 a 仅仅在定义它的第一个<code>Shell</code>进程中有效，对新的<code>Shell</code>进程没有影响。这很好理解，就像小王家和小徐家都有一部电视机（变量名相同），但是同一时刻小王家和小徐家的电视中播放的节目可以是不同的（变量值不同）。</p><p>​        需要强调的是，全局变量的作用范围是当前的<code>Shell</code>进程，而不是当前的<code>Shell</code>脚本文件，它们是不同的概念。打开一个<code>Shell</code>窗口就创建了一个<code>Shell</code>进程，打开多个 Shell 窗口就创建了多个<code>Shell</code>进程，每个<code>Shell</code>进程都是独立的，拥有不同的进程<code>ID</code>。在一个<code>Shell</code>进程中可以使用<strong><code>source</code></strong>命令执行多个<code>Shell</code>脚本文件，此时全局变量在这些脚本文件中都有效。</p><p>​        例如，现在有两个<code>Shell</code>脚本文件，分别是<code>a.sh</code>和<code>b.sh</code>。<code>a.sh</code>的代码如下：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">echo $a</span><br><span class="line">b=200</span><br></pre></td></tr></table></figure><p>​        <code>b.sh</code>的代码如下：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">echo $b</span><br></pre></td></tr></table></figure><p>​        打开一个<code>Shell</code>窗口，输入以下命令：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ a=99</span><br><span class="line">[c.biancheng.net]$ . ./a.sh</span><br><span class="line">99</span><br><span class="line">[c.biancheng.net]$ . ./b.sh</span><br><span class="line">200</span><br></pre></td></tr></table></figure><p>​        这三条命令都是在一个进程中执行的，从输出结果可以发现，在<code>Shell</code>窗口中以命令行的形式定义的变量<code>a</code>，在<code>a.sh</code>中有效；在<code>a.sh</code>中定义的变量<code>b</code>，在<code>b.sh</code>中也有效，变量<code>b</code>的作用范围已经超越了<code>a.sh</code>。</p><p>​        注意，必须在当前进程中运行 Shell 脚本，不能在新进程中运行 Shell 脚本。</p><h2 id="Shell环境变量"><a href="#Shell环境变量" class="headerlink" title="Shell环境变量"></a><code>Shell</code>环境变量</h2><p>​        全局变量只在当前<code>Shell</code>进程中有效，对其它<code>Shell</code>进程和子进程都无效。如果使用<code>export</code> 命令将全局变量导出，那么它就在所有的子进程中也有效了，这称为“环境变量”。</p><p>​        环境变量被创建时所处的<code>Shell</code>进程称为父进程，如果在父进程中再创建一个新的进程来执行<code>Shell</code>命令，那么这个新的进程被称作<code>Shell</code>子进程。当<code>Shell</code>子进程产生时，它会继承父进程的环境变量为自己所用，所以说环境变量可从父进程传给子进程。不难理解，环境变量还可以传递给孙进程。</p><p>​        注意，两个没有父子关系的<code>Shell</code>进程是不能传递环境变量的，并且环境变量只能向下传递而不能向上传递，即“传子不传父”。</p><p>​        创建<code>Shell</code>子进程最简单的方式是运行<code>bash</code>命令，如图 2 所示。 </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1Z41QJGN02.gif" alt></p><p>​        通过<code>exit</code>命令可以一层一层地退出<code>Shell</code>。</p><p>​        下面演示一下环境变量的使用：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ a=22       #定义一个全局变量</span><br><span class="line">[c.biancheng.net]$ echo $a    #在当前Shell中输出a，成功</span><br><span class="line">22</span><br><span class="line">[c.biancheng.net]$ bash       #进入Shell子进程</span><br><span class="line">[c.biancheng.net]$ echo $a    #在子进程中输出a，失败</span><br><span class="line"></span><br><span class="line">[c.biancheng.net]$ exit       #退出Shell子进程，返回上一级Shell</span><br><span class="line">exit</span><br><span class="line">[c.biancheng.net]$ export a   #将a导出为环境变量</span><br><span class="line">[c.biancheng.net]$ bash       #重新进入Shell子进程</span><br><span class="line">[c.biancheng.net]$ echo $a    #在子进程中再次输出a，成功</span><br><span class="line">22</span><br><span class="line">[c.biancheng.net]$ exit       #退出Shell子进程</span><br><span class="line">exit</span><br><span class="line">[c.biancheng.net]$ exit       #退出父进程，结束整个Shell会话</span><br></pre></td></tr></table></figure><p>​        可以发现，默认情况下，<code>a</code>在<code>Shell</code>子进程中是无效的；使用<code>export</code>将<code>a</code>导出为环境变量后，在子进程中就可以使用了。</p><p>​        <code>export a</code>这种形式是在定义变量<code>a</code>以后再将它导出为环境变量，如果想在定义的同时导出为环境变量，可以写作<code>export a=22</code>。</p><p>​        我们一直强调的是环境变量在 Shell 子进程中有效，并没有说它在所有的<code>Shell</code>进程中都有效；如果你通过终端创建了一个新的<code>Shell</code>窗口，那它就不是当前<code>Shell</code>的子进程，环境变量对这个新的<code>Shell</code>进程仍然是无效的。请看下图：  </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1Z41QKS3523.gif" alt></p><p>​        第一个窗口中的环境变量<code>a</code>在第二个窗口中就无效。 </p><h4 id="环境变量也是临时的"><a href="#环境变量也是临时的" class="headerlink" title="环境变量也是临时的"></a>环境变量也是临时的</h4><p>​        通过<code>export</code>导出的环境变量只对当前<code>Shell</code>进程以及所有的子进程有效，如果最顶层的父进程被关闭了，那么环境变量也就随之消失了，其它的进程也就无法使用了，所以说环境变量也是临时的。</p><h2 id="Shell命令替换"><a href="#Shell命令替换" class="headerlink" title="Shell命令替换"></a><code>Shell</code>命令替换</h2><p><code>Shell</code>命令替换是指将命令的输出结果赋值给某个变量。比如，在某个目录中输入<code>ls</code>命令可查看当前目录中所有的文件，但如何将输出内容存入某个变量中呢？这就需要使用命令替换了，这也是<code>Shell</code>编程中使用非常频繁的功能。</p><p>​        <code>Shell</code>中有两种方式可以完成命令替换，一种是反引号，一种是<code>$()</code>，使用方法如下： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variable=`commands`</span><br><span class="line">variable=$(commands)</span><br></pre></td></tr></table></figure><p>​        其中，<code>variable</code>是变量名，<code>commands</code>是要执行的命令。<code>commands</code>可以只有一个命令，也可以有多个命令，多个命令之间以分号<code>;</code>分隔。</p><p>​        例如，<code>date</code>命令用来获得当前的系统时间，使用命令替换可以将它的结果赋值给一个变量。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">begin_time=`date`    #开始时间，使用``替换</span><br><span class="line">sleep 20s            #休眠20秒</span><br><span class="line">finish_time=$(date)  #结束时间，使用$()替换</span><br><span class="line">echo "Begin time: $begin_time"</span><br><span class="line">echo "Finish time: $finish_time"</span><br></pre></td></tr></table></figure><p>​        运行脚本，20 秒后可以看到输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Begin time: 2019年 04月 19日 星期五 09:59:58 CST</span><br><span class="line">Finish time: 2019年 04月 19日 星期五 10:00:18 CST</span><br></pre></td></tr></table></figure><p>​        使用 data 命令的<code>%s</code>格式控制符可以得到当前的<code>UNIX</code>时间戳，这样就可以直接计算脚本的运行时间了。<code>UNIX</code>时间戳是指从<code>1970 年 1 月 1 日 00:00:00</code>到目前为止的秒数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">begin_time=`date +%s`    #开始时间，使用``替换</span><br><span class="line">sleep 20s                #休眠20秒</span><br><span class="line">finish_time=$(date +%s)  #结束时间，使用$()替换</span><br><span class="line">run_time=$((finish_time - begin_time))  #时间差</span><br><span class="line">echo "begin time: $begin_time"</span><br><span class="line">echo "finish time: $finish_time"</span><br><span class="line">echo "run time: $&#123;run_time&#125;s"</span><br></pre></td></tr></table></figure><p>​         运行脚本，20 秒后可以看到输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin time: 1555639864</span><br><span class="line">finish time: 1555639884</span><br><span class="line">run time: 20s</span><br></pre></td></tr></table></figure><p>​        第 6 行代码中的<code>(( ))</code>是 Shell 数学计算命令。和<code>C++</code>、<code>C#</code>、<code>Java</code> 等编程语言不同，在 Shell 中进行数据计算不那么方便，必须使用专门的数学计算命令，<code>(( ))</code>就是其中之一。</p><p>​        注意，如果被替换的命令的输出内容包括多行（也即有换行符），或者含有多个连续的空白符，那么在输出变量时应该将变量用双引号包围，否则系统会使用默认的空白符来填充，这会导致换行无效，以及连续的空白符被压缩成一个。请看下面的代码：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">LSL=`ls -l`</span><br><span class="line">echo $LSL  #不使用双引号包围</span><br><span class="line">echo "--------------------------"  #输出分隔符</span><br><span class="line">echo "$LSL"  #使用引号包围</span><br></pre></td></tr></table></figure><pre><code>运行结果：  </code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">total 8 drwxr-xr-x. 2 root root 21 7月 1 2016 abc -rw-rw-r--. 1 mozhiyan mozhiyan 147 10月 31 10:29 demo.sh -rw-rw-r--. 1 mozhiyan mozhiyan 35 10月 31 10:20 demo.sh~</span><br><span class="line">--------------------------</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x. 2 root     root      21 7月   1 2016 abc</span><br><span class="line">-rw-rw-r--. 1 mozhiyan mozhiyan 147 10月 31 10:29 demo.sh</span><br><span class="line">-rw-rw-r--. 1 mozhiyan mozhiyan  35 10月 31 10:20 demo.sh~</span><br></pre></td></tr></table></figure><p>​        所以，为了防止出现格式混乱的情况，我建议在输出变量时加上双引号。 </p><h2 id="再谈反引号和"><a href="#再谈反引号和" class="headerlink" title="再谈反引号和 $()"></a>再谈反引号和 $()</h2><p>​        原则上讲，上面提到的两种变量替换的形式是等价的，可以随意使用；但是，反引号毕竟看起来像单引号，有时候会对查看代码造成困扰，而使用<code>$()</code>就相对清晰，能有效避免这种混乱。而且有些情况必须使用<code>$()</code>；<code>$()</code>支持嵌套，反引号不行。</p><p>​        下面的例子演示了使用计算<code>ls</code>命令列出的第一个文件的行数，这里使用了两层嵌套。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ Fir_File_Lines=$(wc -l $(ls | sed -n '1p'))</span><br><span class="line">[c.biancheng.net]$ echo "$Fir_File_Lines"</span><br><span class="line">36 anaconda-ks.cfg</span><br></pre></td></tr></table></figure><p>​        要注意的是，<code>$()</code>仅在<code>Bash Shell</code>中有效，而反引号可在多种<code>Shell</code>中使用。所以这两种命令替换的方式各有特点，究竟选用哪种方式全看个人需求。 </p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之union共同体</title>
      <link href="/2018/03/10/c%E8%AF%AD%E8%A8%804-union%E5%85%B1%E7%94%A8%E4%BD%93/"/>
      <url>/2018/03/10/c%E8%AF%AD%E8%A8%804-union%E5%85%B1%E7%94%A8%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p>通过前面的讲解，我们知道结构体（<code>Struct</code>）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在<code>C</code>语言中，还有另外一种和结构体非常类似的语法，叫做<strong>共用体（<code>Union</code>）</strong>，它的定义格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> 共用体名&#123;</span><br><span class="line">   成员列表</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>共用体有时也被称为联合或者联合体，这也是<code>Union</code>这个单词的本意。</p></blockquote><p>​    结构体和共用体的区别在于：<strong>结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</strong></p><a id="more"></a><pre><code>**结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。**</code></pre><p>​    共用体也是一种自定义类型，可以通过它来创建变量，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> data&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">double</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> data a, b, c;</span><br></pre></td></tr></table></figure><p>​    上面是先定义共用体，再创建变量，也可以在定义共用体的同时创建变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> data&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">double</span> f;</span><br><span class="line">&#125; a, b, c;</span><br></pre></td></tr></table></figure><p>​    如果不再定义新的变量，也可以将共用体的名字省略：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">double</span> f;</span><br><span class="line">&#125; a, b, c;</span><br></pre></td></tr></table></figure><p>​    共用体<code>data</code>中，成员<code>f</code>占用的内存最多，为<code>8</code>个字节，所以<code>data</code>类型的变量（也就是<code>a</code>、<code>b</code>、<code>c</code>）也占用<code>8</code>个字节的内存，请看下面的演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> data&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">short</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> data a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %d\n"</span>, <span class="keyword">sizeof</span>(a), <span class="keyword">sizeof</span>(<span class="keyword">union</span> data) );</span><br><span class="line">    a.n = <span class="number">0x40</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%X, %c, %hX\n"</span>, a.n, a.ch, a.m);</span><br><span class="line">    a.ch = <span class="string">'9'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%X, %c, %hX\n"</span>, a.n, a.ch, a.m);</span><br><span class="line">    a.m = <span class="number">0x2059</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%X, %c, %hX\n"</span>, a.n, a.ch, a.m);</span><br><span class="line">    a.n = <span class="number">0x3E25AD54</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%X, %c, %hX\n"</span>, a.n, a.ch, a.m);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>, <span class="number">4</span></span><br><span class="line"><span class="number">40</span>, @, <span class="number">40</span></span><br><span class="line"><span class="number">39</span>, <span class="number">9</span>, <span class="number">39</span></span><br><span class="line"><span class="number">2059</span>, Y, <span class="number">2059</span></span><br><span class="line"><span class="number">3E25</span>AD54, T, AD54</span><br></pre></td></tr></table></figure><p>​    这段代码不但验证了共用体的长度，还说明共用体成员之间会相互影响，修改一个成员的值会影响其他成员。</p><p>​    要想理解上面的输出结果，弄清成员之间究竟是如何相互影响的，就得了解各个成员在内存中的分布。以上面的 <code>data</code>为例，各个成员在内存中的分布如下：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/15255gasd3G12awerew.jpg" alt></p><p>​    成员<code>n</code>、<code>ch</code>、<code>m</code>在内存中“对齐”到一头，对<code>ch</code>赋值修改的是前一个字节，对<code>m</code>赋值修改的是前两个字节，对<code>n</code>赋值修改的是全部字节。也就是说，<code>ch</code>、<code>m</code>会影响到<code>n</code>的一部分数据，而<code>n</code>会影响到<code>ch</code>、<code>m</code>的全部数据。</p><p>​    上图是在绝大多数<code>PC</code>机上的内存分布情况，如果是<code>51</code>单片机，情况就会有所不同：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/15255gasd3G12awerew.jpg" alt></p><h2 id="共用体的应用"><a href="#共用体的应用" class="headerlink" title="共用体的应用"></a>共用体的应用</h2><p>​    共用体在一般的编程中应用较少，在单片机中应用较多。对于<code>PC</code>机，经常使用到的一个实例是： 现有一张关于学生信息和教师信息的表格。学生信息包括姓名、编号、性别、职业、分数，教师的信息包括姓名、编号、性别、职业、教学科目。请看下面的表格：</p><table><thead><tr><th><code>Name</code></th><th><code>Num</code></th><th><code>Sex</code></th><th><code>Profession</code></th><th><code>Score / Course</code></th></tr></thead><tbody><tr><td><code>HanXiaoXiao</code></td><td><code>501</code></td><td><code>f</code></td><td><code>s</code></td><td><code>89.5</code></td></tr><tr><td><code>YanWeiMin</code></td><td><code>1011</code></td><td><code>m</code></td><td><code>t</code></td><td><code>math</code></td></tr><tr><td><code>LiuZhenTao</code></td><td><code>109</code></td><td><code>f</code></td><td><code>t</code></td><td><code>English</code></td></tr><tr><td><code>ZhaoFeiYan</code></td><td><code>982</code></td><td><code>m</code></td><td><code>s</code></td><td><code>95.0</code></td></tr></tbody></table><p>​    <code>f</code>和<code>m</code>分别表示女性和男性，<code>s</code>表示学生，<code>t</code>表示教师。可以看出，学生和教师所包含的数据是不同的。现在要求把这些信息放在同一个表格中，并设计程序输入人员信息然后输出。</p><p>​    如果把每个人的信息都看作一个结构体变量的话，那么教师和学生的前<code>4</code>个成员变量是一样的，第<code>5</code>个成员变量可能是<code>score</code>或者<code>course</code>。当第<code>4</code>个成员变量的值是<code>s</code>的时候，第<code>5</code>个成员变量就是<code>score</code>；当第<code>4</code>个成员变量的值是<code>t</code>的时候，第<code>5</code>个成员变量就是<code>course</code>。</p><p>​    经过上面的分析，我们可以设计一个包含共用体的结构体，请看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOTAL 4  <span class="comment">//人员总数</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">char</span> profession;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">float</span> score;</span><br><span class="line">        <span class="keyword">char</span> course[<span class="number">20</span>];</span><br><span class="line">    &#125; sc;</span><br><span class="line">&#125; bodys[TOTAL];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//输入人员信息</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;TOTAL; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Input info: "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %d %c %c"</span>, bodys[i].name, &amp;(bodys[i].num), &amp;(bodys[i].sex), &amp;(bodys[i].profession));</span><br><span class="line">        <span class="keyword">if</span>(bodys[i].profession == <span class="string">'s'</span>)&#123;  <span class="comment">//如果是学生</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;bodys[i].sc.score);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//如果是老师</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, bodys[i].sc.course);</span><br><span class="line">        &#125;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出人员信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nName\t\tNum\tSex\tProfession\tScore / Course\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;TOTAL; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bodys[i].profession == <span class="string">'s'</span>)&#123;  <span class="comment">//如果是学生</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\t%d\t%c\t%c\t\t%f\n"</span>, bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.score);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//如果是老师</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\t%d\t%c\t%c\t\t%s\n"</span>, bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.course);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input info: HanXiaoXiao <span class="number">501</span> f s <span class="number">89.5</span>↙</span><br><span class="line">Input info: YanWeiMin <span class="number">1011</span> m t math↙</span><br><span class="line">Input info: LiuZhenTao <span class="number">109</span> f t English↙</span><br><span class="line">Input info: ZhaoFeiYan <span class="number">982</span> m s <span class="number">95.0</span>↙</span><br><span class="line"></span><br><span class="line">Name            Num     Sex     Profession      Score / Course</span><br><span class="line">HanXiaoXiao     <span class="number">501</span>     f       s               <span class="number">89.500000</span></span><br><span class="line">YanWeiMin       <span class="number">1011</span>    m       t               math</span><br><span class="line">LiuZhenTao      <span class="number">109</span>     f       t               English</span><br><span class="line">ZhaoFeiYan      <span class="number">982</span>     m       s               <span class="number">95.000000</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之typedef用法</title>
      <link href="/2018/03/08/c%E8%AF%AD%E8%A8%804-typedef%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/03/08/c%E8%AF%AD%E8%A8%804-typedef%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><code>C</code>语言允许为一个数据类型起一个新的别名，就像给人起“绰号”一样。</p><p>​    起别名的目的不是为了提高程序运行效率，而是为了编码方便。例如有一个结构体的名字是<code>stu</code>，要想定义一个结构体变量就得这样写：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu1</span>;</span></span><br></pre></td></tr></table></figure></p><p>​    <code>struct</code>看起来就是多余的，但不写又会报错。如果为<code>struct stu</code>起了一个别名<code>STU</code>，书写起来就简单了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STU stu1;</span><br></pre></td></tr></table></figure></p><p>​    这种写法更加简练，意义也非常明确，不管是在标准头文件中还是以后的编程实践中，都会大量使用这种别名。</p><a id="more"></a><p>​    使用关键字<strong><code>typedef</code></strong>可以为类型起一个新的别名。<code>typedef</code>的用法一般为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  oldName  newName;</span><br></pre></td></tr></table></figure><p>​    <code>oldName</code>是类型原来的名字，<code>newName</code>是类型新的名字。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INTEGER;</span><br><span class="line">INTEGER a, b;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>​    <code>INTEGER a, b;</code>等效于<code>int a, b;</code>。</p><p>​    <code>typedef</code>还可以给数组、指针、结构体等类型定义别名。先来看一个给数组类型定义别名的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ARRAY20[<span class="number">20</span>];</span><br></pre></td></tr></table></figure></p><p>​    表示<code>ARRAY20</code>是类型<code>char [20]</code>的别名。它是一个长度为<code>20</code>的数组类型。接着可以用<code>ARRAY20</code>定义数组：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARRAY20 a1, a2, s1, s2;</span><br></pre></td></tr></table></figure></p><p>​    它等价于：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[<span class="number">20</span>], a2[<span class="number">20</span>], s1[<span class="number">20</span>], s2[<span class="number">20</span>];</span><br></pre></td></tr></table></figure></p><p>​    注意，数组也是有类型的。例如<code>char a1[20];</code>定义了一个数组<code>a1</code>，它的类型就是<code>char [20]</code>。</p><p>​    又如，为结构体类型定义别名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125; STU;</span><br></pre></td></tr></table></figure><p>​    <code>STU</code>是<code>struct stu</code>的别名，可以用<code>STU</code>定义结构体变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STU body1,body2;</span><br></pre></td></tr></table></figure></p><p>​    它等价于：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">body1</span>, <span class="title">body2</span>;</span></span><br></pre></td></tr></table></figure></p><p>​    再如，为指针类型定义别名：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef int (*PTR_TO_ARR)[4];</span><br></pre></td></tr></table></figure></p><p>​    表示<code>PTR_TO_ARR</code>是类型<code>int * [4]</code>的别名，它是一个二维数组指针类型。接着可以使用<code>PTR_TO_ARR</code>定义二维数组指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTR_TO_ARR p1, p2;</span><br></pre></td></tr></table></figure></p><p>​    按照类似的写法，还可以为函数指针类型定义别名：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PTR_TO_FUNC)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">PTR_TO_FUNC pfunc;</span><br></pre></td></tr></table></figure></p><p>【示例】为指针定义别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">typedef char (*PTR_TO_ARR)[30];</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PTR_TO_FUNC)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">3</span>][<span class="number">30</span>] = &#123;</span><br><span class="line">    <span class="string">"http://c.biancheng.net"</span>,</span><br><span class="line">    <span class="string">"C语言中文网"</span>,</span><br><span class="line">    <span class="string">"C-Language"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PTR_TO_ARR parr = str;</span><br><span class="line">    PTR_TO_FUNC pfunc = max;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max: %d\n"</span>, (*pfunc)(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"str[%d]: %s\n"</span>, i, *(parr+i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>max: 20</code><br><code>str[0]: http://c.biancheng.net</code><br><code>str[1]: C语言中文网</code><br><code>str[2]: C-Language</code></p><p>​    需要强调的是，<code>typedef</code>是赋予现有类型一个新的名字，而不是创建新的类型。为了“见名知意”，请尽量使用含义明确的标识符，并且尽量大写。</p><h2 id="typedef和-define的区别"><a href="#typedef和-define的区别" class="headerlink" title="typedef和#define的区别"></a><code>typedef</code>和<code>#define</code>的区别</h2><p>​    <code>typedef</code>在表现上有时候类似于<code>#define</code>，但它和宏替换之间存在一个关键性的区别。正确思考这个问题的方法就是把<code>typedef</code>看成一种彻底的“封装”类型，声明之后不能再往里面增加别的东西。</p><p> 1) 可以使用其他类型说明符对宏类型名进行扩展，但对<code>typedef</code>所定义的类型名却不能这样做。如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERGE int</span></span><br><span class="line"><span class="keyword">unsigned</span> INTERGE n;  <span class="comment">//没问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INTERGE;</span><br><span class="line"><span class="keyword">unsigned</span> INTERGE n;  <span class="comment">//错误，不能在 INTERGE 前面添加 unsigned</span></span><br></pre></td></tr></table></figure></p><p> 2) 在连续定义几个变量的时候，<code>typedef</code>能够保证定义的所有变量均为同一类型，而<code>#define</code>则无法保证。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR_INT int *</span></span><br><span class="line">PTR_INT p1, p2;</span><br></pre></td></tr></table></figure></p><p>​    经过宏替换以后，第二行变为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1, p2;</span><br></pre></td></tr></table></figure></p><p>​    这使得<code>p1</code>、<code>p2</code>成为不同的类型：<code>p1</code>是指向<code>int</code>类型的指针，<code>p2</code>是<code>int</code>类型。</p><p>​    相反，在下面的代码中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> * PTR_INT</span><br><span class="line">PTR_INT p1, p2;</span><br></pre></td></tr></table></figure></p><p>​    <code>p1</code>、<code>p2</code>类型相同，它们都是指向<code>int</code>类型的指针。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之extern关键字</title>
      <link href="/2018/03/05/c%E8%AF%AD%E8%A8%804-extern%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2018/03/05/c%E8%AF%AD%E8%A8%804-extern%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a><code>extern</code>关键字</h2><p>​    我们知道，<code>C</code>语言代码是由上到下依次执行的，不管是变量还是函数，原则上都要先定义再使用，否则就会报错。但在实际开发中，经常会在函数或变量定义之前就使用它们，这个时候就需要提前声明。</p><p>​    所谓声明（<code>Declaration</code>），就是告诉编译器我要使用这个变量或函数，你现在没有找到它的定义不要紧，请不要报错，稍后我会把定义补上。</p><a id="more"></a><p>​    例如，我们知道使用<code>printf()</code>、<code>puts()</code>、<code>scanf()</code>、<code>getchar()</code>等函数要引入<code>stdio.h</code>这个头文件，很多初学者认为<code>stdio.h</code>中包含了函数定义（也就是函数体），只要有了头文件程序就能运行。其实不然，头文件中包含的都是函数声明，而不是函数定义，函数定义都在系统库中，只有头文件没有系统库在链接时就会报错，程序根本不能运行。</p><h4 id="1-函数的声明"><a href="#1-函数的声明" class="headerlink" title="1) 函数的声明"></a>1) 函数的声明</h4><p>​    之前我们讲到了函数声明，那时并没有使用<code>extern</code>关键字，这是因为，函数的定义有函数体，函数的声明没有函数体，编译器很容易区分定义和声明，所以对于函数声明来说，有没有<code>extern</code>都是一样的。</p><p>​    总结起来，函数声明有四种形式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用 extern</span></span><br><span class="line"><span class="function">datatype <span class="title">function</span><span class="params">( datatype1 name1, datatype2 name2, ... )</span></span>;</span><br><span class="line"><span class="function">datatype <span class="title">function</span><span class="params">( datatype1, datatype2, ... )</span></span>;</span><br><span class="line"><span class="comment">//使用 extern</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> datatype <span class="title">function</span><span class="params">( datatype1 name1, datatype2 name2, ... )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> datatype <span class="title">function</span><span class="params">( datatype1, datatype2, ... )</span></span>;</span><br></pre></td></tr></table></figure></p><h4 id="2-变量的声明"><a href="#2-变量的声明" class="headerlink" title="2) 变量的声明"></a>2) 变量的声明</h4><p>​    变量和函数不同，编译器只能根据<code>extern</code>来区分，有<code>extern</code>才是声明，没有<code>extern</code>就是定义。</p><p>​    变量的定义有两种形式，你可以在定义的同时初始化，也可以不初始化：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">datatype name = value;</span><br><span class="line">datatype name;</span><br></pre></td></tr></table></figure></p><p>​    而变量的声明只有一种形式，就是使用<code>extern</code>关键字：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> datatype name;</span><br></pre></td></tr></table></figure></p><p>​    另外，变量也可以在声明的同时初始化，格式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> datatype name = value;</span><br></pre></td></tr></table></figure></p><p>​    这种似是而非的方式是不被推荐的，有的编译器也会给出警告，我们不再深入讨论，也建议各位读者把定义和声明分开，尽量不要这样写。</p><p>​    <code>extern</code>是“外部”的意思，很多教材讲到，<code>extern</code>用来声明一个外部（其他文件中）的变量或函数，也就是说，变量或函数的定义在其他文件中。</p><p>​    不过我认为这样讲不妥，因为除了定义在外部，定义在当前文件中也是正确的。例如，将<code>module.c</code>中的<code>int m = 100;</code>移动到<code>main.c</code>中的任意位置都是可以的。所以我认为，<code>extern</code>是用来声明的，不管具体的定义是在当前文件内部还是外部，都是正确的。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之enum枚举</title>
      <link href="/2018/02/25/c%E8%AF%AD%E8%A8%804-enum%E6%9E%9A%E4%B8%BE/"/>
      <url>/2018/02/25/c%E8%AF%AD%E8%A8%804-enum%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<p>​    了解<code>C</code>语言<code>enum</code>枚举类型定义变量</p><a id="more"></a><h4 id="一次定义多个常量"><a href="#一次定义多个常量" class="headerlink" title="一次定义多个常量"></a>一次定义多个常量</h4><p>​    比如说我们的程序中处理问题时与星期几有关，可能要将星期一转换为数字<code>1</code>，星期二转换为数字<code>2</code>，一直到数字<code>7</code>，在不用<code>enum</code>关键字的情况下，可以使用<code>define</code>来定义，但是大家会觉得很麻烦，因为你要一个一个的定义，星期的还好说，只有<code>7</code>天，如果是月份呢，一年有<code>12</code>个月份，那就要写<code>12</code>个<code>define</code>，非常的不方面，如果利用<code>enum</code>的话就会非常的方便。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> week &#123;Mon=<span class="number">1</span>,Tue,Wed,Thu,Fri,Sat,Sun&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,Tue);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这样定义以后，<code>Mon</code>的值为<code>1</code>，<code>Tue</code>的值为<code>2</code>，<code>Wed</code>的值为<code>3</code>，一次类推。 然后就可以像使用<code>define</code>之后的常量一样的使用定义的7个值了。</p><p>​    如果开头不写<code>Mon=1</code>的话，<code>Mon</code>的<strong>默认值为<code>0</code></strong>，然后从<code>0</code>开始增长。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123;red,blue,green,yellow&#125;;</span><br></pre></td></tr></table></figure><p>​    如果这样定义的话，<code>red</code>的值为<code>0</code>，<code>blue</code>的值为<code>1</code>，然后一次增长。</p><p>​    如果从中间开始赋值的话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123;red,blue,green=<span class="number">5</span>,yellow&#125;;</span><br></pre></td></tr></table></figure><p>​    那么<strong><code>red</code>到<code>blue</code>是按照默认的从<code>0</code>开始增长的</strong>，<code>green</code>就是定义的值<code>5</code>，<strong><code>green</code>之后的值都是从<code>5</code>开始增长的</strong>。</p><p>​    当然你也可以为每个枚举的变量都赋值，这样就和全都用<code>define</code>定义是一样的了，如果枚举中有某个值没有被赋值，那么它将是从前一个赋值的变 量开始，一次增加<code>1</code>。</p><h4 id="限定变量的范围"><a href="#限定变量的范围" class="headerlink" title="限定变量的范围"></a>限定变量的范围</h4><p>​    比如我们的应用程序中要处理有关月份的东西，显然月份只能取<code>1-12</code>中的某个数字，为了保证程序的正确性和健壮性，我们应该使用<code>enum</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Month &#123;Jan=<span class="number">1</span>,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">enum</span> Month a =  Feb;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    比如像这样，定义的枚举类型<code>a</code>的取值只能是那<code>12</code>个变量中的一个，如果赋予了其他的变量，编译器就会报错。</p><h5 id="enum另几种用法"><a href="#enum另几种用法" class="headerlink" title="enum另几种用法"></a><code>enum</code>另几种用法</h5><ul><li>在定义<code>enum</code>的同时，声明变量：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Month &#123;Jan=<span class="number">1</span>,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125; a,b;</span><br></pre></td></tr></table></figure><p>​    这样就声明了两个枚举类型<code>a</code>和<code>b</code></p><ul><li>定义完<code>enum</code>之后再声明变量：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Month &#123;Jan=<span class="number">1</span>,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125;;</span><br><span class="line"><span class="keyword">enum</span> Month a =  Feb;</span><br></pre></td></tr></table></figure><ul><li>定义匿名的枚举变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>  &#123;Jan=<span class="number">1</span>,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125; a;</span><br></pre></td></tr></table></figure><p>​    这样的话，只能使用<code>a</code>这一个枚举类型的变量，不能再定义其他的枚举类型。</p><ul><li><code>typedef  enum</code>则是用来定义一个数据类型，那么该类型的变量值只能在<code>enum</code>定义的范围内取。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>  &#123;Jan=<span class="number">1</span>,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125; Day;</span><br><span class="line">Day a, b;</span><br></pre></td></tr></table></figure><p><strong>注意与宏定义区别：</strong></p><p>​    <code>enum</code>用来定义一系列宏定义常量区别用，相当于一系列的<code>#define xx xx</code>，当然它后面的标识符也可当作一个类型标识符；</p><p>​    <code>typedef  enum</code>则是用来定义一个数据类型，那么该类型的变量值只能在<code>enum</code>定义的范围内取。两者在这点上是没有差别的。</p><p>​    <strong>注意：同一个程序中不能定义同名的枚举类型，不同的枚举类型中也不能存在同名的命名常量</strong></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之const使用</title>
      <link href="/2018/02/24/c%E8%AF%AD%E8%A8%804-const%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/02/24/c%E8%AF%AD%E8%A8%804-const%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>有时候我们希望定义这样一种变量，它的值不能被改变，在整个作用域中都保持固定。例如，用一个变量来表示班级的最大人数，或者表示缓冲区的大小。为了满足这一要求，可以使用<code>const</code>关键字对变量加以限定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxNum = <span class="number">100</span>;  <span class="comment">//班级的最大人数</span></span><br></pre></td></tr></table></figure><p>​    这样<code>MaxNum</code>的值就不能被修改了，任何对<code>MaxNum</code>赋值的行为都将引发错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxNum = <span class="number">90</span>;  <span class="comment">//错误，试图向 const 变量写入数据</span></span><br></pre></td></tr></table></figure><p>​    我们经常<strong>将<code>const</code>变量称为常量（<code>Constant</code>）。</strong>创建常量的格式通常为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> type name = value;</span><br></pre></td></tr></table></figure></p><p>​    <code>const</code>和<code>type</code>都是用来修饰变量的，它们的位置可以互换，也就是将<code>type</code>放在<code>const</code>前面：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="keyword">const</span> name = value;</span><br></pre></td></tr></table></figure></p><p>​    但我们通常采用第一种方式，不采用第二种方式。另外建议将常量名的首字母大写，以提醒程序员这是个常量。</p><a id="more"></a><p>​    <strong>由于常量一旦被创建后其值就不能再改变，所以常量必须在定义的同时赋值（初始化），后面的任何赋值行为都将引发错误。</strong>一如既往，初始化常量可以使用任意形式的表达式，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">90</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MaxNum1 = getNum();  <span class="comment">//运行时初始化</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MaxNum2 = n;  <span class="comment">//运行时初始化</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MaxNum3 = <span class="number">80</span>;  <span class="comment">//编译时初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %d, %d\n"</span>, MaxNum1, MaxNum2, MaxNum3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>100, 90, 80</code></p><h2 id="const和指针"><a href="#const和指针" class="headerlink" title="const和指针"></a><code>const</code>和指针</h2><p>​    <code>const</code>也可以和指针变量一起使用，这样可以限制指针变量本身，也可以限制指针指向的数据。<code>const</code> 和指针一起使用会有几种不同的顺序，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p2;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p3;</span><br></pre></td></tr></table></figure><p>​    在最后一种情况下，指针是只读的，也就是<code>p3</code>本身的值不能被修改；在前面两种情况下，指针所指向的数据是只读的，也就是<code>p1</code>、<code>p2</code>本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。</p><p>​    当然，指针本身和它指向的数据都有可能是只读的，下面的两种写法能够做到这一点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p4;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p5;</span><br></pre></td></tr></table></figure><p>​    <code>const</code>和指针结合的写法多少有点让初学者摸不着头脑，大家可以这样来记忆：<strong><code>const</code>离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针指向的数据，如果近的和远的都有，那么就同时修饰指针变量以及它指向的数据。</strong></p><h2 id="const和函数形参"><a href="#const和函数形参" class="headerlink" title="const和函数形参"></a><code>const</code>和函数形参</h2><p>​    在<code>C</code>语言中，单独定义<code>const</code>变量没有明显的优势，完全可以使用<code>#define</code>命令代替。<code>const</code>通常用在函数形参中，如果形参是一个指针，为了防止在函数内部修改指针指向的数据，就可以用<code>const</code>来限制。</p><p>​    在<code>C</code>语言标准库中，有很多函数的形参都被<code>const</code>限制了，下面是部分函数的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span> ( <span class="keyword">const</span> <span class="keyword">char</span> * str );</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * str1, <span class="keyword">const</span> <span class="keyword">char</span> * str2 )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcat</span> <span class="params">( <span class="keyword">char</span> * destination, <span class="keyword">const</span> <span class="keyword">char</span> * source )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcpy</span> <span class="params">( <span class="keyword">char</span> * destination, <span class="keyword">const</span> <span class="keyword">char</span> * source )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* command)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * str )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * format, ... )</span></span>;</span><br></pre></td></tr></table></figure><p>​    我们自己在定义函数时也可以使用<code>const</code>对形参加以限制，例如查找字符串中某个字符出现的次数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> strnchr(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">char</span> ch)&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n = <span class="number">0</span>, len = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == ch)&#123;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"http://c.biancheng.net"</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">'t'</span>;</span><br><span class="line">    <span class="keyword">int</span> n = strnchr(str, ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>3</code></p><p>​    根据<code>strnchr()</code>的功能可以推断，函数内部要对字符串<code>str</code>进行遍历，不应该有修改的动作，用<code>const</code>加以限制，不但可以防止由于程序员误操作引起的字符串修改，还可以给用户一个提示，函数不会修改你提供的字符串，请你放心。</p><h2 id="const和非const类型转换"><a href="#const和非const类型转换" class="headerlink" title="const和非const类型转换"></a><code>const</code>和非<code>const</code>类型转换</h2><p>​    当一个指针变量<code>str1</code>被<code>const</code>限制时，并且类似<code>const char *str1</code>这种形式，说明指针指向的数据不能被修改；如果将<code>str1</code> 赋值给另外一个未被<code>const</code>修饰的指针变量<code>str2</code>，就有可能发生危险。因为通过<code>str1</code>不能修改数据，而赋值后通过<code>str2</code>能够修改数据了，意义发生了转变，所以编译器不提倡这种行为，会给出错误或警告。</p><p>​    也就是说，<strong><code>const char *</code>和<code>char *</code>是不同的类型，不能将<code>const char *</code>类型的数据赋值给<code>char *</code>类型的变量。但反过来是可以的，编译器允许将<code>char *</code>类型的数据赋值给<code>const char *</code>类型的变量。</strong></p><p>​    这种限制很容易理解，<code>char *</code>指向的数据有读取和写入权限，而<code>const char *</code>指向的数据只有读取权限，降低数据的权限不会带来任何问题，但提升数据的权限就有可能发生危险。</p><p>​    <code>C</code>语言标准库中很多函数的参数都被<code>const</code>限制了，但我们在以前的编码过程中并没有注意这个问题，经常将非<code>const</code>类型的数据传递给<code>const</code>类型的形参，这样做从未引发任何副作用，原因就是上面讲到的，将非<code>const</code>类型转换为<code>const</code>类型是允许的。</p><p>​    下面是一个将<code>const</code>类型赋值给非<code>const</code>类型的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str1 = <span class="string">"c.biancheng.net"</span>;</span><br><span class="line">    <span class="keyword">char</span> *str2 = str1;</span><br><span class="line">    func(str1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    第<code>7</code>、<code>8</code>行代码分别通过赋值、传参（传参的本质也是赋值）将<code>const</code>类型的数据交给了非<code>const</code>类型的变量，编译器不会容忍这种行为，会给出警告，甚至直接报错。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之字节对齐</title>
      <link href="/2018/02/20/c%E8%AF%AD%E8%A8%804-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
      <url>/2018/02/20/c%E8%AF%AD%E8%A8%804-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言字节对齐"><a href="#C语言字节对齐" class="headerlink" title="C语言字节对齐"></a><code>C</code>语言字节对齐</h1><h2 id="不同系统的C语言类型长度"><a href="#不同系统的C语言类型长度" class="headerlink" title="不同系统的C语言类型长度"></a>不同系统的<code>C</code>语言类型长度</h2><table><thead><tr><th><code>Data Type</code></th><th><code>ILP32</code></th><th><code>ILP64</code></th><th><code>LP64</code></th><th><code>LLP64</code></th></tr></thead><tbody><tr><td><code>char</code></td><td><code>8</code></td><td><code>8</code></td><td><code>8</code></td><td><code>8</code></td></tr><tr><td><code>short</code></td><td><code>16</code></td><td><code>16</code></td><td><code>16</code></td><td><code>16</code></td></tr><tr><td><code>int</code></td><td><code>32</code></td><td><code>64</code></td><td><code>32</code></td><td><code>32</code></td></tr><tr><td><code>long</code></td><td><code>32</code></td><td><code>64</code></td><td><code>64</code></td><td><code>32</code></td></tr><tr><td><code>long long</code></td><td><code>64</code></td><td><code>64</code></td><td><code>64</code></td><td><code>64</code></td></tr><tr><td><code>pointer</code></td><td><code>32</code></td><td><code>64</code></td><td><code>64</code></td><td><code>64</code></td></tr></tbody></table><p>​    绝大部分<code>64</code>位的<code>Unix</code>，<code>linux</code>都是使用的<code>LP64</code>模型；<code>32</code>位<code>Linux</code>系统是<code>ILP32</code>模型；<code>64</code>位的<code>Windows</code>使用的是<code>LLP64</code>(<code>long long and point 64</code>)模型。</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>​    许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值<code>K</code>(通常是<code>2</code>，<code>4</code>或<code>8</code>)的倍数。这种对齐限制简化了形成处理器和存储器系统之间的接口的硬件设计。对齐跟数据在内存中的位置有关。<strong>如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。</strong>比如在<code>32</code>位<code>cpu</code>下，假设一个整型变量的地址为<code>0x00000004</code>，那它就是自然对齐的。</p><h3 id="为什么要字节对齐"><a href="#为什么要字节对齐" class="headerlink" title="为什么要字节对齐"></a>为什么要字节对齐</h3><p>​    <strong>需要字节对齐的根本原因在于<code>CPU</code>访问数据的效率问题。</strong>例如，假设一个处理器总是从存储器中取出<code>8</code>个字节，则地址必须为<code>8</code>的倍数。如果我们能保证将所有的<code>double</code>类型数据的地址对齐成<code>8</code>的倍数，那么就可以用一个存储器操作来读或者写值了。否则，我们可能需要执行两次存储器访问，因为对象可能被分放在两个<code>8</code>字节存储块中。</p><p>​    另外，假设一个整型变量的地址不是自然对齐，比如为<code>0x00000002</code>，则<code>CPU</code>如果取它的值的话需要访问两次内存，第一次取从<code>0x00000002-0x00000003</code>的一个<code>short</code>，第二次取从<code>0x00000004-0x00000005</code>的一个<code>short</code>然后组合得到所要的数据；如果变量在<code>0x00000003</code>地址上的话则要访问三次内存，第一次为<code>char</code>，第二次为<code>short</code>，第三次为<code>char</code>，然后组合得到整型数据。而如果变量在自然对齐位置上，则只要一次就可以取出数据。</p><p>​    各个硬件平台对存储空间的处理上有很大的不同，一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的<code>CPU</code>在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。比如<code>sparc</code>系统，如果取未对齐的数据会发生错误，举个例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">char</span> *p = &amp;ch[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> i = *(<span class="keyword">int</span> *)p;</span><br></pre></td></tr></table></figure></p><p>运行时会报<code>segment error</code>，而在<code>x86</code>上就不会出现错误，只是效率下降。</p><h3 id="如何处理字节对齐"><a href="#如何处理字节对齐" class="headerlink" title="如何处理字节对齐"></a>如何处理字节对齐</h3><p>​    先让我们看编译器是按照什么样的原则进行对齐的</p><ul><li><strong>数据类型自身的对齐值：</strong>为指定平台上基本类型的长度。对于<code>char</code>型数据，其自身对齐值为<code>1</code>，对于<code>short</code>型为<code>2</code>，对于<code>int</code>,<code>float</code>,<code>double</code>类型，其自身对齐值为<code>4</code>，单位字节。</li><li><strong>结构体或者类的自身对齐值：</strong>其成员中自身对齐值最大的那个值。</li><li><strong>指定对齐值：</strong><code>#pragma pack (value)</code>时的指定对齐值<code>value</code>。</li><li><strong>数据成员、结构体和类的有效对齐值：</strong>自身对齐值和指定对齐值中小的那个值。</li></ul><p>对于<strong>标准数据类型，它的地址只要是它的长度的整数倍就行了</strong>，而非标准数据类型按下面的原则对齐</p><ul><li><strong>数组 ：</strong>按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。</li><li><strong>联合 ：</strong>按其包含的长度最大的数据类型对齐。</li><li><strong>结构体：</strong> 结构体中每个数据类型都要对齐。</li></ul><p>​    <strong>当数据类型为结构体时，编译器可能需要在结构体字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放（对于非对齐成员需要在其前面填充一些字节，保证其在对齐位置上），结构体本身也要根据自身的有效对齐值圆整(就是结构体总长度需要是结构体有效对齐值的整数倍)，此时可能需要在结构末尾填充一些空间，以满足结构体整体的对齐—-向结构体元素中最大的元素对齐。</strong></p><p>​    通过上面的分析，对结构体进行字节对齐，我们需要知道四个值：</p><ul><li><strong>指定对齐值：</strong>代码中指定的对齐值，记为<code>packLen</code>；</li><li><strong>默认对齐值：</strong>结构体中每个数据成员及结构体本身都有默认对齐值，记为<code>defaultLen</code>；</li><li><strong>成员偏移量：</strong>即相对于结构体起始位置的长度，记为<code>offset</code>；</li><li><strong>成员长度：</strong>结构体中每个数据成员的长度（注结构体成员为补齐之后的长度），记为<code>memberLen</code>。</li></ul><p>及两个规则：</p><ul><li><strong>对齐规则： </strong><code>offset % vaildLen = 0</code>，其中<code>vaildLen</code>为有效对齐值<code>vaildLen = min(packLen, defaultLen)</code>；</li><li><strong>填充规则：</strong> 如成员变量不遵守对齐规则，则需要对其补齐；在其前面填充一些字节保证该成员对齐。需填充的字节数记为<code>pad</code></li></ul><h2 id="Linux和Windows的对齐方式"><a href="#Linux和Windows的对齐方式" class="headerlink" title="Linux和Windows的对齐方式"></a><code>Linux</code>和<code>Windows</code>的对齐方式</h2><h3 id="Linux的对齐策略"><a href="#Linux的对齐策略" class="headerlink" title="Linux的对齐策略"></a><code>Linux</code>的对齐策略</h3><p>​    在<code>Linux</code>中<code>2</code>字节数据类型(例如<code>short</code>)的地址必须是<code>2</code>的倍数，而较大的数据类型(例如<code>int</code>，<code>int *</code>，<code>float</code>和<code>double</code>)的地址必须是<code>4</code>的倍数。也就是说<code>Linux</code>下要么<code>2</code>字节对齐，要么<code>4</code>字节对齐，没有其他格式的对齐。</p><h3 id="Windows的对齐策略"><a href="#Windows的对齐策略" class="headerlink" title="Windows的对齐策略"></a><code>Windows</code>的对齐策略</h3><p>​    在<code>Windows</code>中对齐要求更严–任何<code>K</code>字节基本对象的地址都必须是<code>K</code>的倍数，<code>K=2</code>，<code>4</code>，或者<code>8</code>。特别地，<code>double</code>或者<code>long long</code>类型数据的地址应该是<code>8</code>的倍数。可以看出<code>Windows</code>的对齐策略和<code>Linux</code>还是不同的。</p><h3 id="更改C编译器的缺省字节对齐方式"><a href="#更改C编译器的缺省字节对齐方式" class="headerlink" title="更改C编译器的缺省字节对齐方式"></a>更改<code>C</code>编译器的缺省字节对齐方式</h3><p>​    在缺省情况下，<code>C</code>编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：</p><ul><li>使用伪指令<code>#pragma pack (n)</code>，<code>C</code>编译器将按照<code>n</code>个字节对齐。</li><li>使用伪指令<code>#pragma pack ()</code>，取消自定义字节对齐方式。</li></ul><p>另外，还有如下的一种方式：</p><ul><li><code>__attribute__((aligned (n)))</code>，让所作用的结构成员对齐在<code>n</code>字节自然边界上。如果结构中有成员的长度大于<code>n</code>，则按照最大成员的长度来对齐。</li><li><code>__attribute__ ((packed))</code>，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。</li></ul><p><strong>字节对齐的作用不仅是便于<code>cpu</code>快速访问，同时合理的利用字节对齐可以有效地节省存储空间。</strong></p><p>​    对于<code>32</code>位机来说，<code>4</code>字节对齐能够使<code>cpu</code>访问速度提高，比如说一个<code>long</code>类型的变量，如果跨越了<code>4</code>字节边界存储，那么<code>cpu</code>要读取两次，这样效率就低了。但是在<code>32</code>位机中使用<code>1</code>字节或者<code>2</code>字节对齐，反而会使变量访问速度降低。所以这要考虑处理器类型，另外还得考虑编译器的类型。在<code>vc</code>中默认是<code>4</code>字节对齐的，<code>GNU gcc</code>也是默认<code>4</code>字节对齐。</p><h2 id="结构体举例"><a href="#结构体举例" class="headerlink" title="结构体举例"></a>结构体举例</h2><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: struct_test.c</span></span><br><span class="line"><span class="comment">    &gt; Author:Marvin</span></span><br><span class="line"><span class="comment">    &gt; Created Time: Thu 22 Mar 2018 07:19:46 PM CST</span></span><br><span class="line"><span class="comment"> **********************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="keyword">short</span> b;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">long</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">t</span> = &#123;</span><span class="string">'a'</span>,<span class="number">11</span>,<span class="number">11</span>,<span class="number">11</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"size of struct t = %u\n"</span>, <span class="keyword">sizeof</span>(t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在<code>64</code>位<code>centos</code>上编译编译后结构<code>struct test</code>的布局如下:</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/20180322204257004.png" alt></p><p>​    由于要保证结构体每个元素都要数据对齐，因此必须在<code>a</code>和<code>b</code>之间插入<code>1</code>字节的间隙使得后面的<code>short</code>元素<code>2</code>字节对齐<code>int</code>元素<code>4</code>字节对齐<code>long</code>元素<code>8</code>字节对齐，这样最终<code>test</code>结构大小为<code>16</code>字节。</p><p>​    运行程序结果为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size of <span class="class"><span class="keyword">struct</span> <span class="title">t</span> = 16</span></span><br></pre></td></tr></table></figure></p><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>现在考虑这样一个结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test2</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">long</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test2</span> <span class="title">t2</span> = &#123;</span><span class="number">11</span>,<span class="number">11</span>,<span class="string">'c'</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>在<code>64</code>位<code>centos</code>上编译编译后结构<code>struct test2</code>的布局如下:</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/20180322204333912.png" alt></p><p>​    结构体<code>struct test2</code>的自然对界条件为<code>8</code>字节，所以需要在最后的<code>char</code>型数据后面再填充<code>7</code>个字节使得结构体整体对齐。</p><p>​    运行程序结构为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size of <span class="class"><span class="keyword">struct</span> <span class="title">test2</span> = 24</span></span><br></pre></td></tr></table></figure></p><h3 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h3><p>​    不妨将结构体<code>struct test2</code>里面成员的顺序重新排列一下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test3</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">long</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test3</span> <span class="title">t3</span> = &#123;</span><span class="string">'c'</span>,<span class="number">11</span>,<span class="number">11</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>​    在<code>64</code>位<code>centos</code>上编译编译后结构<code>struct test2</code>的布局如下:</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/20180322204347520.png" alt></p><p>​    运行结果为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size of <span class="class"><span class="keyword">struct</span> <span class="title">test3</span> = 16</span></span><br></pre></td></tr></table></figure></p><p>​    可见适当地编排结构体成员地顺序，可以在保存相同信息地情况下尽可能节约内存空间。</p><h3 id="例子4"><a href="#例子4" class="headerlink" title="例子4"></a>例子4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">short</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    假设<code>B</code>从地址空间<code>0x0000</code>开始排放。该例子中没有定义指定对齐值，在笔者环境下，该值默认为<code>4</code>。</p><p>​    第一个成员变量<code>b</code>的自身对齐值是<code>1</code>，比指定或者默认指定对齐值<code>4</code>小，所以其有效对齐值为<code>1</code>，所以其存放地址<code>0x0000</code>符合<code>0x0000%1=0</code>。</p><p>​    第二个成员变量<code>a</code>，其自身对齐值为<code>4</code>，所以有效对齐值也为<code>4</code>，所以只能存放在起始地址为<code>0x0004</code>到<code>0x0007</code>这四个连续的字节空间中，复核<code>0x0004%4=0</code>，且紧靠第一个变量。</p><p>​    第三个变量<code>c</code>，自身对齐值为<code>2</code>，所以有效对齐值也是<code>2</code>，可以存放在<code>0x0008</code>到<code>0x0009</code>这两个字节空间中，符合<code>0x0008%2=0</code>。所以从<code>0x0000</code>到<code>0x0009</code>存放的都是<code>B</code>内容。</p><p>​    再看数据结构<code>B</code>的自身对齐值为其变量中最大对齐值(这里是<code>b</code>）所以就是<code>4</code>，所以结构体的有效对齐值也是<code>4</code>。根据结构体圆整的要求，<code>0x0009</code>到<code>0x0000</code>等于<code>10</code>字节，<code>（10＋2）％4＝0</code>。所以<code>0x0000A</code>到<code>0x000B</code>也为结构体<code>B</code>所占用。故<code>B</code>从<code>0x0000</code>到<code>0x000B</code>共有<code>12</code>个字节，<code>sizeof(struct B)=12</code>。</p><p>​    其实如果就这一个就来说它已将满足字节对齐了，因为它的起始地址是<code>0</code>，因此肯定是对齐的，之所以在后面补充<code>2</code>个字节，是因为编译器为了实现结构数组的存取效率，试想如果我们定义了一个结构<code>B</code>的数组，那么第一个结构起始地址是<code>0</code>没有问题，但是第二个结构呢？按照数组的定义，数组中所有元素都是紧挨着的，如果我们不把结构的大小补充为<code>4</code>的整数倍，那么下一个结构的起始地址将是<code>0x0000A</code>，这显然不能满足结构的地址对齐了，因此我们要把结构补充成有效对齐大小的整数倍。</p><p>​    其实诸如，对于<code>char</code>型数据，其自身对齐值为<code>1</code>，对于<code>short</code>型为<code>2</code>，对于<code>int</code>,<code>float</code>,<code>double</code>类型，其自身对齐值为<code>4</code>，这些已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知了，所以他们的自身对齐值也就已知了。</p><h3 id="例子5"><a href="#例子5" class="headerlink" title="例子5"></a>例子5</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack (2) <span class="comment">/*指定按2字节对齐*/</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack () <span class="comment">/*取消指定对齐，恢复缺省对齐*/</span></span></span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>​    第一个变量<code>b</code>的自身对齐值为<code>1</code>，指定对齐值为<code>2</code>，所以，其有效对齐值为<code>1</code>，假设<code>C</code>从<code>0x0000</code>开始，那么<code>b</code>存放在<code>0x0000</code>，符合<code>0x0000%1=0</code>；</p><p>​    第二个变量，自身对齐值为<code>4</code>，指定对齐值为<code>2</code>，所以有效对齐值为<code>2</code>，所以顺序存放在<code>0x0002</code>、<code>0x0003</code>、<code>0x0004</code>、<code>0x0005</code>四个连续字节中，符合<code>0x0002%2=0</code>。</p><p>​    第三个变量<code>c</code>的自身对齐值为<code>2</code>，所以有效对齐值为<code>2</code>，顺序存放在<code>0x0006</code>、<code>0x0007</code>中，符合<code>0x0006%2=0</code>。</p><p>​    所以从<code>0x0000</code>到<code>0x00007</code>共八字节存放的是<code>C</code>的变量。又<code>C</code>的自身对齐值为<code>4</code>，所以<code>C</code>的有效对齐值为<code>2</code>。又<code>8%2=0</code>，<code>C</code>只占用<code>0x0000</code>到<code>0x0007</code>的八个字节。所以<code>sizeof(struct C)=8</code>。</p><p>​    对于结构体嵌套地情况，结构体对齐算法思想：深度优先填充。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">padLen = getPadLen(offset , defaultLen);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPadLen</span><span class="params">(<span class="keyword">int</span> offsetLen, <span class="keyword">int</span> defaultLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> vaildLen = min(packLen,defaultLen);</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">0</span> == vaildLen || <span class="number">0</span> == offsetLen % vaildLen)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vaildLen - (offsetLen % vaildLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    先对齐内层结构体：对每个数据成员计算其<code>defaultLen</code>、<code>memberLen</code>和<code>offset</code>；</p><p>​    再遍历每个数据成员时计算：对于基本数据类型成员<code>defaultLen=memberLen</code>；对于结构体成员<code>defaultLen</code>等于它的所有成员的最大的<code>memberLen</code>；遍历时对成员的<code>memberLen</code>进行累加，得到当前成员的<code>offsetLen</code>；</p><p>​    运用对齐及填充规则：在当前结构体成员前填充<code>padLen</code>个字节；</p><p>​    下面是结构体作为成员的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">long</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test4</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test1</span> <span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test4</span> <span class="title">t4</span> = &#123;</span><span class="string">'a'</span>, &#123;<span class="number">11</span>,<span class="number">11</span>&#125;,<span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure></p><p>​    <code>test1</code>的内存分布:</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/20180322204403923.png" alt></p><p>​    <code>test4</code>的内存分布:</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/20180322204413702.png" alt></p><h2 id="字节对齐可能带来的隐患"><a href="#字节对齐可能带来的隐患" class="headerlink" title="字节对齐可能带来的隐患"></a>字节对齐可能带来的隐患</h2><p>​    代码中关于对齐的隐患，很多是隐式的。比如在强制类型转换的时候。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> *p1=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">p=&amp;i;</span><br><span class="line">*p=<span class="number">0x00</span>;</span><br><span class="line">p1=(<span class="keyword">unsigned</span> <span class="keyword">short</span> *)(p+<span class="number">1</span>);</span><br><span class="line">*p1=<span class="number">0x0000</span>;</span><br></pre></td></tr></table></figure></p><p>​    最后两句代码，从奇数边界去访问<code>unsignedshort</code>型变量，显然不符合对齐的规定。在<code>x86</code>上，类似的操作只会影响效率，但是在<code>MIPS</code>或者<code>sparc</code>上，可能就是一个<code>error</code>，因为它们要求必须字节对齐。</p><h2 id="如何查找与字节对齐的问题"><a href="#如何查找与字节对齐的问题" class="headerlink" title="如何查找与字节对齐的问题"></a>如何查找与字节对齐的问题</h2><p>如果出现对齐或者赋值问题首先查看</p><ul><li>编译器的<code>big little</code>端设置。</li><li>看这种体系本身是否支持非对齐访问。</li><li>如果支持看设置了对齐与否，如果没有则看访问时需要加某些特殊的修饰来标志其特殊访问操作。</li></ul><p>举例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//windows 64 位默认 结构体对齐系数为8，32位 结构体对齐系数为4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试系统对齐系数</span></span><br><span class="line"><span class="comment">// #pragma pack(8)  my_struct_1 为16字节</span></span><br><span class="line"><span class="comment">// #pragma pack(4)  my_struct_1 为12字节</span></span><br><span class="line"><span class="comment">// 不加#pragma pack(8)  my_struct_1 为16字节</span></span><br><span class="line"><span class="comment">//顾系统默认对齐系数为8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct_1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;     <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">double</span> b;   <span class="comment">//之前补7 +8     8/8==1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct_2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;    <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">double</span> b;  <span class="comment">//3+8</span></span><br><span class="line">    <span class="keyword">int</span> c;     <span class="comment">//4     16/4=4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct_3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;    <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">double</span> b;  <span class="comment">//1+8</span></span><br><span class="line">    <span class="keyword">int</span> c;     <span class="comment">//4     14/2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct_4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">5</span>];  <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">double</span> b;   <span class="comment">//3+8   16/4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct_5</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">5</span>];  <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">double</span> b;   <span class="comment">//1+8   14/2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct_6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;    <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">3</span>]; <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">char</span> c;    <span class="comment">//1   1+3+1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct_7</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;    <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">3</span>]; <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">char</span> c;    <span class="comment">//1   </span></span><br><span class="line">    <span class="keyword">int</span> d;     <span class="comment">//补齐 3 +4 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> x1;   <span class="comment">//1</span></span><br><span class="line"><span class="keyword">short</span> x2;  <span class="comment">//补齐1+ 2</span></span><br><span class="line"><span class="keyword">float</span> x3;  <span class="comment">//4</span></span><br><span class="line"><span class="keyword">char</span> x4;   <span class="comment">//1 补齐+3  </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"char:"</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">char</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"short:"</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">short</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"int:"</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"long:"</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">long</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"float:"</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">float</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"double:"</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">double</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"long double:"</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(my_struct_1)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//8</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(my_struct_2)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//16</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(my_struct_3)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//14</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(my_struct_4)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//16</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(my_struct_5)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//14</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(my_struct_6)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//5</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(my_struct_7)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(test)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之存储空间布局</title>
      <link href="/2018/02/17/c%E8%AF%AD%E8%A8%803-C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
      <url>/2018/02/17/c%E8%AF%AD%E8%A8%803-C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>虚拟地址空间在<code>32</code>位环境下的大小为<code>4GB</code>，在<code>64</code>位环境下的大小为<code>256TB</code>，那么，一个<code>C</code>语言程序的内存在整个地址空间中是如何分布的呢？</p><a id="more"></a><h2 id="内核空间和用户空间"><a href="#内核空间和用户空间" class="headerlink" title="内核空间和用户空间"></a>内核空间和用户空间</h2><p>​    对于<code>32</code>位环境，理论上程序可以拥有<code>4GB</code> 的虚拟地址空间，我们在<code>C</code>语言中使用到的变量、函数、字符串等都会对应内存中的一块区域。</p><p>​    但是，在这<code>4GB</code>的地址空间中，要拿出一部分给操作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间（<code>Kernel Space</code>）。</p><pre><code>`Windows `在默认情况下会将高地址的` 2GB `空间分配给内核（也可以配置为`1GB`），而` Linux `默认情况下会将高地址的` 1GB `空间分配给内核。也就是说，应用程序只能使用剩下的` 2GB `或` 3GB `的地址空间，称为用户空间（`User Space`）。</code></pre><h2 id="Linux下32位环境的用户空间内存分布情况"><a href="#Linux下32位环境的用户空间内存分布情况" class="headerlink" title="Linux下32位环境的用户空间内存分布情况"></a><code>Linux</code>下<code>32</code>位环境的用户空间内存分布情况</h2><p>我们暂时不关心内核空间的内存分布情况，下图是<code>Linux</code>下<code>32</code>位环境的一种经典内存模型：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-16041510402a94.jpg" alt></p><h3 id="存储空间组成"><a href="#存储空间组成" class="headerlink" title="存储空间组成"></a>存储空间组成</h3><ul><li><p><strong>代码区（<code>text</code>）</strong><br>加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的，具有只读特性和共享性。</p></li><li><p><strong>未初始化数据区（<code>BSS</code>）</strong><br>加载的是可执行文件<code>BSS</code> 段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。</p></li><li><p><strong>全局初始化数据区/静态数据区（<code>data</code>）</strong><br>加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。</p></li><li><p><strong>栈区（<code>stack</code>）</strong><br>栈又称堆栈，是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等，也就是我们函数大括号”{}”中定义的变量(不包括static声明的变量)。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。由于栈的先进先出特性，所有栈特别方便用来保存/恢复调用现场。从这个意义上讲，把堆栈看成一个寄存、交换临时数据的内存区。</p></li><li><p><strong>堆区（<code>heap</code>）</strong><br>堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于<code>BSS</code>区和栈区之间。当进程调用<code>malloc</code>等函数分配内存时，新分配的内存就被动态添加到堆上(堆被扩张)；当利用<code>free</code>等函数释放内存时，被释放的内存从堆上被剔除(堆被缩减)。</p></li></ul><p>为了加深对内存布局的理解，请大家看下面一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *str1 = <span class="string">"c.biancheng.net"</span>;  <span class="comment">//字符串在常量区，str1在全局数据区</span></span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//全局数据区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"C语言中文网"</span>;  <span class="comment">//字符串在常量区，str在栈区</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;  <span class="comment">//栈区</span></span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">"01234"</span>;  <span class="comment">//字符串在常量区，str2在栈区</span></span><br><span class="line">    <span class="keyword">char</span>  arr[<span class="number">20</span>] = <span class="string">"56789"</span>;  <span class="comment">//字符串和arr都在栈区</span></span><br><span class="line">    <span class="keyword">char</span> *pstr = func();  <span class="comment">//栈区</span></span><br><span class="line">    <span class="keyword">int</span> b;  <span class="comment">//栈区</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str1: %#X\npstr: %#X\nstr2: %#X\n"</span>, str1, pstr, str2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"--------------"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;str1: %#X\n   &amp;n: %#X\n"</span>, &amp;str1, &amp;n);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"--------------"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  &amp;a: %#X\n arr: %#X\n  &amp;b: %#X\n"</span>, &amp;a, arr, &amp;b);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"--------------"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n: %d\na :%d\nb: %d\n"</span>, n, a, b);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"--------------"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, pstr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">str1: <span class="number">0X400710</span></span><br><span class="line">pstr: <span class="number">0X400720</span></span><br><span class="line">str2: <span class="number">0X400731</span></span><br><span class="line">--------------</span><br><span class="line">&amp;str1: <span class="number">0X601040</span></span><br><span class="line">   &amp;n: <span class="number">0X60104C</span></span><br><span class="line">--------------</span><br><span class="line"> &amp;a: <span class="number">0X19D0728C</span></span><br><span class="line">arr: <span class="number">0X19D07270</span></span><br><span class="line"> &amp;b: <span class="number">0X19D0726C</span></span><br><span class="line">--------------</span><br><span class="line">n: <span class="number">0</span></span><br><span class="line">a: <span class="number">-858993460</span></span><br><span class="line">b: <span class="number">-858993460</span></span><br><span class="line">--------------</span><br><span class="line">C语言中文网</span><br></pre></td></tr></table></figure><p>对代码的说明：<br> 1) 全局变量的内存在编译时就已经分配好了，它的默认初始值是<code>0</code>（它所占用的每一个字节都是<code>0</code>值），局部变量的内存在函数调用时分配，它默认初始值是不确定的，由编译器决定，一般是垃圾值。</p><p> 2) 函数<code>func()</code>中的局部字符串常量<code>&quot;C语言中文网&quot;</code>也被存储到常量区，不会随着<code>func()</code>的运行结束而销毁，所以最后依然能够输出。</p><p> 3) 字符数组<code>arr[20]</code>在栈区分配内存，字符串<code>&quot;56789&quot;</code>就保存在这块内存中，而不是在常量区，大家要注意区分。</p><h3 id="详解数据段"><a href="#详解数据段" class="headerlink" title="详解数据段"></a>详解数据段</h3><h4 id="全局静态区"><a href="#全局静态区" class="headerlink" title="全局静态区"></a>全局静态区</h4><p>​    全局静态区分为<strong>全局区</strong>、<strong>静态区</strong>、<strong>常量区</strong></p><h5 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h5><p>​    处于该区域的数据属于<strong>外部链接</strong>，可以被<strong>其他文件</strong>使用。</p><h5 id="静态区"><a href="#静态区" class="headerlink" title="静态区"></a>静态区</h5><p>​    静态区分为静态全局变量和静态局部变量</p><ul><li><p>静态全局变量</p><p>由<strong><code>static</code></strong>修饰的<strong>全局变量</strong>，属于<strong>内部链接</strong>，只能在<strong>本文件</strong>中使用</p></li><li><p>静态局部变量</p><p>由<strong><code>static</code></strong>修饰的<strong>局部变量</strong>，当<code>static</code>用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为<strong>静态存储区</strong>。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。</p></li></ul><h5 id="常量区"><a href="#常量区" class="headerlink" title="常量区"></a>常量区</h5><p>​    常量区分为<strong>字符串常量</strong>和<strong>常变量</strong></p><ul><li><p>字符串常量</p></li><li><p>常变量</p><ol><li><strong>全局常变量</strong>存放在静态存储区，不可以间接修改。</li><li><strong>局部常变量</strong>存放于栈，实际可间接通过指针或者引用进行修改。</li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//全局变量，在全局区,默认外部链接</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">20</span>; <span class="comment">//全局静态变量，在静态区,是内部链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量和全局静态变量有什么区别？</span></span><br><span class="line"><span class="comment">//全局变量是外部链接</span></span><br><span class="line"><span class="comment">//静态全局变量是内部链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内部链接和外部链接有什么区别？</span></span><br><span class="line"><span class="comment">//1. 如果变量是内部链接的话，那么此变量只能在当前文件内访问</span></span><br><span class="line"><span class="comment">//2. 如果是变量是外部链接的话，那么此变量可以被其他文件使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局静态变量和局部静态变量有什么区别？</span></span><br><span class="line"><span class="comment">//1. 全局静态变量和局部静态变量都存储在静态区，都是在程序运行期间都是合法有效</span></span><br><span class="line"><span class="comment">//2. 局部静态变量符号的可见范围仅限于当前函数内部，全局静态变量可见范围从定义到文件结尾</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> v1 = <span class="number">20</span>; <span class="comment">//全局常变量，一旦初始化，不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> arr[] = <span class="string">"hello world!"</span>; <span class="comment">//局部静态变量，在静态区存储可读可写</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">'c'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> v2 = <span class="number">20</span>; <span class="comment">//局部常变量，可以通过指针或者引用进行间接修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* p = <span class="string">"hello world!"</span>; <span class="comment">//字符串"hello world!"在常量区，p局部变量：stack(栈)</span></span><br><span class="line"><span class="comment">//p[2] = 'c'; //只读，不可修改</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">test01();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态内存分配函数"><a href="#动态内存分配函数" class="headerlink" title="动态内存分配函数"></a>动态内存分配函数</h4><p>​    堆（<code>Heap</code>）是唯一由程序员控制的内存区域，我们常说的动态内存分配也是在这个区域。在堆上分配和释放内存需要用到C语言标准库中的几个函数：<code>malloc()</code>、<code>calloc()</code>、<code>realloc()</code> 和<code>free()</code>。</p><p>​    这几个函数的具体用法在<code>C</code>标准库中已经进行了讲解（点击上面链接查看），这里不再赘述，仅作简单的对比，并给出一个综合示例。</p><h5 id="1-malloc"><a href="#1-malloc" class="headerlink" title="1) malloc()"></a>1) <code>malloc()</code></h5><p>​    原型：<code>void* malloc (size_t size);</code></p><p>​    作用：在堆区分配<code>size</code>字节的内存空间。</p><p>​    返回值：成功返回分配的内存地址，失败则返回<code>NULL</code>。</p><p>​    注意：分配内存在动态存储区（堆区），手动分配，手动释放，申请时空间可能有也可能没有，需要自行判断，由于返回的是<code>void*</code>，建议手动强制类型转换。</p><h5 id="2-calloc"><a href="#2-calloc" class="headerlink" title="2) calloc()"></a>2) <code>calloc()</code></h5><p>原型：<code>void* calloc(size_t n, size_t size);</code></p><p> 功能：在堆区分配<code>n*size</code>字节的连续空间。</p><p> 返回值：成功返回分配的内存地址，失败则返回<code>NULL</code>。</p><p> 注意：<code>calloc()</code>函数是对<code>malloc()</code>函数的简单封装，参数不同，使用时务必小心，第一参数是第二参数的单元个数，第二参数是单位的字节数。</p><h5 id="3-realloc"><a href="#3-realloc" class="headerlink" title="3) realloc()"></a>3) <code>realloc()</code></h5><p>原型：<code>void* realloc(void *ptr, size_t size);</code></p><p> 功能：对<code>ptr</code>指向的内存重新分配<code>size</code>大小的空间，<code>size</code>可比原来的大或者小，还可以不变（如果你无聊的话）。</p><p> 返回值：成功返回更改后的内存地址，失败则返回<code>NULL</code>。</p><h5 id="4-free"><a href="#4-free" class="headerlink" title="4) free()"></a>4) <code>free()</code></h5><p>原型：<code>void free(void* ptr);</code></p><p> 功能：释放由<code>malloc()</code>、<code>calloc()</code>、<code>realloc()</code>申请的内存空间。</p><h5 id="几点注意"><a href="#几点注意" class="headerlink" title="几点注意"></a>几点注意</h5><p>1) <strong>每个内存分配函数必须有相应的<code>free</code>函数，释放后不能再次使用被释放的内存。</strong></p><p> 2) <strong>在分配内存时最好不要直接用数字指定内存空间的大小，这样不利于程序的移植。</strong>因为在不同的操作系统中，同一数据类型的长度可能不一样。为了解决这个问题，<code>C</code>语言提供了一个判断数据类型长度的操作符，就是<code>sizeof</code>。</p><p> 3) <strong><code>free(p)</code>并不能改变指针<code>p</code>的值，<code>p</code>依然指向以前的内存，为了防止再次使用该内存，建议将<code>p</code>的值手动置为<code>NULL</code>。</strong></p><p>​    <code>sizeof</code>是一个单目操作符，不是函数，用以获取数据类型的长度时必须加括号，例如<code>sizeof(int)</code>、<code>sizeof(char)</code> 等。</p><p> 最后是一个综合的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  N  (5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  N1 (7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  N2 (3)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ip;</span><br><span class="line">    <span class="keyword">int</span> *large_ip;</span><br><span class="line">    <span class="keyword">int</span> *small_ip;</span><br><span class="line">    <span class="keyword">if</span>((ip = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="keyword">int</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"memory allocated failed!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ip[i] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ip[%d] = %d\t"</span>, i, ip[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((large_ip = (<span class="keyword">int</span>* )<span class="built_in">realloc</span>(ip, N1 * <span class="keyword">sizeof</span>(<span class="keyword">int</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"memory allocated failed!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = N; i &lt; N1; i++)</span><br><span class="line">        large_ip[i] = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N1; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"large_ip[%d] = %d\t"</span>, i, large_ip[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((small_ip = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(large_ip, N2 * <span class="keyword">sizeof</span>(<span class="keyword">int</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"memory allocated failed!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N2; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"small_ip[%d] = %d\t"</span>, i, small_ip[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(small_ip);</span><br><span class="line">    small_ip = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>ip[0] = 0   ip[1] = 1   ip[2] = 2   ip[3] = 3   ip[4] = 4</code><br><code>large_ip[0] = 0 large_ip[1] = 1 large_ip[2] = 2 large_ip[3] = 3</code><br><code>large_ip[4] = 4 large_ip[5] = 9 large_ip[6] = 9</code><br><code>small_ip[0] = 0 small_ip[1] = 1 small_ip[2] = 2</code></p><p> 代码说明：<br> 1)  代码看似很长，其实较为简单，首先分配一个包含<code>5</code>个整型的内存区域，分别赋值<code>0</code>到<code>4</code>；再用<code>realloc</code>函数扩大内存区域以容纳<code>7</code>个整型数，对额外的两个整数赋值为<code>9</code>；最后再用<code>realloc</code>函数缩小内存区域，直接输出结果（因为<code>realloc</code>函数会自动复制数据）。</p><p> 2) 这次把分配函数与验证返回值验证写在了一起，为的是书写方便，考虑到优先级问题添加了适当的括号，这种写法较为常用，注意学习使用。</p><p> 3) 本例<code>free</code>函数只用释放<code>small_ip</code>指针即可，如函数介绍中注意里提到的，另外两个指针已被系统回收，不能再次使用。 </p><h2 id="Linux下64位环境的用户空间内存分布情况"><a href="#Linux下64位环境的用户空间内存分布情况" class="headerlink" title="Linux下64位环境的用户空间内存分布情况"></a><code>Linux</code>下<code>64</code>位环境的用户空间内存分布情况</h2><p>​    在<code>64</code>位环境下，虚拟地址空间大小为<code>256TB</code>，<code>Linux</code>将高<code>128TB</code>的空间分配给内核使用，而将低<code>128TB</code>的空间分配给用户程序使用。如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-160415151135409.jpg" alt></p><p>​    在<code>64</code>位环境下，虚拟地址虽然占用<code>64</code>位，但只有最低<code>48</code>位有效。这里需要补充的一点是，任何虚拟地址的<code>48</code>位至<code>63</code>位必须与<code>47</code>位一致。</p><p>​    上图中，用户空间地址的<code>47</code>位是<code>0</code>，所以高<code>16</code>位也是<code>0</code>，换算成十六进制形式，最高的四个数都是<code>0</code>；内核空间地址的<code>47</code>位是<code>1</code>，所以高<code>16</code>位也是<code>1</code>，换算成十六进制形式，最高的四个数都是<code>1</code>。这样中间的一部分地址正好空出来，也就是图中的“未定义区域”，这部分内存无论如何也访问不到。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之栈区</title>
      <link href="/2018/02/12/c%E8%AF%AD%E8%A8%803-%E6%A0%88%E5%8C%BA/"/>
      <url>/2018/02/12/c%E8%AF%AD%E8%A8%803-%E6%A0%88%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>程序的虚拟地址空间分为多个区域，栈（<code>Stack</code>）是其中地址较高的一个区域。<strong>栈（<code>Stack</code>）可以存放函数参数、局部变量、局部数组等作用范围在函数内部的数据，它的用途就是完成函数的调用。</strong></p><p>​    <strong>栈内存由系统自动分配和释放：发生函数调用时就为函数运行时用到的数据分配内存，函数调用结束后就将之前分配的内存全部销毁。</strong>所以局部变量、参数只在当前函数中有效，不能传递到函数外部。</p><a id="more"></a><h2 id="栈的概念"><a href="#栈的概念" class="headerlink" title="栈的概念"></a>栈的概念</h2><p>​    在计算机中，栈可以理解为一个特殊的容器，用户可以将数据依次放入栈中，然后再将数据按照相反的顺序从栈中取出。<strong>也就是说，先放入的数据最后才能取出，而最后放入的数据必须先取出。这称为先进后出（<code>First In Last Out</code>）原则。</strong></p><p>​    <strong>放入数据常称为入栈或压栈（<code>Push</code>），取出数据常称为出栈或弹出（<code>Pop</code>）。</strong>如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1603291J251110.jpg" alt><br> 图：数据的出栈和入栈</p><p>​    可以发现，栈底始终不动，出栈入栈只是在移动栈顶，当栈中没有数据时，栈顶和栈底重合。</p><p>​    从本质上来讲，栈是一段连续的内存，需要同时记录栈底和栈顶，才能对当前的栈进行定位。在现代计算机中，通常使用<code>ebp</code>寄存器指向栈底，而使用<code>esp</code>寄存器指向栈顶。随着数据的进栈出栈，<code>esp</code>的值会不断变化，进栈时<code>esp</code>的值减小，出栈时<code>esp</code>的值增大。</p><blockquote><p>​    <code>ebp</code>和<code>esp</code>都是CPU中的寄存器：<code>ebp</code>是<code>Extend Base Pointer</code>的缩写，通常用来指向栈底；<code>esp</code>是<code>Extend Stack Pointer</code>的缩写，通常用来指向栈顶。</p></blockquote><p>如下图所示是一个栈的实例：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-160330164123225.jpg" alt></p><h2 id="栈的大小以及栈溢出"><a href="#栈的大小以及栈溢出" class="headerlink" title="栈的大小以及栈溢出"></a>栈的大小以及栈溢出</h2><p>​    对每个程序来说，栈能使用的内存是有限的，一般是<code>1M~8M</code>，这在编译时就已经决定了，程序运行期间不能再改变。如果程序使用的栈内存超出最大值，就会发生栈溢出（<code>Stack Overflow</code>）错误。</p><blockquote><p>​    一个程序可以包含多个线程，每个线程都有自己的栈，严格来说，栈的最大值是针对线程来说的，而不是针对程序。</p></blockquote><p>​    栈内存的大小和编译器有关，编译器会为栈内存指定一个最大值，在<code>VC/VS</code> 下，默认是<code>1M</code>，在<code>C-Free</code>下，默认是<code>2M</code>，在<code>Linux GCC</code>下，默认是<code>8M</code>。</p><p>​    当然，我们也可以通过参数来修改栈内存的大小。以<code>VS2010</code>为例，在工程名处右击，会弹出一个菜单，选择“属性”，会出现一个对话框，如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-16040Q43K9311.png" alt></p><p>​    该图中，我们将栈内存设置为<code>4M</code>。提示：<strong>栈也经常被称为堆栈，而堆依然称为堆，所以堆栈这个概念并不包含堆，大家要注意区分。</strong></p><p>​    <strong>当程序使用的栈内存大于默认值（或者修改后的值）时，就会发生栈溢出（<code>Stack Overflow</code>）错误。</strong>使用<code>VS2010</code> 并切换到<code>Debug</code>模式，运行如下的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    局部字符数组<code>str</code>存储在栈上，占用<code>2M</code>的内存，超出了默认值<code>1M</code>，所以会发生栈溢出错误，如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-16040Q45220N2.png" alt></p><h2 id="栈帧-活动记录"><a href="#栈帧-活动记录" class="headerlink" title="栈帧/活动记录"></a>栈帧/活动记录</h2><p>​    <strong>当发生函数调用时，会将函数运行需要的信息全部压入栈中，这常常被称为栈帧（<code>Stack Frame</code>）或活动记录（<code>Activate Record</code>）。</strong>活动记录一般包括以下几个方面的内容：</p><p> <strong>1) 函数的返回地址，也就是函数执行完成后从哪里开始继续执行后面的代码。</strong>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a, b, c;</span><br><span class="line">func(1, 2);</span><br><span class="line">c = a + b;</span><br></pre></td></tr></table></figure><p>​    站在<code>C</code>语言的角度看，<code>func()</code>函数执行完成后，会继续执行<code>c=a+b;</code>语句，那么返回地址就是该语句在内存中的位置。</p><blockquote><p>​    注意：<code>C</code>语言代码最终会被编译为机器指令，确切地说，返回地址应该是下一条指令的地址，这里之所以说是下一条<code>C</code>语言语句的地址，仅仅是为了更加直观地说明问题。</p></blockquote><p><strong>2) 参数和局部变量。</strong>有些编译器，或者编译器在开启优化选项的情况下，会通过寄存器来传递参数，而不是将参数压入栈中，我们暂时不考虑这种情况。</p><p> <strong>3) 编译器自动生成的临时数据。</strong>例如，当函数返回值的长度较大（比如占用<code>40</code>个字节）时，会先将返回值压入栈中，然后再交给函数调用者。</p><blockquote><p>​    当返回值的长度较小（<code>char</code>、<code>int</code>、<code>long</code>等）时，不会被压入栈中，而是先将返回值放入寄存器，再传递给函数调用者。</p></blockquote><p><strong>4) 一些需要保存的寄存器，例如<code>ebp</code>、<code>ebx</code>、<code>esi</code>、<code>edi</code>等。</strong>之所以要保存寄存器的值，是为了在函数退出时能够恢复到函数调用之前的场景，继续执行上层函数。</p><p> 下图是一个函数调用的实例：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-160416150RK28.jpg" alt></p><pre><code>上图是在`Windows`下使用`VS2010 Debug`模式编译时一个函数所使用的栈内存，可以发现，理论上 `ebp `寄存器应该指向栈底，但在实际应用中，它却指向了`old ebp`。</code></pre><blockquote><p>在寄存器名字前面添加<code>“old”</code>，表示函数调用之前该寄存器的值。</p></blockquote><p>当发生函数调用时：</p><ul><li>实参、返回地址、<code>ebp</code>寄存器首先入栈；</li><li>然后再分配一块内存供局部变量、返回值等使用，这块内存一般比较大，足以容纳所有数据，并且会有冗余；</li><li>最后将其他寄存器的值压入栈中。</li></ul><p>需要注意的是，不同编译器在不同编译模式下所产生的函数栈并不完全相同，例如在<code>VS2010</code>下选择<code>Release</code>模式，编译器会进行大量优化，函数栈的样貌荡然无存，不具有教学意义，所以本教程以<code>VS2010 Debug</code>模式为例进行分析。</p><h2 id="关于数据的定位"><a href="#关于数据的定位" class="headerlink" title="关于数据的定位"></a>关于数据的定位</h2><p>​    由于<code>esp</code>的值会随着数据的入栈而不断变化，要想根据<code>esp</code>找到参数、局部变量等数据是比较困难的，所以在实现上是根据<code>ebp</code>来定位栈内数据的。<code>ebp</code>的值是固定的，数据相对<code>ebp</code>的偏移也是固定的，<code>ebp</code>的值加上偏移量就是数据的地址。</p><p>​    例如一个函数的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">28.5</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    调用形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="number">15</span>, <span class="number">92</span>);</span><br></pre></td></tr></table></figure><p>​    那么函数的活动记录如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1604161ATU15.jpg" alt></p><p>​    这里我们假设两个局部变量挨着，并且第一个变量和<code>old ebp</code>也挨着（实际上它们之间有<code>4</code>个字节的空白），如此，第一个参数的地址是<code>ebp+12</code>，第二个参数的地址是<code>ebp+8</code>，第一个局部变量的地址是<code>ebp-4</code>，第二个局部变量的地址是<code>ebp-8</code>。</p><h2 id="函数调用惯例"><a href="#函数调用惯例" class="headerlink" title="函数调用惯例"></a>函数调用惯例</h2><p>​    我们知道，一个<code>C</code>程序由若干个函数组成，<code>C</code>程序的执行实际上就是函数之间的相互调用。请看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"funcA被调用\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span>&#123;</span><br><span class="line">    funcA(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"funcB被调用\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    funcB(<span class="number">19.9</span>, <span class="number">28.5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main被调用\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>main()</code>调用了<code>funcB()</code>，<code>funcB()</code>又调用了<code>funcA()</code>。对于<code>main()</code>调用<code>funcB()</code>，我们称<code>main()</code>是调用方，<code>funcB()</code>是被调用方；同理，对于<code>funcB()</code>调用<code>funcA()</code>，<code>funcB()</code>是调用方，<code>funcA()</code>是被调用方。</p><p>​    函数的参数（实参）由调用方压入栈中供被调用方使用，它们之间要有一致的约定。例如，参数是从左到右入栈还是从右到左入栈，如果双方理解不一致，被调用方使用参数时就会出错。</p><p>​    以<code>funcB()</code>为例，假设<code>main()</code>函数先将 <code>19.9</code>入栈，后将<code>28.5</code>入栈，但是<code>funcB()</code>在使用这些实参时却认为<code>28.5</code>先入栈，<code>19.9</code>后入栈，那么就一定会产生混乱，误以为<code>19.9</code>是传递给<code>b</code>、<code>28.5</code>是传递给<code>a</code>的。</p><p>​    所以，<strong>函数调用方和被调用方必须遵守同样的约定，理解要一致，这称为调用惯例（<code>Calling Convention</code>）。</strong></p><p>​    一个调用惯例一般规定以下两方面的内容：</p><p> 1) <strong>函数参数的传递方式，是通过栈传递还是通过寄存器传递</strong>（这里我们只讲解通过栈传递的情况）。</p><p> 2) <strong>函数参数的传递顺序，是从左到右入栈还是从右到左入栈。</strong></p><p> 3) <strong>参数弹出方式。</strong>函数调用结束后需要将压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由调用方来完成，也可以由被调用方来完成。</p><p> 4) <strong>函数名修饰方式。</strong>函数名在编译时会被修改，调用惯例可以决定如何修改函数名。</p><p>​    在<code>C</code>语言中，存在多种调用惯例，可以在函数声明或函数定义时指定，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">max</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = max(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">max</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = m&gt;n ? m : n;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    函数调用惯例在函数声明和函数定义时都可以指定，语法格式为：</p><p><code>返回值类型  调用惯例  函数名(函数参数)</code></p><p>​    在函数声明处是为调用方指定调用惯例，而在函数定义处是为被调用方（也就是函数本身）指定调用惯例。</p><p>​    <code>__cdecl</code>是<code>C</code>语言默认的调用惯例，在平时编程中，我们其实很少去指定调用惯例，这个时候就使用默认的<code>__cdecl</code>。</p><blockquote><p>​    注意：<code>__cdecl</code>并不是标准关键字，上面的写法在<code>VC/VS</code>下有效，但是在<code>GCC</code>下，要使用<code>__attribute__((cdecl))</code>。</p></blockquote><p>除了<code>cdecl</code>，还有其他调用惯例，请看下表：</p><table><thead><tr><th>调用惯例</th><th>参数传递方式</th><th>参数出栈方式</th><th>名字修饰</th></tr></thead><tbody><tr><td><code>cdecl</code></td><td>按照从右到左的顺序入栈</td><td>调用方</td><td>下划线<code>+</code>函数名， 如函数<code>max()</code>的修饰名为<code>_max</code></td></tr><tr><td><code>stdcall</code></td><td>按照从右到左的顺序入栈</td><td>函数本身  （被调用方）</td><td>下划线<code>+</code>函数名<code>+@+</code>参数的字节数，如函数<code>int max(int m, int n)</code>的修饰名为<code>_max_@8</code></td></tr><tr><td><code>fastcall</code></td><td>将部分参数放入寄存器，剩下的参数按照从右到左的顺序入栈</td><td>函数本身 （被调用方）</td><td><code>@+</code>函数名<code>+@+</code>参数的字节数</td></tr><tr><td><code>pascal</code></td><td>按照从左到右的顺序入栈</td><td>函数本身 （被调用方）</td><td>较为复杂，这里不再展开讨论</td></tr></tbody></table><h2 id="分析函数进出栈"><a href="#分析函数进出栈" class="headerlink" title="分析函数进出栈"></a>分析函数进出栈</h2><p>​    前面我们只是讲解了一个函数的活动记录是什么样子的，相信大家对函数的详细调用过程的认识还不是太清晰，这节我们就以<code>VS2010 Debug</code>模式为例来深入分析一下。</p><p> 请看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p =<span class="number">12</span>, q = <span class="number">345</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func(<span class="number">90</span>, <span class="number">26</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    函数使用默认的调用惯例<code>cdecl</code>，即参数从右到左入栈，由调用方负责将参数出栈。函数的进栈出栈过程如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-160416234225209.jpg" alt></p><h3 id="函数进栈"><a href="#函数进栈" class="headerlink" title="函数进栈"></a>函数进栈</h3><p>步骤<code>①</code>到<code>⑥</code>是函数进栈过程：<br> 1) <code>main()</code>是主函数，也需要进栈，如步骤<code>①</code>所示。</p><p> 2) 在步骤<code>②</code>中，执行语句<code>func(90, 26);</code>，先将实参<code>90</code>、<code>26</code>压入栈中，再将返回地址压入栈中，这些工作都由<code>main()</code>函数（调用方）完成。这个时候<code>ebp</code>的值并没有变，仅仅是改变<code>esp</code>的指向。</p><p> 3) 到了步骤<code>③</code>，就开始执行<code>func()</code>的函数体了。首先将原来<code>ebp</code>寄存器的值压入栈中（也即图中的<code>old ebp</code>），并将<code>esp</code>的值赋给<code>ebp</code>，这样<code>ebp</code>就从<code>main()</code>函数的栈底指向了<code>func()</code>函数的栈底，完成了函数栈的切换。由于此时<code>esp</code>和<code>ebp</code>的值相等，所以它们也就指向了同一个位置。</p><p> 4) 为局部变量、返回值等预留足够的内存，如步骤<code>④</code>所示。由于栈内存在函数调用之前就已经分配好了，所以这里并不是真的分配内存，而是将<code>esp</code>的值减去一个整数，例如<code>esp - 0XC0</code>，就是预留<code>0XC0</code>字节的内存。</p><p> 5) 将<code>ebp</code>、<code>esi</code>、<code>edi</code>寄存器的值依次压入栈中。</p><p> 6) 将局部变量的值放入预留好的内存中。注意，第一个变量和<code>old ebp</code>之间有4个字节的空白，变量之间也有若干字节的空白。</p><p>​    为什么要留出这么多的空白，岂不是浪费内存吗？这是因为我们使用<code>Debug</code>模式生成程序，留出多余的内存，方便加入调试信息；以<code>Release</code>模式生成程序时，内存将会变得更加紧凑，空白也被消除。</p><p>​    至此，<code>func()</code>函数的活动记录就构造完成了。可以发现，在函数的实际调用过程中，形参是不存在的，不会占用内存空间，内存中只有实参，而且是在执行函数体代码之前、由调用方压入栈中的。</p><h4 id="未初始化的局部变量的值为什么是垃圾值"><a href="#未初始化的局部变量的值为什么是垃圾值" class="headerlink" title="未初始化的局部变量的值为什么是垃圾值"></a>未初始化的局部变量的值为什么是垃圾值</h4><p>​    为局部变量分配内存时，仅仅是将<code>esp</code>的值减去一个整数，预留出足够的空白内存，不同的编译器在不同的模式下会对这片空白内存进行不同的处理，可能会初始化为一个固定的值，也可能不进行初始化。</p><p>​    例如在<code>VS2010 Debug</code>模式下，会将预留出来的内存初始化为<code>0XCCCCCCCC</code>，如果不对局部变量赋值，它们的内存就不会改变，输出时的结果就是<code>0XCCCCCCCC</code>，请看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%#X, %#X\n"</span>, m, n);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><code>0XCCCCCCCC, 0XCCCCCCCC</code></p><p>​    虽然编译器对空白内存进行了初始化，但这个值对我们来说一般没有意义，所以我们可以认为它是垃圾值、是随机的。</p><h3 id="函数出栈"><a href="#函数出栈" class="headerlink" title="函数出栈"></a>函数出栈</h3><p>步骤<code>⑦</code>到<code>⑨</code>是函数<code>func()</code>出栈过程：<br> 7) 函数<code>func()</code>执行完成后开始出栈，首先将<code>edi</code>、<code>esi</code>、<code>ebx</code>寄存器的值出栈。</p><p> 8) 将局部变量、返回值等数据出栈时，直接将<code>ebp</code>的值赋给<code>esp</code>，这样<code>ebp</code>和<code>esp</code>就指向了同一个位置。</p><p> 9) 接下来将 <code>old ebp</code>出栈，并赋值给现在的<code>ebp</code>，此时<code>ebp</code>就指向了<code>func()</code>调用之前的位置，即 <code>main()</code>活动记录的<code>old ebp</code> 位置，如步骤<code>⑨</code>所示。</p><p>​    这一步很关键，保证了还原到函数调用之前的情况，这也是每次调用函数时都必须将<code>old ebp</code>压入栈中的原因。</p><p>​    最后根据返回地址找到下一条指令的位置，并将返回地址和实参都出栈，此时<code>esp</code>就指向了<code>main()</code>活动记录的栈顶， 这意味着<code>func()</code>完全出栈了，栈被还原到了<code>func()</code>被调用之前的情况。</p><h4 id="遗留的错误认知"><a href="#遗留的错误认知" class="headerlink" title="遗留的错误认知"></a>遗留的错误认知</h4><p>​    经过上面的分析可以发现，函数出栈只是在增加<code>esp</code>寄存器的值，使它指向上一个数据，并没有销毁之前的数据。前面我们讲局部变量在函数运行结束后立即被销毁其实是错误的，这只是为了让大家更容易理解，对局部变量的作用范围有一个清晰的认识。</p><p>​    栈上的数据只有在后续函数继续入栈时才能被覆盖掉，这就意味着，只要时机合适，在函数外部依然能够取得局部变量的值。请看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">18</span>, b = <span class="number">100</span>;</span><br><span class="line">    p = &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    func(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    n = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n = %d\n"</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>n = 18</code></p><p>​    在<code>func()</code>中，将局部变量<code>a</code>的地址赋给<code>p</code>，在<code>main()</code>函数中调用<code>func()</code>，函数刚刚调用结束，还没有其他函数入栈，局部变量<code>a</code>所在的内存没有被覆盖掉，所以通过语句<code>n = *p;</code>能够取得它的值。</p><h2 id="栈溢出攻击的原理"><a href="#栈溢出攻击的原理" class="headerlink" title="栈溢出攻击的原理"></a>栈溢出攻击的原理</h2><p>​    我们先来看下面的一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str: %s\n"</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在<code>main()</code>函数内部定义一个字符数组，并通过<code>gets()</code>为它赋值。</p><p>​    在<code>VS2010 Debug</code>模式下运行程序，当输入的字符不超过<code>10</code>个时，可以正确输出，但是当输入的字符过多时，就会出现运行时错误。例如输入<code>&quot;12345678901234567890&quot;</code>，就会出现下面的错误：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-16041G35029191.png" alt></p><p>​    这是为什么呢？我们不妨先来看一下<code>main()</code>函数的栈：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-16041G35J3620.jpg" alt></p><p>​    局部数组也是在栈上分配内存，当输入<code>&quot;12345678901234567890&quot;</code>时，会发生数组溢出，占用<code>“4字节空白内存”</code>、<code>“old  ebp”</code>和<code>“返回地址”</code>所在的内存，并将原有的数据覆盖掉，这样当<code>main()</code>函数执行完成后，会取得一个错误的返回地址，该地址上的指令是不确定的，或者根本就没有指令，所以程序在返回时出错。</p><p>​    <code>C</code>语言不会对数组溢出做检测，这是一个典型的由于数组溢出导致覆盖了函数返回地址的例子，我们将这样的错误称为“栈溢出错误”。</p><blockquote><p>​    注意：这里所说的“栈溢出”是指栈上的某个数据过大，覆盖了其他的数据。</p></blockquote><p>​    局部数组在栈上分配内存，并且不对数组溢出做检测，这是导致栈溢出的根源。除了上面讲到的<code>gets()</code>函数，<code>strcpy()</code>、<code>scanf()</code>等能够向数组写入数据的函数都有导致栈溢出的风险。</p><p>​    下面是使用<code>strcpy()</code>函数导致栈溢出的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">"这里是C语言中文网"</span>;</span><br><span class="line">    <span class="keyword">char</span> str2[<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(str2, str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str: %s\n"</span>, str2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    将<code>str1</code>复制到<code>str2</code>，显然超出了<code>str2</code>的接受范围，会发生溢出，覆盖返回地址，导致<code>main()</code>函数返回时出错。</p><p>​    栈溢出一般不会产生严重的后果，但是如果有用户精心构造栈溢出，让返回地址指向恶意代码，那就比较危险了，这就是常说的栈溢出攻击。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之指针和数组</title>
      <link href="/2018/02/05/c%E8%AF%AD%E8%A8%802-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84/"/>
      <url>/2018/02/05/c%E8%AF%AD%E8%A8%802-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="数组和指针的不同"><a href="#数组和指针的不同" class="headerlink" title="数组和指针的不同"></a>数组和指针的不同</h2><p>​    通过前面的讲解，相信很多读者都会认为数组和指针是等价的，数组名表示数组的首地址。不幸的是，这是一种非常危险的想法，并不完全正确，前面我们将数组和指针等价起来是为了方便大家理解（在大多数情况下数组名确实可以当做指针使用），不至于被指针难倒，这节请大家放弃这种观念，我将会颠覆你的认知。</p><a id="more"></a><p>​    <strong>数组和指针不等价的一个典型案例就是求数组的长度，这个时候只能使用数组名，不能使用数组指针。</strong>前面我们已经强调过了，这里不妨再来演示一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = a;</span><br><span class="line">    <span class="keyword">int</span> len_a = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> len_p = <span class="keyword">sizeof</span>(p) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"len_a = %d, len_p = %d\n"</span>, len_a, len_p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：</p><p><code>len_a = 6, len_p = 1</code></p><p>​    数组是一系列数据的集合，没有开始和结束标志，<code>p</code>仅仅是一个指向<code>int</code>类型的指针，编译器不知道它指向的是一个整数还是一堆整数，对<code>p</code>使用<code>sizeof</code>求得的是指针变量本身的长度。也就是说，编译器并没有把<code>p</code>和数组关联起来，<code>p</code>仅仅是一个指针变量，不管它指向哪里，<code>sizeof</code>求得的永远是它本身所占用的字节数。</p><p>​    站在编译器的角度讲，变量名、数组名都是一种符号，它们最终都要和数据绑定起来。<strong>变量名用来指代一份数据，数组名用来指代一组数据（数据集合），它们都是有类型的，以便推断出所指代的数据的长度。</strong></p><p>​    对，数组也有类型，这是很多读者没有意识到的，大部分<code>C</code>语言书籍对这一点也含糊其辞！我们可以将 <code>int</code>、<code>float</code>、<code>char</code>等理解为基本类型，将数组理解为由基本类型派生得到的稍微复杂一些的类型。<code>sizeof</code>就是根据符号的类型来计算长度的。</p><p>​    对于数组<code>a</code>，它的类型是<code>int [6]</code>，表示这是一个拥有<code>6</code>个<code>int</code>数据的集合，<code>1</code>个<code>int</code>的长度为<code>4</code>，<code>6</code>个<code>int</code> 的长度为<code>4×6 = 24</code>，<code>sizeof</code>很容易求得。</p><p>​    对于指针变量<code>p</code>，它的类型是<code>int *</code>，在<code>32</code>位环境下长度为<code>4</code>，在<code>64</code>位环境下长度为<code>8</code>。</p><p>​    归根结底，<code>a</code>和<code>p</code>这两个符号的类型不同，指代的数据也不同，它们不是一码事，<code>sizeof</code>是根据符号类型来求长度的，<code>a</code>和<code>p</code>的类型不同，求得的长度自然也不一样。</p><p>​    对于二维数组，也是类似的道理，例如<code>int a[3][3]={1, 2, 3, 4, 5, 6, 7, 8, 9};</code>，它的类型是<code>int [3][3]</code>，长度是<code>4×3×3 = 36</code>。</p><h2 id="站在哲学的高度看问题"><a href="#站在哲学的高度看问题" class="headerlink" title="站在哲学的高度看问题"></a>站在哲学的高度看问题</h2><p>​    编程语言的目的是为了将计算机指令（机器语言）抽象成人类能够理解的自然语言，让程序员能够更加容易地管理和操作各种计算机资源，这些计算机资源最终表现为编程语言中的各种符号和语法规则。</p><p>​    整数、小数、数组、指针等不同类型的数据都是对内存的抽象，它们的名字用来指代不同的内存块，程序员在编码过程中不需要直接面对内存，使用这些名字将更加方便。</p><p>​    编译器在编译过程中会创建一张专门的表格用来保存名字以及名字对应的数据类型、地址、作用域等信息，<code>sizeof</code>是一个操作符，不是函数，使用<code>sizeof</code>时可以从这张表格中查询到符号的长度。</p><p>​    与普通变量名相比，<strong>数组名既有一般性也有特殊性：一般性表现在数组名也用来指代特定的内存块，也有类型和长度；特殊性表现在数组名有时候会转换为一个指针，而不是它所指代的数据本身的值。</strong></p><h2 id="数组什么时候转换为指针"><a href="#数组什么时候转换为指针" class="headerlink" title="数组什么时候转换为指针"></a>数组什么时候转换为指针</h2><p>​    数组名的本意是表示一组数据的集合，它和普通变量一样，都用来指代一块内存，但在使用过程中，数组名有时候会转换为指向数据集合的指针（地址），而不是表示数据集合本身，这在前面的例子中已经被多次证实。</p><p>​    数据集合包含了多份数据，直接使用一个集合没有明确的含义，将数组名转换为指向数组的指针后，可以很容易地访问其中的任何一份数据，使用时的语义更加明确。</p><p>​    <strong><code>C</code>语言标准规定，当数组名作为数组定义的标识符（也就是定义或声明数组时）、<code>sizeof</code>或<code>&amp;</code>的操作数时，它才表示整个数组本身，在其他的表达式中，数组名会被转换为指向第<code>0</code>个元素的指针（地址）。</strong></p><p>​    数组和指针的关系颇像诗和词的关系，它们都是一种文学形式，有不少共同之处，但在实际的表现手法上又各有特色。</p><h2 id="再谈数组下标"><a href="#再谈数组下标" class="headerlink" title="再谈数组下标[]"></a>再谈数组下标<code>[]</code></h2><p>​    <code>C</code>语言标准还规定，数组下标与指针的偏移量相同。通俗地理解，就是对数组下标的引用总是可以写成“一个指向数组的起始地址的指针加上偏移量”。假设现在有一个数组<code>a</code>和指针变量<code>p</code>，它们的定义形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, *p, i = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>​    读者可以通过以下任何一种方式来访问<code>a[i]</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = a;  p[i]; </span><br><span class="line">p = a;  *(p + i); </span><br><span class="line">p = a + i;  *p;</span><br></pre></td></tr></table></figure></p><p>​    对数组的引用<code>a[i]</code>在编译时总是被编译器改写成<code>*(a+i)</code>的形式，<code>C</code>语言标准也要求编译器必须具备这种行为。</p><p>​    取下标操作符<code>[]</code>是建立在指针的基础上，它的作用是使一个指针和一个整数相加，产生出一个新的指针，然后从这个新指针（新地址）上取得数据；假设指针的类型为<code>T *</code>，所产生的结果的类型就是<code>T</code>。</p><p>​    取下标操作符的两个操作数是可以交换的，它并不在意操作数的先后顺序，就像在加法中<code>3+5</code>和<code>5+3</code>并没有什么不一样。以上面的数组<code>a</code>为例，如果希望访问第<code>3</code>个元素，那么可以写作<code>a[3]</code>，也可以写作<code>3[a]</code>，这两种形式都是正确的，只不过后面的形式从不曾使用，它除了可以把初学者搞晕之外，实在没有什么实际的意义。</p><blockquote><p><code>a[3]</code>等价于<code>*(a + 3)</code>，<code>3[a]</code>等价于<code>*(3 + a)</code>，仅仅是把加法的两个操作数调换了位置。</p></blockquote><p>​    使用下标时，编译器会自动把下标的步长调整到数组元素的大小。数组<code>a</code>中每个元素都是<code>int</code>类型，长度为<code>4</code>个字节，那么<code>a[i+1]</code>和<code>a[i]</code>在内存中的距离是<code>4</code>（而不是<code>1</code>）。</p><h2 id="数组作函数参数"><a href="#数组作函数参数" class="headerlink" title="数组作函数参数"></a>数组作函数参数</h2><p>​    <strong><code>C</code>语言标准规定，作为“类型的数组”的形参应该调整为“类型的指针”。</strong>在函数形参定义这个特殊情况下，编译器必须把数组形式改写成指向数组第<code>0</code>个元素的指针形式。编译器只向函数传递数组的地址，而不是整个数组的拷贝。</p><p>​    这种隐式转换意味着下面三种形式的函数定义是完全等价的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *parr)</span></span>&#123; ...... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123; ...... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> arr[<span class="number">5</span>])</span></span>&#123; ...... &#125;</span><br></pre></td></tr></table></figure><p>​    <strong>在函数内部，<code>arr</code>会被转换成一个指针变量，编译器为<code>arr</code>分配<code>4</code>个字节的内存，用<code>sizeof(arr)</code>求得的是指针变量的长度，而不是数组长度。要想在函数内部获得数组长度必须额外增加一个参数，在调用函数之前求得数组长度。</strong></p><p>​    参数传递是一次赋值的过程，赋值也是一个表达式，函数调用时不管传递的是数组名还是数组指针，效果都是一样的，相当于给一个指针变量赋值。</p><p>​    把作为形参的数组和指针等同起来是出于效率方面的考虑。数组是若干类型相同的数据的集合，数据的数目没有限制，可能只有几个，也可能成千上万，如果要传递整个数组，无论在时间还是内存空间上的开销都可能非常大。而且绝大部分情况下，我们其实并不需要整个数组的拷贝，我们只想告诉函数在那一时刻对哪个特定的数组感兴趣。</p><h2 id="关于数组和指针可交换性的总结"><a href="#关于数组和指针可交换性的总结" class="headerlink" title="关于数组和指针可交换性的总结"></a>关于数组和指针可交换性的总结</h2><p>​    1) 用<code>a[i]</code>这样的形式对数组进行访问总是会被编译器改写成（或者说解释为）像<code>*(a+i)</code>这样的指针形式。</p><p>​    2) 指针始终是指针，它绝不可以改写成数组。你可以用下标形式访问指针，一般都是指针作为函数参数时，而且你知道实际传递给函数的是一个数组。</p><p>​    3) 在特定的环境中，也就是数组作为函数形参，也只有这种情况，一个数组可以看做是一个指针。作为函数形参的数组始终会被编译器修改成指向数组第一个元素的指针。</p><p>​    4) 当希望向函数传递数组时，可以把函数参数定义为数组形式（可以指定长度也可以不指定长度），也可以定义为指针。不管哪种形式，在函数内部都要作为指针变量对待。</p><h2 id="解析指针和数组"><a href="#解析指针和数组" class="headerlink" title="解析指针和数组"></a>解析指针和数组</h2><p>​    前面我们讲解了指针数组、二维数组指针、函数指针等几种较为复杂的指针，它们的定义形式分别是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1[<span class="number">6</span>];  <span class="comment">//指针数组</span></span><br><span class="line"><span class="keyword">int</span> *(p2[<span class="number">6</span>]);  <span class="comment">//指针数组，和上面的形式等价</span></span><br><span class="line"><span class="keyword">int</span> (*p3)[<span class="number">6</span>];  <span class="comment">//二维数组指针</span></span><br><span class="line"><span class="keyword">int</span> (*p4)(<span class="keyword">int</span>, <span class="keyword">int</span>);  <span class="comment">//函数指针</span></span><br></pre></td></tr></table></figure><p>​    我相信大部分初学者对上面几种形式的指针都非常迷惑，不知道该从哪里入手去理解，为什么<code>p1</code>、<code>p2</code>是数组，而<code>p3</code>却是指针呢，它们仅仅是一个括号的区别。</p><p>​    指针是<code>C</code>语言中最强大最灵活的一部分，也是最难以理解的一部分，它是学习<code>C</code>语言的重点，没有学会指针就无从谈学会<code>C</code>语言。如果大家觉得上面几种形式的指针还能勉强接受，那么下面两个指针是不是让人抓狂呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *(* c[<span class="number">10</span>])(<span class="keyword">int</span> **p);</span><br><span class="line"><span class="keyword">int</span> (*(*(*pfunc)(<span class="keyword">int</span> *))[<span class="number">5</span>])(<span class="keyword">int</span> *);</span><br></pre></td></tr></table></figure><p>​    只要找到了窍门，再复杂的指针也是可以理解的，这节我们就来戳破这层窗户纸！</p><p>​    <code>C</code>语言标准规定，对于一个符号的定义，编译器总是从它的名字开始读取，然后按照优先级顺序依次解析。对，从名字开始，不是从开头也不是从末尾，这是理解复杂指针的关键！</p><p>​    对于初学者，有几种运算符的优先级非常容易混淆，它们的优先级从高到低依次是：</p><ul><li>定义中被括号<code>()</code>括起来的那部分。</li><li>后缀操作符：括号<code>()</code>表示这是一个函数，方括号<code>[]</code>表示这是一个数组。</li><li>前缀操作符：星号<code>*</code>表示<code>“指向xxx的指针”</code>。</li></ul><p> 学会了“绝杀招式”，接下来我们就由浅入深，逐个击破上面的指针定义。</p><h3 id="1-int-p1-6"><a href="#1-int-p1-6" class="headerlink" title="1)int *p1[6];"></a>1)<code>int *p1[6];</code></h3><p>​    从<code>p1</code>开始理解，它的左边是<code>*</code>，右边是<code>[]</code>，<code>[]</code>的优先级高于<code>*</code>，所以编译器先解析<code>p1[6]</code>，<code>p1</code>首先是一个拥有<code>6</code>个元素的数组，然后再解析<code>int *</code>，它用来说明数组元素的类型。从整体上讲，<code>p1</code>是一个拥有<code>6</code>个<code>int *</code>元素的数组，也即指针数组。</p><h3 id="2-int-p3-6"><a href="#2-int-p3-6" class="headerlink" title="2)int (*p3)[6];"></a>2)<code>int (*p3)[6];</code></h3><p>​    从<code>p3</code>开始理解，<code>()</code>的优先级最高，编译器先解析<code>(*p3)</code>，<code>p3</code>首先是一个指针，剩下的<code>int [6]</code>是<code>p3</code>指向的数据的类型，它是一个拥有<code>6</code>个元素的一维数组。从整体上讲，<code>p3</code>是一个指向拥有<code>6</code>个<code>int</code>元素数组的指针，也即二维数组指针。</p><blockquote><p>​    为了能够通过指针来遍历数组元素，在定义数组指针时需要进行降维处理，例如三维数组指针实际指向的数据类型是二维数组，二维数组指针实际指向的数据类型是一维数组，一维数组指针实际指向的是一个基本类型；在表达式中，数组名也会进行同样的转换（下降一维）。</p></blockquote><h3 id="3-int-p4-int-int"><a href="#3-int-p4-int-int" class="headerlink" title="3) int (*p4)(int, int);"></a>3) <code>int (*p4)(int, int);</code></h3><p>​    从<code>p4</code>开始理解，<code>()</code>的优先级最高，编译器先解析<code>(*p4)</code>，<code>p4</code>首先是一个指针，它后边的<code>()</code>说明<code>p4</code>指向的是一个函数，括号中的<code>int, int</code>是参数列表，开头的<code>int</code>用来说明函数的返回值类型。整体来看，<code>p4</code>是一个指向原型为<code>int func(int, int);</code>的函数的指针。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之函数返回值</title>
      <link href="/2018/01/23/c%E8%AF%AD%E8%A8%802-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
      <url>/2018/01/23/c%E8%AF%AD%E8%A8%802-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p><strong>问：那些临时变量是不能作为返回值的？</strong></p><h4 id="返回局部变量"><a href="#返回局部变量" class="headerlink" title="返回局部变量"></a>返回局部变量</h4><p>​    首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，已经可能被分配给其他变量了。所以在函数退出后，该内存可能已经被修改了，对于临时变量来说已经是没有意义的值了。</p><a id="more"></a><p>​     <code>C</code>语言里规定：<code>16bit</code>程序中，返回值保存在<code>ax</code>寄存器中，<code>32bit</code>程序中，返回值保持在<code>eax</code>寄存器中，如果是<code>64bit</code>返回值，<code>edx</code>寄存器保存高<code>32bit</code>，<code>eax</code>寄存器保存低<code>32bit</code>。</p><pre><code>由此可见，函数调用结束后，**返回值被临时存储到寄存器中**，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中，与临时变量的生命周期没有关系。</code></pre><p>​    如果我们需要返回值，一般使用赋值语句就可以了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a = func();</span><br></pre></td></tr></table></figure><pre><code>综上，**函数是可以将临时变量的值作为返回值的。**</code></pre><h4 id="返回局部变量的指针"><a href="#返回局部变量的指针" class="headerlink" title="返回局部变量的指针"></a>返回局部变量的指针</h4><p>​    然而将一个指向局部变量的指针作为函数的返回值是有问题的。</p><p>​    由于指针指向局部变量，因此在函数返回时，临时变量被销毁，指针指向一块无意义的地址空间，所以一般不会有返回值。</p><p>​    如果得到正常的值，只能是幸运的，因为退出函数的时候，系统只是修改了栈顶的指针，并没有清内存；所以，是有可能正常访问到局部变量的内存的。但因为栈是系统自动管理的，所以该内存可能会可以被分配给其他函数，这样，该内存的内容就会被覆盖，不再是原来的值了。</p><p>​    常规程序中，函数返回的指针（函数指针，数组指针，结构体指针，联合体指针等）通常应该是：</p><p> (1)、<strong>指向静态（<code>static</code>）变量；</strong></p><p> (2)、<strong>指向专门申请分配的（如用<code>malloc</code>）空间；</strong></p><p> (3)、<strong>指向常量区（如指向字符串<code>&quot;hello&quot;</code>）；</strong></p><p> (4)、<strong>指向全局变量；</strong></p><p> (5)、<strong>指向程序代码区（如指向函数的指针）。</strong></p><p>​    对于结构体和联合体来说，在作为函数的参数和返回值时，表现与<code>C</code>语言的内置类型（<code>int</code>,<code>float</code>, <code>char</code>等）是一样的。当为临时变量的时候，作为返回值是有效的。这个也是与指针不同的地方。但是不要与结构体指针或者联合体指针弄混了，他们是指针，而不是自定义数据类型。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言-整数在内存的存储</title>
      <link href="/2018/01/21/c%E8%AF%AD%E8%A8%801-%E6%95%B4%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8/"/>
      <url>/2018/01/21/c%E8%AF%AD%E8%A8%801-%E6%95%B4%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<p>​    加法和减法是计算机中最基本的运算，计算机时时刻刻都离不开它们，所以它们由硬件直接支持。为了提高加减法的运算效率，硬件电路要设计得尽量简单。<br>​    对于有符号数，内存要区分符号位和数值位，对于人脑来说，很容易辨别，但是对于计算机来说，就要设计专门的电路，这无疑增加了硬件的复杂性，增加了计算的时间。要是能把符号位和数值位等同起来，让它们一起参与运算，不再加以区分，这样硬件电路就变得简单了。</p><a id="more"></a><h3 id="整数在内存的存储"><a href="#整数在内存的存储" class="headerlink" title="整数在内存的存储"></a>整数在内存的存储</h3><p>​    另外，加法和减法也可以合并为一种运算，就是加法运算，因为减去一个数相当于加上这个数的相反数，例如，<code>5 - 3</code>等价于 <code>5 + (-3)</code>，<code>10 - (-9)</code>等价于<code>10 + 9</code>。 </p><blockquote><p> 相反数是指数值相同，符号不同的两个数，例如，<code>10</code>和<code>-10</code>就是一对相反数，<code>-98</code>和<code>98</code>也是一对相反数。</p></blockquote><p>​    如果能够实现上面的两个目标，那么只要设计一种简单的、不用区分符号位和数值位的加法电路，就能同时实现加法和减法运算，并且非常高效。实际上，这两个目标都已经实现了，真正的计算机硬件电路就是如此简单。</p><p>​    然而，简化硬件电路是有代价的，这个代价就是有符号数在存储和读取时都要进行转化。那么，这个转换过程究竟是怎样的呢？接下来我们就详细地讲解一下。</p><p>​    首先，请读者先记住下面的几个概念。 </p><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>​    <strong>将一个整数转换成二进制形式，就是其原码。</strong>例如<code>short a = 6;</code>，<code>a</code>的原码就是<code>0000 0000 0000 0110</code>；更改<code>a</code>的值<code>a = -18;</code>，此时<code>a</code>的原码就是<code>1000 0000 0001 0010</code>。</p><p>​    通俗的理解，<strong>原码就是一个整数本来的二进制形式。</strong></p><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>​    谈到反码，正数和负数要区别对待，因为它们的反码不一样。</p><p>​    <strong>对于正数，它的反码就是其原码（原码和反码相同）；负数的反码是将原码中除符号位以外的所有位（数值位）取反，也就是<code>0</code>变成<code>1</code>，<code>1</code>变成<code>0</code>。</strong>例如<code>short a = 6;</code>，<code>a</code>的原码和反码都是<code>0000 0000 0000 0110</code>；更改<code>a</code>的值<code>a = -18;</code>，此时<code>a</code>的反码是<code>1111 1111 1110 1101</code>。</p><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>​    正数和负数的补码也不一样，也要区别对待。</p><p>​    <strong>对于正数，它的补码就是其原码（原码、反码、补码都相同）；负数的补码是其反码加<code>1</code>。</strong>例如<code>short a = 6;</code>，<code>a</code>的原码、反码、补码都是<code>0000 0000 0000 0110</code>；更改<code>a</code>的值<code>a = -18;</code>，此时<code>a</code>的补码是<code>1111 1111 1110 1110</code>。</p><p>​    可以认为，补码是在反码的基础上打了一个补丁，进行了一下修正，所以叫“补码”。</p><p>​    <strong>原码、反码、补码的概念只对负数有实际意义，对于正数，它们都一样。</strong></p><p>​    最后我们总结一下<code>6</code>和<code>-18</code>从原码到补码的转换过程： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1G01G5120I49.jpg" alt></p><p>​    <strong>在计算机内存中，整数一律采用补码的形式来存储。这意味着，当读取整数时还要采用逆向的转换，也就是将补码转换为原码。</strong></p><p>​    将补码转换为原码也很简单：先减去<code>1</code>，再将数值位取反即可。</p><h4 id="补码如何简化硬件电路"><a href="#补码如何简化硬件电路" class="headerlink" title="补码如何简化硬件电路"></a>补码如何简化硬件电路</h4><p>​    假设<code>6</code>和<code>18</code>都是<code>short</code>类型的，现在我们要计算<code>6 - 18</code>的结果，根据运算规则，它等价于<code>6 + (-18)</code>。</p><p>​    如果采用原码计算，那么运算过程为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> - <span class="number">18</span> = <span class="number">6</span> + (<span class="number">-18</span>)</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0110</span>]原 + [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0010</span>]原</span><br><span class="line">= [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1000</span>]原</span><br><span class="line">= <span class="number">-24</span></span><br></pre></td></tr></table></figure></p><p>​    直接用原码表示整数，让符号位也参与运算，对于类似上面的减法来说，结果显然是不正确的。</p><p>​    于是人们开始继续探索，不断试错，后来设计出了反码。下面就演示了反码运算的过程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> - <span class="number">18</span> = <span class="number">6</span> + (<span class="number">-18</span>)</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0110</span>]反 + [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1110</span> <span class="number">1101</span>]反</span><br><span class="line">= [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0011</span>]反</span><br><span class="line">= [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span>]原</span><br><span class="line">= <span class="number">-12</span></span><br></pre></td></tr></table></figure></p><p>​    这样一来，计算结果就正确了。</p><p>​    然而，这样还不算万事大吉，我们不妨将减数和被减数交换一下位置，也就是计算<code>18 - 6</code> 的结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span> - <span class="number">6</span> = <span class="number">18</span> + (<span class="number">-6</span>)</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0010</span>]反 + [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1001</span>]反</span><br><span class="line">= [<span class="number">1</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1011</span>]反</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1011</span>]反</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1011</span>]原</span><br><span class="line">= <span class="number">11</span></span><br></pre></td></tr></table></figure></p><p>​    按照反码计算的结果是<code>11</code>，而真实的结果应该是<code>12</code>才对，它们相差了<code>1</code>。 </p><blockquote><p> 蓝色的 <strong><code>1</code></strong> 是加法运算过程中的进位，它溢出了，内存容纳不了了，所以直接截掉。</p></blockquote><p>​    <code>6 - 18</code> 的结果正确，<code>18 - 6</code> 的结果就不正确，相差<code>1</code>。按照反码来计算，是不是小数减去大数正确，大数减去小数就不对了，始终相差<code>1</code>呢？我们不妨再看两个例子，分别是 <code>5 - 13</code> 和 <code>13 - 5</code>。</p><p>​    <code>5 - 13</code>的运算过程为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> - <span class="number">13</span> = <span class="number">5</span> + (<span class="number">-13</span>)</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0101</span>]原 + [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1101</span>]原</span><br><span class="line">=  [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0101</span>]反 + [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0010</span>]反</span><br><span class="line">= [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0111</span>]反</span><br><span class="line">= [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span>]原</span><br><span class="line">= <span class="number">-8</span></span><br></pre></td></tr></table></figure></p><p><code>13 - 5</code>的运算过程为： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span> - <span class="number">5</span> = <span class="number">13</span> + (<span class="number">-5</span>)</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1101</span>]原 + [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0101</span>]原</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1101</span>]反 + [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1010</span>]反</span><br><span class="line">= [<span class="number">1</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span>]反 </span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span>]反</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span>]原</span><br><span class="line">= <span class="number">7</span></span><br></pre></td></tr></table></figure><p>​    这足以证明，刚才的猜想是正确的：小数减去大数不会有问题，而大数减去小数的就不对了，结果始终相差<code>1</code>。</p><p>​    相差的这个<code>1</code>要进行纠正，但是又不能影响小数减去大数，怎么办呢？于是人们又绞尽脑汁设计出了补码，给反码打了一个“补丁”，终于把相差的<code>1</code>给纠正过来了。</p><p>​    下面演示了按照补码计算的过程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> - <span class="number">18</span> = <span class="number">6</span> + (<span class="number">-18</span>)</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0110</span>]补 + [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1110</span> <span class="number">1110</span>]补</span><br><span class="line">= [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0100</span>]补</span><br><span class="line">=  [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0011</span>]反</span><br><span class="line">= [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span>]原</span><br><span class="line">= <span class="number">-12</span></span><br><span class="line"> </span><br><span class="line"><span class="number">18</span> - <span class="number">6</span> = <span class="number">18</span> + (<span class="number">-6</span>)</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0010</span>]补 + [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1010</span>]补</span><br><span class="line">= [<span class="number">1</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span>]补</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span>]补</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span>]反</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span>]原</span><br><span class="line">= <span class="number">12</span></span><br><span class="line"> </span><br><span class="line"><span class="number">5</span> - <span class="number">13</span> = <span class="number">5</span> + (<span class="number">-13</span>)</span><br><span class="line">=  [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0101</span>]补 + [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0011</span>]补</span><br><span class="line">= [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1000</span>]补</span><br><span class="line">= [<span class="number">1000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0111</span>]反</span><br><span class="line">= [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span>]原</span><br><span class="line">= <span class="number">-8</span></span><br><span class="line"> </span><br><span class="line"><span class="number">13</span> - <span class="number">5</span> = <span class="number">13</span> + (<span class="number">-5</span>)</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1101</span>]补 + [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1011</span>]补</span><br><span class="line">= [<span class="number">1</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span>]补 </span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span>]补</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span>]反</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span>]原</span><br><span class="line">= <span class="number">8</span></span><br></pre></td></tr></table></figure></p><p>​    你看，采用补码的形式正好把相差的<code>1</code>纠正过来，也没有影响到小数减去大数，这个<code>“补丁”</code>真是巧妙。</p><p>​    小数减去大数，结果为负数，之前（负数从反码转换为补码要加<code>1</code>）加上的<code>1</code>，后来（负数从补码转换为反码要减<code>1</code>）还要减去，正好抵消掉，所以不会受影响。</p><p>​    而大数减去小数，结果为正数，之前（负数从反码转换为补码要加<code>1</code>）加上的<code>1</code>，后来（正数的补码和反码相同，从补码转换为反码不用减<code>1</code>）就没有再减去，不能抵消掉，这就相当于给计算结果多加了一个<code>1</code>。</p><p>​    补码这种天才般的设计，一举达成了本文开头提到的两个目标，简化了硬件电路。</p><h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p>​    上一节我们还留下了一个谜团，就是有符号数以无符号的形式输出，或者无符号数以有符号的形式输出时，会得到一个奇怪的值，请看下面的代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> a = <span class="number">0100</span>;  <span class="comment">//八进制</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">-0x1</span>;  <span class="comment">//十六进制</span></span><br><span class="line">    <span class="keyword">long</span> c = <span class="number">720</span>;  <span class="comment">//十进制</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> m = <span class="number">0xffff</span>;  <span class="comment">//十六进制</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = <span class="number">0x80000000</span>;  <span class="comment">//十六进制</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> p = <span class="number">100</span>;  <span class="comment">//十进制</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//以无符号的形式输出有符号数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%#ho, b=%#x, c=%#ld\n"</span>, a, b, c);</span><br><span class="line">    <span class="comment">//以有符号数的形式输出无符号类型（只能以十进制形式输出）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"m=%hd, n=%d, p=%ld\n"</span>, m, n, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">0100</span>, b=<span class="number">0xffffffff</span>, c=<span class="number">720</span></span><br><span class="line"></span><br><span class="line">m=<span class="number">-1</span>, n=<span class="number">-2147483648</span>, p=<span class="number">100</span></span><br></pre></td></tr></table></figure></p><p>​    其中，<code>b</code>、<code>m</code>、<code>n</code>的输出结果看起来非常奇怪。</p><p>​    <code>b</code>是有符号数，它在内存中的存储形式（也就是补码）为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">-0x1</span></span><br><span class="line">= [<span class="number">1000</span> <span class="number">0000</span> …… <span class="number">0000</span> <span class="number">0001</span>]原</span><br><span class="line">= [<span class="number">1111</span> <span class="number">1111</span> …… <span class="number">1111</span> <span class="number">1110</span>]反</span><br><span class="line">= [<span class="number">1111</span> <span class="number">1111</span> …… <span class="number">1111</span> <span class="number">1111</span>]补</span><br><span class="line">= [<span class="number">0xffffffff</span>]补</span><br></pre></td></tr></table></figure></p><p>​    <code>%#x</code>表示以无符号的形式输出，而无符号数的补码和原码相同，所以不用转换了，直接输出 <code>0xffffffff</code> 即可。</p><p>​    <code>m</code> 和<code>n</code> 是无符号数，它们在内存中的存储形式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="number">0xffff</span></span><br><span class="line">= [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>]补</span><br><span class="line"> </span><br><span class="line">n = <span class="number">0x80000000</span></span><br><span class="line">= [<span class="number">1000</span> <span class="number">0000</span> …… <span class="number">0000</span> <span class="number">0000</span>]补</span><br></pre></td></tr></table></figure></p><p>​    <code>%hd</code>和<code>%d</code>表示以有符号的形式输出，所以还要经过一个逆向的转换过程： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>]补</span><br><span class="line">= [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1110</span>]反</span><br><span class="line">= [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span>]原</span><br><span class="line">= <span class="number">-1</span></span><br><span class="line"> </span><br><span class="line">[<span class="number">1000</span> <span class="number">0000</span> …… <span class="number">0000</span> <span class="number">0000</span>]补</span><br><span class="line">= <span class="number">-231</span></span><br><span class="line">= <span class="number">-2147483648</span></span><br></pre></td></tr></table></figure><p> 由此可见，<code>-1</code> 和<code>-2147483648</code>才是最终的输出值。 </p><blockquote><p> 注意，<code>[1000 0000 …… 0000 0000]补</code>是一个特殊的补码，无法按照本节讲到的方法转换为原码，所以计算机直接规定这个补码对应的值就是<code>-231</code>，至于为什么，下节我们会详细分析。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言-小数在内存的存储</title>
      <link href="/2018/01/20/c%E8%AF%AD%E8%A8%801-%E5%B0%8F%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8/"/>
      <url>/2018/01/20/c%E8%AF%AD%E8%A8%801-%E5%B0%8F%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<p>  小数在内存中是以<strong>浮点数</strong>的形式存储的。浮点数并不是一种数值分类，它和整数、小数、实数等不是一个层面的概念。</p><p>​    <strong>浮点数是数字（或者说数值）在内存中的一种存储格式，它和定点数是相对的。</strong></p><a id="more"></a><h2 id="小数在内存的存储"><a href="#小数在内存的存储" class="headerlink" title="小数在内存的存储"></a>小数在内存的存储</h2><p>​    <code>C</code>语言使用定点数格式来存储<code>short</code>、<code>int</code>、<code>long</code>类型的整数，使用浮点数格式来存储<code>float</code>、<code>double</code>类型的小数。整数和小数在内存中的存储格式不一样。</p><p>​    我们在学习<code>C</code>语言时，通常认为浮点数和小数是等价的，并没有严格区分它们的概念，这也并没有影响到我们的学习，原因就是浮点数和小数是绑定在一起的，只有小数才使用浮点格式来存储。</p><p>​    其实，<strong>整数和小数可以都使用定点格式来存储，也可以都使用浮点格式来存储，但实际情况却是，<code>C</code>语言使用定点格式存储整数，使用浮点格式存储小数，这是在“数值范围”和“数值精度”两项重要指标之间追求平衡的结果</strong>，稍后我会给大家带来深入的剖析。 </p><blockquote><p> 计算机的设计是一门艺术，很多实用技术都是权衡和妥协的结果。</p></blockquote><p>​    <strong>浮点数</strong>和<strong>定点数</strong>中的“点”指的就是小数点！</p><p>​    对于整数，可以认为小数点后面都是零，小数部分是否存在并不影响整个数字的值，所以干脆将小数部分省略，只保留整数部分。 </p><h2 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h2><p>​    所谓定点数，就是指小数点的位置是固定的，不会向前或者向后移动。</p><p>​    假设我们用<code>4</code>个字节（<code>32</code>位）来存储无符号的定点数，并且约定，前<code>16</code>位表示整数部分，后<code>16</code>位表示小数部分，如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1G01Q63SS96.png" alt></p><p>​    如此一来，小数点就永远在第<code>16</code>位之后，整数部分和小数部分一目了然，不管什么时候，整数部分始终占用<code>16</code>位（不足<code>16</code>位前置补<code>0</code>），小数部分也始终占用<code>16</code>位（不足<code>16</code>位后置补<code>0</code>）。例如，在内存中存储了  <code>10101111  00110001  01011100  11000011</code>，那么对应的小数就是 <code>10101111  00110001 . 01011100  11000011</code>，非常直观。 </p><h4 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h4><p>​    小数部分的最后一位可能是精确数字，也可能是近似数字（由四舍五入、向零舍入等不同方式得到）；除此以外，剩余的<code>31</code>位都是精确数字。从二进制的角度看，这种定点格式的小数，最多有<code>32</code>位有效数字，但是能保证的是<code>31</code>位；也就是说，整体的精度为<code>31~32</code>位。</p><h4 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h4><p>​    将内存中的所有位（<code>Bit</code>）都置为<code>1</code>，小数的值最大，为 $2^{16}$ - $2^{-16}$，极其接近$2^{16}$，换算成十进制为 <code>65 536</code>。将内存中最后一位（第<code>32</code>位）置1，其它位都置0，小数的值最小，为$2^{-16}$。 </p><blockquote><p> 这里所说的最小值不是<code>0</code>值，而是最接近<code>0</code>的那个值。</p></blockquote><h4 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h4><p>​    <strong>用定点格式来存储小数，优点是精度高，因为所有的位都用来存储有效数字了，缺点是取值范围太小，不能表示很大或者很小的数字。</strong></p><h4 id="反面例子"><a href="#反面例子" class="headerlink" title="反面例子"></a>反面例子</h4><p>​    在科学计算中，小数的取值范围很大，最大值和最小值的差距有上百个数量级，使用定点数来存储将变得非常困难。</p><p>​    例如，电子的质量为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000000000000000000000.9</span> 克 = <span class="number">9</span> × <span class="number">10</span>^(<span class="number">-28</span>) 克</span><br></pre></td></tr></table></figure></p><p>​    太阳的质量为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2000000000000000000000000000000000</span> 克 = <span class="number">2</span> × <span class="number">10</span>^<span class="number">33</span> 克</span><br></pre></td></tr></table></figure></p><p>​    如果使用定点数，那么只能按照<code>=</code>前面的格式来存储，这将需要很大的一块内存，大到需要几十个字节。更加科学的方案是按照<code>=</code>后面的指数形式来存储，这样不但节省内存，也非常直观。<strong>这种以指数的形式来存储小数的解决方案就叫做浮点数。</strong></p><p>​    浮点数是对定点数的升级和优化，克服了定点数取值范围太小的缺点。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>​    <code>C</code>语言标准规定，小数在内存中以科学计数法的形式来存储，具体形式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flt = (<span class="number">-1</span>)sign × mantissa × baseexponent</span><br></pre></td></tr></table></figure></p><p>​    对各个部分的说明： </p><ul><li><code>flt</code>是要表示的小数。</li><li><code>sign</code>用来表示<code>flt</code>的正负号，它的取值只能是<code>0</code>或<code>1</code>：取值为<code>0</code>表示<code>flt</code>是正数，取值为<code>1</code>表示<code>flt</code>是负数。</li><li><code>base</code>是基数，或者说进制，它的取值大于等于<code>2</code>（例如，<code>2</code>表示二进制、<code>10</code>表示十进制、<code>16</code>表示十六进制<code>……</code>）。数学中常见的科学计数法是基于十进制的，例如<code>6.93 × 1013</code>；计算机中的科学计数法可以基于其它进制，例如<code>1.001 × 27</code>就是基于二进制的，它等价于<code>1001 0000</code>。</li><li><code>mantissa</code>为尾数，或者说精度，是<code>base</code>进制的小数，并且<code>1 ≤ mantissa ＜ base</code>，这意味着，小数点前面只能有一位数字；</li><li><code>exponent</code>为指数，是一个整数，可正可负，并且为了直观一般采用十进制表示。</li></ul><p>下面我们以<code>19.625</code>为例来演示如何将小数转换为浮点格式。</p><p>​    当<code>base</code>取值为<code>10</code>时，<code>19.625</code>的浮点形式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19.625</span> = <span class="number">1.9625</span> × <span class="number">101</span></span><br></pre></td></tr></table></figure></p><p>​    当<code>base</code>取值为<code>2</code>时，将<code>19.625</code>转换成二进制为<code>10011.101</code>，用浮点形式来表示为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19.625</span> = <span class="number">10011.101</span> = <span class="number">1.0011101</span>×<span class="number">2</span>^<span class="number">4</span></span><br></pre></td></tr></table></figure></p><blockquote><p> <code>19.625</code>整数部分的二进制形式为：<br> <code>19 = 1×24 + 0×23 + 0×22 + 1×21 + 1×20 = 10011</code><br> 小数部分的二进制形式为：<br> <code>0.625 = 1×2-1 + 0×2-2 + 1×2-3 = 101</code><br> 将整数部分和小数部分合并在一起：<br> <code>19.625 = 10011.101</code></p></blockquote><p>可以看出，当基数（进制）<code>base</code>确定以后，指数<code>exponent</code>实际上就成了小数点的移动位数： </p><ul><li><p><code>exponent</code>大于零，<code>mantissa</code>中的小数点右移<code>exponent</code>位即可还原小数的值；</p></li><li><p><code>exponent</code>小于零，<code>mantissa</code>中的小数点左移<code>exponent</code>位即可还原小数的值。</p></li></ul><p>​    <strong>换句话说，将小数转换成浮点格式后，小数点的位置发生了浮动（移动），并且浮动的位数和方向由 <code>exponent</code>决定，所以我们将这种表示小数的方式称为浮点数。</strong></p><h2 id="二进制形式的浮点数的存储"><a href="#二进制形式的浮点数的存储" class="headerlink" title="二进制形式的浮点数的存储"></a>二进制形式的浮点数的存储</h2><p>​    虽然<code>C</code>语言标准没有规定<code>base</code>使用哪种进制，但是在实际应用中，各种编译器都将<code>base</code>实现为二进制，这样不仅贴近计算机硬件（任何数据在计算机底层都以二进制形式表示），还能减少转换次数。</p><p>​    接下来我们就讨论一下如何将二进制形式的浮点数放入内存中。</p><p>​    原则上讲，上面的科学计数法公式中，符号<code>sign</code>、尾数<code>mantissa</code>、基数<code>base</code>和指数<code>exponent</code>都是不确定因素，都需要在内存中体现出来。但是现在基数<code>base</code>已经确定是二进制了，就不用在内存中体现出来了，这样只需要在内存中存储符号<code>sign</code>、尾数<code>mantissa</code>、指数<code>exponent</code>这三个不确定的元素就可以了。</p><p>​    仍然以<code>19.625</code>为例，将它转换成二进制形式的浮点数格式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19.625</span> = <span class="number">1.0011101</span>×<span class="number">2</span>^<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>​    此时符号<code>sign</code>为<code>0</code>，尾数<code>mantissa</code>为<code>1.0011101</code>，指数<code>exponent</code>为<code>4</code>。 </p><h4 id="1-符号的存储"><a href="#1-符号的存储" class="headerlink" title="1) 符号的存储"></a>1) 符号的存储</h4><p>​    符号的存储很容易，就像存储<code>short</code>、<code>int</code>等普通整数一样，单独分配出一个位（<code>Bit</code>）来，用<code>0</code>表示正数，用<code>1</code>表示负数。对于<code>19.625</code>，这一位的值是<code>0</code>。 </p><h4 id="2-尾数的存储"><a href="#2-尾数的存储" class="headerlink" title="2) 尾数的存储"></a>2) 尾数的存储</h4><p>​    当采用二进制形式后，尾数部分的取值范围为<code>1 ≤ mantissa ＜ 2</code>，这意味着：尾数的整数部分一定为<code>1</code>，是一个恒定的值，这样就无需在内存中提现出来，可以将其直接截掉，只要把小数点后面的二进制数字放入内存中即可。对于<code>1.0011101</code>，就是把<code>0011101</code>放入内存。</p><p>​    我们不妨将真实的尾数命名为<code>mantissa</code>，将内存中存储的尾数命名为<code>mant</code>，那么它们之间的关系为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mantissa = <span class="number">1.</span>mant</span><br></pre></td></tr></table></figure></p><p>​    如果<code>base</code>采用其它进制，那么尾数的整数部分就不是固定的，它有多种取值的可能，以十进制为例，尾数的整数部分可能是<code>1~9</code>之间的任何一个值，这样一来尾数的整数部分就不能省略了，必须在内存中体现出来。而将<code>base</code>设置为二进制就可以节省掉一个位（<code>Bit</code>）的内存，这也算是采用二进制的一点点优势。</p><h4 id="3-指数的存储"><a href="#3-指数的存储" class="headerlink" title="3) 指数的存储"></a>3) 指数的存储</h4><p>​    指数是一个整数，并且有正负之分，不但需要存储它的值，还得能区分出正负号来。</p><p>​    <code>short</code>、<code>int</code>、<code>long</code>等类型的整数在内存中的存储采用的是补码加符号位的形式，数值在写入内存之前必须先进行转换，读取以后还要再转换一次。但是为了提高效率，避免繁琐的转换，指数的存储并没有采用补码加符号位的形式，而是设计了一套巧妙的解决方案，稍等我会为您解开谜团。 </p><h2 id="为二进制浮点数分配内存"><a href="#为二进制浮点数分配内存" class="headerlink" title="为二进制浮点数分配内存"></a>为二进制浮点数分配内存</h2><p>​    <code>C</code>语言中常用的浮点数类型为<code>float</code>和<code>double</code>；<code>float</code>始终占用<code>4</code>个字节，<code>double</code>始终占用<code>8</code>个字节。</p><p>​    下图演示了<code>float</code>和<code>double</code>的存储格式： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1601021422192L.png" alt></p><p>​    浮点数的内存被分成了三部分，分别用来存储符号<code>sign</code>、尾数<code>mantissa</code>和指数<code>exponent</code>，当浮点数的类型确定后，每一部分的位数就是固定的。</p><p>​    符号<code>sign</code>可以不加修改直接放入内存中，尾数<code>mantissa</code>只需要将小数部分放入内存中，最让人疑惑的是指数<code>exponent</code>如何放入内存中，这也是我们在前面留下的一个谜团，下面我们以<code>float</code>为例来揭开谜底。</p><p>​    <code>float</code>的指数部分占用<code>8 Bits</code>，能表示从<code>0~255</code>的值，取其中间值<code>127</code>，指数在写入内存前先加上<code>127</code>，读取时再减去<code>127</code>，正数负数就显而易见了。<code>19.625</code>转换后的指数为<code>4</code>，<code>4+127 = 131</code>，<code>131</code>换算成二进制为<code>1000 0011</code>，这就是<code>19.626</code>的指数部分在<code>float</code>中的最终存储形式。</p><p>​    先确定内存中指数部分的取值范围，得到一个中间值，写入指数时加上这个中间值，读取指数时减去这个中间值，这样符号和值就都能确定下来了。</p><p>​    中间值的求取有固定的公式。设中间值为<code>median</code>，指数部分占用的内存为<code>n</code>位，那么中间值为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">median = <span class="number">2</span>^(n<span class="number">-1</span>) - <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>​    对于<code>float</code>，中间值为 $2^{8-1}$ - 1 = 127；对于<code>double</code>，中间值为 $2^{11-1}$ -1 = 1023。</p><p>​    我们不妨将真实的指数命名为<code>exponent</code>，将内存中存储的指数命名为<code>exp</code>，那么它们之间的关系为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exponent = <span class="built_in">exp</span> - median</span><br></pre></td></tr></table></figure></p><p>​     也可以写作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exp</span> = exponent + median</span><br></pre></td></tr></table></figure></p><blockquote><p> 为了方便后续文章的编写，这里我强调一下命名：     </p><ul><li><code>mantissa</code>表示真实的尾数，包括整数部分和小数部分；<code>mant</code>表示内存中存储的尾数，只有小数部分，省略了整数部分。</li><li><code>exponent</code>表示真实的指数，<code>exp</code>表示内存中存储的指数，<code>exponent</code>和<code>exp</code>并不相等，<code>exponent</code>加上中间数<code>median</code>才等于<code>exp</code>。</li></ul></blockquote><h2 id="用代码验证float的存储"><a href="#用代码验证float的存储" class="headerlink" title="用代码验证float的存储"></a>用代码验证<code>float</code>的存储</h2><p>​    <code>19.625</code>转换成二进制的指数形式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19.625</span> = <span class="number">1.0011101</span>×<span class="number">2</span>^<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>​    此时符号为<code>0</code>；尾数为<code>1.0011101</code>，截掉整数部分后为<code>0011101</code>，补齐到<code>23 Bits</code>后为 <code>001 1101 0000 0000 0000 0000</code>；指数为 <code>4</code>，<code>4+127 = 131</code>，<code>131</code> 换算成二进制为 <code>1000 0011</code>。</p><p>​    综上所述，<code>float</code>类型的 <code>19.625</code> 在内存中的值为：<code>0 - 10000011 - 001 1101 0000 0000 0000 0000</code>。</p><p>​    下面我们通过代码来验证一下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//浮点数结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nMant : <span class="number">23</span>;  <span class="comment">//尾数部分</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nExp : <span class="number">8</span>;  <span class="comment">//指数部分</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nSign : <span class="number">1</span>;  <span class="comment">//符号位</span></span><br><span class="line">&#125; FP_SINGLE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strBin[<span class="number">33</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">19.625</span>;</span><br><span class="line">    FP_SINGLE *p = (FP_SINGLE*)&amp;f;</span><br><span class="line">   </span><br><span class="line">    itoa(p-&gt;nSign, strBin, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sign: %s\n"</span>, strBin);</span><br><span class="line">    itoa(p-&gt;nExp, strBin, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"exp: %s\n"</span>, strBin);</span><br><span class="line">    itoa(p-&gt;nMant, strBin, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mant: %s\n"</span>, strBin);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     运行结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sign: <span class="number">0</span></span><br><span class="line"><span class="built_in">exp</span>: <span class="number">10000011</span></span><br><span class="line">mant: <span class="number">111010000000000000000</span></span><br></pre></td></tr></table></figure></p><blockquote><p><code>mant</code>的位数不足，在前面补齐两个<code>0</code>即可。</p></blockquote><blockquote><p> <code>printf()</code>不能直接输出二进制形式，这里我们借助<code>itoa()</code>函数将十进制数转换成二进制的字符串，再使用<code>%s</code>输出。<code>itoa()</code>虽然不是标准函数，但是大部分编译器都支持。不过<code>itoa()</code>在<code>C99</code>标准中已经被指定为不可用函数，在一些严格遵循<code>C99</code>标准的编译器下会失效，甚至会引发错误，例如在<code>Xcode</code>（使用<code>LLVM</code>编译器）下就会编译失败。如果<code>itoa()</code>无效，请使用<code>%X</code>输出十六进制形式，十六进制能够很方便地转换成二进制。</p></blockquote><h2 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h2><p>​    对于十进制小数，整数部分转换成二进制使用“展除法”（就是不断除以<code>2</code>，直到余数为<code>0</code>），一个有限位数的整数一定能转换成有限位数的二进制。但是小数部分就不一定了，小数部分转换成二进制使用“乘二取整法”（就是不断乘以<code>2</code>，直到小数部分为<code>0</code>），一个有限位数的小数并不一定能转换成有限位数的二进制，只有末位是<code>5</code>的小数才有可能转换成有限位数的二进制，其它的小数都不行。 </p><p>​    <code>float</code>和<code>double</code>的尾数部分是有限的，固然不能容纳无限的二进制；即使小数能够转换成有限的二进制，也有可能会超出尾数部分的长度，此时也不能容纳。这样就必须“四舍五入”，将多余的二进制“处理掉”，只保留有效长度的二进制，这就涉及到了精度的问题。</p><p>​    也就是说，浮点数不一定能保存真实的小数，很有可能保存的是一个近似值。</p><p>​    对于<code>float</code>，尾数部分有<code>23</code>位，再加上一个隐含的整数<code>1</code>，一共是<code>24</code>位。最后一位可能是精确数字，也可能是近似数字（由四舍五入、向零舍入等不同方式得到）；除此以外，剩余的<code>23</code>位都是精确数字。从二进制的角度看，这种浮点格式的小数，最多有<code>24</code>位有效数字，但是能保证的是<code>23</code>位；也就是说，整体的精度为<code>23~24</code>位。如果转换成十进制，$2^{24}$ = 16 777 216，一共<code>8</code>位；也就是说，最多有<code>8 位</code>有效数字，但是能保证的是<code>7</code>位，从而得出整体精度为<code>7~8</code>位。</p><p>​    对于<code>double</code>，同理可得，二进制形式的精度为<code>52~53</code>位，十进制形式的精度为<code>15~16</code>位。 </p><h2 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a><code>IEEE 754</code>标准</h2><p>​    浮点数的存储以及加减乘除运算是一个比较复杂的问题，很多小的处理器在硬件指令方面甚至不支持浮点运算，其他的则需要一个独立的协处理器来处理这种运算，只有最复杂的处理器才会在硬件指令集中支持浮点运算。省略浮点运算，可以将处理器的复杂度减半！如果硬件不支持浮点运算，那么只能通过软件来实现，代价就是需要容忍不良的性能。 </p><blockquote><p> <code>PC</code>和智能手机上的处理器就是最复杂的处理器了，它们都能很好地支持浮点运算。</p></blockquote><p>​    在六七十年代，计算机界对浮点数的处理比较混乱，各家厂商都有自己的一套规则，缺少统一的业界标准，这给数据交换、计算机协同工作带来了很大不便。</p><p>​    作为处理器行业的老大，<code>Intel</code>早就意识到了这个问题，并打算一统浮点数的世界。Intel 在研发 8087  浮点数协处理器时，聘请到加州大学伯克利分校的<code>William Kahan</code>教授（最优秀的数值分析专家之一）以及他的两个伙伴，来为<code>8087</code>协处理器设计浮点数格式，他们的工作完成地如此出色，设计的浮点数格式具有足够的合理性和先进性，被 IEEE 组织采用为浮点数的业界标准，并于<code>1985</code>年正式发布，这就是<code>IEEE 754</code>标准，它等同于国际标准<code>ISO/IEC/IEEE 60559</code>。 </p><blockquote><p> <code>IEEE</code>是<code>Institute of Electrical and Electronics Engineers</code>的简写，中文意思是“电气和电子工程师协会”。</p></blockquote><p>​    <code>IEEE 754</code>简直是天才一般的设计，<code>William Kahan</code>教授也因此获得了<code>1987</code>年的图灵奖。图灵奖是计算机界的“诺贝尔奖”。</p><p>​    目前，几乎所有的计算机都支持<code>IEEE 754</code>标准，大大改善了科学应用程序的可移植性，<code>C</code>语言编译器在实现浮点数时也采用了该标准。</p><p>​    不过，<code>IEEE 754</code>标准的出现晚于<code>C</code>语言标准（最早的<code>ANSI C</code>标准于<code>1983</code>年发布），<code>C</code>语言标准并没有强制编译器采用<code>IEEE  754</code>格式，只是说要使用科学计数法的形式来表示浮点数，但是编译器在实现浮点数时，都采用了<code>IEEE 754</code>格式，这既符合<code>C</code>语言标准，又符合<code>IEEE</code>标准，何乐而不为。 </p><h2 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h2><p>​    <code>IEEE 754</code>标准规定，当指数<code>exp</code>的所有位都为<code>1</code>时，不再作为“正常”的浮点数对待，而是作为特殊值处理：</p><ul><li>如果此时尾数<code>mant</code>的二进制位都为<code>0</code>，则表示无穷大：         <ul><li>如果符号<code>sign</code>为<code>1</code>，则表示负无穷大；</li><li>如果符号<code>sign</code>为<code>0</code>，则表示正无穷大。</li></ul></li><li>如果此时尾数<code>mant</code>的二进制位不全为<code>0</code>，则表示<code>NaN</code>（<code>Not a Number</code>），也即这是一个无效的数字，或者该数字未经初始化。</li></ul><h2 id="非规格化浮点数"><a href="#非规格化浮点数" class="headerlink" title="非规格化浮点数"></a>非规格化浮点数</h2><p>​    当指数<code>exp</code>的所有二进制位都为<code>0</code>时，情况也比较特殊。</p><p>​    对于“正常”的浮点数，尾数<code>mant</code>隐含的整数部分为<code>1</code>，并且在读取浮点数时，内存中的指数<code>exp</code>要减去中间值<code>median</code>才能还原真实的指数<code>exponent</code>，也即：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mantissa = <span class="number">1.</span>mant</span><br><span class="line">exponent = <span class="built_in">exp</span> - median</span><br></pre></td></tr></table></figure></p><p>​     但是当指数<code>exp</code>的所有二进制位都为<code>0</code>时，一切都变了！尾数<code>mant</code>隐含的整数部分变成了<code>0</code>，并且用<code>1</code>减去内存中的指数<code>exp</code>才能还原真实的指数<code>exponent</code>，也即：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mantissa = <span class="number">0.</span>mant</span><br><span class="line">exponent = <span class="number">1</span> - <span class="built_in">exp</span></span><br></pre></td></tr></table></figure></p><p>​    对于<code>float</code>，<code>exponent = 1 - 127 = -126</code>，指数<code>exponent</code>的值恒为<code>-126</code>；对于<code>double</code>，<code>exponent = 1 - 1023 = -1022</code>，指数<code>exponent</code>的值恒为<code>-1022</code>。</p><p>​    当指数<code>exp</code>的所有二进制位都是<code>0</code>时，我们将这样的浮点数称为“非规格化浮点数”；当指数<code>exp</code>的所有二进制位既不全为<code>0</code>也不全为<code>1</code>时，我们称之为“规格化浮点数”；当指数<code>exp</code>的所有二进制位都是<code>1</code>时，作为特殊值对待。</p><p>​    也就是说，究竟是规格化浮点数，还是非规格化浮点数，还是特殊值，完全看指数<code>exp</code>。 </p><h4 id="0和-0的表示"><a href="#0和-0的表示" class="headerlink" title="+0和-0的表示"></a><code>+0</code>和<code>-0</code>的表示</h4><p>​    对于非规格化浮点数，当尾数<code>mant</code>的所有二进制位都为<code>0</code>时，整个浮点数的值就为<code>0</code>： </p><ul><li>如果符号<code>sign</code>为<code>0</code>，则表示<code>+0</code>；</li><li>如果符号<code>sign</code>为<code>1</code>，则表示<code>-0</code>。</li></ul><h2 id="IEEE-754为什么增加非规格化浮点数"><a href="#IEEE-754为什么增加非规格化浮点数" class="headerlink" title="IEEE 754为什么增加非规格化浮点数"></a><code>IEEE 754</code>为什么增加非规格化浮点数</h2><p>​    我们以<code>float</code>类型为例来说明。</p><p>​    对于规格化浮点数，当尾数<code>mant</code>的所有位都为<code>0</code>、指数<code>exp</code>的最低位为<code>1</code>时，浮点数的绝对值最小（符号<code>sign</code>的取值不影响绝对值），为 1.0 × $2^{-126}$，也即 $2^{-126}$。</p><p>​    对于一般的计算，这个值已经很小了，非常接近<code>0</code>值了，但是对于科学计算，它或许还不够小，距离<code>0</code>值还不够近，非规格化浮点数就是来弥补这一缺点的：非规格化浮点数可以让最小值更小，更加接近<code>0</code>值。</p><p>​    对于非规格化浮点数，当尾数的最低位为<code>1</code>时，浮点数的绝对值最小，为 $2^{-23}$ × $2^{-126}$ = $2^{-149}$，这个值比 $2^{-126}$小了<code>23</code>个数量级，更加即接近<code>0</code>值。</p><p>​    上表演示了正数时的情形，负数与此类似。请读者注意观察最大非规格化数和最小规格化数，它们是连在一起的，是平滑过渡的。 </p><h2 id="舍入模式"><a href="#舍入模式" class="headerlink" title="舍入模式"></a>舍入模式</h2><p>​    浮点数的尾数部分<code>mant</code>所包含的二进制位有限，不可能表示太长的数字，如果尾数部分过长，在放入内存时就必须将多余的位丢掉，取一个近似值。究竟该如何来取这个近似值，<code>IEEE 754</code>列出了四种不同的舍入模式。 </p><h4 id="1-舍入到最接近的值"><a href="#1-舍入到最接近的值" class="headerlink" title="1) 舍入到最接近的值"></a>1) 舍入到最接近的值</h4><p>​    就是将结果舍入为最接近且可以表示的值，这是默认的舍入模式。最近舍入模式和我们平时所见的“四舍五入”非常类似，但有一个细节不同。</p><p>​    对于最近舍入模式，<code>IEEE 754</code>规定，当有两个最接近的可表示的值时首选“偶数”值；而对于四舍五入模式，当有两个最接近的可表示的值时要选较大的值。以十进制为例，就是对<code>.5</code>的舍入上采用偶数的方式，请看下面的例子。</p><ul><li><p>最近舍入模式：<code>Round(0.5) = 0</code>、<code>Round(1.5) = 2</code>、<code>Round(2.5) = 2</code></p></li><li><p>四舍五入模式：<code>Round(0.5) = 1</code>、<code>Round(1.5) = 2</code>、<code>Round(2.5) = 3</code> </p></li></ul><h4 id="2-向-∞方向舍入（向上舍入）"><a href="#2-向-∞方向舍入（向上舍入）" class="headerlink" title="2) 向+∞方向舍入（向上舍入）"></a>2) 向<code>+∞</code>方向舍入（向上舍入）</h4><p>​    会将结果朝正无穷大的方向舍入。标准库函数<code>ceil()</code>使用的就是这种舍入模式，例如，<code>ceil(1.324) = 2</code>，<code>Ceil(-1.324) = -1</code>。</p><h4 id="3-向-∞方向舍入（向下舍入）"><a href="#3-向-∞方向舍入（向下舍入）" class="headerlink" title="3) 向-∞方向舍入（向下舍入）"></a>3) 向<code>-∞</code>方向舍入（向下舍入）</h4><p>​    会将结果朝负无穷大的方向舍入。标准库函数<code>floor()</code>使用的就是这种舍入模式，例如，<code>floor(1.324) = 1</code>，<code>floor(-1.324) = -2</code>。 </p><h4 id="4-向0舍入（直接截断）"><a href="#4-向0舍入（直接截断）" class="headerlink" title="4) 向0舍入（直接截断）"></a>4) 向<code>0</code>舍入（直接截断）</h4><p>​    会将结果朝接近<code>0</code>的方向舍入，也就是将多余的位数直接丢掉。<code>C</code>语言中的类型转换使用的就是这种舍入模式，例如，<code>(int)1.324 = 1</code>，<code>(int) -1.324 = -1</code>。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    与定点数相比，浮点数在精度方面损失不小，但是在取值范围方面增大很多。牺牲精度，换来取值范围，这就是浮点数的整体思想。</p><p>​    <code>IEEE 754</code>标准其实还规定了浮点数的加减乘除运算，不过本文的重点是讲解浮点数的存储，所以对于浮点数的运算不再展开讨论。 </p><h2 id="答疑解惑"><a href="#答疑解惑" class="headerlink" title="答疑解惑"></a>答疑解惑</h2><p>​    上节我们还留下了一个疑问，就是用<code>%f</code>输出<code>128.101</code>时得到的是一个近似值，而不是一个精确值，这是因为，<code>128.101</code>转换为浮点格式后，尾数部分过长，被丢掉了，不能“真实”地存储了。</p><p>​    <code>128.101</code>转换成二进制为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000000.0001100111011011001000101101</span>……（无限循环）</span><br></pre></td></tr></table></figure></p><p>​    向左移动<code>7</code>位后为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.00000000001100111011011001000101101</span>……</span><br></pre></td></tr></table></figure></p><p>​    由此可见，尾数部分为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span> <span class="number">1101</span> <span class="number">1011</span> <span class="number">001000101101</span>……</span><br></pre></td></tr></table></figure></p><p>​    将多出的二进制丢掉后为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span> <span class="number">1101</span> <span class="number">1011</span></span><br></pre></td></tr></table></figure></p><p>​    使用<code>printf</code>输出时，还需要进行还原，还原后的二进制为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000000.0001100111011011</span></span><br></pre></td></tr></table></figure></p><p>​    转换成十进制为<code>128.1009979248046875</code>，按照四舍五入的原则取<code>6</code>位小数，就是<code>128.100998</code></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之位运算</title>
      <link href="/2018/01/17/c%E8%AF%AD%E8%A8%801-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2018/01/17/c%E8%AF%AD%E8%A8%801-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="位运算小结"><a href="#位运算小结" class="headerlink" title="位运算小结"></a>位运算小结</h2><p>​    位运算不管是在<code>C</code>语言中，或者其他语言，都是经常会用到的，所以本文也就不固定以某种语言来举例子了，原始点就从<code>0</code>、<code>1</code>开始。位运算主要包括按位与(<code>&amp;</code>)、按位或(<code>|</code>)、按位异或(<code>^</code>)、取反(<code>~</code>)、左移(<code>&lt;&lt;</code>)、右移(<code>&gt;&gt;</code>)这几种，其中除了取反(<code>~</code>)以外，其他的都是二目运算符，即要求运算符左右两侧均有一个运算量。</p><a id="more"></a><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>   在总结按位运算前，有必要先介绍下补码的知识，我们知道当将一个十进制正整数转换为二进制数的时候，只需要通过除<code>2</code>取余的方法即可，但是怎么将一个十进制的负整数转换为二进制数呢<code>？</code>其实，负数是以补码的形式表示，其转换方式，简单的一句话就是：先按正数转换，然后取反加<code>1</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">要将十进制的<span class="number">-10</span>用二进制表示，先将<span class="number">10</span>用二进制表示：</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line">取反：</span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0101</span></span><br><span class="line">加<span class="number">1</span>：</span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0110</span></span><br><span class="line">所以，<span class="number">-10</span>的二进制表示就是：</span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0110</span></span><br></pre></td></tr></table></figure><h3 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与(&amp;)"></a>按位与(<code>&amp;</code>)</h3><p>​    参加运算的两个数，换算为二进制(<code>0</code>、<code>1</code>)后，进行与运算。只有当相应位上的数都是<code>1</code>时，该位才取<code>1</code>，否则该为为<code>0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将<span class="number">10</span>与<span class="number">-10</span>进行按位与(&amp;)运算：</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0110</span></span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span></span><br><span class="line">所以：</span><br><span class="line"><span class="number">10</span> &amp; <span class="number">-10</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span>`</span><br></pre></td></tr></table></figure><h3 id="按位或"><a href="#按位或" class="headerlink" title="按位或(|)"></a>按位或(<code>|</code>)</h3><p>​    参加运算的两个数，换算为二进制(<code>0</code>、<code>1</code>)后，进行或运算。只要相应位上存在<code>1</code>，那么该位就取<code>1</code>，均不为<code>1</code>，即为<code>0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将<span class="number">10</span>与<span class="number">-10</span>进行按位或(|)运算：</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0110</span></span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1110</span></span><br><span class="line">所以：</span><br><span class="line"><span class="number">10</span> | <span class="number">-10</span> = <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1110</span>`</span><br></pre></td></tr></table></figure><h3 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或(^)"></a>按位异或(<code>^</code>)</h3><p>​    参加运算的两个数，换算为二进制(<code>0</code>、<code>1</code>)后，进行异或运算。只有当相应位上的数字不相同时，该为才取<code>1</code>，若相同，即为<code>0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将<span class="number">10</span>与<span class="number">-10</span>进行按位异或(^)运算：</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0110</span></span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1100</span></span><br><span class="line">所以：</span><br><span class="line"><span class="number">10</span> ^ <span class="number">-10</span> = <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1100</span>`</span><br></pre></td></tr></table></figure><p>​    可以看出，任何数与<code>0</code>异或，结果都是其本身。利用异或还可以实现一个很好的交换算法，用于交换两个数，算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = b ^ a;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><h3 id="取反"><a href="#取反" class="headerlink" title="取反(~)"></a>取反(<code>~</code>)</h3><p>​    参加运算的两个数，换算为二进制(<code>0</code>、<code>1</code>)后，进行取反运算。每个位上都取相反值，<code>1</code>变成<code>0</code>，<code>0</code>变成<code>1</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对<span class="number">10</span>进行取反(~)运算：</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line">---------------------</span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0101</span></span><br><span class="line">所以：</span><br><span class="line">~<span class="number">10</span> = <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0101</span>`</span><br></pre></td></tr></table></figure><h3 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移(&lt;&lt;)"></a>左移(<code>&lt;&lt;</code>)</h3><p>​    参加运算的两个数，换算为二进制(<code>0</code>、<code>1</code>)后，进行左移运算，用来将一个数各二进制位全部向左移动若干位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对<span class="number">10</span>左移<span class="number">2</span>位(就相当于在右边加<span class="number">2</span>个<span class="number">0</span>)：</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line">--------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span> <span class="number">1000</span></span><br><span class="line">所以：</span><br><span class="line"><span class="number">10</span> &lt;&lt; <span class="number">2</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span> <span class="number">1000</span> = <span class="number">40</span></span><br></pre></td></tr></table></figure><p>  注意，观察可以发现，<strong>左移一位的结果就是原值乘<code>2</code></strong>，左移两位的结果就是原值乘<code>4</code>。</p><h3 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移(&gt;&gt;)"></a>右移(<code>&gt;&gt;</code>)</h3><p>​    参加运算的两个数，换算为二进制(<code>0</code>、<code>1</code>)后，进行右移运算，用来将一个数各二进制位全部向右移动若干位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对<span class="number">10</span>右移<span class="number">2</span>位(就相当于在左边加<span class="number">2</span>个<span class="number">0</span>)：</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line">--------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span></span><br><span class="line">所以：</span><br><span class="line"><span class="number">10</span> &gt;&gt; <span class="number">2</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>​        注意，观察可以发现，<strong>右移一位的结果就是原值除<code>2</code></strong>，左移两位的结果就是原值除<code>4</code>，注意哦，<strong>除了以后没有小数位的，都是取整</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之位段</title>
      <link href="/2018/01/15/c%E8%AF%AD%E8%A8%801-%E4%BD%8D%E6%AE%B5/"/>
      <url>/2018/01/15/c%E8%AF%AD%E8%A8%801-%E4%BD%8D%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<p>有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用<code>0</code>和<code>1</code>表示足以，也就是用一个二进位。正是基于这种考虑，C语言又提供了一种叫做位域的<strong>数据结构</strong>。</p><a id="more"></a><p>​    <strong>在结构体定义时，我们可以指定某个成员变量所占用的二进制位数（<code>Bit</code>），这就是位域。</strong>请看下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> m;</span><br><span class="line">    <span class="keyword">unsigned</span> n: <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ch: <span class="number">6</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    <strong><code>:</code>后面的数字用来限定成员变量占用的位数。</strong>成员<code>m</code>没有限制，根据数据类型即可推算出它占用<code>4</code>个字节（<code>Byte</code>）的内存。成员<code>n</code>、<code>ch</code>被<code>:</code>后面的数字限制，不能再根据数据类型计算长度，它们分别占用<code>4</code>、<code>6</code>位（<code>Bit</code>）的内存。</p><p>​    <code>n</code>、<code>ch</code>的取值范围非常有限，数据稍微大些就会发生溢出，请看下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> m;</span><br><span class="line">        <span class="keyword">unsigned</span> n: <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> ch: <span class="number">6</span>;</span><br><span class="line">    &#125; a = &#123; <span class="number">0xad</span>, <span class="number">0xE</span>, <span class="string">'$'</span>&#125;;</span><br><span class="line">    <span class="comment">//第一次输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%#x, %#x, %c\n"</span>, a.m, a.n, a.ch);</span><br><span class="line">    <span class="comment">//更改值后再次输出</span></span><br><span class="line">    a.m = <span class="number">0xb8901c</span>;</span><br><span class="line">    a.n = <span class="number">0x2d</span>;</span><br><span class="line">    a.ch = <span class="string">'z'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%#x, %#x, %c\n"</span>, a.m, a.n, a.ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>0xad, 0xe, $</code><br><code>0xb8901c, 0xd, :</code></p><p>​    对于<code>n</code>和<code>ch</code>，第一次输出的数据是完整的，第二次输出的数据是残缺的。</p><p>​    第一次输出时，<code>n</code>、<code>ch</code>的值分别是<code>0xE</code>、<code>0x24</code>（<code>&#39;$&#39;</code>对应的<code>ASCII</code>码为<code>0x24</code>），换算成二进制是<code>1110</code>、<code>10 0100</code>，都没有超出限定的位数，能够正常输出。</p><p>​    第二次输出时，<code>n</code>、<code>ch</code>的值变为<code>0x2d</code>、<code>0x7a</code>（<code>&#39;z&#39;</code>对应的<code>ASCII</code>码为<code>0x7a</code>），换算成二进制分别是<code>10 1101</code>、<code>111 1010</code>，都超出了限定的位数。超出部分被直接截去，剩下<code>1101</code>、<code>11 1010</code>，换算成十六进制为<code>0xd</code>、<code>0x3a</code>（<code>0x3a</code>对应的字符是<code>:</code>）。</p><p>​    <code>C</code>语言标准规定，<strong>位域的宽度不能超过它所依附的数据类型的长度。通俗地讲，成员变量都是有类型的，这个类型限制了成员变量的最大长度，<code>:</code>后面的数字不能超过这个长度。</strong></p><p>​    例如上面的<code>bs</code>，<code>n</code>的类型是<code>unsigned int</code>，长度为<code>4</code>个字节，共计<code>32</code>位，那么<code>n</code>后面的数字就不能超过<code>32</code>；<code>ch</code> 的类型是<code>unsigned char</code>，长度为<code>1</code>个字节，共计<code>8</code>位，那么<code>ch</code>后面的数字就不能超过<code>8</code>。</p><p>​    我们可以这样认为，位域技术就是在成员变量所占用的内存中选出一部分位宽来存储数据。</p><p>​    <code>C</code>语言标准还规定，只有有限的几种数据类型可以用于位域。在<code>ANSI C</code>中，这几种数据类型是<code>int</code>、<code>signed int</code>和<code>unsigned int</code>（<code>int</code>默认就是<code>signed int</code>）。</p><p>​    但编译器在具体实现时都进行了扩展，额外支持了<code>char</code>、<code>signed char</code>、<code>unsigned char</code>以及<code>enum</code>类型，所以上面的代码虽然不符合<code>C</code>语言标准，但它依然能够被编译器支持。</p><h2 id="位域的存储"><a href="#位域的存储" class="headerlink" title="位域的存储"></a>位域的存储</h2><p>​    <code>C</code>语言标准并没有规定位域的具体存储方式，不同的编译器有不同的实现，但它们都尽量压缩存储空间。</p><p>​    位域的具体存储规则如下：<br>​    1) 当相邻成员的类型相同时，如果它们的位宽之和小于类型的<code>sizeof</code>大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；如果它们的位宽之和大于类型的<code>sizeof</code>大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。</p><p>​    以下面的位域<code>bs</code>为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> m: <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> n: <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> p: <span class="number">4</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(struct bs));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>4</code></p><p>​    <code>m</code>、<code>n</code>、<code>p</code>的类型都是<code>unsigned int</code>，<code>sizeof</code>的结果为<code>4</code>个字节（<code>Byte</code>），也即<code>32</code>个位（<code>Bit</code>）。<code>m</code>、<code>n</code>、<code>p</code>的位宽之和为<code>6+12+4 = 22</code>，小于<code>32</code>，所以它们会挨着存储，中间没有缝隙。</p><blockquote><p><code>sizeof(struct bs)</code>的大小之所以为<code>4</code>，而不是<code>3</code>，是因为要将内存对齐到<code>4</code>个字节，以便提高存取效率。</p></blockquote><p>​    如果将成员<code>m</code>的位宽改为<code>22</code>，那么输出结果将会是<code>8</code>，因为<code>22+12 = 34</code>，大于<code>32</code>，<code>n</code>会从新的位置开始存储，相对<code>m</code>的偏移量是<code>sizeof(unsigned int)</code>，也即<code>4</code>个字节。</p><p>​    如果再将成员<code>p</code>的位宽也改为<code>22</code>，那么输出结果将会是<code>12</code>，三个成员都不会挨着存储。</p><p>​    2) 当相邻成员的类型不同时，不同的编译器有不同的实现方案，<code>GCC</code>会压缩存储，而<code>VC/VS</code>不会。</p><p>​    请看下面的位域<code>bs</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> m: <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> ch: <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> p: <span class="number">4</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(struct bs));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在<code>GCC</code>下的运行结果为<code>4</code>，三个成员挨着存储；在<code>VC/VS</code>下的运行结果为<code>12</code>，三个成员按照各自的类型存储（与不指定位宽时的存储方式相同）。</p><blockquote><p><code>m</code> 、<code>ch</code>、<code>p</code>的长度分别是<code>4</code>、<code>1</code>、<code>4</code>个字节，共计占用<code>9</code>个字节内存。</p></blockquote><p>​    3) 如果成员之间穿插着非位域成员，那么不会进行压缩。例如对于下面的<code>bs</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> m: <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> ch;</span><br><span class="line">    <span class="keyword">unsigned</span> p: <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    在各个编译器下<code>sizeof</code>的结果都是<code>12</code>。</p><p>​    通过上面的分析，我们发现位域成员往往不占用完整的字节，有时候也不处于字节的开头位置，因此使用<code>&amp;</code>获取位域成员的地址是没有意义的，<code>C</code>语言也禁止这样做。地址是字节（<code>Byte</code>）的编号，而不是位（<code>Bit</code>）的编号。</p><h2 id="无名位域"><a href="#无名位域" class="headerlink" title="无名位域"></a>无名位域</h2><p>​    位域成员可以没有名称，只给出数据类型和位宽，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m: <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span>  : <span class="number">20</span>;  <span class="comment">//该位域成员不能使用</span></span><br><span class="line">    <span class="keyword">int</span> n: <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    无名位域一般用来作填充或者调整成员位置。因为没有名称，无名位域不能使用。</p><p>​    上面的例子中，如果没有位宽为<code>20</code>的无名成员，<code>m</code>、<code>n</code>将会挨着存储，<code>sizeof(struct bs)</code>的结果为<code>4</code>；有了这<code>20</code>位作为填充，<code>m</code>、<code>n</code>将分开存储，<code>sizeof(struct bs)</code>的结果为<code>8</code>。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之基础数据类型</title>
      <link href="/2018/01/13/c%E8%AF%AD%E8%A8%801-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/01/13/c%E8%AF%AD%E8%A8%801-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型位数"><a href="#数据类型位数" class="headerlink" title="数据类型位数"></a>数据类型位数</h2><h3 id="标准基础类型"><a href="#标准基础类型" class="headerlink" title="标准基础类型"></a>标准基础类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>位平台</span><br><span class="line"> <span class="keyword">char</span> <span class="number">1</span>个字节<span class="number">8</span>位  </span><br><span class="line"> <span class="keyword">short</span>    <span class="number">2</span>个字节<span class="number">16</span>位  </span><br><span class="line"> <span class="keyword">int</span>      <span class="number">2</span>个字节<span class="number">16</span>位  </span><br><span class="line"> <span class="keyword">long</span>     <span class="number">4</span>个字节<span class="number">32</span>位  </span><br><span class="line"> 指针        <span class="number">2</span>个字节<span class="number">16</span>位    </span><br><span class="line">---------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">32</span>位平台    </span><br><span class="line"> <span class="keyword">char</span>     <span class="number">1</span>个字节<span class="number">8</span>位  </span><br><span class="line"> <span class="keyword">short</span>    <span class="number">2</span>个字节<span class="number">16</span>位  </span><br><span class="line"> <span class="keyword">int</span>      <span class="number">4</span>个字节<span class="number">32</span>位  </span><br><span class="line"> <span class="keyword">long</span>     <span class="number">4</span>个字节<span class="number">32</span>位  </span><br><span class="line"> <span class="keyword">long</span> <span class="keyword">long</span> <span class="number">8</span>个字节<span class="number">64</span>位  </span><br><span class="line"> 指针        <span class="number">4</span>个字节<span class="number">32</span>位    </span><br><span class="line">---------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">64</span>位平台    </span><br><span class="line"> <span class="keyword">char</span>     <span class="number">1</span>个字节<span class="number">8</span>位  </span><br><span class="line"> <span class="keyword">short</span>    <span class="number">2</span>个字节<span class="number">16</span>位  </span><br><span class="line"> <span class="keyword">int</span>      <span class="number">4</span>个字节<span class="number">32</span>位  </span><br><span class="line"> <span class="keyword">long</span>     <span class="number">8</span>个字节<span class="number">64</span>位  </span><br><span class="line"> <span class="keyword">long</span> <span class="keyword">long</span> <span class="number">8</span>个字节<span class="number">64</span>位 </span><br><span class="line"> 指针       <span class="number">8</span>个字节<span class="number">64</span>位</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="int-t同类"><a href="#int-t同类" class="headerlink" title="int_t同类"></a><code>int_t</code>同类</h3><p>​        <code>int_t</code> 为一个结构的标注，可以理解为<code>type/typedef</code>的缩写，表示它是通过<code>typedef</code>定义的，而不是一种新的数据类型。因为跨平台，不同的平台会有不同的字长，所以利用预编译和<code>typedef</code>可以最有效的维护代码</p><pre><code>int8_t     : typedef signed char;uint8_t    : typedef unsigned char;int16_t    : typedef signed short ;uint16_t   : typedef unsigned short ;int32_t    : typedef signed int;uint32_t   : typedef unsigned int;int64_t    : typedef signed  long long;uint64_t   : typedef unsigned long long;</code></pre><table><thead><tr><th><code>Specifier</code></th><th><code>Common Equivalent</code></th><th style="text-align:center"><code>Signing</code></th><th><code>Bits</code></th><th><code>Bytes</code></th><th><code>Minimum Value</code></th><th><code>Maximum Value</code></th></tr></thead><tbody><tr><td><code>int8_t</code></td><td><code>signed char</code></td><td style="text-align:center"><code>Signed</code></td><td><code>8</code></td><td><code>1</code></td><td><code>-128</code></td><td><code>127</code></td></tr><tr><td><code>uint8_t</code></td><td><code>unsigned char</code></td><td style="text-align:center"><code>Unsigned</code></td><td><code>8</code></td><td><code>1</code></td><td><code>0</code></td><td><code>255</code></td></tr><tr><td><code>int16_t</code></td><td><code>short</code></td><td style="text-align:center"><code>Signed</code></td><td><code>16</code></td><td><code>2</code></td><td><code>-32,768</code></td><td><code>32,767</code></td></tr><tr><td><code>uint16_t</code></td><td><code>unsigned short</code></td><td style="text-align:center"><code>Unsigned</code></td><td><code>16</code></td><td><code>2</code></td><td><code>0</code></td><td><code>65,535</code></td></tr><tr><td><code>int32_t</code></td><td><code>int</code></td><td style="text-align:center"><code>Signed</code></td><td><code>32</code></td><td><code>4</code></td><td><code>-2,147,483,648</code></td><td><code>2,147,483,647</code></td></tr><tr><td><code>uint32_t</code></td><td><code>unsigned int</code></td><td style="text-align:center"><code>Unsigned</code></td><td><code>32</code></td><td><code>4</code></td><td><code>0</code></td><td><code>4,294,967,295</code></td></tr><tr><td><code>int64_t</code></td><td><code>long long</code></td><td style="text-align:center"><code>Signed</code></td><td><code>64</code></td><td><code>8</code></td><td><code>-9,223,372,036,854,775,808</code></td><td><code>9,223,372,036,854,775,807</code></td></tr><tr><td><code>uint64_t</code></td><td><code>unsigned long long</code></td><td style="text-align:center"><code>Unsigned</code></td><td><code>64</code></td><td><code>8</code></td><td><code>0</code></td><td><code>18,446,744,073,709,551,615</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之大端和小端</title>
      <link href="/2018/01/08/c%E8%AF%AD%E8%A8%801-%E5%A4%A7%E7%AB%AF%E5%92%8C%E5%B0%8F%E7%AB%AF/"/>
      <url>/2018/01/08/c%E8%AF%AD%E8%A8%801-%E5%A4%A7%E7%AB%AF%E5%92%8C%E5%B0%8F%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<p>大端和小端是指数据在内存中的存储模式，它由<code>CPU</code>决定：</p><p>​    1) 大端模式（<code>Big-endian</code>）是指将数据的低位（比如<code>1234</code> 中的<code>34</code>就是低位）放在内存的高地址上，而数据的高位（比如<code>1234</code>中的<code>12</code>就是高位）放在内存的低地址上。这种存储模式有点儿类似于把数据当作字符串顺序处理，地址由小到大增加，而数据从高位往低位存放。</p><p>​    2) 小端模式（<code>Little-endian</code>）是指将数据的低位放在内存的低地址上，而数据的高位放在内存的高地址上。这种存储模式将地址的高低和数据的大小结合起来，高地址存放数值较大的部分，低地址存放数值较小的部分，这和我们的思维习惯是一致，比较容易理解。</p><a id="more"></a><h2 id="为什么有大小端模式之分"><a href="#为什么有大小端模式之分" class="headerlink" title="为什么有大小端模式之分"></a>为什么有大小端模式之分</h2><p>​    计算机中的数据是以字节（<code>Byte</code>）为单位存储的，每个字节都有不同的地址。现代<code>CPU</code>的位数（可以理解为一次能处理的数据的位数）都超过了<code>8</code>位（一个字节），<code>PC</code>机、服务器的<code>CPU</code>基本都是<code>64</code>位的，嵌入式系统或单片机系统仍然在使用<code>32</code>位和<code>16</code>位的<code>CPU</code>。</p><p>​    对于一次能处理多个字节的<code>CPU</code>，必然存在着如何安排多个字节的问题，也就是大端和小端模式。以<code>int</code>类型的<code>0x12345678</code>为例，它占用<code>4</code> 个字节，如果是小端模式（<code>Little-endian</code>），那么在内存中的分布情况为（假设从地址<code>0x4000</code>开始存放）：</p><table><thead><tr><th>内存地址</th><th><code>0x4000</code></th><th><code>0x4001</code></th><th><code>0x4002</code></th><th><code>0x4003</code></th></tr></thead><tbody><tr><td>存放内容</td><td><code>0x78</code></td><td><code>0x56</code></td><td><code>0x34</code></td><td><code>0x12</code></td></tr></tbody></table><p> 如果是大端模式（<code>Big-endian</code>），那么分布情况正好相反：</p><table><thead><tr><th>内存地址</th><th><code>0x4000</code></th><th><code>0x4001</code></th><th><code>0x4002</code></th><th><code>0x4003</code></th></tr></thead><tbody><tr><td>存放内容</td><td><code>0x12</code></td><td><code>0x34</code></td><td><code>0x56</code></td><td><code>0x78</code></td></tr></tbody></table><p>​    我们的<code>PC</code>机上使用的是<code>X86</code>结构的<code>CPU</code>，它是小端模式；<code>51</code>单片机是大端模式；很多<code>ARM</code>、<code>DSP</code>也是小端模式（部分<code>ARM</code>处理器还可以由硬件来选择是大端模式还是小端模式）。</p><p>​    借助共用体，我们可以检测<code>CPU</code>是大端模式还是小端模式，请看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">    &#125; data;</span><br><span class="line"></span><br><span class="line">    data.n = <span class="number">0x00000001</span>;  <span class="comment">//也可以直接写作 data.n = 1;</span></span><br><span class="line">    <span class="keyword">if</span>(data.ch == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Little-endian\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Big-endian\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>PC</code>机上的运行结果：<br><code>Little-endian</code></p><p>​    共用体的各个成员是共用一段内存的。<code>1</code>是数据的低位，如果<code>1</code>被存储在<code>data</code>的低字节，就是小端模式，这个时候<code>data.ch</code>的值也是<code>1</code>。如果<code>1</code>被存储在<code>data</code>的高字节，就是大端模式，这个时候<code>data.ch</code>的值就是<code>0</code>。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之指针</title>
      <link href="/2018/01/01/c%E8%AF%AD%E8%A8%802-%E6%8C%87%E9%92%88/"/>
      <url>/2018/01/01/c%E8%AF%AD%E8%A8%802-%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="指针详解"><a href="#指针详解" class="headerlink" title="指针详解"></a>指针详解</h2><p>​    这段时间在看<code>Linux</code>内核，深觉<code>C</code>语言功底不扎实，很多代码都看不太懂，深入学习巩固<code>C</code>语言的知识很有必要。先从指针开始。</p><a id="more"></a><h3 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h3><p>​    <code>C</code>语言里，变量存放在内存中，而<strong>内存其实就是一组有序字节组成的数组</strong>，每个字节有唯一的内存地址。<code>CPU</code>通过内存寻址对存储在内存中的某个指定数据对象的地址进行定位。这里，<strong>数据对象是指存储在内存中的一个指定数据类型的数值或字符串，它们都有一个自己的地址，而指针便是保存这个地址的变量。</strong>也就是说：<strong>指针是一种保存变量地址的变量</strong>。</p><p>​    前面已经提到内存其实就是一组有序字节组成的数组，数组中，每个字节大大小固定，都是 <code>8bit</code>。对这些连续的字节从<code>0</code>开始进行编号，每个字节都有唯一的一个编号，这个编号就是内存地址。示意如下图：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/765389-20180918115659254-712651853.png" alt></p><p>​    这是一个 <code>4GB</code> 的内存，可以存放 <code>2^32</code> 个字节的数据。左侧的连续的十六进制编号就是内存地址，每个内存地址对应一个字节的内存空间。而指针变量保存的就是这个编号，也即内存地址。</p><h3 id="为什么要使用指针"><a href="#为什么要使用指针" class="headerlink" title="为什么要使用指针"></a>为什么要使用指针</h3><p>​    在<code>C</code>语言中，指针的使用非常广泛，因为使用指针往往可以生成更高效、更紧凑的代码。总的来说，使用指针有如下好处：</p><p>1）指针的使用使得不同区域的代码可以轻易的共享内存数据，这样可以使程序更为快速高效；</p><p>2）<code>C</code>语言中一些复杂的数据结构往往需要使用指针来构建，如链表、二叉树等；</p><p>3）<code>C</code>语言是传值调用，而有些操作传值调用是无法完成的，如通过被调函数修改调用函数的对象，但是这种操作可以由指针来完成，而且并不违背传值调用。</p><h3 id="如何声明一个指针"><a href="#如何声明一个指针" class="headerlink" title="如何声明一个指针"></a>如何声明一个指针</h3><h4 id="声明并初始化一个指针"><a href="#声明并初始化一个指针" class="headerlink" title="声明并初始化一个指针"></a>声明并初始化一个指针</h4><p>​    指针其实就是一个变量，指针的声明方式与一般的变量声明方式没太大区别：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;        <span class="comment">// 声明一个 int 类型的指针 p</span></span><br><span class="line"><span class="keyword">char</span> *p        <span class="comment">// 声明一个 char 类型的指针 p</span></span><br><span class="line"><span class="keyword">int</span> *arr[<span class="number">10</span>]   <span class="comment">// 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向 int 类型对象的指针</span></span><br><span class="line"><span class="keyword">int</span> (*arr)[<span class="number">10</span>] <span class="comment">// 声明一个数组指针，该指针指向一个 int 类型的一维数组</span></span><br><span class="line"><span class="keyword">int</span> **p;       <span class="comment">// 声明一个指针 p ，该指针指向一个 int 类型的指针</span></span><br></pre></td></tr></table></figure><p>​    指针的声明比普通变量的声明多了一个一元运算符 <code>“*”</code>。运算符 <code>“*”</code>  是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。在上述的声明中：<strong><code>p</code> 是一个指针，保存着一个地址，该地址指向内存中的一个变量； <code>*p</code>则会访问这个地址所指向的变量。</strong></p><p>​    声明一个指针变量并不会自动分配任何内存。在对指针进行间接访问之前，指针必须进行初始化：或是使他指向现有的内存，或者给他动态分配内存，否则我们并不知道指针指向哪儿，这将是一个很严重的问题，稍后会讨论这个问题。初始化操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方法1：使指针指向现有的内存 */</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;x;　　<span class="comment">// 指针 p 被初始化，指向变量 x ，其中取地址符 &amp; 用于产生操作数内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方法2：动态分配内存给指针 */</span></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">10</span>);　　　　<span class="comment">// malloc 函数用于动态分配内存</span></span><br><span class="line"><span class="built_in">free</span>(p);　　　　</span><br><span class="line"><span class="comment">// free 函数用于释放一块已经分配的内存，常与 malloc 函数一起使用，要使用这两个函数需要头文件 stdlib.h</span></span><br></pre></td></tr></table></figure><p>​    指针的初始化<strong>实际上就是给指针一个合法的地址，让程序能够清楚地知道指针指向哪儿。</strong></p><h4 id="未初始化和非法的指针"><a href="#未初始化和非法的指针" class="headerlink" title="未初始化和非法的指针"></a>未初始化和非法的指针</h4><p>​    如果一个指针没有被初始化，那么程序就不知道它指向哪里。它可能指向一个非法地址，这时，程序会报错，在<code>Linux</code>上，错误类型是<code>Segmentation fault（core  dumped）</code>，提醒我们段违例或内存错误。它也可能指向一个合法地址，实际上，这种情况更严重，你的程序或许能正常运行，但是这个没有被初始化的指针所指向的那个位置的值将会被修改，而你并无意去修改它。用一个例子简单的演示一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    *p = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这个程序可以编译通过，但是运行的话会报错，报错信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hly_centos learn]# gcc -o point point.c </span><br><span class="line">[root@hly_centos learn]# ./point </span><br><span class="line">Segmentation fault</span><br><span class="line">[root@hly_centos learn]#</span><br></pre></td></tr></table></figure><p>​    要想使这个程序运行起来，需要先对指针<code>p</code>进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">int</span> *p = &amp;x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*p);</span><br><span class="line">　  *p = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这段代码的输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hly_centos learn]# gcc -o point point.c </span><br><span class="line">[root@hly_centos learn]# ./point </span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>​    可以看到，对指针进行初始化后，便可以正常对指针进行赋值了。 </p><h4 id="NULL指针"><a href="#NULL指针" class="headerlink" title="NULL指针"></a><code>NULL</code>指针</h4><p>​    <strong><code>NULL</code>指针是一个特殊的指针变量，表示不指向任何东西</strong>。可以通过给一个指针赋一个零值来生成一个<code>NULL</code>指针。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p的地址为%d\n"</span>,p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************</span></span><br><span class="line"><span class="comment"> * 程序输出：</span></span><br><span class="line"><span class="comment"> * p的地址为0</span></span><br><span class="line"><span class="comment">***************/</span></span><br></pre></td></tr></table></figure><p>​    可以看到指针指向内存地址<code>0</code>。在大多数的操作系统上，程序不允许访问地址为<code>0</code>的内存，因为该内存是为操作系统保留的。但是，<strong>内存地址<code>0</code>有一个特别重要的意义，它表明该指针指向一个不可访问的内存位置。</strong></p><h3 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h3><p>​    <code>C</code>指针的算术运算只限于两种形式：</p><h4 id="指针-整数-："><a href="#指针-整数-：" class="headerlink" title="指针+/-整数 ："></a>指针<code>+/-</code>整数 ：</h4><p>​    可以对指针变量<code>p</code>进行<code>p++</code>、<code>p--</code>、<code>p + i</code>等操作，所得结果也是一个指针，只是指针所指向的内存地址相比于<code>p</code>所指的内存地址前进或者后退了<code>i</code>个操作数。用一张图来说明一下：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/765389-20180921154218407-1813012241.png" alt></p><p>​    在上图中，<code>10000000</code>等是内存地址的十六进制表示（数值是假定的），<code>p</code>是一个<code>int</code>类型的指针，指向内存地址  <code>0x10000008</code> 处。则<code>p++</code>将指向与<code>p</code>相邻的下一个内存地址，由于<code>int</code>型数据占<code>4</code>个字节，因此<code>p++</code>所指的内存地址为  <code>1000000b</code>。其余类推。不过要注意的是，这种运算并不会改变指针变量<code>p</code>自身的地址，只是改变了它所指向的地址。</p><h4 id="指针-指针"><a href="#指针-指针" class="headerlink" title="指针-指针"></a>指针<code>-</code>指针</h4><p>​    只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。两个指针相减的结果的类型是  <code>ptrdiff_t</code>，它是一种有符号整数类型。<strong>减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位，而不是以字节为单位），因为减法运算的结果将除以数组元素类型的长度。</strong>举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> sub;</span><br><span class="line">    <span class="keyword">int</span> *p1 = &amp;a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> *p2 = &amp;a[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    sub = p2-p1;                                                                            </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sub);　　　　<span class="comment">// 输出结果为 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>​    在<code>C</code>语言中，指针与数组之间的关系十分密切。实际上，许多可以用数组完成的工作都可以使用指针来完成。一般来说，用指针编写的程序比用数组编写的程序执行速度快，但另一方面，用指针实现的程序理解起来稍微困难一些。</p><h4 id="指针与数组的关系"><a href="#指针与数组的关系" class="headerlink" title="指针与数组的关系"></a>指针与数组的关系</h4><p>​    我们先声明一个数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];        <span class="comment">// 声明一个int类型的数组，这个数组有10个元素</span></span><br></pre></td></tr></table></figure><p>​    我们可以用<code>a[0]</code>、<code>a[1]</code>、<code>...</code>、<code>a[9]</code>来表示这个数组中的<code>10</code>个元素，这<code>10</code>个元素是存储在一段连续相邻的内存区域中的。</p><p>​    接下来，我们再声明一个指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;           <span class="comment">// 声明一个int类型的指针变量</span></span><br></pre></td></tr></table></figure><p>​    <code>p</code>是一个指针变量，指向内存中的一个区域。如果我们对指针<code>p</code>做如下的初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">0</span>];        <span class="comment">// 对指针进行初始化，p将指向数组 a 的第 1 个元素 a[0]</span></span><br></pre></td></tr></table></figure><p>​    我们知道，对指针进行自增操作会让指针指向与当前元素相邻的下一个元素，即<code>*(p + 1)</code>将指向 <code>a[1]</code> ；同样的，<code>*(p +  i)</code>将指向<code>a[i]</code>。因此，我们可以使用该指针来遍历数组<code>a[10]</code>的所有元素。可以看到，数组下标与指针运算之间的关系是一一对应的。而根据定义，<strong>数组类型的变量或表达式的值是该数组第<code>1</code>个元素的地址，且数组名所代表的的就是该数组第<code>1</code>个元素的地址，</strong>故，上述赋值语句可以直接写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = a;        // a 为数组名，代表该数组最开始的一个元素的地址</span><br></pre></td></tr></table></figure><p>​    很显然，<strong>一个通过数组和下标实现的表达式可以等价地通过指针及其偏移量来实现</strong>，这就是数组和指针的互通之处。但有一点要明确的是，数组和指针并不是完全等价，<strong>指针是一个变量，而数组名不是变量，它数组中第<code>1</code>个元素的地址，数组可以看做是一个用于保存变量的容器。</strong>更直接的方法，我们可以直接看二者的地址，并不一样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span>                                                                          </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x的地址为：%p\n"</span>,x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x[0]的地址为：%p\n"</span>,&amp;x[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p的地址为：%p\n"</span>,&amp;p);　　　　　　<span class="comment">// 打印指针 p 的地址，并不是指针所指向的地方的地址</span></span><br><span class="line"></span><br><span class="line">    p += <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*(p+2)的值为：%d\n"</span>,*p);　　　　<span class="comment">// 输出结果为 3，*(p+2)指向了 x[2]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@hly_centos learn]# gcc -o point point.c </span><br><span class="line">[root@hly_centos learn]# ./point </span><br><span class="line">x的地址为：0x7ffe02b98a60</span><br><span class="line">x[0]的地址为：0x7ffe02b98a60</span><br><span class="line">p的地址为：0x7ffe02b98a58</span><br><span class="line">*(p+2)的值为：3</span><br></pre></td></tr></table></figure><p>​    可以看到，<code>x</code>的值与<code>x[0]</code>的地址是一样的，也就是说数组名即为数组中第<code>1</code>个元素的地址。实际上，打印<code>&amp;x</code>后发现，<code>x</code>的地址也是这个值。而<code>x</code>的地址与指针变量<code>p</code>的地址是不一样的。故而数组和指针并不能完全等价。</p><p>（笔者注：上述输出结果是在 <code>centos7 64bit</code> 的环境下使用 <code>gcc</code>  编译器得到的，可以看到地址是一个<code>12</code>位的十六进制数，转换成二进制是<code>48</code>位，也就是说寻址空间有 <code>256TB</code>，但是笔者的电脑只有 <code>8GB</code>  内存，猜测是不是由于 <code>linux</code> 系统开启了内存分页机制，这里寻址的是虚拟地址<code>？</code>另外，在Windows下使用 <code>vs2015</code>编译运行的话，则输出结果是一个<code>8</code>位的十六进制数，也就是<code>32</code>位二进制，寻址空间为 <code>4GB</code>） </p><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><p>​    指针是一个变量，而数组是用于存储变量的容器，因此，指针也可以像其他变量一样存储在数组中，也就是指针数组。 <strong>指针数组是一个数组，数组中的每一个元素都是指针</strong>。声明一个指针数组的方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[<span class="number">10</span>];    <span class="comment">// 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向int类型的指针</span></span><br></pre></td></tr></table></figure><p>​    在上述声明中，由于<code>[]</code>的优先级比<code>*</code>高，故<code>p</code>先与<code>[]</code>结合，成为一个数组<code>p[]</code>；再由<code>int *</code>指明这是一个<code>int</code>类型的指针数组，数组中的元素都是<code>int</code>类型的指针。数组的第<code>i</code>个元素是<code>*p[i]</code>，而 <strong><code>p[i]</code>是一个指针</strong>。由于指针数组中存放着多个指针，操作灵活，在一些需要操作大量数据的程序中使用，可以使程序更灵活快速。</p><h4 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h4><p>​    <strong>数组指针是一个指针，它指向一个数组</strong>。声明一个数组指针的方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)[<span class="number">10</span>];        <span class="comment">// 声明一个数组指针 p ，该指针指向一个数组</span></span><br></pre></td></tr></table></figure><p>​    由于<code>()</code>的优先级最高，所以<code>p</code>是一个指针，指向一个<code>int</code>类型的一维数组，这个一维数组的长度是<code>10</code>，这也是指针<code>p</code>的步长。也就是说，执行<code>p+1</code>时，<code>p</code>要跨过<code>1</code>个<code>int</code>型数据的长度。数组指针与二维数组联系密切，可以用数组指针来指向一个二维数组，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;     <span class="comment">// 定义一个二维数组并初始化</span></span><br><span class="line">    <span class="keyword">int</span> (*p)[<span class="number">3</span>];                       <span class="comment">// 定义一个数组指针，指针指向一个含有3个元素的一维数组</span></span><br><span class="line"></span><br><span class="line">    p = arr;        <span class="comment">// 将二维数组的首地址赋给 p，此时 p 指向 arr[0] 或 &amp;arr[0][0]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(*p)[<span class="number">0</span>]);　　　　　　　<span class="comment">// 输出结果为 1</span></span><br><span class="line">    p++;　　　　　　　<span class="comment">// 对 p 进行算术运算，此时 p 将指向二维数组的下一行的首地址，即 &amp;arr[1][0]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(*p)[<span class="number">1</span>]);           <span class="comment">// 输出结果为5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针与结构"><a href="#指针与结构" class="headerlink" title="指针与结构"></a>指针与结构</h3><h4 id="简单介绍一下结构"><a href="#简单介绍一下结构" class="headerlink" title="简单介绍一下结构"></a>简单介绍一下结构</h4><p>​    结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。由于结构将一组相关的变量看做一个单元而不是各自独立的实体，因此结构有助于组织复杂的数据，特别是在大型的程序中。声明一个结构的方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message</span>&#123;</span>　　　　　　      <span class="comment">// 声明一个结构 message</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];             <span class="comment">// 成员</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">message</span> <span class="title">s_message</span>;</span>　　　　 <span class="comment">// 类型定义符 typedef</span></span><br><span class="line"></span><br><span class="line">s_message mess = &#123;<span class="string">"tongye"</span>,<span class="number">23</span>,<span class="number">83</span>&#125;;　　　　<span class="comment">// 声明一个 struct message 类型的变量 mess,并对其进行初始化　</span></span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/* 另一种更简便的声明方法 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">　　<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">　　<span class="keyword">int</span> age;</span><br><span class="line">　　<span class="keyword">int</span> score;</span><br><span class="line">&#125;message;</span><br></pre></td></tr></table></figure><p>​    可以使用 <strong>结构名.成员</strong> 的方式来访问结构中的成员，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,mess.name);　　　　<span class="comment">// 输出结果：tongye</span></span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mess.age);　　　　 <span class="comment">// 输出结果：23</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构指针"><a href="#结构指针" class="headerlink" title="结构指针"></a>结构指针</h4><p>​    结构指针是指向结构的指针，以上面的结构为例，可以这样定义一个结构指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s_message *p;        <span class="comment">// 声明一个结构指针 p ，该指针指向一个 s_message 类型的结构</span></span><br><span class="line">p = &amp;mess;　　　　　　<span class="comment">// 对结构指针的初始化与普通指针一样，也是使用取地址符 &amp;</span></span><br></pre></td></tr></table></figure><p>​    <code>C</code>语言中使用<code>-&gt;</code>操作符来访问结构指针的成员，举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;  </span><br><span class="line">&#125;message;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    message mess = &#123;<span class="string">"tongye"</span>,<span class="number">23</span>,<span class="number">83</span>&#125;;</span><br><span class="line">    message *p = &amp;mess;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p-&gt;mess);　　　　　　<span class="comment">// 输出结果为：tongye</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p-&gt;score);         <span class="comment">// 输出结果为：83</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><p>​    <strong><code>C</code>语言的所有参数均是以“传值调用”的方式进行传递的，这意味着函数将获得参数值的一份拷贝。</strong>这样，函数可以放心修改这个拷贝值，而不必担心会修改调用程序实际传递给它的参数。 </p><h4 id="指针作为函数的参数"><a href="#指针作为函数的参数" class="headerlink" title="指针作为函数的参数"></a>指针作为函数的参数</h4><p>​    传值调用的好处是是被调函数不会改变调用函数传过来的值，可以放心修改。但是有时候需要被调函数回传一个值给调用函数，这样的话，传值调用就无法做到。为了解决这个问题，可以使用传指针调用。<strong>指针参数使得被调函数能够访问和修改主调函数中对象的值。</strong>用一个例子来说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>　　　　　　  <span class="comment">// 参数为普通的 int 变量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> temp;</span><br><span class="line">　　temp = a;</span><br><span class="line">　　a = b;</span><br><span class="line">　　b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span>　　　　　　<span class="comment">// 参数为指针，接受调用函数传递过来的变量地址作为参数，对所指地址处的内容进行操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> temp;　　　　                <span class="comment">// 最终结果是，地址本身并没有改变，但是这一地址所对应的内存段中的内容发生了变化，即x,y的值发生了变化</span></span><br><span class="line">　　temp = *a;</span><br><span class="line">　　*a = *b;</span><br><span class="line">　　*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> x = <span class="number">1</span>,y = <span class="number">2</span>;</span><br><span class="line">　　swap1(x,y);                     <span class="comment">// 将 x,y 的值本身作为参数传递给了被调函数</span></span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">"%d %5d\n"</span>,x,y);         <span class="comment">// 输出结果为：1     2</span></span><br><span class="line"></span><br><span class="line">　　swap(&amp;x,&amp;y);                    <span class="comment">// 将 x,y 的地址作为参数传递给了被调函数，传递过去的也是一个值，与传值调用不冲突</span></span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">"%d %5d\n"</span>,x,y);         <span class="comment">// 输出结果为：2     1</span></span><br><span class="line">　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h4><p>​    <strong>指针函数</strong>： <strong>顾名思义，它的本质是一个函数，不过它的返回值是一个指针</strong>。其声明的形式如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ret *<span class="title">func</span><span class="params">(args, ...)</span></span>;</span><br></pre></td></tr></table></figure></p><p>​    其中，<code>func</code>是一个函数，<code>args</code>是形参列表，<code>ret *</code>作为一个整体，是 <code>func</code>函数的返回值，是一个指针的形式。<br>​    下面举一个具体的实例来做说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">文件：pointer_func.c</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">func_sum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error:n must be &gt; 0\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please input one number:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">    <span class="keyword">int</span> *p = func_sum(num); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum:%d\n"</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上例就是一个指针函数的例子，其中，<code>int * func_sum(int n)</code>就是一个指针函数， 其功能十分简单，是根据传入的参数<code>n</code>，来计算从<code>0</code>到<code>n</code>的所有自然数的和，其结果通过指针的形式返回给调用方。<br>​    以上代码的运行结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hly_centos learn]# gcc -o point_func point_func.c </span><br><span class="line">[root@hly_centos learn]# ./point_func </span><br><span class="line">please input one number:100</span><br><span class="line">sum:4950</span><br></pre></td></tr></table></figure><p>​    如果上述代码使用普通的局部变量来实现，也是可以的，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">文件：pointer_func2.c</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_sum2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error:n must be &gt; 0\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please input one number:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">    <span class="keyword">int</span> ret = func_sum2(num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum2:%d\n"</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    本案例中，<code>func_sum2</code>函数的功能与指针函数所实现的功能完全一样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hly_centos learn]# gcc -o point_func point_func.c </span><br><span class="line">[root@hly_centos learn]# ./point_func </span><br><span class="line">please input one number:100</span><br><span class="line">sum:4950</span><br></pre></td></tr></table></figure><p>​    不过在使用指针函数时，需要注意一点，相信细心地读者已经发现了，对比<code>func_sum</code>和<code>func_sum2</code>函数，除了返回值不一样之外，还有一个不同的地方在于，在<code>func_sum</code>中，变量<code>sum</code>使用的是静态局部变量，而<code>func_sum2</code>函数中，变量<code>sum</code>使用的则是普通的变量。<br>​    如果我们把指针函数的<code>sum</code>定义为普通的局部变量，会是什么结果呢？不妨来试验一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">文件：pointer_func3.c</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">func_sum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error:n must be &gt; 0\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please input one number:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">    <span class="keyword">int</span> *p = func_sum(num); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum:%d\n"</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    执行以上程序，发现仍然能得到正确的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hly_centos learn]# gcc -o point_func point_func.c </span><br><span class="line">[root@hly_centos learn]# ./point_func </span><br><span class="line">please input one number:100</span><br><span class="line">sum:4950</span><br></pre></td></tr></table></figure><p>​    可如果我们把<code>main</code>函数里面稍微改动一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please input one number:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">    <span class="keyword">int</span> *p = func_sum(num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wait for a while...\n"</span>);    <span class="comment">//此处加一句打印</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum:%d\n"</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    我们在输出<code>sum</code>之前打印一句话，这时看到得到的结果完全不是我们预先想象的样子，得到的并不是我们想要的答案。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@hly_centos learn]# gcc -o point_func point_func.c </span><br><span class="line">[root@hly_centos learn]# ./point_func </span><br><span class="line">please input one number:100</span><br><span class="line">wait for a while...</span><br><span class="line">sum:0</span><br></pre></td></tr></table></figure><p>​    为什么会出现上面的结果呢？<br>​    其实原因在于，一般的局部变量是存放于栈区的，当函数结束，栈区的变量就会释放掉，如果我们在函数内部定义一个变量，在使用一个指针去指向这个变量，当函数调用结束时，这个变量的空间就已经被释放，这时就算返回了该地址的指针，也不一定会得到正确的值。上面的示例中，在返回该指针后，立即访问，的确是得到了正确的结果，但这只是十分巧合的情况，如果我们等待一会儿再去访问该地址，很有可能该地址已经被其他的变量所占用，这时候得到的就不是我们想要的结果。甚至更严重的是，如果因此访问到了不可访问的内容，很有可能造成段错误等程序崩溃的情况。<br>​    因此，在使用指针函数的时候，一定要避免出现返回局部变量指针的情况。<br>​    那么为什么用了<code>static</code>就可以避免这个问题呢？<br>​    原因是一旦使用了<code>static</code>去修饰变量，那么该变量就变成了静态变量。而静态变量是存放在数据段的，它的生命周期存在于整个程序运行期间，只要程序没有结束，该变量就会一直存在，所以该指针就能一直访问到该变量。<br>​    因此，还有一种解决方案是使用全局变量，因为全局变量也是放在数据段的，但是并不推荐使用全局变量。</p><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>​    与指针函数不同，函数指针的本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。<br>​    我们知道，函数的定义是存在于代码段，因此，每个函数在代码段中，也有着自己的入口地址，函数指针就是指向代码段中函数入口地址的指针。<br>​    其声明形式如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret (*p)(args, ...);</span><br></pre></td></tr></table></figure><p>​    其中，<code>ret</code>为返回值，<code>*p</code>作为一个整体，代表的是指向该函数的指针，<code>args</code>为形参列表。其中p被称为<strong>函数指针变量</strong> 。<br>​        关于函数指针的初始化与数组类似，在数组中，数组名即代表着该数组的首地址，函数也是一样，函数名即是该数组的入口地址，因此，函数名就是该函数的函数指针。<br>​    因此，我们可以采用如下的初始化方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数指针变量 =  函数名;</span><br></pre></td></tr></table></figure><p>​    下面还是以一个简单的例子来具体说明一下函数指针的应用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">文件：func_pointer.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">//函数指针的定义</span></span><br><span class="line">    <span class="comment">//int (*p)();       //函数指针的另一种定义方式，不过不建议使用</span></span><br><span class="line">    <span class="comment">//int (*p)(int a, int b);   //也可以使用这种方式定义函数指针</span></span><br><span class="line">    </span><br><span class="line">    p = max;    <span class="comment">//函数指针初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = p(<span class="number">10</span>, <span class="number">15</span>);    <span class="comment">//函数指针的调用</span></span><br><span class="line">    <span class="comment">//int ret = (*max)(10,15);</span></span><br><span class="line">    <span class="comment">//int ret = (*p)(10,15);</span></span><br><span class="line">    <span class="comment">//以上两种写法与第一种写法是等价的，不过建议使用第一种方式</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max = %d \n"</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    上面这个函数的功能也十分简单，就是求两个数中较大的一个数。值得注意的是通过函数指针调用的方式。<br>​    首先代码里提供了<code>3</code>种函数指针定义的方式，这三种方式都是正确的，比较推荐第一种和第三种定义方式。然后对函数指针进行初始化，前面已经提到过了，直接将函数名赋值给函数指针变量名即可。<br>​    上述代码运行的结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hly_centos learn]# gcc -o func_point func_point.c </span><br><span class="line">[root@hly_centos learn]# ./func_point </span><br><span class="line">max = 15</span><br></pre></td></tr></table></figure><p>​    <strong>调用的时候，既可以直接使用函数指针调用，也可以通过函数指针所指向的值去调用。<code>(*p)</code>所代表的就是函数指针所指向的值，也就是函数本身，这样调用自然不会有问题。</strong><br>​    为什么要使用函数指针？</p><p>​    那么，有不少人就觉得，本来很简单的函数调用，搞那么复杂干什么？其实在这样比较简单的代码实现中不容易看出来，当项目比较大，代码变得复杂了以后，函数指针就体现出了其优越性。<br>​    举个例子，如果我们要实现数组的排序，我们知道，常用的数组排序方法有很多种，比如快排，插入排序，冒泡排序，选择排序等，如果不管内部实现，你会发现，除了函数名不一样之外，返回值，包括函数入参都是相同的，这时候如果要调用不同的排序方法，就可以使用指针函数来实现，我们只需要修改函数指针初始化的地方，而不需要去修改每个调用的地方（特别是当调用特别频繁的时候）。</p><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>​    函数指针的一个非常典型的应用就是<strong>回调函数</strong>。<br>​    什么是回调函数？<br>​    <strong>回调函数就是一个通过指针函数调用的函数。其将函数指针作为一个参数，传递给另一个函数。</strong><br>​    回调函数并不是由实现方直接调用，而是在特定的事件或条件发生时由另外一方来调用的。同样我们来看一个回调函数的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">文件：callback.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能：实现累加求和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_sum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"n must be &gt; 0\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数是回调函数，其中第二个参数为一个函数指针，通过该函数指针来调用求和函数，并把结果返回给主调函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">callback</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> (*p)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"please input number:"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the sum from 0 to %d is %d\n"</span>, n, callback(n, func_sum));       <span class="comment">//此处直接调用回调函数，而不是直接调用func_sum函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上面这个简单的<code>demo</code>就是一个比较典型的回调函数的例子。在这个程序中，回调函数<code>callback</code>无需关心<code>func_sum</code>是怎么实现的，只需要去调用即可。</p><p>​    这样的好处就是，如果以后对求和函数有优化，比如新写了个<code>func_sum2</code>函数的实现，我们只需要在调用回调函数的地方将函数指针指向<code>func_sum2</code>即可，而无需去修改<code>callback</code>函数内部。<br>​    以上代码的输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hly_centos learn]# gcc -o call_back call_back.c </span><br><span class="line">[root@hly_centos learn]# ./call_back </span><br><span class="line">please input number:10</span><br><span class="line">the sum from 0 to 10 is 45</span><br></pre></td></tr></table></figure><p>​    回调函数广泛用于开发场景中，比如信号函数、线程函数等，都使用到了回调函数的知识。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
