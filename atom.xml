<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龙场驿站</title>
  
  <subtitle>无善无恶心之体，有善有恶意之动；知善知恶是良知，为善去恶是格物。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-21T02:41:05.925Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>建木</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++虚继承下的内存模型</title>
    <link href="http://yoursite.com/2019/05/25/C++%E8%99%9A%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/05/25/C++虚继承下的内存模型/</id>
    <published>2019-05-25T09:54:02.000Z</published>
    <updated>2019-10-21T02:41:05.925Z</updated>
    
    <content type="html"><![CDATA[<p>  简单的面向对象，只有单继承或多继承的情况下，内存模型很好理解，编译器实现起来也容易，C++ 的效率和 C 的效率不相上下。一旦和 virtual 关键字扯上关系，使用到虚继承或虚函数，内存模型就变得混乱起来，各种编译器的实现也不一致，让人抓狂。</p><a id="more"></a><h2 id="虚继承下的内存模型"><a href="#虚继承下的内存模型" class="headerlink" title="虚继承下的内存模型"></a>虚继承下的内存模型</h2><p>​        这是因为 C++ 标准仅对 C++ 的实现做了框架‘性的概述，并没有规定细节如何实现，所以不同厂商的编译器在具体实现方案上会有所差异。<br>​<br>​        对于普通继承，基类子对象始终位于派生类对象的前面（也即基类成员变量始终在派生类成员变量的前面），而且不管继承层次有多深，它相对于派生类对象顶部的偏移量是固定的。请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a1;</span><br><span class="line">    <span class="keyword">int</span> m_a2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b1;</span><br><span class="line">    <span class="keyword">int</span> b2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> c1;</span><br><span class="line">    <span class="keyword">int</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> d1;</span><br><span class="line">    <span class="keyword">int</span> d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A obj_a;</span><br><span class="line">    B obj_b;</span><br><span class="line">    C obj_c;</span><br><span class="line">    D obj_d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <code>obj_a</code>、<code>obj_b</code>、<code>obj_c</code>、<code>obj_d</code> 的内存模型如下所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-161019164406212.jpg" alt></p><pre><code>A 是最顶层的基类，在派生类 B、C、D 的对象中，A 类子对象始终位于最前面，偏移量是固定的，为 0。`b1`、`b2` 是派生类 B 的新增成员变量，它们的偏移量也是固定的，分别为 8 和 12。`c1`、`c2`、`d1`、`d2` 也是同样的道理。</code></pre><p>​        前面我们说过，编译器在知道对象首地址的情况下，通过计算偏移来存取成员变量。<strong>对于普通继承，基类成员变量的偏移是固定的，不会随着继承层级的增加而改变，存取起来非常方便</strong>。</p><p>​        而对于虚继承，恰恰和普通继承相反，<strong>大部分编译器会把基类成员变量放在派生类成员变量的后面，这样随着继承层级的增加，基类成员变量的偏移就会改变，就得通过其他方案来计算偏移量</strong>。</p><p>​        下面我们来一步一步地分析虚继承时的对象内存模型。</p><p> 1) 修改上面的代码，使得 A 是 B 的虚基类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br></pre></td></tr></table></figure></p><p> 此时 obj_b、obj_c、obj_d 的内存模型就会发生变化，如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1509151624041K.jpg" alt></p><pre><code>**不管是虚基类的直接派生类还是间接派生类，虚基类的子对象始终位于派生类对象的最后面**。</code></pre><p> 2) 再假设 A 是 B 的虚基类，B 又是 C 的虚基类，那么各个对象的内存模型如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-15091520200R52.jpg" alt></p><pre><code>从上面的两张图中可以发现，虚继承时的派生类对象被分成了两部分： </code></pre><ul><li>不带阴影的一部分偏移量固定，不会随着继承层次的增加而改变，称为固定部分；</li><li>带有阴影的一部分是虚基类的子对象，偏移量会随着继承层次的增加而改变，称为共享部分。</li></ul><p>​     当要访问对象的成员变量时，需要知道对象的首地址和变量的偏移，对象的首地址很好获得，关键是变量的偏移。对于固定部分，偏移是不变的，很好计算；而对于共享部分，偏移会随着继承层次的增加而改变，这就需要设计一种方案，在偏移不断变化的过程中准确地计算偏移。各个编译器正是在设计这一方案时出现了分歧，不同的编译器设计了不同的方案来计算共享部分的偏移。 </p><blockquote><pre><code>对于虚继承，将派生类分为**固定部分**和**共享部分**，并把共享部分放在最后，几乎所有的编译器都在这一点上达成了共识。主要的分歧就是如何计算共享部分的偏移，可谓是百花齐放，没有统一标准。</code></pre></blockquote><h2 id="cfront解决方案"><a href="#cfront解决方案" class="headerlink" title="cfront解决方案"></a><code>cfront</code>解决方案</h2><p>​        早期的 <code>cfront</code> 编译器会在派生类对象中安插一些指针，每个指针指向一个虚基类的子对象，要存取继承来的成员变量，可以使用指针间接完成。</p><p> 1) 如果 A 是 B 的虚基类，那么各个对象的实际内存模型如下所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1509151J044P3.jpg" alt></p><p>​        编译器会在直接派生类的对象 <code>obj_b</code> 中安插一个指针，指向虚基类 A  的起始位置，并且这个指针的偏移是固定的，不会随着继承层次的增加而改变。当要访问 <code>a1</code>、<code>a2</code> 时，要先通过对象指针找到 pa，再通过 pa 找到  <code>a1</code>、<code>a2</code>，这样一来就比没有虚继承时多了一层间接。</p><p>​        假设 p 是obj_d 的指针，现在要访问成员变量 <code>a2</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> member_a2 = p -&gt; a2;</span><br></pre></td></tr></table></figure></p><pre><code>那么编译器内部会进行类似下面的转换： </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A *pa = (A*)( *(int*)( (int)p + sizeof(int)*2 ) );</span><br><span class="line">int member_a2 = *(int*)( (int)pa + sizeof(int) );</span><br></pre></td></tr></table></figure><p> 2) 如果 A 是 B 的虚基类，同时 B 也是 C 的虚基类，那么各个对象的实际内存模型如下所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1509151P15C35.jpg" alt></p><p>​        当要访问 <code>a1</code>、<code>a2</code> 时，要先通过对象指针找到 <code>pb</code>，再通过 <code>pb</code> 找到 <code>pa</code>，最后才能通过 pa 找到 <code>a1</code>、<code>a2</code>，这样一来就比没有虚继承时多了两层间接。</p><p>​        通过上面的分析可以发现，这种方案的一个缺点就是，随着虚继承层次的增加，访问顶层基类需要的间接转换会越来越多，效率越来越低。</p><p>​        这种方案另外的一个缺点是：<strong>当有多个虚基类时，派生类要为每个虚基类都安插一个指针，会增加对象的体积</strong>。</p><p>​    例如，假设 A、B、C、D 类的继承关系为： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1509151S441J0.jpg" alt></p><p>​    <code>obj_d</code> 的内存模型如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1509151T420R4.jpg" alt></p><p> D 有三个虚基类，所以 obj_d 对象要额外背负三个指针 <code>pa</code>、<code>pab</code>、<code>pc</code>。 </p><h2 id="VC解决方案"><a href="#VC解决方案" class="headerlink" title="VC解决方案"></a><code>VC</code>解决方案</h2><p>​         <code>cfront</code> 的后来者 <code>VC</code> 尝试对上面的方案进行了改进，一定程度上弥补了它的不足。</p><p>​        <code>VC</code> 引入了<strong>虚基类表</strong>，如果某个派生类有一个或多个虚基类，编译器就会在派生类对象中安插一个指针，指向虚基类表。虚基类表其实就是一个数组，数组中的元素存放的是各个虚基类的偏移。</p><p>​         假设 A 是 B 的虚基类，那么各对象的内存模型如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-15091519111R32.jpg" alt></p><pre><code>假设 A 是 B 的虚基类，同时 B 又是 C 的虚基类，那么各对象的内存模型如下图所示： </code></pre><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-150915201003P8.jpg" alt></p><p>​        虚继承表中保存的是所有虚基类（包括直接继承和间接继承到的）相对于当前对象的偏移，这样通过派生类指针访问虚基类的成员变量时，不管继承层次都多深，只需要一次间接转换就可以。</p><p>​        另外，这种方案还可以避免有多个虚基类时让派生类对象额外背负过多的指针。例如，假设 A、B、C、D 类的继承关系为： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1509151S441J0.jpg" alt></p><pre><code>那么 obj_d 的内存模型如下图所示： </code></pre><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-15091520341C51.jpg" alt></p><pre><code>如此一来，D 类虽然有三个虚基类，但它的对象 obj_d 只需要额外背负一个指针。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  简单的面向对象，只有单继承或多继承的情况下，内存模型很好理解，编译器实现起来也容易，C++ 的效率和 C 的效率不相上下。一旦和 virtual 关键字扯上关系，使用到虚继承或虚函数，内存模型就变得混乱起来，各种编译器的实现也不一致，让人抓狂。&lt;/p&gt;
    
    </summary>
    
      <category term="c++_language" scheme="http://yoursite.com/categories/c-language/"/>
    
    
      <category term="c++_language" scheme="http://yoursite.com/tags/c-language/"/>
    
  </entry>
  
  <entry>
    <title>C++对象内存分布和编译实现</title>
    <link href="http://yoursite.com/2019/05/25/C++%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%92%8C%E7%BC%96%E8%AF%91%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/05/25/C++对象内存分布和编译实现/</id>
    <published>2019-05-25T09:47:02.000Z</published>
    <updated>2019-10-21T02:40:37.542Z</updated>
    
    <content type="html"><![CDATA[<p>  <strong>类</strong>是创建对象的模板，不占用内存空间，不存在于编译后的可执行文件中；而<strong>对象</strong>是实实在在的数据，需要内存来存储。对象被创建时会在栈区或者堆区分配内存。</p><a id="more"></a><h2 id="C-对象内存分布"><a href="#C-对象内存分布" class="headerlink" title="C++对象内存分布"></a>C++对象内存分布</h2><p>​        直观的认识是，如果创建了 10 个对象，就要分别为这 10 个对象的成员变量和成员函数分配内存，如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-150Z9134434637.png" alt></p><p>​        不同对象的成员变量的值可能不同，需要单独分配内存来存储。但是不同对象的成员函数的代码是一样的，上面的内存模型保存了 10 分相同的代码片段，浪费了不少空间，可以将这些代码片段压缩成一份。</p><p>​        事实上编译器也是这样做的，编译器会将成员变量和成员函数分开存储：<strong>分别为每个对象的成员变量分配内存，但是所有对象都共享同一段函数代码</strong>。</p><p>如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-150Z9135223356.png" alt></p><p>​        成员变量在堆区或栈区分配内存，成员函数在代码区分配内存。</p><p> <strong>【示例】使用 sizeof 获取对象所占内存的大小</strong>： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setname</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setage</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setscore</span><span class="params">(<span class="keyword">float</span> score)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Student::setname(<span class="keyword">char</span> *name)&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::setage(<span class="keyword">int</span> age)&#123;</span><br><span class="line">    m_age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::setscore(<span class="keyword">float</span> score)&#123;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::show()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//在栈上创建对象</span></span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(stu)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//在堆上创建对象</span></span><br><span class="line">    Student *pstu = <span class="keyword">new</span> Student();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(*pstu)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//类的大小</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Student)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure></p><p>​        <code>Student</code> 类包含三个成员变量，它们的类型分别是<code>char *</code>、<code>int</code>、<code>float</code>，都占用 4 个字节的内存，加起来共占用 12 个字节的内存。通过 <code>sizeof</code> 求得的结果等于 12，恰好说明对象所占用的内存仅仅包含了成员变量。</p><p>​        类可以看做是一种复杂的数据类型，也可以使用 <code>sizeof</code> 求得该类型的大小。从运行结果可以看出，在计算类这种类型的大小时，只计算了成员变量的大小，并没有把成员函数也包含在内。</p><p>​        对象的大小只受成员变量的影响，和成员函数没有关系。</p><p>​        假设 <code>stu</code> 的起始地址为 <code>0X1000</code>，那么该对象的内存分布如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-150Z9162122339.png" alt></p><p>​        <code>m_name</code>、<code>m_age</code>、<code>m_score</code> 按照声明的顺序依次排列，和结构体非常类似，也会有内存对齐的问题。</p><p>​        从上节的分析中可以看出，对象的内存中只保留了成员变量，除此之外没有任何其他信息，程序运行时不知道 <code>stu</code> 的类型为  <code>Student</code>，也不知道它还有四个成员函数 <code>setname()</code>、<code>setage()</code>、<code>setscore()</code>、<code>show()</code>，C++  究竟是如何通过对象调用成员函数的呢？ </p><h2 id="C-函数的编译"><a href="#C-函数的编译" class="headerlink" title="C++函数的编译"></a>C++函数的编译</h2><p>​        C++和C语言的编译方式不同。C语言中的函数在编译时名字不变，或者只是简单的加一个下划线<code>_</code>（不同的编译器有不同的实现），例如，<code>func()</code> 编译后为 <code>func()</code> 或<code>_func()</code>。</p><p>​        而C++中的函数在编译时会根据它所在的命名空间、它所属的类、以及它的参数列表（也叫参数签名）等信息进行重新命名，形成一个新的函数名。这个新的函数名只有编译器知道，对用户是不可见的。对函数重命名的过程叫做<strong>名字编码</strong><code>（Name Mangling）</code>，是通过一种特殊的算法来实现的。</p><p>​        <code>Name Mangling</code> 的算法是可逆的，既可以通过现有函数名计算出新函数名，也可以通过新函数名逆向推演出原有函数名。<code>Name  Mangling</code> 可以确保新函数名的唯一性，只要函数所在的命名空间、所属的类、包含的参数列表等有一个不同，最后产生的新函数名也不同。</p><p>​        如果你希望看到经 <code>Name Mangling</code> 产生的新函数名，可以只声明而不定义函数，这样调用函数时就会产生链接错误，从报错信息中就可以看到新函数名。请看下面的代码： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ns&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    display();</span><br><span class="line">    display(<span class="number">1</span>);</span><br><span class="line">    ns::display();</span><br><span class="line">    Demo obj;</span><br><span class="line">    obj.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        该例中声明了四个同名函数，包括两个具有重载关系的全局函数，一个位于命名空间 <code>ns</code>下的函数，以及一个属于类 Demo 的函数。它们都是只声明而未定义的函数。</p><p>​        在 VS 下编译源代码可以看到类似下面的错误信息：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-150Z91ZU0P1.png" alt></p><p>​        小括号中就是经 Name Mangling 产生的新函数名，它们都以<code>?</code>开始，以区别C语言中的<code>_</code>。</p><p>​        上图是 <code>VS2010</code> 产生的错误信息，不同的编译器有不同的 <code>Name Mangling</code> 算法，产生的函数名也不一样。 </p><blockquote><pre><code>__thiscall、cdecl 是函数调用惯例。</code></pre></blockquote><p>​        除了函数，某些变量也会经 <code>Name Mangling</code> 算法产生新名字，这里不再赘述。 </p><h2 id="成员函数的调用"><a href="#成员函数的调用" class="headerlink" title="成员函数的调用"></a>成员函数的调用</h2><p>​        从上图可以看出，成员函数最终被编译成与对象无关的全局函数，如果函数体中没有成员变量，那问题就很简单，不用对函数做任何处理，直接调用即可。</p><p>​        如果成员函数中使用到了成员变量该怎么办呢？成员变量的作用域不是全局，不经任何处理就无法在函数内部访问。</p><p>​        C++规定，编译成员函数时要额外添加一个参数，把当前对象的指针传递进去，通过指针来访问成员变量。</p><p>​        假设 Demo 类有两个 int 型的成员变量，分别是 a 和 b，并且在成员函数 display() 中使用到了，如下所示： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Demo::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        那么编译后的代码类似于： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_function_name</span><span class="params">(Demo * <span class="keyword">const</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过指针p来访问a、b</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p-&gt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p-&gt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        使用<code>obj.display()</code>调用函数时，也会被编译成类似下面的形式： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_function_name(&amp;obj);</span><br></pre></td></tr></table></figure><p>​        这样通过传递对象指针就完成了成员函数和成员变量的关联。这与我们从表明上看到的刚好相反，通过对象调用成员函数时，不是通过对象找函数，而是通过函数找对象。</p><p>​        这一切都是隐式完成的，对程序员来说完全透明，就好像这个额外的参数不存在一样。</p><p>​        最后需要提醒的是，<code>Demo * const p</code>中的 <code>const</code>表示指针不能被修改，p 只能指向当前对象，不能指向其他对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  &lt;strong&gt;类&lt;/strong&gt;是创建对象的模板，不占用内存空间，不存在于编译后的可执行文件中；而&lt;strong&gt;对象&lt;/strong&gt;是实实在在的数据，需要内存来存储。对象被创建时会在栈区或者堆区分配内存。&lt;/p&gt;
    
    </summary>
    
      <category term="c++_language" scheme="http://yoursite.com/categories/c-language/"/>
    
    
      <category term="c++_language" scheme="http://yoursite.com/tags/c-language/"/>
    
  </entry>
  
  <entry>
    <title>c++虚继承和虚基类</title>
    <link href="http://yoursite.com/2019/05/25/c++%E8%99%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/05/25/c++虚继承和虚基类/</id>
    <published>2019-05-25T09:37:02.000Z</published>
    <updated>2019-10-21T02:41:01.805Z</updated>
    
    <content type="html"><![CDATA[<p>  <strong>多继承（Multiple Inheritance）</strong>是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。</p><a id="more"></a><h3 id="多继承（Multiple-Inheritance）"><a href="#多继承（Multiple-Inheritance）" class="headerlink" title="多继承（Multiple Inheritance）"></a>多继承（Multiple Inheritance）</h3><p>​        多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是菱形继承，如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-16101GG114954.jpg" alt></p><p>​        类 A 派生出类 B 和类 C，类 D 继承自类 B 和类 C，这个时候类 A 中的成员变量和成员函数继承到类 D 中变成了两份，一份来自 <code>A--&gt;B--&gt;D</code> 这条路径，另一份来自<code>A--&gt;C--&gt;D</code> 这条路径。</p><p>​        在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：<strong>因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突</strong>。假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 <code>A --&gt;B--&gt;D</code> 这条路径，还是来自 <code>A--&gt;C--&gt;D</code> 这条路径。下面是菱形继承的具体实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//间接基类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接基类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接基类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; m_a = a; &#125;  <span class="comment">//命名冲突</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setb</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123; m_b = b; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setc</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123; m_c = c; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setd</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123; m_d = d; &#125;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​        这段代码实现了上图所示的菱形继承，第 25 行代码试图直接访问成员变量 <code>m_a</code>，结果发生了错误，因为类 B 和类 C 中都有成员变量 <code>m_a</code>（从 A 类继承而来），编译器不知道选用哪一个，所以产生了歧义。</p><p>​        为了消除歧义，我们可以在 m_a 的前面指明它具体来自哪个类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; B::m_a = a; &#125;</span><br></pre></td></tr></table></figure></p><p>​        这样表示使用 B 类的 m_a。当然也可以使用 C 类的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; C::m_a = a; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="虚继承（Virtual-Inheritance）"><a href="#虚继承（Virtual-Inheritance）" class="headerlink" title="虚继承（Virtual Inheritance）"></a>虚继承（Virtual Inheritance）</h3><p>​        为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">在继承方式前面加上 <span class="keyword">virtual</span> 关键字就是虚继承，请看下面的例子：</span><br><span class="line"></span><br><span class="line"><span class="comment">//间接基类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接基类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;  <span class="comment">//虚继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接基类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;  <span class="comment">//虚继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; m_a = a; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setb</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123; m_b = b; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setc</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123; m_c = c; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setd</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123; m_d = d; &#125;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​        这段代码使用虚继承重新实现了上图所示的菱形继承，这样在派生类 D 中就只保留了一份成员变量 m_a，直接访问就不会再有歧义了。</p><p>​        虚继承的<strong>目的是让某个类做出声明，承诺愿意共享它的基类</strong>。其中，这个被共享的基类就称为<strong>虚基类（Virtual Base Class）</strong>，本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p><p>​        现在让我们重新梳理一下本例的继承关系，如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-16101G60332440.jpg" alt></p><p>​        观察这个新的继承体系，我们会发现虚继承的一个不太直观的特征：<strong>必须在虚派生的真实需求出现前就已经完成虚派生的操作</strong>。在上图中，当定义 D 类时才出现了对虚派生的需求，但是如果 B 类和 C 类不是从 A 类虚派生得到的，那么 D 类还是会保留 A 类的两份成员。</p><p>​        换个角度讲，虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。</p><p>​        在实际开发中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题。通常情况下，使用虚继承的类层次是由一个人或者一个项目组一次性设计完成的。对于一个独立开发的类来说，很少需要基类中的某一个类是虚基类，况且新类的开发者也无法改变已经存在的类体系。</p><p>​        C++标准库中的 <code>iostream</code> 类就是一个虚继承的实际应用案例。<code>iostream</code> 从 <code>istream</code> 和 <code>ostream</code> 直接继承而来，而 <code>istream</code> 和 <code>ostream</code> 又都继承自一个共同的名为 <code>base_ios</code> 的类，是典型的菱形继承。此时<code>istream</code> 和 <code>ostream</code> 必须采用虚继承，否则将导致 <code>iostream</code> 类中保留两份 <code>base_ios</code> 类的成员。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-16101GF521302.jpg" alt></p><h3 id="虚基类成员的可见性"><a href="#虚基类成员的可见性" class="headerlink" title="虚基类成员的可见性"></a>虚基类成员的可见性</h3><p>​        因为在虚继承的最终派生类中只保留了一份虚基类的成员，所以该成员可以被直接访问，不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，那么仍然可以直接访问这个被覆盖的成员。但是如果该成员被两条或多条路径覆盖了，那就不能直接访问了，此时必须指明该成员属于哪个类。</p><p>​        以图2中的菱形继承为例，假设 B 定义了一个名为 x 的成员变量，当我们在 D 中直接访问 x 时，会有三种可能性：</p><blockquote><p>如果 B 和 C 中都没有 x 的定义，那么 x 将被解析为 B 的成员，此时不存在二义性。<br>如果 B 或 C 其中的一个类定义了 x，也不会有二义性，派生类的 x 比虚基类的 x 优先级更高。<br>如果 B 和 C 中都定义了 x，那么直接访问 x 将产生二义性问题。</p></blockquote><p>​        可以看到，使用多继承经常会出现二义性问题，必须十分小心。上面的例子是简单的，如果继承的层次再多一些，关系更复杂一些，程序员就很容易陷人迷魂阵，程序的编写、调试和维护工作都会变得更加困难，因此我不提倡在程序中使用多继承，只有在比较简单和不易出现二义性的情况或实在必要时才使用多继承，能用单一继承解决的问题就不要使用多继承。也正是由于这个原因，C++ 之后的很多面向对象的编程语言，例如 Java、C#、PHP 等，都不支持多继承。</p><h3 id="虚继承时的构造函数"><a href="#虚继承时的构造函数" class="headerlink" title="虚继承时的构造函数"></a>虚继承时的构造函数</h3><p>​        在虚继承中，虚基类是由最终的派生类初始化的，换句话说，<strong>最终派生类的构造函数必须要调用虚基类的构造函数。对最终的派生类来说，虚基类是间接基类，而不是直接基类</strong>。这跟普通继承不同，在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。</p><pre><code>下面我们以菱形继承为例来演示构造函数的调用： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚基类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a): m_a(a)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接派生类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">B::B(<span class="keyword">int</span> a, <span class="keyword">int</span> b): A(a), m_b(b)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> B::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="string">", m_b="</span>&lt;&lt;m_b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接派生类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C(<span class="keyword">int</span> a, <span class="keyword">int</span> c);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line">C::C(<span class="keyword">int</span> a, <span class="keyword">int</span> c): A(a), m_c(c)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> C::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="string">", m_c="</span>&lt;&lt;m_c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//间接派生类D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line">D::D(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d): A(a), B(<span class="number">90</span>, b), C(<span class="number">100</span>, c), m_d(d)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> D::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="string">", m_b="</span>&lt;&lt;m_b&lt;&lt;<span class="string">", m_c="</span>&lt;&lt;m_c&lt;&lt;<span class="string">", m_d="</span>&lt;&lt;m_d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    b.display();</span><br><span class="line">   </span><br><span class="line">    <span class="function">C <span class="title">c</span><span class="params">(<span class="number">30</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    c.display();</span><br><span class="line"></span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>)</span></span>;</span><br><span class="line">    d.display();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m_a=<span class="number">10</span>, m_b=<span class="number">20</span></span><br><span class="line">m_a=<span class="number">30</span>, m_c=<span class="number">40</span></span><br><span class="line">m_a=<span class="number">50</span>, m_b=<span class="number">60</span>, m_c=<span class="number">70</span>, m_d=<span class="number">80</span></span><br></pre></td></tr></table></figure></p><p>​        请注意第 50 行代码，在最终派生类 D 的构造函数中，除了调用 B 和 C 的构造函数，还调用了 A 的构造函数，这说明 D  不但要负责初始化直接基类 B 和 C，还要负责初始化间接基类  A。<strong>而在以往的普通继承中，派生类的构造函数只负责初始化它的直接基类，再由直接基类的构造函数初始化间接基类，用户尝试调用间接基类的构造函数将导致错误</strong>。</p><p>​        现在采用了虚继承，虚基类 A 在最终派生类 D 中只保留了一份成员变量 m_a，如果由 B 和 C 初始化 m_a，那么 B 和 C 在调用 A 的构造函数时很有可能给出不同的实参，这个时候编译器就会犯迷糊，不知道使用哪个实参初始化 m_a。</p><p>​        为了避免出现这种矛盾的情况，C++ 干脆规定必须由最终的派生类 D 来初始化虚基类 A，直接派生类 B 和 C 对 A  的构造函数的调用是无效的。在第 50 行代码中，调用 B 的构造函数时试图将 m_a 初始化为 90，调用 C 的构造函数时试图将 m_a  初始化为 100，但是输出结果有力地证明了这些都是无效的，m_a 最终被初始化为 50，这正是在 D 中直接调用 A 的构造函数的结果。</p><p>​        另外需要关注的是构造函数的执行顺序。虚继承时构造函数的执行顺序与普通继承时不同：<strong>在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何，编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数；而对于普通继承，就是按照构造函数出现的顺序依次调用的</strong>。</p><pre><code>修改本例中第 50 行代码，改变构造函数出现的顺序： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D::D(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d): B(<span class="number">90</span>, b), C(<span class="number">100</span>, c), A(a), m_d(d)&#123; &#125;</span><br></pre></td></tr></table></figure><p>​        虽然我们将 A() 放在了最后，但是编译器仍然会先调用 A()，然后再调用 B()、C()，因为 A() 是虚基类的构造函数，比其他构造函数优先级高。如果没有使用虚继承的话，那么编译器将按照出现的顺序依次调用 B()、C()、A()。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  &lt;strong&gt;多继承（Multiple Inheritance）&lt;/strong&gt;是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。&lt;/p&gt;
    
    </summary>
    
      <category term="c++_language" scheme="http://yoursite.com/categories/c-language/"/>
    
    
      <category term="c++_language" scheme="http://yoursite.com/tags/c-language/"/>
    
  </entry>
  
  <entry>
    <title>c++拷贝控制操作</title>
    <link href="http://yoursite.com/2019/05/25/c++%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/05/25/c++拷贝控制操作/</id>
    <published>2019-05-25T09:35:02.000Z</published>
    <updated>2019-10-21T02:40:51.068Z</updated>
    
    <content type="html"><![CDATA[<p>  当定义一个类时，我们显式地或隐式地指定了此类型的对象在拷贝、赋值和销毁时做什么。一个类通过定义三种特殊的成员函数来控制这些操作，分别是拷贝构造函数、赋值运算符和析构函数。<br>  拷贝构造函数定义了当用同类型的另一个对象初始化新对象时做什么，赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么，析构函数定义了此类型的对象销毁时做什么。我们将这些操作称为拷贝控制操作。 </p><a id="more"></a><h2 id="拷贝控制操作"><a href="#拷贝控制操作" class="headerlink" title="拷贝控制操作"></a>拷贝控制操作</h2><blockquote><pre><code>由于拷贝控制操作是由三个特殊的成员函数来完成的，所以我们称此为“C++三法则”。在较新的 C++11  标准中，为了支持移动语义，又增加了移动构造函数和移动赋值运算符，这样共有五个特殊的成员函数，所以又称为“C++五法则”。也就是说，“三法则”是针对较旧的  C++89 标准说的，“五法则”是针对较新的 C++11 标准说的。为了统一称呼，后来人们干把它叫做“C++ 三/五法则”。</code></pre></blockquote><p>​        如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义默认的操作，因此很多类会忽略这些拷贝控制操作。但是，对于一些持有其他资源（例如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等）的类来说，依赖这些默认的操作会导致灾难，我们必须显式的定义这些操作。</p><p>​        C++ 并不要求我们定义所有的这些操作，你可以只定义其中的一个或两个。但是，这些操作通常应该被看做一个整体，只需要定义其中一个操作，而不需要定义其他操作的情况很少见。 </p><h3 id="需要析构函数的类也需要拷贝和赋值操作"><a href="#需要析构函数的类也需要拷贝和赋值操作" class="headerlink" title="需要析构函数的类也需要拷贝和赋值操作"></a>需要析构函数的类也需要拷贝和赋值操作</h3><p>​        当我们决定是否要为一个类显式地定义拷贝构造函数和赋值运算符时，一个基本原则是首先确定这个类是否需要一个析构函数。通常，对析构函数的需求要比拷贝构造函数和赋值运算符的需求更加明显。如果一个类需要定义析构函数，那么几乎可以肯定这个类也需要一个拷贝构造函数和一个赋值运算符。</p><p>​        我们在前面几节中使用过的 Array 类就是一个典型的例子。这个类在构造函数中动态地分配了一块内存，并用一个成员变量（指针变量）指向它，默认的析构函数不会释放这块内存，所以我们需要显式地定义一个析构函数来释放内存。</p><p>​        「应该怎么做」可能还是有点不清晰，但基本原则告诉我们，Array 类也需要一个拷贝构造函数和一个赋值运算符。</p><p>​        如果我们为 Array 定义了一个析构函数，但却使用默认的拷贝构造函数和赋值运算符，那么将导致不同对象之间相互干扰，修改一个对象的数据会影响另外的对象。此外还可能会导致内存操作错误，请看下面的代码： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Array <span class="title">func</span><span class="params">(Array arr)</span></span>&#123;  <span class="comment">//按值传递，将发生拷贝</span></span><br><span class="line">    Array ret = arr;  <span class="comment">//发生拷贝</span></span><br><span class="line">    <span class="keyword">return</span> ret;  <span class="comment">//ret和arr将被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        当 <code>func()</code>返回时，<code>arr</code> 和 <code>ret `</code>都会被销毁，在两个对象上都会调用析构函数，此析构函数会 <code>free()</code>掉 m_p <code>成员所指向的动态内存。但是，这两个对象的 m_p 成员指向的是同一块内存，所以该内存会被</code>free()`  两次，这显然是一个错误，将要发生什么是未知的。</p><p>​         此外，<code>func()</code>的调用者还会继续使用传递给<code>func()</code>的对象： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Array <span class="title">arr1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">func(arr1);  <span class="comment">//当 func() 调用结束时，arr1.m_p 指向的内存被释放</span></span><br><span class="line">Array arr2 = arr1;  <span class="comment">//现在 arr2 和 arr1 都指向无效内存</span></span><br></pre></td></tr></table></figure><p>​         <code>arr2</code>（以及 <code>arr1</code>）指向的内存不再有效，在<code>arr</code>（以及 <code>ret</code>）被销毁时系统已经归还给操作系统了。</p><p>​        总之，如果一个类需要定义析构函数，那么几乎可以肯定它也需要定义拷贝构造函数和赋值运算符。 </p><h3 id="需要拷贝操作的类也需要赋值操作，反之亦然"><a href="#需要拷贝操作的类也需要赋值操作，反之亦然" class="headerlink" title="需要拷贝操作的类也需要赋值操作，反之亦然"></a>需要拷贝操作的类也需要赋值操作，反之亦然</h3><p>​        虽然很多类需要定义所有（或是不需要定义任何）拷贝控制成员，但某些类所要完成的工作，只需要拷贝或者赋值操作，不需要析构操作。</p><p>​        作为一个例子，考虑一个类为每个对象分配一个独有的、唯一的编号。这个类除了需要一个拷贝构造函数为每个新创建的对象生成一个新的编号，还需要一个赋值运算符来避免将一个对象的编号赋值给另外一个对象。但是，这个类并不需要析构函数。</p><p>​        这个例子引出了第二个基本原则：如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个赋值运算符；反之亦然。然而，无论需要拷贝构造函数还是需要复制运算符，都不必然意味着也需要析构函数。</p><p>​        在 C/C++ 中，不同的数据类型之间可以相互转换。无需用户指明如何转换的称为自动类型转换（隐式类型转换），需要用户显式地指明如何转换的称为强制类型转换。</p><p>自动类型转换示例： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line">a = <span class="number">7.5</span> + a;</span><br></pre></td></tr></table></figure><p>​        编译器对 7.5 是作为 double 类型处理的，在求解表达式时，先将 a 转换为 double 类型，然后与 7.5 相加，得到和为  13.5。在向整型变量 a 赋值时，将 13.5 转换为整数 13，然后赋给  a。整个过程中，我们并没有告诉编译器如何去做，编译器使用内置的规则完成数据类型的转换。</p><p>​        强制类型转换示例： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;n;</span><br><span class="line"><span class="keyword">float</span> *p2 = (<span class="keyword">float</span>*)p1;</span><br></pre></td></tr></table></figure><p>​        <code>p1</code> 是<code>int *</code>类型，它指向的内存里面保存的是整数，<code>p2</code> 是<code>float *</code>类型，将 <code>p1</code> 赋值给 <code>p2</code>后，<code>p2</code>  也指向了这块内存，并把这块内存中的数据作为小数处理。我们知道，整数和小数的存储格式大相径庭，将整数作为小数处理非常荒诞，可能会引发莫名其妙的错误，所以编译器默认不允许将 <code>p1</code>赋值给<code>p2</code>。但是，使用强制类型转换后，编译器就认为我们知道这种风险的存在，并进行了适当的权衡，所以最终还是允许了这种行为。 </p><p>​        不管是自动类型转换还是强制类型转换，前提必须是编译器知道如何转换，例如，将小数转换为整数会抹掉小数点后面的数字，将<code>int *</code>转换为<code>float *</code>只是简单地复制指针的值，这些规则都是编译器内置的，我们并没有告诉编译器。</p><p>​        换句话说，如果编译器不知道转换规则就不能转换，使用强制类型也无用，请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);  <span class="comment">//友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">10.0</span>, <span class="number">20.0</span>)</span></span>;</span><br><span class="line">    a = (Complex)<span class="number">25.5</span>;  <span class="comment">//错误，转换失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        25.5 是实数，a 是复数，将 25.5 赋值给 a 后，我们期望 a 的实部变为 25.5，而虚部为 0。但是，编译器并不知道这个转换规则，这超出了编译器的处理能力，所以转换失败，即使加上强制类型转换也无用。</p><p>​        幸运的是，C++ 允许我们自定义类型转换规则，用户可以将其它类型转换为当前类类型，也可以将当前类类型转换为其它类型。这种自定义的类型转换规则只能以类的成员函数的形式出现，换句话说，这种转换规则只适用于类。</p><p>​        本节我们先讲解如何将其它类型转换为当前类类型，下节再讲解如何将当前类类型转换为其它类型。</p><h2 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h2><p>​        将其它类型转换为当前类类型需要借助转换构造函数（Conversion constructor）。</p><p>​        转换构造函数也是一种构造函数，它遵循构造函数的一般规则。转换构造函数只有一个参数。</p><p>​        仍然以 Complex 类为例，我们为它添加转换构造函数： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real): m_real(real), m_imag(<span class="number">0.0</span>)&#123; &#125;  <span class="comment">//转换构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);  <span class="comment">//友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">10.0</span>, <span class="number">20.0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    a = <span class="number">25.5</span>;  <span class="comment">//调用转换构造函数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>运行结果：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="number">20</span>i</span><br><span class="line"></span><br><span class="line"><span class="number">25.5</span> + <span class="number">0</span>i</span><br></pre></td></tr></table></figure><p>​        <code>Complex(double real);</code>就是转换构造函数，它的作用是将 double 类型的参数 real 转换成 Complex 类的对象，并将 real 作为复数的实部，将 0 作为复数的虚部。这样一来，<code>a = 25.5;</code>整体上的效果相当于：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.Complex(<span class="number">25.5</span>);</span><br></pre></td></tr></table></figure></p><p>​        将赋值的过程转换成了函数调用的过程。</p><p>​        在进行数学运算、赋值、拷贝等操作时，如果遇到类型不兼容、需要将 double 类型转换为 Complex 类型时，编译器会检索当前的类是否定义了转换构造函数，如果没有定义的话就转换失败，如果定义了的话就调用转换构造函数。</p><p>​        转换构造函数也是构造函数的一种，它除了可以用来将其它类型转换为当前类类型，还可以用来初始化对象，这是构造函数本来的意义。下面创建对象的方式是正确的： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">26.4</span>)</span></span>;  <span class="comment">//创建具名对象</span></span><br><span class="line">Complex c2 = <span class="number">240.3</span>;  <span class="comment">//以拷贝的方式初始化对象</span></span><br><span class="line">Complex(<span class="number">15.9</span>);  <span class="comment">//创建匿名对象</span></span><br><span class="line">c1 = Complex(<span class="number">46.9</span>);  <span class="comment">//创建一个匿名对象并将它赋值给 c1</span></span><br></pre></td></tr></table></figure><p>​        在以拷贝的方式初始化对象时，编译器先调用转换构造函数，将 240.3 转换为 Complex 类型（创建一个 Complex 类的匿名对象），然后再拷贝给 <code>c2</code>。</p><p>​        如果已经对<code>+</code>运算符进行了重载，使之能进行两个 Complex 类对象的相加，那么下面的语句也是正确的： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">15.6</span>, <span class="number">89.9</span>)</span></span>;</span><br><span class="line">Complex c2;</span><br><span class="line">c2 = c1 + <span class="number">29.6</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;c2&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>​        在进行加法运算符时，编译器先将 29.6 转换为 Complex 类型（创建一个 Complex 类的匿名对象）再相加。</p><p>​        需要注意的是，为了获得目标类型，编译器会“不择手段”，会综合使用内置的转换规则和用户自定义的转换规则，并且会进行多级类型转换，例如： </p><ul><li>编译器会根据内置规则先将 int 转换为 double，再根据用户自定义规则将 double 转换为 <code>Complex（int --&gt; double --&gt; Complex）</code>；</li><li>编译器会根据内置规则先将 char 转换为 int，再将 int 转换为 double，最后根据用户自定义规则将 double 转换为 <code>Complex（char --&gt; int --&gt; double --&gt; Complex）</code>。</li></ul><p>​        从本例看，只要一个类型能转换为 double 类型，就能转换为 Complex 类型。请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Complex c1 = <span class="number">100</span>;  <span class="comment">//int --&gt; double --&gt; Complex</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c1 = <span class="string">'A'</span>;  <span class="comment">//char --&gt; int --&gt; double --&gt; Complex</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c1 = <span class="literal">true</span>;  <span class="comment">//bool --&gt; int --&gt; double --&gt; Complex</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">25.8</span>, <span class="number">0.7</span>)</span></span>;</span><br><span class="line">    <span class="comment">//假设已经重载了+运算符</span></span><br><span class="line">    c1 = c2 + <span class="string">'H'</span> + <span class="literal">true</span> + <span class="number">15</span>;  <span class="comment">//将char、bool、int都转换为Complex类型再运算</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> + <span class="number">0</span>i</span><br><span class="line"><span class="number">65</span> + <span class="number">0</span>i</span><br><span class="line"><span class="number">1</span> + <span class="number">0</span>i</span><br><span class="line"><span class="number">113.8</span> + <span class="number">0.7</span>i</span><br></pre></td></tr></table></figure></p><h3 id="再谈构造函数"><a href="#再谈构造函数" class="headerlink" title="再谈构造函数"></a>再谈构造函数</h3><p>​        构造函数的本意是在创建对象的时候初始化对象，编译器会根据传递的实参来匹配不同的（重载的）构造函数。回顾一下以前的章节，到目前为止我们已经学习了以下几种构造函数。</p><p>​    1) 默认构造函数。就是编译器自动生成的构造函数。以 Complex 类为例，它的原型为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex();  <span class="comment">//没有参数</span></span><br></pre></td></tr></table></figure></p><p>​    2) 普通构造函数。就是用户自定义的构造函数。以 Complex 类为例，它的原型为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag);  <span class="comment">//两个参数</span></span><br></pre></td></tr></table></figure></p><p>​    3) 拷贝构造函数。在以拷贝的方式初始化对象时调用。以 Complex 类为例，它的原型为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex(<span class="keyword">const</span> Complex &amp;c);</span><br></pre></td></tr></table></figure></p><p>​    4) 转换构造函数。将其它类型转换为当前类类型时调用。以 Complex 为例，它的原型为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex(<span class="keyword">double</span> real);</span><br></pre></td></tr></table></figure></p><p>​        不管哪一种构造函数，都能够用来初始化对象，这是构造函数的本意。假设 Complex 类定义了以上所有的构造函数，那么下面创建对象的方式都是正确的： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">()</span></span>;  <span class="comment">//调用Complex()</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">//调用Complex(double real, double imag)</span></span><br><span class="line"><span class="function">Complex <span class="title">c3</span><span class="params">(c2)</span></span>;  <span class="comment">//调用Complex(const Complex &amp;c)</span></span><br><span class="line"><span class="function">Complex <span class="title">c4</span><span class="params">(<span class="number">25.7</span>)</span></span>;  <span class="comment">//调用Complex(double real)</span></span><br></pre></td></tr></table></figure><p>​        这些代码都体现了构造函数的本意——在创建对象时初始化对象。</p><p>​        除了在创建对象时初始化对象，其他情况下也会调用构造函数，例如，以拷贝的的方式初始化对象时会调用拷贝构造函数，将其它类型转换为当前类类型时会调用转换构造函数。这些在其他情况下调用的构造函数，就成了特殊的构造函数了。特殊的构造函数并不一定能体现出构造函数的本意。 </p><h3 id="对-Complex-类的进一步精简"><a href="#对-Complex-类的进一步精简" class="headerlink" title="对 Complex 类的进一步精简"></a>对 Complex 类的进一步精简</h3><p>​        上面的 Complex 类中我们定义了三个构造函数，其中包括两个普通的构造函数和一个转换构造函数。其实，借助函数的默认参数，我们可以将这三个构造函数简化为一个，请看下面的代码： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);  <span class="comment">//友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">10.0</span>, <span class="number">20.0</span>)</span></span>;  <span class="comment">//向构造函数传递 2 个实参，不使用默认参数</span></span><br><span class="line">    <span class="function">Complex <span class="title">b</span><span class="params">(<span class="number">89.5</span>)</span></span>;  <span class="comment">//向构造函数传递 1 个实参，使用 1 个默认参数</span></span><br><span class="line">    Complex c;  <span class="comment">//不向构造函数传递实参，使用全部默认参数</span></span><br><span class="line">    a = <span class="number">25.5</span>;  <span class="comment">//调用转换构造函数（向构造函数传递 1 个实参，使用 1 个默认参数）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        精简后的构造函数包含了两个默认参数，在调用它时可以省略部分或者全部实参，也就是可以向它传递 0 个、1 个、2 个实参。转换构造函数就是包含了一个参数的构造函数，恰好能够和其他两个普通的构造函数“融合”在一起。</p><h2 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h2><p>​        转换构造函数能够将其它类型转换为当前类类型（例如将 double 类型转换为 Complex 类型），但是不能反过来将当前类类型转换为其它类型（例如将 Complex 类型转换为 double 类型）。</p><p>​        C++ 提供了类型转换函数（Type conversion function）来解决这个问题。类型转换函数的作用就是将当前类类型转换为其它类型，它只能以成员函数的形式出现，也就是只能出现在类中。</p><p>​        类型转换函数的语法格式为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​        operator 是 C++ 关键字，type 是要转换的目标类型，data 是要返回的 type 类型的数据。</p><p>​        因为要转换的目标类型是 type，所以返回值 data 也必须是 type 类型。既然已经知道了要返回 type 类型的数据，所以没有必要再像普通函数一样明确地给出返回值类型。这样做导致的结果是：类型转换函数看起来没有返回值类型，其实是隐式地指明了返回值类型。</p><p>​        类型转换函数也没有参数，因为要将当前类的对象转换为其它类型，所以参数不言而喻。实际上编译器会把当前对象的地址赋值给 this 指针，这样在函数体内就可以操作当前对象了。</p><p>​        【示例】为 Complex 类添加类型转换函数，使得 Complex 类型能够转换为 double 类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//类型转换函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载+运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real + c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag + c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">24.6</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> f = c1;  <span class="comment">//相当于 double f = Complex::operator double(&amp;c1);</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"f = "</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    f = <span class="number">12.5</span> + c1 + <span class="number">6</span>;  <span class="comment">//相当于 f = 12.5 + Complex::operator double(&amp;c1) + 6;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"f = "</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n = Complex(<span class="number">43.2</span>, <span class="number">9.3</span>);  <span class="comment">//先转换为 double，再转换为 int</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"n = "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​        运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="number">24.6</span></span><br><span class="line">f = <span class="number">43.1</span></span><br><span class="line">n = <span class="number">43</span></span><br></pre></td></tr></table></figure></p><p>​        本例中，类型转换函数非常简单，就是返回成员变量 m_real 的值，所以建议写成 inline 的形式。</p><p>​        类型转换函数和运算符的重载非常相似，都使用 operator 关键字，因此也把类型转换函数称为类型转换运算符。</p><h3 id="关于类型转换函数的说明"><a href="#关于类型转换函数的说明" class="headerlink" title="关于类型转换函数的说明"></a>关于类型转换函数的说明</h3><p>​    1) type 可以是内置类型、类类型以及由 typedef 定义的类型别名，任何可作为函数返回类型的类型（void 除外）都能够被支持。一般而言，不允许转换为数组或函数类型，转换为指针类型或引用类型是可以的。</p><p>​    2) 类型转换函数一般不会更改被转换的对象，所以通常被定义为 <code>const</code> 成员。</p><p>​    3) 类型转换函数可以被继承，可以是虚函数。</p><p>​    4) 一个类虽然可以有多个类型转换函数（类似于函数重载），但是如果多个类型转换函数要转换的目标类型本身又可以相互转换（类型相近），那么有时候就会产生二义性。以 Complex 类为例，假设它有两个类型转换函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//转换为double类型</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">int</span>)m_real; &#125;  <span class="comment">//转换为int类型</span></span><br></pre></td></tr></table></figure></p><p>​    那么下面的写法就会引发二义性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">24.6</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">12.5</span> + c1;</span><br></pre></td></tr></table></figure></p><p>​        编译器可以调用 operator double() 将 <code>c1</code>转换为 double 类型，也可以调用 operator int() 将<code>c1</code>转换为 int 类型，这两种类型都可以跟 12.5 进行加法运算，并且从 Complex 转换为 double 与从 Complex 转化为 int 是平级的，没有谁的优先级更高，所以这个时候编译器就不知道该调用哪个函数了，干脆抛出一个二义性错误，让用户解决。</p><h2 id="转换构造函数和类型转换函数异同"><a href="#转换构造函数和类型转换函数异同" class="headerlink" title="转换构造函数和类型转换函数异同"></a>转换构造函数和类型转换函数异同</h2><p>​        转换构造函数和类型转换函数的作用是相反的：转换构造函数会将其它类型转换为当前类类型，类型转换函数会将当前类类型转换为其它类型。如果没有这两个函数，<code>Complex</code> 类和 <code>int</code>、<code>double</code>、<code>bool</code>等基本类型的四则运算、逻辑运算都将变得非常复杂，要编写大量的运算符重载函数。</p><p>​        但是，如果一个类同时存在这两个函数，就有可能产生二义性。下面以 Complex 类为例来演示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;  <span class="comment">//包含了转换构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//类型转换函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载+运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real + c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag + c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">24.6</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> f = c1;  <span class="comment">//①正确，调用类型转换函数</span></span><br><span class="line">    c1 = <span class="number">78.4</span>;  <span class="comment">//②正确，调用转换构造函数</span></span><br><span class="line">    f = <span class="number">12.5</span> + c1;  <span class="comment">//③错误，产生二义性</span></span><br><span class="line">    Complex c2 = c1 + <span class="number">46.7</span>;  <span class="comment">//④错误，产生二义性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    ①和②是正确的，相信大家很容易理解。</p><p>​    对于③，进行加法运算时，有两种转换方案：</p><ul><li>第一种方案是先将 12.5 转换为 Complex 类型再运算，这样得到的结果也是 Complex 类型，再调用类型转换函数就可以赋值给 f 了。</li><li>第二种方案是先将 c1 转换为 double 类型再运算，这样得到的结果也是 double 类型，可以直接赋值给 f。</li></ul><p>​      很多人会认为，既然=左边是 double 类型，很显然应该选择第二种方案，这样才符合“常理”。其实不然，编译器不会根据=左边的数据类型来选择转换方案，编译器只关注12.5 + c1这个表达式本身，站在这个角度考虑，上面的两种转换方案都可以，编译器不知道选择哪一种，所以会抛出二义性错误，让用户自己去解决。</p><p>​        当然，你也可以认为编译器不够智能，没有足够强大的上下文（周边环境）推导能力。反过来说，即使我们假设编译器会根据=左边的数据类型来选择解决方案，那仍然会存在二义性问题，下面就是一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">24.6</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;c1 + <span class="number">46.7</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>​        该语句没有将<code>c1 + 46.7</code>的结果赋值给其他变量，而是直接输出，这种情况应该将<code>c1</code> 转换成 double 类型呢，还是应该将<code>46.7</code>转换成 <code>Complex</code> 类型呢？很明显都可以，因为转换构造函数和类型转换函数是平级的，没有谁的优先级更高，所以该语句也会产生二义性错误。</p><p>​        解决二义性问题的办法也很简单粗暴，要么只使用转换构造函数，要么只使用类型转换函数。实践证明，用户对转换构造函数的需求往往更加强烈，这样能增加编码的灵活性，例如，可以将一个字符串字面量或者一个字符数组直接赋值给 string 类的对象，可以将一个<code>int</code>、<code>double</code>、<code>bool</code> 等基本类型的数据直接赋值给 Complex 类的对象。</p><p>​        那么，如果我们想把当前类类型转换为其它类型怎么办呢？很简单，增加一个普通的成员函数即可，例如，string 类使用<code>c_str()</code>函数转换为 C 风格的字符串，complex 类使用 real() 和<code>imag()</code>函数来获取复数的实部和虚部。</p><p>​        complex 是 C++ 标准库中的复数类，c是小写的，使用时需要引入complex头文件。Complex 是我们为了教学而自定义的复数类，C是大写的，Complex 类尽量模拟 complex 类。</p><p>​        下面是重新编写的 Complex 类，该类只使用了转换构造函数，没有使用类型转换函数，取而代之的是 <code>real()</code> 和<code>imag()</code>两个普通成员函数。一个实用的 <code>Complex</code> 类能够进行四则运算和关系运算，需要重载 +、-、<em>、/、+=、-=、</em>=、/=、==、!= 这些运算符，不过作为教学演示，这里仅仅重载了 +、+=、==、!= 运算符，其它运算符的重载与此类似。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//构造函数</span></span><br><span class="line">    Complex(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;  <span class="comment">//包含了转换构造函数</span></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//运算符重载</span></span><br><span class="line">    <span class="comment">//以全局函数的形式重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);</span><br><span class="line">    <span class="keyword">friend</span> istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;in, Complex &amp;c);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="comment">//以成员函数的形式重载</span></span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_real; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_imag; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载&lt;&lt;运算符</span></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;in, Complex &amp;c)&#123;</span><br><span class="line">    in &gt;&gt; c.m_real &gt;&gt; c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载+运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real + c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag + c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载+=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real += c.m_real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag += c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载==运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">if</span>( c1.m_real == c2.m_real &amp;&amp; c1.m_imag == c2.m_imag )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载!=运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">if</span>( c1.m_real != c2.m_real || c1.m_imag != c2.m_imag )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">12</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 = "</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先调用转换构造函数将 22.8 转换为 Complex 类型，再调用重载过的 + 运算符</span></span><br><span class="line">    Complex c2 = c1 + <span class="number">22.8</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c2 = "</span>&lt;&lt;c2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    Complex c3 = <span class="number">8.3</span> + c1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c3 = "</span>&lt;&lt;c3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先调用转换构造函数将 73 转换为 Complex 类型，再调用重载过的 += 运算符</span></span><br><span class="line">    <span class="function">Complex <span class="title">c4</span><span class="params">(<span class="number">4</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">    c4 += <span class="number">73</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c4 = "</span>&lt;&lt;c4&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用重载过的 += 运算符</span></span><br><span class="line">    <span class="function">Complex <span class="title">c5</span><span class="params">(<span class="number">14.6</span>, <span class="number">26.2</span>)</span></span>;</span><br><span class="line">    c5 += c1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c5 = "</span>&lt;&lt;c5&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//调用重载过的 == 运算符</span></span><br><span class="line">    <span class="keyword">if</span>(c1 == c2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 == c2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 != c2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//先调用转换构造函数将 77 转换为 Complex 类型，再调用重载过的 != 运算符</span></span><br><span class="line">    <span class="keyword">if</span>(c4 != <span class="number">77</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c4 != 77"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c4 == 77"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将 Complex 转换为 double，没有调用类型转换函数，而是调用了 real() 这个普通的成员函数</span></span><br><span class="line">    <span class="keyword">double</span> f = c5.real();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"f = "</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c1 = <span class="number">12</span> + <span class="number">60</span>i</span><br><span class="line">c2 = <span class="number">34.8</span> + <span class="number">60</span>i</span><br><span class="line">c3 = <span class="number">20.3</span> + <span class="number">60</span>i</span><br><span class="line">c4 = <span class="number">77</span> + <span class="number">19</span>i</span><br><span class="line">c5 = <span class="number">26.6</span> + <span class="number">86.2</span>i</span><br><span class="line">c1 != c2</span><br><span class="line">c4 != <span class="number">77</span></span><br><span class="line">f = <span class="number">26.6</span></span><br></pre></td></tr></table></figure><h2 id="类型转换的本质"><a href="#类型转换的本质" class="headerlink" title="类型转换的本质"></a>类型转换的本质</h2><p>​        在 C/C++ 中，不同的数据类型之间可以相互转换：无需用户指明如何转换的称为自动类型转换（隐式类型转换），需要用户显式地指明如何转换的称为强制类型转换（显式类型转换）。</p><p>​        隐式类型转换利用的是编译器内置的转换规则，或者用户自定义的转换构造函数以及类型转换函数（这些都可以认为是已知的转换规则），例如从 int 到 double、从派生类到基类、从<code>type *</code>到<code>void *</code>、从 double 到 Complex 等。</p><p>​        <code>type *</code>是一个具体类型的指针，例如int <em>、double </em>、Student <em>等，它们都可以直接赋值给void </em>指针。而反过来是不行的，必须使用强制类型转换才能将<code>void *</code>转换为<code>type *</code>，例如，<code>malloc()</code> 分配内存后返回的就是一个void *指针，我们必须进行强制类型转换后才能赋值给指针变量。</p><p>​        当隐式转换不能完成类型转换工作时，我们就必须使用强制类型转换了。强制类型转换的语法也很简单，只需要在表达式的前面增加新类型的名称，格式为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(new_type) expression</span><br></pre></td></tr></table></figure></p><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>​        我们知道，数据是放在内存中的，变量（以及指针、引用）是给这块内存起的名字，有了变量就可以找到并使用这份数据。但问题是，该如何使用呢？</p><p>​        诸如数字、文字、符号、图形、音频、视频等数据都是以二进制形式存储在内存中的，它们并没有本质上的区别，那么，00010000 该理解为数字 16 呢，还是图像中某个像素的颜色呢，还是要发出某个声音呢？如果没有特别指明，我们并不知道。也就是说，内存中的数据有多种解释方式，使用之前必须要确定。这种「确定数据的解释方式」的工作就是由数据类型（Data Type）来完成的。例如int a;表明，a 这份数据是整数，不能理解为像素、声音、视频等。</p><p>​        顾名思义，数据类型用来说明数据的类型，确定了数据的解释方式，让计算机和程序员不会产生歧义。C/C++ 支持多种数据类型，包括内置类型（例如 int、double、bool 等）和自定义类型（结构体类型和类类型）。</p><p>​        所谓数据类型转换，就是对数据所占用的二进制位做出重新解释。如果有必要，在重新解释的同时还会修改数据，改变它的二进制位。对于隐式类型转换，编译器可以根据已知的转换规则来决定是否需要修改数据的二进制位；而对于强制类型转换，由于没有对应的转换规则，所以能做的事情仅仅是重新解释数据的二进制位，但无法对数据的二进制位做出修正。这就是隐式类型转换和强制类型转换最根本的区别。</p><p>​        这里说的修改数据并不是修改原有的数据，而是修改它的副本（先将原有数据拷贝到另外一个地方再修改）。</p><p>​        修改数据的二进制位非常重要，它能把转换后的数据调整到正确的值，所以这种修改时常会发生，例如：<br>​    1) 整数和浮点数在内存中的存储形式大相径庭，将浮点数 f 赋值给整数 i 时，不能原样拷贝 f 的二进制位，也不能截取部分二进制位，必须先将 f 的二进制位读取出来，以浮点数的形式呈现，然后直接截掉小数部分，把剩下的整数部分再转换成二进制形式，拷贝到 i 所在的内存中。</p><p>​    2) short 一般占用两个字节，int 一般占用四个字节，将 short 类型的 s 赋值给 int 类型的 i 时，如果仅仅是将 s 的二进制位拷贝给 i，那么 i 最后的两个字节会原样保留，这样会导致赋值结束后 i 的值并不等于 s 的值，所以这样做是错误的。正确的做法是，先给 s 添加 16 个二进制位（两个字节）并全部置为 0，然后再拷贝给 i 所在的内存。</p><p>​    3) 当存在多重继承时，如果把派生类指针 pd 赋值给基类指针 pb，就必须考虑基类子对象在派生类对象中的偏移，偏移不为 0 时就要调整 pd 的值，让它加上或减去偏移量，这样赋值后才能让 pb 恰好指向基类子对象。更多细节请猛击《将派生类指针赋值给基类指针时到底发生了什么》。</p><p>​    4) Complex 类型占用 16 个字节，double 类型占用 8 个字节，将 double 类型的数据赋值给 Complex 类型的变量（对象）时，必须调用转换构造函数，否则剩下的 8 个字节就不知道如何填充了。</p><p>​        以上这些都是隐式类型转换，它对数据的调整都是有益的，能够让程序更加安全稳健地运行。</p><p>​        隐式类型转换必须使用已知的转换规则，虽然灵活性受到了限制，但是由于能够对数据进行恰当地调整，所以更加安全（几乎没有风险）。强制类型转换能够在更大范围的数据类型之间进行转换，例如不同类型指针（引用）之间的转换、从 <code>const</code>到非<code>const</code>的转换、从 int 到指针的转换（有些编译器也允许反过来）等，这虽然增加了灵活性，但是由于不能恰当地调整数据，所以也充满了风险，程序员要小心使用。</p><p>​        下面的代码演示了不同类型指针之间的转换所带来的风险：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>): m_a(a), m_b(b)&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//风险①：破坏类的封装性</span></span><br><span class="line">    Base *pb = <span class="keyword">new</span> Base(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">int</span> n = *((<span class="keyword">int</span>*)pb + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//风险②：进行无意义的操作</span></span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">56.2</span>;</span><br><span class="line">    <span class="keyword">int</span> *pi = (<span class="keyword">int</span>*)&amp;f;</span><br><span class="line">    *pi = <span class="number">-23</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line">NaN</span><br></pre></td></tr></table></figure></p><blockquote><p>NaN 是“not a number”的缩写，意思是“不是一个数字”。</p></blockquote><p>​        Base 类有两个 private 属性的成员变量，原则上讲它们不能在类的外部访问，但是当把对象指针进行强制类型转换后，就突破了这种限制，破坏了类的封装性。更多内容请猛击《借助指针突破访问权限的限制》一文。</p><p>​        f 是 float 类型的变量，用来存储浮点数，但是我们通过指针将一个整数直接放到了 f 所在的内存，由于整数和浮点数的存储格式不一样，所以直接放入一个整数毫无意义。关于整数和浮点数在内存中的存储请猛击《整数在内存中是如何存储的》和《小数在内存中是如何存储的》。</p><h3 id="为什么会有隐式类型转换和强制类型转换之分？"><a href="#为什么会有隐式类型转换和强制类型转换之分？" class="headerlink" title="为什么会有隐式类型转换和强制类型转换之分？"></a>为什么会有隐式类型转换和强制类型转换之分？</h3><p>​        隐式类型转换和显式类型转换最根本的区别是：隐式类型转换除了会重新解释数据的二进制位，还会利用已知的转换规则对数据进行恰当地调整；而显式类型转换只能简单粗暴地重新解释二进制位，不能对数据进行任何调整。</p><p>​        其实，能不能对数据进行调整是显而易见地事情，有转换规则就可以调整，没有转换规则就不能调整，当进行数据类型转换时，编译器明摆着是知道有没有转换规则的。站在这个角度考虑，强制类型转换的语法就是多此一举，编译器完全可以自行判断是否需要调整数据。例如从int <em>转换到float </em>，加不加强制类型转换的语法都不能对数据进行调整。</p><p>​        C/C++ 之所以增加强制类型转换的语法，是为了提醒程序员这样做存在风险，一定要谨慎小心。说得通俗一点，你现在的类型转换存在风险，你自己一定要知道。</p><h3 id="强制类型转换也不是万能的"><a href="#强制类型转换也不是万能的" class="headerlink" title="强制类型转换也不是万能的"></a>强制类型转换也不是万能的</h3><p>​        类型转换只能发生在相关类型或者相近类型之间，两个毫不相干的类型不能相互转换，即使使用强制类型转换也不行。例如，两个没有继承关系的类不能相互转换，基类不能向派生类转换（向下转型），类类型不能向基本类型转换，指针和类类型之间不能相互转换。</p><p>​        下面的代码演示了不相干类型之间的转换：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123; &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    Base obj1;</span><br><span class="line">    Derived obj2;</span><br><span class="line"></span><br><span class="line">    a = (A)b;  <span class="comment">//Error: 两个没有继承关系的类不能相互转换</span></span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)a;  <span class="comment">//Error: 类类型不能向基本类型转换</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)b;  <span class="comment">//Error: 指针和类类型之间不能相互转换</span></span><br><span class="line">    obj2 = (Derived)obj1;  <span class="comment">//Error: 向下转型</span></span><br><span class="line">    obj1 = obj2;  <span class="comment">//Correct: 向上转型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  当定义一个类时，我们显式地或隐式地指定了此类型的对象在拷贝、赋值和销毁时做什么。一个类通过定义三种特殊的成员函数来控制这些操作，分别是拷贝构造函数、赋值运算符和析构函数。&lt;br&gt;  拷贝构造函数定义了当用同类型的另一个对象初始化新对象时做什么，赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么，析构函数定义了此类型的对象销毁时做什么。我们将这些操作称为拷贝控制操作。 &lt;/p&gt;
    
    </summary>
    
      <category term="c++_language" scheme="http://yoursite.com/categories/c-language/"/>
    
    
      <category term="c++_language" scheme="http://yoursite.com/tags/c-language/"/>
    
  </entry>
  
  <entry>
    <title>c语言-小数在内存的存储</title>
    <link href="http://yoursite.com/2019/05/25/c%E8%AF%AD%E8%A8%80-%E5%B0%8F%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2019/05/25/c语言-小数在内存的存储/</id>
    <published>2019-05-25T09:31:02.000Z</published>
    <updated>2019-10-21T02:30:19.414Z</updated>
    
    <content type="html"><![CDATA[<p>  小数在内存中是以<strong>浮点数</strong>的形式存储的。浮点数并不是一种数值分类，它和整数、小数、实数等不是一个层面的概念。</p><p>  <strong>浮点数是数字（或者说数值）在内存中的一种存储格式，它和定点数是相对的。</strong></p><a id="more"></a><h2 id="小数在内存的存储"><a href="#小数在内存的存储" class="headerlink" title="小数在内存的存储"></a>小数在内存的存储</h2><p>​    C语言使用定点数格式来存储 short、int、long 类型的整数，使用浮点数格式来存储 float、double 类型的小数。整数和小数在内存中的存储格式不一样。</p><p>​    我们在学习C语言时，通常认为浮点数和小数是等价的，并没有严格区分它们的概念，这也并没有影响到我们的学习，原因就是浮点数和小数是绑定在一起的，只有小数才使用浮点格式来存储。</p><p>​    其实，整数和小数可以都使用定点格式来存储，也可以都使用浮点格式来存储，但实际情况却是，C语言使用定点格式存储整数，使用浮点格式存储小数，这是在“数值范围”和“数值精度”两项重要指标之间追求平衡的结果，稍后我会给大家带来深入的剖析。 </p><blockquote><pre><code>计算机的设计是一门艺术，很多实用技术都是权衡和妥协的结果。</code></pre></blockquote><p>​    <strong>浮点数</strong>和<strong>定点数</strong>中的“点”指的就是小数点！</p><p>​    对于整数，可以认为小数点后面都是零，小数部分是否存在并不影响整个数字的值，所以干脆将小数部分省略，只保留整数部分。 </p><h2 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h2><p>​    所谓定点数，就是指小数点的位置是固定的，不会向前或者向后移动。</p><p>​    假设我们用4个字节（32位）来存储无符号的定点数，并且约定，前16位表示整数部分，后16位表示小数部分，如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1G01Q63SS96.png" alt></p><p>​    如此一来，小数点就永远在第16位之后，整数部分和小数部分一目了然，不管什么时候，整数部分始终占用16位（不足16位前置补0），小数部分也始终占用16位（不足16位后置补0）。例如，在内存中存储了  <code>10101111  00110001  01011100  11000011</code>，那么对应的小数就是 <code>10101111  00110001 . 01011100  11000011</code>，非常直观。 </p><h4 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h4><p>​    小数部分的最后一位可能是精确数字，也可能是近似数字（由四舍五入、向零舍入等不同方式得到）；除此以外，剩余的31位都是精确数字。从二进制的角度看，这种定点格式的小数，最多有 32 位有效数字，但是能保证的是 31 位；也就是说，整体的精度为 31~32 位。</p><h4 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h4><p>​    将内存中的所有位（Bit）都置为 1，小数的值最大，为 $2^{16}$ - $2^{-16}$，极其接近$2^{16}$，换算成十进制为 <code>65 536</code>。将内存中最后一位（第32位）置1，其它位都置0，小数的值最小，为$2^{-16}$。 </p><blockquote><pre><code>这里所说的最小值不是 0 值，而是最接近 0 的那个值。</code></pre></blockquote><h4 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h4><p>​    <strong>用定点格式来存储小数，优点是精度高，因为所有的位都用来存储有效数字了，缺点是取值范围太小，不能表示很大或者很小的数字。</strong></p><h4 id="反面例子"><a href="#反面例子" class="headerlink" title="反面例子"></a>反面例子</h4><p>​    在科学计算中，小数的取值范围很大，最大值和最小值的差距有上百个数量级，使用定点数来存储将变得非常困难。</p><p>​    例如，电子的质量为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000000000000000000000.9</span> 克 = <span class="number">9</span> × <span class="number">10</span>^(<span class="number">-28</span>) 克</span><br></pre></td></tr></table></figure></p><p>​    太阳的质量为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2000000000000000000000000000000000</span> 克 = <span class="number">2</span> × <span class="number">10</span>^<span class="number">33</span> 克</span><br></pre></td></tr></table></figure></p><p>​    如果使用定点数，那么只能按照<code>=</code>前面的格式来存储，这将需要很大的一块内存，大到需要几十个字节。更加科学的方案是按照<code>=</code>后面的指数形式来存储，这样不但节省内存，也非常直观。<strong>这种以指数的形式来存储小数的解决方案就叫做浮点数。</strong></p><p>​    浮点数是对定点数的升级和优化，克服了定点数取值范围太小的缺点。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>​    C语言标准规定，小数在内存中以科学计数法的形式来存储，具体形式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flt = (<span class="number">-1</span>)sign × mantissa × baseexponent</span><br></pre></td></tr></table></figure></p><p>​    对各个部分的说明： </p><ul><li>flt 是要表示的小数。</li><li>sign 用来表示 flt 的正负号，它的取值只能是 0 或 1：取值为 0 表示 flt 是正数，取值为 1 表示 flt 是负数。</li><li>base 是基数，或者说进制，它的取值大于等于 2（例如，2 表示二进制、10 表示十进制、16 表示十六进制……）。数学中常见的科学计数法是基于十进制的，例如 6.93 × 1013；计算机中的科学计数法可以基于其它进制，例如 1.001 × 27 就是基于二进制的，它等价于 1001 0000。</li><li>mantissa 为尾数，或者说精度，是 base 进制的小数，并且 1 ≤ mantissa ＜ base，这意味着，小数点前面只能有一位数字；</li><li>exponent 为指数，是一个整数，可正可负，并且为了直观一般采用十进制表示。</li></ul><p>下面我们以 19.625 为例来演示如何将小数转换为浮点格式。</p><p>​    当 base 取值为 10 时，19.625 的浮点形式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19.625</span> = <span class="number">1.9625</span> × <span class="number">101</span></span><br></pre></td></tr></table></figure></p><p>​    当 base 取值为 2 时，将 19.625 转换成二进制为 10011.101，用浮点形式来表示为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19.625</span> = <span class="number">10011.101</span> = <span class="number">1.0011101</span>×<span class="number">24</span></span><br></pre></td></tr></table></figure></p><blockquote><pre><code>19.625 整数部分的二进制形式为：19 = 1×24 + 0×23 + 0×22 + 1×21 + 1×20 = 10011小数部分的二进制形式为：0.625 = 1×2-1 + 0×2-2 + 1×2-3 = 101将整数部分和小数部分合并在一起：19.625 = 10011.101</code></pre></blockquote><p>可以看出，当基数（进制）base 确定以后，指数 exponent 实际上就成了小数点的移动位数： </p><ul><li><p>exponent 大于零，mantissa 中的小数点右移 exponent 位即可还原小数的值；</p></li><li><p>exponent 小于零，mantissa 中的小数点左移 exponent 位即可还原小数的值。</p></li></ul><p>​    <strong>换句话说，将小数转换成浮点格式后，小数点的位置发生了浮动（移动），并且浮动的位数和方向由 exponent 决定，所以我们将这种表示小数的方式称为浮点数。</strong></p><h2 id="二进制形式的浮点数的存储"><a href="#二进制形式的浮点数的存储" class="headerlink" title="二进制形式的浮点数的存储"></a>二进制形式的浮点数的存储</h2><p>​    虽然C语言标准没有规定 base 使用哪种进制，但是在实际应用中，各种编译器都将 base 实现为二进制，这样不仅贴近计算机硬件（任何数据在计算机底层都以二进制形式表示），还能减少转换次数。</p><p>​    接下来我们就讨论一下如何将二进制形式的浮点数放入内存中。</p><p>​    原则上讲，上面的科学计数法公式中，符号 sign、尾数 mantissa、基数 base 和指数 exponent  都是不确定因素，都需要在内存中体现出来。但是现在基数 base 已经确定是二进制了，就不用在内存中体现出来了，这样只需要在内存中存储符号  sign、尾数 mantissa、指数 exponent 这三个不确定的元素就可以了。</p><p>​    仍然以 19.625 为例，将它转换成二进制形式的浮点数格式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19.625</span> = <span class="number">1.0011101</span>×<span class="number">24</span></span><br></pre></td></tr></table></figure></p><p>​    此时符号 sign 为 0，尾数 mantissa 为 1.0011101，指数 exponent 为 4。 </p><h4 id="1-符号的存储"><a href="#1-符号的存储" class="headerlink" title="1) 符号的存储"></a>1) 符号的存储</h4><p>​    符号的存储很容易，就像存储 short、int 等普通整数一样，单独分配出一个位（Bit）来，用 0 表示正数，用 1 表示负数。对于 19.625，这一位的值是 0。 </p><h4 id="2-尾数的存储"><a href="#2-尾数的存储" class="headerlink" title="2) 尾数的存储"></a>2) 尾数的存储</h4><p>​    当采用二进制形式后，尾数部分的取值范围为 1 ≤ mantissa ＜ 2，这意味着：尾数的整数部分一定为  1，是一个恒定的值，这样就无需在内存中提现出来，可以将其直接截掉，只要把小数点后面的二进制数字放入内存中即可。对于 1.0011101，就是把  0011101 放入内存。</p><p>​    我们不妨将真实的尾数命名为 mantissa，将内存中存储的尾数命名为 mant，那么它们之间的关系为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mantissa = <span class="number">1.</span>mant</span><br></pre></td></tr></table></figure></p><p>​    如果 base 采用其它进制，那么尾数的整数部分就不是固定的，它有多种取值的可能，以十进制为例，尾数的整数部分可能是 1~9  之间的任何一个值，这样一来尾数的整数部分就不能省略了，必须在内存中体现出来。而将 base  设置为二进制就可以节省掉一个位（Bit）的内存，这也算是采用二进制的一点点优势。</p><h4 id="3-指数的存储"><a href="#3-指数的存储" class="headerlink" title="3) 指数的存储"></a>3) 指数的存储</h4><p>​    指数是一个整数，并且有正负之分，不但需要存储它的值，还得能区分出正负号来。</p><p>​    short、int、long  等类型的整数在内存中的存储采用的是补码加符号位的形式，数值在写入内存之前必须先进行转换，读取以后还要再转换一次。但是为了提高效率，避免繁琐的转换，指数的存储并没有采用补码加符号位的形式，而是设计了一套巧妙的解决方案，稍等我会为您解开谜团。 </p><h2 id="为二进制浮点数分配内存"><a href="#为二进制浮点数分配内存" class="headerlink" title="为二进制浮点数分配内存"></a>为二进制浮点数分配内存</h2><p>​    C语言中常用的浮点数类型为 float 和 double；float 始终占用 4 个字节，double 始终占用 8 个字节。</p><p>​    下图演示了 float 和 double 的存储格式： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1601021422192L.png" alt></p><p>​    浮点数的内存被分成了三部分，分别用来存储符号 sign、尾数 mantissa 和指数 exponent ，当浮点数的类型确定后，每一部分的位数就是固定的。</p><p>​    符号 sign 可以不加修改直接放入内存中，尾数 mantissa 只需要将小数部分放入内存中，最让人疑惑的是指数 exponent 如何放入内存中，这也是我们在前面留下的一个谜团，下面我们以 float 为例来揭开谜底。</p><p>​    float 的指数部分占用 8 Bits，能表示从 0~255 的值，取其中间值  127，指数在写入内存前先加上127，读取时再减去127，正数负数就显而易见了。19.625 转换后的指数为 4，<code>4+127 = 131</code>，131  换算成二进制为 <code>1000 0011</code>，这就是 19.626 的指数部分在 float 中的最终存储形式。</p><p>​    先确定内存中指数部分的取值范围，得到一个中间值，写入指数时加上这个中间值，读取指数时减去这个中间值，这样符号和值就都能确定下来了。</p><p>​    中间值的求取有固定的公式。设中间值为 median，指数部分占用的内存为 n 位，那么中间值为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">median = <span class="number">2</span>n<span class="number">-1</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>​    对于 float，中间值为 $2^{8-1}$ - 1 = 127；对于 double，中间值为 $2^{11-1}$ -1 = 1023。</p><p>​    我们不妨将真实的指数命名为 exponent，将内存中存储的指数命名为 exp，那么它们之间的关系为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exponent = <span class="built_in">exp</span> - median</span><br></pre></td></tr></table></figure></p><p>​     也可以写作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exp</span> = exponent + median</span><br></pre></td></tr></table></figure></p><blockquote><pre><code>为了方便后续文章的编写，这里我强调一下命名：     </code></pre><ul><li>mantissa 表示真实的尾数，包括整数部分和小数部分；mant 表示内存中存储的尾数，只有小数部分，省略了整数部分。</li><li>exponent 表示真实的指数，exp 表示内存中存储的指数，exponent 和 exp 并不相等，exponent 加上中间数 median 才等于 exp。</li></ul></blockquote><h2 id="用代码验证-float-的存储"><a href="#用代码验证-float-的存储" class="headerlink" title="用代码验证 float 的存储"></a>用代码验证 float 的存储</h2><p>​    19.625 转换成二进制的指数形式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19.625</span> = <span class="number">1.0011101</span>×<span class="number">24</span></span><br></pre></td></tr></table></figure></p><p>​    此时符号为<code>0</code>；尾数为<code>1.0011101</code>，截掉整数部分后为 0011101，补齐到 23 Bits 后为 <code>001 1101 0000 0000 0000 0000</code>；指数为 <code>4</code>，<code>4+127 = 131</code>，<code>131</code> 换算成二进制为 <code>1000 0011</code>。</p><p>​    综上所述，float 类型的 <code>19.625</code> 在内存中的值为：<code>0 - 10000011 - 001 1101 0000 0000 0000 0000</code>。</p><p>​    下面我们通过代码来验证一下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//浮点数结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nMant : <span class="number">23</span>;  <span class="comment">//尾数部分</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nExp : <span class="number">8</span>;  <span class="comment">//指数部分</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nSign : <span class="number">1</span>;  <span class="comment">//符号位</span></span><br><span class="line">&#125; FP_SINGLE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strBin[<span class="number">33</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">19.625</span>;</span><br><span class="line">    FP_SINGLE *p = (FP_SINGLE*)&amp;f;</span><br><span class="line">   </span><br><span class="line">    itoa(p-&gt;nSign, strBin, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sign: %s\n"</span>, strBin);</span><br><span class="line">    itoa(p-&gt;nExp, strBin, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"exp: %s\n"</span>, strBin);</span><br><span class="line">    itoa(p-&gt;nMant, strBin, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mant: %s\n"</span>, strBin);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     运行结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sign: <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exp</span>: <span class="number">10000011</span></span><br><span class="line"></span><br><span class="line">mant: <span class="number">111010000000000000000</span></span><br></pre></td></tr></table></figure></p><blockquote><p>mant 的位数不足，在前面补齐两个 0 即可。</p></blockquote><blockquote><pre><code>printf() 不能直接输出二进制形式，这里我们借助 itoa() 函数将十进制数转换成二进制的字符串，再使用`%s`输出。itoa()  虽然不是标准函数，但是大部分编译器都支持。不过 itoa() 在 C99 标准中已经被指定为不可用函数，在一些严格遵循 C99  标准的编译器下会失效，甚至会引发错误，例如在 Xcode（使用 LLVM 编译器）下就会编译失败。如果 itoa() 无效，请使用`%X`输出十六进制形式，十六进制能够很方便地转换成二进制。</code></pre></blockquote><h2 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h2><p>​    对于十进制小数，整数部分转换成二进制使用“展除法”（就是不断除以 2，直到余数为  0），一个有限位数的整数一定能转换成有限位数的二进制。但是小数部分就不一定了，小数部分转换成二进制使用“乘二取整法”（就是不断乘以  2，直到小数部分为 0），一个有限位数的小数并不一定能转换成有限位数的二进制，只有末位是 5 的小数才有可能转换成有限位数的二进制，其它的小数都不行。 </p><p>​    float 和 double 的尾数部分是有限的，固然不能容纳无限的二进制；即使小数能够转换成有限的二进制，也有可能会超出尾数部分的长度，此时也不能容纳。这样就必须“四舍五入”，将多余的二进制“处理掉”，只保留有效长度的二进制，这就涉及到了精度的问题。</p><p>​    也就是说，浮点数不一定能保存真实的小数，很有可能保存的是一个近似值。</p><p>​    对于 float，尾数部分有 23 位，再加上一个隐含的整数 1，一共是 24  位。最后一位可能是精确数字，也可能是近似数字（由四舍五入、向零舍入等不同方式得到）；除此以外，剩余的23位都是精确数字。从二进制的角度看，这种浮点格式的小数，最多有  24 位有效数字，但是能保证的是 23 位；也就是说，整体的精度为 23~24 位。如果转换成十进制，$2^{24}$ = 16 777 216，一共8位；也就是说，最多有 8 位有效数字，但是能保证的是 7 位，从而得出整体精度为 7~8 位。</p><p>​    对于 double，同理可得，二进制形式的精度为 52~53 位，十进制形式的精度为 15~16 位。 </p><h2 id="IEEE-754-标准"><a href="#IEEE-754-标准" class="headerlink" title="IEEE 754 标准"></a>IEEE 754 标准</h2><p>​    浮点数的存储以及加减乘除运算是一个比较复杂的问题，很多小的处理器在硬件指令方面甚至不支持浮点运算，其他的则需要一个独立的协处理器来处理这种运算，只有最复杂的处理器才会在硬件指令集中支持浮点运算。省略浮点运算，可以将处理器的复杂度减半！如果硬件不支持浮点运算，那么只能通过软件来实现，代价就是需要容忍不良的性能。 </p><blockquote><pre><code>PC 和智能手机上的处理器就是最复杂的处理器了，它们都能很好地支持浮点运算。</code></pre></blockquote><p>​    在六七十年代，计算机界对浮点数的处理比较混乱，各家厂商都有自己的一套规则，缺少统一的业界标准，这给数据交换、计算机协同工作带来了很大不便。</p><p>​    作为处理器行业的老大，Intel 早就意识到了这个问题，并打算一统浮点数的世界。Intel 在研发 8087  浮点数协处理器时，聘请到加州大学伯克利分校的 William Kahan 教授（最优秀的数值分析专家之一）以及他的两个伙伴，来为 8087  协处理器设计浮点数格式，他们的工作完成地如此出色，设计的浮点数格式具有足够的合理性和先进性，被 IEEE 组织采用为浮点数的业界标准，并于  1985 年正式发布，这就是 IEEE 754 标准，它等同于国际标准 ISO/IEC/IEEE 60559。 </p><blockquote><pre><code>IEEE 是 Institute of Electrical and Electronics Engineers 的简写，中文意思是“电气和电子工程师协会”。</code></pre></blockquote><p>​    IEEE 754 简直是天才一般的设计，William Kahan 教授也因此获得了 1987 年的图灵奖。图灵奖是计算机界的“诺贝尔奖”。</p><p>​    目前，几乎所有的计算机都支持 IEEE 754 标准，大大改善了科学应用程序的可移植性，C语言编译器在实现浮点数时也采用了该标准。</p><p>​    不过，IEEE 754 标准的出现晚于C语言标准（最早的 ANSI C 标准于 1983 年发布），C语言标准并没有强制编译器采用 IEEE  754 格式，只是说要使用科学计数法的形式来表示浮点数，但是编译器在实现浮点数时，都采用了 IEEE 754 格式，这既符合C语言标准，又符合  IEEE 标准，何乐而不为。 </p><h2 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h2><p>​    IEEE 754 标准规定，当指数 exp 的所有位都为 1 时，不再作为“正常”的浮点数对待，而是作为特殊值处理：</p><ul><li>如果此时尾数 mant 的二进制位都为 0，则表示无穷大：         <ul><li>如果符号 sign 为 1，则表示负无穷大；</li><li>如果符号 sign 为 0，则表示正无穷大。</li></ul></li><li>如果此时尾数 mant 的二进制位不全为 0，则表示 NaN（Not a Number），也即这是一个无效的数字，或者该数字未经初始化。</li></ul><h2 id="非规格化浮点数"><a href="#非规格化浮点数" class="headerlink" title="非规格化浮点数"></a>非规格化浮点数</h2><p>​    当指数 exp 的所有二进制位都为 0 时，情况也比较特殊。</p><p>​    对于“正常”的浮点数，尾数 mant 隐含的整数部分为 1，并且在读取浮点数时，内存中的指数 exp 要减去中间值 median 才能还原真实的指数 exponent，也即：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mantissa = <span class="number">1.</span>mant</span><br><span class="line">exponent = <span class="built_in">exp</span> - median</span><br></pre></td></tr></table></figure></p><p>​     但是当指数 exp 的所有二进制位都为 0 时，一切都变了！尾数 mant 隐含的整数部分变成了 0，并且用 1 减去内存中的指数 exp 才能还原真实的指数 exponent，也即：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mantissa = <span class="number">0.</span>mant</span><br><span class="line">exponent = <span class="number">1</span> - <span class="built_in">exp</span></span><br></pre></td></tr></table></figure></p><p>​    对于 float，<code>exponent = 1 - 127 = -126</code>，指数 exponent 的值恒为 -126；对于 double，<code>exponent = 1 - 1023 = -1022</code>，指数 exponent 的值恒为 -1022。</p><p>​    当指数 exp 的所有二进制位都是 0 时，我们将这样的浮点数称为“非规格化浮点数”；当指数 exp 的所有二进制位既不全为 0 也不全为 1 时，我们称之为“规格化浮点数”；当指数 exp 的所有二进制位都是 1 时，作为特殊值对待。</p><p>​    也就是说，究竟是规格化浮点数，还是非规格化浮点数，还是特殊值，完全看指数 exp。 </p><h4 id="0-和-0-的表示"><a href="#0-和-0-的表示" class="headerlink" title="+0 和 -0 的表示"></a>+0 和 -0 的表示</h4><p>​    对于非规格化浮点数，当尾数 mant 的所有二进制位都为 0 时，整个浮点数的值就为 0： </p><ul><li>如果符号 sign 为 0，则表示 +0；</li><li>如果符号 sign 为 1，则表示 -0。</li></ul><h2 id="IEEE-754-为什么增加非规格化浮点数"><a href="#IEEE-754-为什么增加非规格化浮点数" class="headerlink" title="IEEE 754 为什么增加非规格化浮点数"></a>IEEE 754 为什么增加非规格化浮点数</h2><p>​    我们以 float 类型为例来说明。</p><p>​    对于规格化浮点数，当尾数 mant 的所有位都为 0、指数 exp 的最低位为 1 时，浮点数的绝对值最小（符号 sign 的取值不影响绝对值），为 1.0 × $2^{-126}$，也即 $2^{-126}$。</p><p>​    对于一般的计算，这个值已经很小了，非常接近 0 值了，但是对于科学计算，它或许还不够小，距离 0 值还不够近，非规格化浮点数就是来弥补这一缺点的：非规格化浮点数可以让最小值更小，更加接近 0 值。</p><p>​    对于非规格化浮点数，当尾数的最低位为 1 时，浮点数的绝对值最小，为 $2^{-23}$ × $2^{-126}$ = $2^{-149}$，这个值比 $2^{-126}$小了 23 个数量级，更加即接近 0 值。</p><p>​    上表演示了正数时的情形，负数与此类似。请读者注意观察最大非规格化数和最小规格化数，它们是连在一起的，是平滑过渡的。 </p><h2 id="舍入模式"><a href="#舍入模式" class="headerlink" title="舍入模式"></a>舍入模式</h2><p>​    浮点数的尾数部分 mant 所包含的二进制位有限，不可能表示太长的数字，如果尾数部分过长，在放入内存时就必须将多余的位丢掉，取一个近似值。究竟该如何来取这个近似值，IEEE 754 列出了四种不同的舍入模式。 </p><h4 id="1-舍入到最接近的值"><a href="#1-舍入到最接近的值" class="headerlink" title="1) 舍入到最接近的值"></a>1) 舍入到最接近的值</h4><p>​    就是将结果舍入为最接近且可以表示的值，这是默认的舍入模式。最近舍入模式和我们平时所见的“四舍五入”非常类似，但有一个细节不同。</p><p>​    对于最近舍入模式，IEEE 754 规定，当有两个最接近的可表示的值时首选“偶数”值；而对于四舍五入模式，当有两个最接近的可表示的值时要选较大的值。以十进制为例，就是对<code>.5</code>的舍入上采用偶数的方式，请看下面的例子。</p><ul><li><p>最近舍入模式：Round(0.5) = 0、Round(1.5) = 2、Round(2.5) = 2</p></li><li><p>四舍五入模式：Round(0.5) = 1、Round(1.5) = 2、Round(2.5) = 3 </p></li></ul><h4 id="2-向-∞-方向舍入（向上舍入）"><a href="#2-向-∞-方向舍入（向上舍入）" class="headerlink" title="2) 向 +∞ 方向舍入（向上舍入）"></a>2) 向 +∞ 方向舍入（向上舍入）</h4><p>​    会将结果朝正无穷大的方向舍入。标准库函数 ceil() 使用的就是这种舍入模式，例如，ceil(1.324) = 2，Ceil(-1.324) = -1。</p><h4 id="3-向-∞-方向舍入（向下舍入）"><a href="#3-向-∞-方向舍入（向下舍入）" class="headerlink" title="3) 向 -∞ 方向舍入（向下舍入）"></a>3) 向 -∞ 方向舍入（向下舍入）</h4><p>​    会将结果朝负无穷大的方向舍入。标准库函数 floor() 使用的就是这种舍入模式，例如，floor(1.324) = 1，floor(-1.324) = -2。 </p><h4 id="4-向-0-舍入（直接截断）"><a href="#4-向-0-舍入（直接截断）" class="headerlink" title="4) 向 0 舍入（直接截断）"></a>4) 向 0 舍入（直接截断）</h4><p>​    会将结果朝接近 0 的方向舍入，也就是将多余的位数直接丢掉。C语言中的类型转换使用的就是这种舍入模式，例如，(int)1.324 = 1，(int) -1.324 = -1。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    与定点数相比，浮点数在精度方面损失不小，但是在取值范围方面增大很多。牺牲精度，换来取值范围，这就是浮点数的整体思想。</p><p>​    IEEE 754 标准其实还规定了浮点数的加减乘除运算，不过本文的重点是讲解浮点数的存储，所以对于浮点数的运算不再展开讨论。 </p><h2 id="答疑解惑"><a href="#答疑解惑" class="headerlink" title="答疑解惑"></a>答疑解惑</h2><p>​    上节我们还留下了一个疑问，就是用 %f 输出 128.101 时得到的是一个近似值，而不是一个精确值，这是因为，128.101 转换为浮点格式后，尾数部分过长，被丢掉了，不能“真实”地存储了。</p><p>​    128.101 转换成二进制为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000000.0001100111011011001000101101</span>……（无限循环）</span><br></pre></td></tr></table></figure></p><p>​    向左移动 7 位后为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.00000000001100111011011001000101101</span>……</span><br></pre></td></tr></table></figure></p><p>​    由此可见，尾数部分为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span> <span class="number">1101</span> <span class="number">1011</span> <span class="number">001000101101</span>……</span><br></pre></td></tr></table></figure></p><p>​    将多出的二进制丢掉后为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span> <span class="number">1101</span> <span class="number">1011</span></span><br></pre></td></tr></table></figure></p><p>​    使用 printf 输出时，还需要进行还原，还原后的二进制为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000000.0001100111011011</span></span><br></pre></td></tr></table></figure></p><p>​    转换成十进制为 128.1009979248046875，按照四舍五入的原则取 6 位小数，就是128.100998</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  小数在内存中是以&lt;strong&gt;浮点数&lt;/strong&gt;的形式存储的。浮点数并不是一种数值分类，它和整数、小数、实数等不是一个层面的概念。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;浮点数是数字（或者说数值）在内存中的一种存储格式，它和定点数是相对的。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>c++多态与虚函数</title>
    <link href="http://yoursite.com/2019/05/25/c++%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/05/25/c++多态与虚函数/</id>
    <published>2019-05-25T09:27:02.000Z</published>
    <updated>2019-10-21T02:40:42.808Z</updated>
    
    <content type="html"><![CDATA[<p>  有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为<strong>多态（Polymorphism）</strong>。</p><a id="more"></a><h2 id="虚函数实现多态"><a href="#虚函数实现多态" class="headerlink" title="虚函数实现多态"></a>虚函数实现多态</h2><p>​        基类的指针也可以指向派生类对象，请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类People</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    People(<span class="keyword">char</span> *name, <span class="keyword">int</span> age);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line">People::People(<span class="keyword">char</span> *name, <span class="keyword">int</span> age): m_name(name), m_age(age)&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> People::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁了，是个无业游民。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类Teacher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span> <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Teacher(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">int</span> salary);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_salary;</span><br><span class="line">&#125;;</span><br><span class="line">Teacher::Teacher(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">int</span> salary): People(name, age), m_salary(salary)&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> Teacher::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁了，是一名教师，每月有"</span>&lt;&lt;m_salary&lt;&lt;<span class="string">"元的收入。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    People *p = <span class="keyword">new</span> People(<span class="string">"王志刚"</span>, <span class="number">23</span>);</span><br><span class="line">    p -&gt; display();</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">new</span> Teacher(<span class="string">"赵宏佳"</span>, <span class="number">45</span>, <span class="number">8200</span>);</span><br><span class="line">    p -&gt; display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">王志刚今年<span class="number">23</span>岁了，是个无业游民。</span><br><span class="line">赵宏佳今年<span class="number">45</span>岁了，是个无业游民。</span><br></pre></td></tr></table></figure></p><p>​        我们直观上认为，如果指针指向了派生类对象，那么就应该使用派生类的成员变量和成员函数，这符合人们的思维习惯。但是本例的运行结果却告诉我们，当基类指针  p 指向派生类 Teacher 的对象时，虽然使用了 Teacher  的成员变量，但是却没有使用它的成员函数，导致输出结果不伦不类（赵宏佳本来是一名老师，输出结果却显示人家是个无业游民），不符合我们的预期。</p><p>​        换句话说，通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。</p><p>​        为了消除这种尴尬，让基类指针能够访问派生类的成员函数，C++ 增加了<strong>虚函数（Virtual Function）</strong>。使用虚函数非常简单，只需要在函数声明前面增加<code>virtual</code>关键字。</p><p>​        更改上面的代码，将 display() 声明为虚函数： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类People</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    People(<span class="keyword">char</span> *name, <span class="keyword">int</span> age);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;  <span class="comment">//声明为虚函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line">People::People(<span class="keyword">char</span> *name, <span class="keyword">int</span> age): m_name(name), m_age(age)&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> People::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁了，是个无业游民。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类Teacher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span> <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Teacher(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">int</span> salary);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;  <span class="comment">//声明为虚函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_salary;</span><br><span class="line">&#125;;</span><br><span class="line">Teacher::Teacher(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">int</span> salary): People(name, age), m_salary(salary)&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> Teacher::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁了，是一名教师，每月有"</span>&lt;&lt;m_salary&lt;&lt;<span class="string">"元的收入。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    People *p = <span class="keyword">new</span> People(<span class="string">"王志刚"</span>, <span class="number">23</span>);</span><br><span class="line">    p -&gt; display();</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">new</span> Teacher(<span class="string">"赵宏佳"</span>, <span class="number">45</span>, <span class="number">8200</span>);</span><br><span class="line">    p -&gt; display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>运行结果：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">王志刚今年<span class="number">23</span>岁了，是个无业游民。</span><br><span class="line">赵宏佳今年<span class="number">45</span>岁了，是一名教师，每月有<span class="number">8200</span>元的收入。</span><br></pre></td></tr></table></figure><p>​        和前面的例子相比，本例仅仅是在 display() 函数声明前加了一个<code>virtual</code>关键字，将成员函数声明为了<strong>虚函数（Virtual Function）</strong>，这样就可以通过 p 指针调用 Teacher 类的成员函数了，运行结果也证明了这一点（赵宏佳已经是一名老师了，不再是无业游民了）。</p><p>​        <strong>有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）</strong>。</p><p>​        上面的代码中，同样是<code>p-&gt;display();</code>这条语句，当 p 指向不同的对象时，它执行的操作是不一样的。同一条语句可以执行不同的操作，看起来有不同表现方式，这就是多态。</p><pre><code>多态是面向对象编程的主要特征之一，C++中虚函数的唯一用处就是构成多态。</code></pre><p>​        C++提供多态的目的是：<strong>可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问，尤其是成员函数。如果没有多态，我们只能访问成员变量</strong>。</p><p>​        前面我们说过，通过指针调用普通的成员函数时会根据指针的类型（通过哪个类定义的指针）来判断调用哪个类的成员函数，但是通过本节的分析可以发现，这种说法并不适用于虚函数，虚函数是根据指针的指向来调用的，指针指向哪个类的对象就调用哪个类的虚函数。</p><h2 id="引用实现多态"><a href="#引用实现多态" class="headerlink" title="引用实现多态"></a>引用实现多态</h2><p>​        引用在本质上是通过指针的方式实现的，既然借助指针可以实现多态，那么我们就有理由推断：<strong>借助引用也可以实现多态</strong>。</p><p>​        修改上例中 main() 函数内部的代码，用引用取代指针： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">People <span class="title">p</span><span class="params">(<span class="string">"王志刚"</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">    <span class="function">Teacher <span class="title">t</span><span class="params">(<span class="string">"赵宏佳"</span>, <span class="number">45</span>, <span class="number">8200</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">    People &amp;rp = p;</span><br><span class="line">    People &amp;rt = t;</span><br><span class="line">   </span><br><span class="line">    rp.display();</span><br><span class="line">    rt.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">王志刚今年<span class="number">23</span>岁了，是个无业游民。</span><br><span class="line">赵宏佳今年<span class="number">45</span>岁了，是一名教师，每月有<span class="number">8200</span>元的收入。</span><br></pre></td></tr></table></figure></p><p>​        <strong>由于引用类似于常量，只能在定义的同时初始化，并且以后也要从一而终，不能再引用其他数据，所以本例中必须要定义两个引用变量，一个用来引用基类对象，一个用来引用派生类对象。</strong>从运行结果可以看出，当基类的引用指代基类对象时，调用的是基类的成员，而指代派生类对象时，调用的是派生类的成员。</p><p>​        不过引用不像指针灵活，指针可以随时改变指向，而引用只能指代固定的对象，在多态性方面缺乏表现力，所以以后我们再谈及多态时一般是说指针。</p><p>​        本例的主要目的是让读者知道，除了指针，引用也可以实现多态。</p><h2 id="多态的用途"><a href="#多态的用途" class="headerlink" title="多态的用途"></a>多态的用途</h2><p>​        通过上面的例子读者可能还未发现多态的用途，不过确实也是，多态在小项目中鲜有有用武之地。</p><p>​        接下来的例子中，我们假设你正在玩一款军事游戏，敌人突然发动了地面战争，于是你命令陆军、空军及其所有现役装备进入作战状态。具体的代码如下所示： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//军队</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Troops</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Strike back!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//陆军</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Army</span>:</span> <span class="keyword">public</span> Troops&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"--Army is fighting!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//99A主战坦克</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _99<span class="title">A</span>:</span> <span class="keyword">public</span> Army&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"----99A(Tank) is fighting!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//武直10武装直升机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WZ_10</span>:</span> <span class="keyword">public</span> Army&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"----WZ-10(Helicopter) is fighting!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//长剑10巡航导弹</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CJ_10</span>:</span> <span class="keyword">public</span> Army&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"----CJ-10(Missile) is fighting!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空军</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirForce</span>:</span> <span class="keyword">public</span> Troops&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"--AirForce is fighting!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//J-20隐形歼击机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">J_20</span>:</span> <span class="keyword">public</span> AirForce&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"----J-20(Fighter Plane) is fighting!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//CH5无人机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CH_5</span>:</span> <span class="keyword">public</span> AirForce&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"----CH-5(UAV) is fighting!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//轰6K轰炸机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H_6K</span>:</span> <span class="keyword">public</span> AirForce&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"----H-6K(Bomber) is fighting!"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Troops *p = <span class="keyword">new</span> Troops;</span><br><span class="line">    p -&gt;fight();</span><br><span class="line">    <span class="comment">//陆军</span></span><br><span class="line">    p = <span class="keyword">new</span> Army;</span><br><span class="line">    p -&gt;fight();</span><br><span class="line">    p = <span class="keyword">new</span> _99A;</span><br><span class="line">    p -&gt; fight();</span><br><span class="line">    p = <span class="keyword">new</span> WZ_10;</span><br><span class="line">    p -&gt; fight();</span><br><span class="line">    p = <span class="keyword">new</span> CJ_10;</span><br><span class="line">    p -&gt; fight();</span><br><span class="line">    <span class="comment">//空军</span></span><br><span class="line">    p = <span class="keyword">new</span> AirForce;</span><br><span class="line">    p -&gt; fight();</span><br><span class="line">    p = <span class="keyword">new</span> J_20;</span><br><span class="line">    p -&gt; fight();</span><br><span class="line">    p = <span class="keyword">new</span> CH_5;</span><br><span class="line">    p -&gt; fight();</span><br><span class="line">    p = <span class="keyword">new</span> H_6K;</span><br><span class="line">    p -&gt; fight();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Strike back!</span><br><span class="line">--Army is fighting!</span><br><span class="line">----99A(Tank) is fighting!</span><br><span class="line">----WZ-10(Helicopter) is fighting!</span><br><span class="line">----CJ-10(Missile) is fighting!</span><br><span class="line">--AirForce is fighting!</span><br><span class="line">----J-20(Fighter Plane) is fighting!</span><br><span class="line">----CH-5(UAV) is fighting!</span><br><span class="line">----H-6K(Bomber) is fighting!</span><br></pre></td></tr></table></figure></p><p>​        这个例子中的派生类比较多，如果不使用多态，那么就需要定义多个指针变量，很容易造成混乱；而有了多态，只需要一个指针变量 p 就可以调用所有派生类的虚函数。</p><p>​        从这个例子中也可以发现，对于具有复杂继承关系的大中型程序，多态可以增加其灵活性，让代码更具有表现力。</p><h2 id="虚函数注意事项"><a href="#虚函数注意事项" class="headerlink" title="虚函数注意事项"></a>虚函数注意事项</h2><p>​        虚函数对于多态具有决定性的作用，有虚函数才能构成多态，这节我们来重点说一下虚函数的注意事项。</p><p> 1) 只需要在虚函数的声明处加上 <code>virtual</code> 关键字，函数定义处可以加也可以不加。</p><p> 2) 为了方便，你可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽（覆盖）关系的同名函数都将自动成为虚函数。</p><p> 3) 当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。</p><p> 4) 只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）。例如基类虚函数的原型为<code>virtual void func();</code>，派生类虚函数的原型为<code>virtual void func(int);</code>，那么当基类指针 p 指向派生类对象时，语句<code>p -&gt; func(100);</code>将会出错，而语句<code>p -&gt; func();</code>将调用基类的函数。</p><p> 5) 构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。</p><p> 6) 析构函数可以声明为虚函数，而且有时候必须要声明为虚函数，这点我们将在下节中讲解。 </p><h2 id="构成多态的条件"><a href="#构成多态的条件" class="headerlink" title="构成多态的条件"></a>构成多态的条件</h2><p>​        站在“学院派”的角度讲，<strong>封装</strong>、<strong>继承</strong>和<strong>多态</strong>是面向对象的三大特征，<strong>多态是指通过基类的指针既可以访问基类的成员，也可以访问派生类的成员</strong>。</p><p> 下面是构成多态的条件：</p><ul><li>必须存在继承关系；</li><li>继承关系中必须有同名的虚函数，并且它们是遮蔽（覆盖）关系。</li><li><p>存在基类的指针，通过该指针调用虚函数。</p><p>下面的例子对各种混乱情形进行了演示： </p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类Base</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Base::func()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"void Base::func()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Base::func(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"void Base::func(int)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类Derived</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Derived::func()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"void Derived::func()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Derived::func(<span class="keyword">char</span> *str)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"void Derived::func(char *)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> Derived();</span><br><span class="line">    p -&gt; func();  <span class="comment">//输出void Derived::func()</span></span><br><span class="line">    p -&gt; func(<span class="number">10</span>);  <span class="comment">//输出void Base::func(int)</span></span><br><span class="line">    p -&gt; func(<span class="string">"http://c.biancheng.net"</span>);  <span class="comment">//compile error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在基类 Base 中我们将<code>void func()</code>声明为虚函数，这样派生类 Derived 中的<code>void func()</code>就会自动成为虚函数。p 是基类 Base 的指针，但是指向了派生类 Derived 的对象。语句<code>p -&gt; func();</code>调用的是派生类的虚函数，构成了多态。语句<code>p -&gt; func(10);</code>调用的是基类的虚函数，因为派生类中没有函数遮蔽它。语句<code>p -&gt; func(&quot;http://c.biancheng.net&quot;);</code>出现编译错误，因为通过基类的指针只能访问从基类继承过去的成员，不能访问派生类新增的成员。 </p><h2 id="什么时候声明虚函数"><a href="#什么时候声明虚函数" class="headerlink" title="什么时候声明虚函数"></a>什么时候声明虚函数</h2><p>​        首先看成员函数所在的类是否会作为基类。然后看成员函数在类的继承后有无可能被更改功能，如果希望更改其功能的，一般应该将它声明为虚函数。如果成员函数在类被继承后功能不需修改，或派生类用不到该函数，则不要把它声明为虚函数。</p><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>​        上节我们讲到，<strong>构造函数不能是虚函数，因为派生类不能继承基类的构造函数，将构造函数声明为虚函数没有意义</strong>。</p><p>​        这是原因之一，另外还有一个原因：<strong>C++ 中的构造函数用于在创建对象时进行初始化工作，在执行构造函数之前对象尚未创建完成，虚函数表尚不存在，也没有指向虚函数表的指针，所以此时无法查询虚函数表，也就不知道要调用哪一个构造函数。</strong></p><p>​        <strong>析构函数用于在销毁对象时进行清理工作，可以声明为虚函数，而且有时候必须要声明为虚函数。</strong></p><p>​        为了说明虚析构函数的必要性，请大家先看下面一个例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base();</span><br><span class="line">    ~Base();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">&#125;;</span><br><span class="line">Base::Base()&#123;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base constructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Base::~Base()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] str;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived();</span><br><span class="line">    ~Derived();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line">Derived::Derived()&#123;</span><br><span class="line">    name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived constructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Derived::~Derived()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] name;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Base *pb = <span class="keyword">new</span> Derived();</span><br><span class="line">   <span class="keyword">delete</span> pb;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"-------------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   Derived *pd = <span class="keyword">new</span> Derived();</span><br><span class="line">   <span class="keyword">delete</span> pd;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Derived constructor</span><br><span class="line">Base destructor</span><br><span class="line">\-------------------</span><br><span class="line">Base constructor</span><br><span class="line">Derived constructor</span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br></pre></td></tr></table></figure></p><p>​        本例中定义了两个类，基类 Base 和派生类 Derived，它们都有自己的构造函数和析构函数。在构造函数中，会分配 100 个 char 类型的内存空间；在析构函数中，会把这些内存释放掉。</p><p>​        <code>pb</code>、<code>pd</code>分别是基类指针和派生类指针，它们都指向派生类对象，最后使用 delete 销毁 <code>pb</code>、<code>pd</code> 所指向的对象。</p><p>​        从运行结果可以看出，语句<code>delete pb;</code>只调用了基类的析构函数，没有调用派生类的析构函数；而语句<code>delete pd;</code>同时调用了派生类和基类的析构函数。</p><p>​        在本例中，不调用派生类的析构函数会导致 name 指向的 100 个 char 类型的内存空间得不到释放；除非程序运行结束由操作系统回收，否则就再也没有机会释放这些内存。这是典型的内存泄露。</p><p> 1) 为什么<code>delete pb;</code>不会调用派生类的析构函数呢？</p><p>​        因为这里的析构函数是非虚函数，通过指针访问非虚函数时，编译器会根据指针的类型来确定要调用的函数；也就是说，指针是哪个类就调用哪个类的函数，这在前面的章节中已经多次强调过。<code>pb</code> 是基类的指针，所以不管它指向基类的对象还是派生类的对象，始终都是调用基类的析构函数。</p><p> 2) 为什么<code>delete pd;</code>会同时调用派生类和基类的析构函数呢？</p><p>​        <code>pd</code>是派生类的指针，编译器会根据它的类型匹配到派生类的析构函数，在执行派生类的析构函数的过程中，又会调用基类的析构函数。派生类析构函数始终会调用基类的析构函数，并且这个过程是隐式完成的，</p><p>​        更改上面的代码，将基类的析构函数声明为虚函数： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base();</span><br><span class="line">    <span class="keyword">virtual</span> ~Base();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Derived constructor</span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br><span class="line">\-------------------</span><br><span class="line">Base constructor</span><br><span class="line">Derived constructor</span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br></pre></td></tr></table></figure></p><p>​        将基类的析构函数声明为虚函数后，派生类的析构函数也会自动成为虚函数。这个时候编译器会忽略指针的类型，而根据指针的指向来选择函数；也就是说，指针指向哪个类的对象就调用哪个类的函数。<code>pb</code>、<code>pd</code> 都指向了派生类的对象，所以会调用派生类的析构函数，继而再调用基类的析构函数。如此一来也就解决了内存泄露的问题。</p><p>​        在实际开发中，一旦我们自己定义了析构函数，就是希望在对象销毁时用它来进行清理工作，比如释放内存、关闭文件等，如果这个类又是一个基类，那么我们就必须将该析构函数声明为虚函数，否则就有内存泄露的风险。</p><p>也就是说，<strong>大部分情况下都应该将基类的析构函数声明为虚函数。</strong></p><p><strong>注意，这里强调的是基类，如果一个类是最终的类，那就没必要再声明为虚函数了。</strong></p><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>​        在C++中，可以将虚函数声明为<strong>纯虚函数</strong>，语法格式为： </p><blockquote><p>virtual 返回值类型 函数名 (函数参数) = 0;</p></blockquote><p>​        纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上<code>=0</code>，表明此函数为纯虚函数。 </p><blockquote><p> 最后的<code>=0</code>并不表示函数返回值为0，它只起形式上的作用，告诉编译系统“这是纯虚函数”。</p></blockquote><p>​        包含纯虚函数的类称为<strong>抽象类（Abstract Class）</strong>。之所以说它抽象，是因为它无法实例化，也就是无法创建对象。原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。</p><p>​        <strong>抽象类通常是作为基类，让派生类去实现纯虚函数。派生类必须实现纯虚函数才能被实例化。</strong></p><pre><code>纯虚函数使用举例： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Line(<span class="keyword">float</span> len);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">volume</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> m_len;</span><br><span class="line">&#125;;</span><br><span class="line">Line::Line(<span class="keyword">float</span> len): m_len(len)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rec</span>:</span> <span class="keyword">public</span> Line&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rec(<span class="keyword">float</span> len, <span class="keyword">float</span> width);</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> m_width;</span><br><span class="line">&#125;;</span><br><span class="line">Rec::Rec(<span class="keyword">float</span> len, <span class="keyword">float</span> width): Line(len), m_width(width)&#123; &#125;</span><br><span class="line"><span class="keyword">float</span> Rec::area()&#123; <span class="keyword">return</span> m_len * m_width; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//长方体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cuboid</span>:</span> <span class="keyword">public</span> Rec&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cuboid(<span class="keyword">float</span> len, <span class="keyword">float</span> width, <span class="keyword">float</span> height);</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">volume</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> m_height;</span><br><span class="line">&#125;;</span><br><span class="line">Cuboid::Cuboid(<span class="keyword">float</span> len, <span class="keyword">float</span> width, <span class="keyword">float</span> height): Rec(len, width), m_height(height)&#123; &#125;</span><br><span class="line"><span class="keyword">float</span> Cuboid::area()&#123; <span class="keyword">return</span> <span class="number">2</span> * ( m_len*m_width + m_len*m_height + m_width*m_height); &#125;</span><br><span class="line"><span class="keyword">float</span> Cuboid::volume()&#123; <span class="keyword">return</span> m_len * m_width * m_height; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正方体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cube</span>:</span> <span class="keyword">public</span> Cuboid&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cube(<span class="keyword">float</span> len);</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">volume</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Cube::Cube(<span class="keyword">float</span> len): Cuboid(len, len, len)&#123; &#125;</span><br><span class="line"><span class="keyword">float</span> Cube::area()&#123; <span class="keyword">return</span> <span class="number">6</span> * m_len * m_len; &#125;</span><br><span class="line"><span class="keyword">float</span> Cube::volume()&#123; <span class="keyword">return</span> m_len * m_len * m_len; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Line *p = <span class="keyword">new</span> Cuboid(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"The area of Cuboid is "</span>&lt;&lt;p-&gt;area()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"The volume of Cuboid is "</span>&lt;&lt;p-&gt;volume()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">    p = <span class="keyword">new</span> Cube(<span class="number">15</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"The area of Cube is "</span>&lt;&lt;p-&gt;area()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"The volume of Cube is "</span>&lt;&lt;p-&gt;volume()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The area of Cuboid is <span class="number">2200</span></span><br><span class="line">The volume of Cuboid is <span class="number">6000</span></span><br><span class="line">The area of Cube is <span class="number">1350</span></span><br><span class="line">The volume of Cube is <span class="number">3375</span></span><br></pre></td></tr></table></figure></p><p>​        本例中定义了四个类，它们的继承关系为：<code>Line --&gt; Rec --&gt; Cuboid --&gt; Cube</code>。</p><p>​        <code>Line</code> 是一个抽象类，也是最顶层的基类，在 Line 类中定义了两个纯虚函数 <code>area()</code> 和 <code>volume()</code>。</p><p>​        在 Rec 类中，实现了 area() 函数；所谓实现，就是定义了纯虚函数的函数体。但这时 Rec 仍不能被实例化，因为它没有实现继承来的 volume() 函数，volume() 仍然是纯虚函数，所以 Rec 也仍然是抽象类。</p><p>​        直到 Cuboid 类，才实现了 volume() 函数，才是一个完整的类，才可以被实例化。</p><p>​        可以发现，Line 类表示“线”，没有面积和体积，但它仍然定义了 area() 和 volume() 两个纯虚函数。这样的用意很明显：Line  类不需要被实例化，但是它为派生类提供了“约束条件”，派生类必须要实现这两个函数，完成计算面积和体积的功能，否则就不能实例化。</p><p>​        在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现（谁派生谁实现）。这部分未完成的功能，往往是基类不需要的，或者在基类中无法实现的。虽然抽象基类没有完成，但是却强制要求派生类完成，这就是抽象基类的“霸王条款”。</p><p>​        抽象基类除了约束派生类的功能，还可以实现多态。请注意第 51 行代码，指针 p  的类型是 Line，但是它却可以访问派生类中的 area() 和 volume() 函数，正是由于在 Line  类中将这两个函数定义为纯虚函数；如果不这样做，51 行后面的代码都是错误的。我想，这或许才是C++提供纯虚函数的主要目的。</p><h4 id="纯虚函数的说明"><a href="#纯虚函数的说明" class="headerlink" title="纯虚函数的说明"></a>纯虚函数的说明</h4><p> 1) 一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。</p><p> 2) 只有类中的虚函数才能被声明为<strong>纯虚函数</strong>，普通成员函数和顶层函数均不能声明为纯虚函数。如下例所示： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶层函数不能被声明为纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;   <span class="comment">//compile error</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="comment">//普通成员函数不能被声明为纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">//compile error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前面我们一再强调，当通过指针访问类的成员函数时： </p><ul><li>如果该函数是非虚函数，那么编译器会根据指针的类型找到该函数；也就是说，指针是哪个类的类型就调用哪个类的函数。</li><li>如果该函数是虚函数，并且派生类有同名的函数遮蔽它，那么编译器会根据指针的指向找到该函数；也就是说，指针指向的对象属于哪个类就调用哪个类的函数。这就是多态。</li></ul><p>​     </p><h2 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h2><p>​        编译器之所以能通过指针指向的对象找到虚函数，是因为在创建对象时额外地增加了虚函数表。</p><p>​        如果一个类包含了虚函数，那么在创建该类的对象时就会额外地增加一个数组，数组中的每一个元素都是虚函数的入口地址。不过数组和对象是分开存储的，为了将对象和数组关联起来，编译器还要在对象中安插一个指针，指向数组的起始位置。</p><p>​        这里的数组就是<strong>虚函数表（Virtual function table）</strong>，简写为<strong><code>vtable</code></strong>。</p><p>​        我们以下面的继承关系为例进行讲解： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//People类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    People(<span class="built_in">string</span> name, <span class="keyword">int</span> age);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eating</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line">People::People(<span class="built_in">string</span> name, <span class="keyword">int</span> age): m_name(name), m_age(age)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> People::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class People："</span>&lt;&lt;m_name&lt;&lt;<span class="string">"今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁了。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> People::eating()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class People：我正在吃饭，请不要跟我说话..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">examing</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line">Student::Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score):</span><br><span class="line">    People(name, age), m_score(score)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> Student::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class Student："</span>&lt;&lt;m_name&lt;&lt;<span class="string">"今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁了，考了"</span>&lt;&lt;m_score&lt;&lt;<span class="string">"分。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::examing()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class Student："</span>&lt;&lt;m_name&lt;&lt;<span class="string">"正在考试，请不要打扰T啊！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Senior类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Senior</span>:</span> <span class="keyword">public</span> Student&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Senior(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score, <span class="keyword">bool</span> hasJob);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">partying</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_hasJob;</span><br><span class="line">&#125;;</span><br><span class="line">Senior::Senior(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score, <span class="keyword">bool</span> hasJob):</span><br><span class="line">    Student(name, age, score), m_hasJob(hasJob)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> Senior::display()&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_hasJob)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class Senior："</span>&lt;&lt;m_name&lt;&lt;<span class="string">"以"</span>&lt;&lt;m_score&lt;&lt;<span class="string">"的成绩从大学毕业了，并且顺利找到了工作，Ta今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class Senior："</span>&lt;&lt;m_name&lt;&lt;<span class="string">"以"</span>&lt;&lt;m_score&lt;&lt;<span class="string">"的成绩从大学毕业了，不过找工作不顺利，Ta今年"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"岁。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Senior::partying()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class Senior：快毕业了，大家都在吃散伙饭..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    People *p = <span class="keyword">new</span> People(<span class="string">"赵红"</span>, <span class="number">29</span>);</span><br><span class="line">    p -&gt; display();</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">new</span> Student(<span class="string">"王刚"</span>, <span class="number">16</span>, <span class="number">84.5</span>);</span><br><span class="line">    p -&gt; display();</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">new</span> Senior(<span class="string">"李智"</span>, <span class="number">22</span>, <span class="number">92.0</span>, <span class="literal">true</span>);</span><br><span class="line">    p -&gt; display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class People：赵红今年<span class="number">29</span>岁了。</span><br><span class="line">Class Student：王刚今年<span class="number">16</span>岁了，考了<span class="number">84.5</span>分。</span><br><span class="line">Class Senior：李智以<span class="number">92</span>的成绩从大学毕业了，并且顺利找到了工作，Ta今年<span class="number">22</span>岁。</span><br></pre></td></tr></table></figure></p><p> 各个类的对象内存模型如下所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-161029110543X5.jpg" alt></p><p>​        图中左半部分是对象占用的内存，右半部分是虚函数表 <code>vtable</code>。在对象的开头位置有一个指针 <code>vfptr</code>，指向虚函数表，并且这个指针始终位于对象的开头位置。</p><p>​        仔细观察虚函数表，可以发现基类的虚函数在 <code>vtable</code> 中的索引（下标）是固定的，不会随着继承层次的增加而改变，派生类新增的虚函数放在  <code>vtable</code> 的最后。如果派生类有同名的虚函数遮蔽（覆盖）了基类的虚函数，那么将使用派生类的虚函数替换基类的虚函数，这样具有遮蔽关系的虚函数在  <code>vtable</code> 中只会出现一次。</p><p>​        当通过指针调用虚函数时，先根据指针找到 <code>vfptr</code>，再根据 <code>vfptr</code> 找到虚函数的入口地址。以虚函数 display() 为例，它在 <code>vtable</code> 中的索引为 0，通过 p 调用时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; display();</span><br></pre></td></tr></table></figure></p><pre><code>编译器内部会发生类似下面的转换： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( *( *(p+<span class="number">0</span>) + <span class="number">0</span> ) )(p);</span><br></pre></td></tr></table></figure><p> 下面我们一步一步来分析这个表达式： </p><ul><li><code>0</code>是 <code>vfptr</code> 在对象中的偏移，<code>p+0</code>是 <code>vfptr</code> 的地址；</li><li><code>*(p+0)</code>是 <code>vfptr</code> 的值，而 <code>vfptr</code> 是指向 <code>vtable</code> 的指针，所以<code>*(p+0)</code>也就是 <code>vtable</code> 的地址；</li><li>display() 在 <code>vtable</code> 中的索引（下标）是 0，所以<code>( *(p+0) + 0 )</code>也就是 <code>display()</code> 的地址；</li><li>知道了 <code>display()</code> 的地址，<code>( *( *(p+0) + 0 ) )(p)</code>也就是对 <code>display()</code> 的调用了，这里的 p 就是传递的实参，它会赋值给 this 指针。</li></ul><p>​       可以看到，转换后的表达式是固定的，只要调用 display() 函数，不管它是哪个类的，都会使用这个表达式。换句话说，编译器不管 p 指向哪里，一律转换为相同的表达式。</p><p>​       转换后的表达式没有用到与 p 的类型有关的信息，只要知道 p 的指向就可以调用函数，这跟名字编码（Name Mangling）算法有着本质上的区别。</p><p>​        再来看一下 eating() 函数，它在 <code>vtable</code> 中的索引为 1，通过 p 调用时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; eating();</span><br></pre></td></tr></table></figure></p><pre><code>编译器内部会发生类似下面的转换： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( *( *(p+<span class="number">0</span>) + <span class="number">1</span> ) )(p);</span><br></pre></td></tr></table></figure><p>​        对于不同的虚函数，仅仅改变索引（下标）即可。</p><p>​        以上是针对单继承进行的讲解。当存在多继承时，虚函数表的结构就会变得复杂，尤其是有虚继承时，还会增加虚基类表，更加让人抓狂，这里我们就不分析了，有兴趣的读者可以自行研究。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为&lt;strong&gt;多态（Polymorphism）&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="c++_language" scheme="http://yoursite.com/categories/c-language/"/>
    
    
      <category term="c++_language" scheme="http://yoursite.com/tags/c-language/"/>
    
  </entry>
  
  <entry>
    <title>C++向上转型</title>
    <link href="http://yoursite.com/2019/05/25/C++%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/05/25/C++向上转型/</id>
    <published>2019-05-25T09:26:02.000Z</published>
    <updated>2019-10-21T02:40:55.721Z</updated>
    
    <content type="html"><![CDATA[<p>  在 C/C++ 中经常会发生数据类型的转换，例如将 int 类型的数据赋值给 float 类型的变量时，编译器会先把 int 类型的数据转换为 float 类型再赋值；反过来，float 类型的数据在经过类型转换后也可以赋值给 int 类型的变量。</p><a id="more"></a><pre><code>数据类型转换的前提是，编译器知道如何对数据进行取舍。例如： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10.9</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br></pre></td></tr></table></figure><pre><code>输出结果为 10，编译器会将小数部分直接丢掉（不是四舍五入）。再如： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, b);</span><br></pre></td></tr></table></figure><pre><code>输出结果为 10.000000，编译器会自动添加小数部分。</code></pre><p>​        <strong>类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为向上转型（Upcasting）。相应地，将基类赋值给派生类称为向下转型（Downcasting）</strong>。</p><p>​        <strong>向上转型非常安全，可以由编译器自动完成；向下转型有风险，需要程序员手动干预</strong>。</p><blockquote><p> 向上转型和向下转型是面向对象编程的一种通用概念，它们也存在于 Java、C# 等编程语言中。</p></blockquote><h2 id="将派生类对象赋值给基类对象"><a href="#将派生类对象赋值给基类对象" class="headerlink" title="将派生类对象赋值给基类对象"></a>将派生类对象赋值给基类对象</h2><pre><code>下面的例子演示了如何将派生类对象赋值给基类对象： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a): m_a(a)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> A::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class A: m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">B::B(<span class="keyword">int</span> a, <span class="keyword">int</span> b): A(a), m_b(b)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> B::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class B: m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="string">", m_b="</span>&lt;&lt;m_b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">66</span>, <span class="number">99</span>)</span></span>;</span><br><span class="line">    <span class="comment">//赋值前</span></span><br><span class="line">    a.display();</span><br><span class="line">    b.display();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"--------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//赋值后</span></span><br><span class="line">    a = b;</span><br><span class="line">    a.display();</span><br><span class="line">    b.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class A: m_a=<span class="number">10</span></span><br><span class="line">Class B: m_a=<span class="number">66</span>, m_b=<span class="number">99</span></span><br><span class="line">\----------------------------</span><br><span class="line">Class A: m_a=<span class="number">66</span></span><br><span class="line">Class B: m_a=<span class="number">66</span>, m_b=<span class="number">99</span></span><br></pre></td></tr></table></figure></p><p>​        本例中 A 是基类， B 是派生类，a、b 分别是它们的对象，由于派生类 B 包含了从基类 A 继承来的成员，因此可以将派生类对象 b 赋值给基类对象 a。通过运行结果也可以发现，赋值后 a 所包含的成员变量的值已经发生了变化。</p><p>​        <strong>赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了成员变量，所以对象之间的赋值是成员变量的赋值，成员函数不存在赋值问题</strong>。</p><p>​        运行结果也有力地证明了这一点，虽然有<code>a=b;</code>这样的赋值过程，但是 <code>a.display()</code> 始终调用的都是 A 类的 <code>display()</code>函数。换句话说，对象之间的赋值不会影响成员函数，也不会影响 this 指针。</p><p>​         将派生类对象赋值给基类对象时，会舍弃派生类新增的成员，也就是“大材小用”，如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-150S121411IQ.png" alt></p><p>​        可以发现，即使将派生类对象赋值给基类对象，基类对象也不会包含派生类的成员，所以依然不同通过基类对象来访问派生类的成员。对于上面的例子，<code>a.m_a</code> 是正确的，但 <code>a.m_b</code> 就是错误的，因为 a 不包含成员 <code>m_b</code>。</p><p>​        <strong>这种转换关系是不可逆的，只能用派生类对象给基类对象赋值，而不能用基类对象给派生类对象赋值</strong>。</p><p>​        理由很简单，基类不包含派生类的成员变量，无法对派生类的成员变量赋值。同理，同一基类的不同派生类对象之间也不能赋值。</p><p>​        要理解这个问题，还得从赋值的本质入手。赋值实际上是向内存填充数据，当数据较多时很好处理，舍弃即可；本例中将 b 赋值给 a 时（执行<code>a=b;</code>语句），成员 <code>m_b</code> 是多余的，会被直接丢掉，所以不会发生赋值错误。但当数据较少时，问题就很棘手，编译器不知道如何填充剩下的内存；如果本例中有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b= a;</span><br></pre></td></tr></table></figure><p>​        这样的语句，编译器就不知道该如何给变量 m_b 赋值，所以会发生错误。</p><h2 id="将派生类指针赋值给基类指针"><a href="#将派生类指针赋值给基类指针" class="headerlink" title="将派生类指针赋值给基类指针"></a>将派生类指针赋值给基类指针</h2><p>​        除了可以将派生类对象赋值给基类对象（对象变量之间的赋值），还可以将派生类指针赋值给基类指针（对象指针之间的赋值）。我们先来看一个多继承的例子，继承关系为： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-161023202054F5.jpg" alt></p><pre><code>下面的代码实现了这种继承关系： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a): m_a(a)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> A::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class A: m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间派生类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">B::B(<span class="keyword">int</span> a, <span class="keyword">int</span> b): A(a), m_b(b)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> B::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class B: m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="string">", m_b="</span>&lt;&lt;m_b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C(<span class="keyword">int</span> c);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line">C::C(<span class="keyword">int</span> c): m_c(c)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> C::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class C: m_c="</span>&lt;&lt;m_c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终派生类D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line">D::D(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d): B(a, b), C(c), m_d(d)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> D::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Class D: m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="string">", m_b="</span>&lt;&lt;m_b&lt;&lt;<span class="string">", m_c="</span>&lt;&lt;m_c&lt;&lt;<span class="string">", m_d="</span>&lt;&lt;m_d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *pa = <span class="keyword">new</span> A(<span class="number">1</span>);</span><br><span class="line">    B *pb = <span class="keyword">new</span> B(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">    C *pc = <span class="keyword">new</span> C(<span class="number">3</span>);</span><br><span class="line">    D *pd = <span class="keyword">new</span> D(<span class="number">4</span>, <span class="number">40</span>, <span class="number">400</span>, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    pa = pd;</span><br><span class="line">    pa -&gt; display();</span><br><span class="line"></span><br><span class="line">    pb = pd;</span><br><span class="line">    pb -&gt; display();</span><br><span class="line"></span><br><span class="line">    pc = pd;</span><br><span class="line">    pc -&gt; display();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"-----------------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pa="</span>&lt;&lt;pa&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pb="</span>&lt;&lt;pb&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pc="</span>&lt;&lt;pc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pd="</span>&lt;&lt;pd&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class A: m_a=<span class="number">4</span></span><br><span class="line">Class B: m_a=<span class="number">4</span>, m_b=<span class="number">40</span></span><br><span class="line">Class C: m_c=<span class="number">400</span></span><br><span class="line">\-----------------------</span><br><span class="line">pa=<span class="number">0x9b17f8</span></span><br><span class="line">pb=<span class="number">0x9b17f8</span></span><br><span class="line">pc=<span class="number">0x9b1800</span></span><br><span class="line">pd=<span class="number">0x9b17f8</span></span><br></pre></td></tr></table></figure></p><p>​        本例中定义了多个对象指针，并尝试将派生类指针赋值给基类指针。与对象变量之间的赋值不同的是，对象指针之间的赋值并没有拷贝对象的成员，也没有修改对象本身的数据，仅仅是改变了指针的指向。</p><h4 id="1-通过基类指针访问派生类的成员"><a href="#1-通过基类指针访问派生类的成员" class="headerlink" title="1) 通过基类指针访问派生类的成员"></a>1) 通过基类指针访问派生类的成员</h4><p>​        请读者先关注第 68 行代码，我们将派生类指针 pd 赋值给了基类指针 pa，从运行结果可以看出，调用 display()  函数时虽然使用了派生类的成员变量，但是 display()  函数本身却是基类的。也就是说，将派生类指针赋值给基类指针时，通过基类指针只能使用派生类的成员变量，但不能使用派生类的成员函数，这看起来有点不伦不类，究竟是为什么呢？第  71、74 行代码也是类似的情况。</p><p>​        pa 本来是基类 A 的指针，现在指向了派生类 D 的对象，这使得隐式指针 this 发生了变化，也指向了 D 类的对象，所以最终在 display() 内部使用的是 D 类对象的成员变量，相信这一点不难理解。</p><p>​        编译器虽然通过指针的指向来访问成员变量，但是却不通过指针的指向来访问成员函数：编译器通过指针的类型来访问成员函数。对于 pa，它的类型是 A，不管它指向哪个对象，使用的都是 A 类的成员函数。</p><p>​        概括起来说就是：<strong>编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数</strong>。</p><h4 id="2-赋值后值不一致的情况"><a href="#2-赋值后值不一致的情况" class="headerlink" title="2) 赋值后值不一致的情况"></a>2) 赋值后值不一致的情况</h4><p>​        本例中我们将最终派生类的指针 pd 分别赋值给了基类指针 pa、pb、pc，按理说它们的值应该相等，都指向同一块内存，但是运行结果却有力地反驳了这种推论，只有 pa、pb、pd 三个指针的值相等，pc 的值比它们都大。也就是说，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pc = pd;</span><br></pre></td></tr></table></figure><p>语句后，pc 和 pd 的值并不相等。</p><p>​        这非常出乎我们的意料，按照我们通常的理解，赋值就是将一个变量的值交给另外一个变量，不会出现不相等的情况，究竟是什么导致了 pc 和 pd 不相等呢？</p><h2 id="将派生类引用赋值给基类引用"><a href="#将派生类引用赋值给基类引用" class="headerlink" title="将派生类引用赋值给基类引用"></a>将派生类引用赋值给基类引用</h2><p>​        引用在本质上是通过指针的方式实现的，既然基类的指针可以指向派生类的对象，那么我们就有理由推断：<strong>基类的引用也可以指向派生类的对象，并且它的表现和指针是类似的</strong>。</p><pre><code>修改上例中 main() 函数内部的代码，用引用取代指针： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">4</span>, <span class="number">40</span>, <span class="number">400</span>, <span class="number">4000</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">    A &amp;ra = d;</span><br><span class="line">    B &amp;rb = d;</span><br><span class="line">    C &amp;rc = d;</span><br><span class="line">   </span><br><span class="line">    ra.display();</span><br><span class="line">    rb.display();</span><br><span class="line">    rc.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class A: m_a=<span class="number">4</span></span><br><span class="line">Class B: m_a=<span class="number">4</span>, m_b=<span class="number">40</span></span><br><span class="line">Class C: m_c=<span class="number">400</span></span><br></pre></td></tr></table></figure></p><p>​        ra、rb、rc 是基类的引用，它们都引用了派生类对象 d，并调用了 display() 函数，从运行结果可以发现，虽然使用了派生类对象的成员变量，但是却没有使用派生类的成员函数，这和指针的表现是一样的。</p><p>​        引用和指针的表现之所以如此类似，是因为引用和指针并没有本质上的区别，引用仅仅是对指针进行了简单封装。</p><p>​        最后需要注意的是，向上转型后通过基类的对象、指针、引用只能访问从基类继承过去的成员（包括成员变量和成员函数），不能访问派生类新增的成员。</p><h2 id="将派生类指针赋值给基类指针时到底发生了什么"><a href="#将派生类指针赋值给基类指针时到底发生了什么" class="headerlink" title="将派生类指针赋值给基类指针时到底发生了什么"></a>将派生类指针赋值给基类指针时到底发生了什么</h2><p>​        通过上节最后一个例子我们发现，将派生类的指针赋值给基类的指针后，它们的值有可能相等，也有可能不相等。例如执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pc = pd;</span><br></pre></td></tr></table></figure><p>​        语句后，<code>pc</code> 的值为 <code>0x9b1800</code>，<code>pd</code> 的值为 <code>0x9b17f8</code>，它们不相等。</p><p>​        我们通常认为，赋值就是将一个变量的值交给另外一个变量，这种想法虽然没错，但是有一点要注意，就是赋值以前编译器可能会对现有的值进行处理。例如将  double 类型的值赋给 int 类型的变量，编译器会直接抹掉小数部分，导致赋值运算符两边变量的值不相等。请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="keyword">int</span> n = pi;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pi&lt;&lt;<span class="string">", "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14159</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>​        pi 的值是 3.14159，执行<code>int n = pi;</code>后 n 的值变为 3，虽然是赋值，但是 pi 和 n 的值并不相等。将派生类的指针赋值给基类的指针时也是类似的道理，编译器也可能会在赋值前进行处理。</p><p>​        要理解这个问题，首先要清楚 D 类对象的内存模型，如下图所示： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-16102511030U35.jpg" alt></p><p>​        首先要明确的一点是，对象的指针必须要指向对象的起始位置。</p><p>​        对于 A 类和 B  类来说，它们的子对象的起始地址和 D 类对象一样，所以将 pd 赋值给 pa、<code>pb</code> 时不需要做任何调整，直接传递现有的值即可；而 C  类子对象距离 D 类对象的开头有一定的偏移，将 pd 赋值给 pa 时要加上这个偏移，这样 <code>pc</code> 才能指向 C  类子对象的起始位置。也就是说，执行<code>pc = pd;</code>语句时编译器对 pd 的值进行了调整，才导致 <code>pc</code>、pd 的值不同。</p><p>​        下面的代码演示了将 pd 赋值给 <code>pc</code> 时编译器的调整过程： </p><p><code>pc = (C*)( (int)pd + sizeof(B) );</code></p><p>​        如果我们把 B、C 类的继承顺序调整一下，让 C 在 B 前面，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C, <span class="keyword">public</span> B</span><br></pre></td></tr></table></figure></p><p>​        那么输出结果就会变为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pa=<span class="number">0x317fc</span></span><br><span class="line">pb=<span class="number">0x317fc</span></span><br><span class="line">pc=<span class="number">0x317f8</span></span><br><span class="line">pd=<span class="number">0x317f8</span></span><br></pre></td></tr></table></figure></p><p>​        相信聪明的你能够自行分析出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  在 C/C++ 中经常会发生数据类型的转换，例如将 int 类型的数据赋值给 float 类型的变量时，编译器会先把 int 类型的数据转换为 float 类型再赋值；反过来，float 类型的数据在经过类型转换后也可以赋值给 int 类型的变量。&lt;/p&gt;
    
    </summary>
    
      <category term="c++_language" scheme="http://yoursite.com/categories/c-language/"/>
    
    
      <category term="c++_language" scheme="http://yoursite.com/tags/c-language/"/>
    
  </entry>
  
  <entry>
    <title>c++拷贝构造函数</title>
    <link href="http://yoursite.com/2019/05/25/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/05/25/c++拷贝构造函数/</id>
    <published>2019-05-25T09:21:02.000Z</published>
    <updated>2019-10-21T02:40:46.957Z</updated>
    
    <content type="html"><![CDATA[<p>  <strong>拷贝</strong>和<strong>复制</strong>是一个意思，对应的英文单词都是<code>copy</code>。对于计算机来说，<strong>拷贝是指用一份原有的、已经存在的数据创建出一份新的数据，最终的结果是多了一份相同的数据</strong>。</p><a id="more"></a><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>​        例如，将 Word 文档拷贝到U盘去复印店打印，将 D 盘的图片拷贝到桌面以方便浏览，将重要的文件上传到百度网盘以防止丢失等，都是「创建一份新数据」的意思。</p><p>​        在 C++ 中，拷贝并没有脱离它本来的含义，只是将这个含义进行了“特化”，是指用已经存在的对象创建出一个新的对象。从本质上讲，对象也是一份数据，因为它会占用内存。</p><p>​        严格来说，对象的创建包括两个阶段，首先要<strong>分配内存空间</strong>，然后再进行<strong>初始化</strong>： </p><ul><li><strong>分配内存</strong>很好理解，就是在堆区、栈区或者全局数据区留出足够多的字节。这个时候的内存还比较“原始”，没有被“教化”，它所包含的数据一般是零值或者随机值，没有实际的意义。</li><li><strong>初始化</strong>就是首次对内存赋值，让它的数据有意义。注意是首次赋值，再次赋值不叫初始化。初始化的时候还可以为对象分配其他的资源（打开文件、连接网络、动态分配内存等），或者提前进行一些计算（根据价格和数量计算出总价、根据长度和宽度计算出矩形的面积等）等。说白了，初始化就是调用构造函数。</li></ul><p>​      <strong>很明显，这里所说的拷贝是在初始化阶段进行的，也就是用其它对象的数据来初始化新对象的内存。</strong></p><p>​        那么，如何用拷贝的方式来初始化一个对象呢？其实这样的例子比比皆是，string 类就是一个典型的例子。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"http://c.biancheng.net"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> s3 = s1;</span><br><span class="line">    <span class="built_in">string</span> s4 = s1 + <span class="string">" "</span> + s2;</span><br><span class="line">    func(s1);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s3&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s4&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net http://c.biancheng.net</span></span><br></pre></td></tr></table></figure></p><p>​        <code>s1</code>、<code>s2</code>、<code>s3</code>、<code>s4</code> 以及 <code>func()</code> 的形参<code>str</code>，都是使用拷贝的方式来初始化的。 </p><blockquote><p> 对于 s1，表面上看起来是将一个字符串直接赋值给了 s1，实际上在内部进行了类型转换，将 const char * 类型转换为 string 类型后才赋值的，s4 也是类似的道理。</p></blockquote><p>​        对于<code>s1</code>、<code>s2</code>、<code>s3</code>、<code>s4</code>，都是将其它对象的数据拷贝给当前对象，以完成当前对象的初始化。</p><p>​        对于<code>func()</code> 的形参 <code>str</code>，其实在定义时就为它分配了内存，但是此时并没有初始化，只有等到调用<code>func()</code> 时，才会将其它对象的数据拷贝给 <code>str</code>以完成初始化。</p><p>​        当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是拷贝构造函数（Copy Constructor）。</p><p>​        下面的例子演示了拷贝构造函数的定义和使用： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name = <span class="string">""</span>, <span class="keyword">int</span> age = <span class="number">0</span>, <span class="keyword">float</span> score = <span class="number">0.0f</span>);  <span class="comment">//普通构造函数</span></span><br><span class="line">    Student(<span class="keyword">const</span> Student &amp;stu);  <span class="comment">//拷贝构造函数（声明）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数（定义）</span></span><br><span class="line">Student::Student(<span class="keyword">const</span> Student &amp;stu)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_name = stu.m_name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_age = stu.m_age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_score = stu.m_score;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy constructor was called."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Student::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">    Student stu2 = stu1;  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    <span class="function">Student <span class="title">stu3</span><span class="params">(stu1)</span></span>;  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    stu1.display();</span><br><span class="line">    stu2.display();</span><br><span class="line">    stu3.display();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>运行结果：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copy constructor was called.</span><br><span class="line">Copy constructor was called.</span><br><span class="line">小明的年龄是<span class="number">16</span>，成绩是<span class="number">90.5</span></span><br><span class="line">小明的年龄是<span class="number">16</span>，成绩是<span class="number">90.5</span></span><br><span class="line">小明的年龄是<span class="number">16</span>，成绩是<span class="number">90.5</span></span><br></pre></td></tr></table></figure><p>​        第 8 行是拷贝构造函数的声明，第 20 行是拷贝构造函数的定义。拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 <code>const</code>引用。 </p><h4 id="1-为什么必须是当前类的引用呢？"><a href="#1-为什么必须是当前类的引用呢？" class="headerlink" title="1) 为什么必须是当前类的引用呢？"></a>1) 为什么必须是当前类的引用呢？</h4><p>​        如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。</p><p>​        只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是 C++ 语法的要求。 </p><h4 id="2-为什么是-const-引用呢？"><a href="#2-为什么是-const-引用呢？" class="headerlink" title="2) 为什么是 const 引用呢？"></a>2) 为什么是 const 引用呢？</h4><p>​        拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 <code>const</code> 限制后，这个含义更加明确了。</p><p>​        另外一个原因是，添加 <code>const</code> 限制后，可以将 <code>const</code> 对象和非 <code>const</code> 对象传递给形参了，因为非<code>const</code> 类型可以转换为  <code>const</code> 类型。如果没有 <code>const</code> 限制，就不能将 <code>const</code> 对象传递给形参，因为<code>const</code>类型不能转换为非 <code>const</code>类型，这就意味着，不能使用 <code>const</code>对象来初始化当前对象了。</p><p>​        以上面的 Student 类为例，将<code>const</code> 去掉后，拷贝构造函数的原型变为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student::Student(Student &amp;stu);</span><br></pre></td></tr></table></figure></p><p>​        此时，下面的代码就会发生错误： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">Student stu2 = stu1;</span><br><span class="line"><span class="function">Student <span class="title">stu3</span><span class="params">(stu1)</span></span>;</span><br></pre></td></tr></table></figure><p>​        <code>stu1</code> 是 <code>const</code> 类型，在初始化 <code>stu2</code>、<code>stu3</code> 时，编译器希望调用<code>Student::Student(const Student &amp;stu)</code>，但是这个函数却不存在，又不能将 <code>const Student</code> 类型转换为 Student 类型去调用<code>Student::Student(Student &amp;stu)</code>，所以最终调用失败了。</p><p>​        当然，你也可以再添加一个参数为 <code>const</code> 引用的拷贝构造函数，这样就不会出错了。换句话说，一个类可以同时存在两个拷贝构造函数，一个函数的参数为 <code>const</code>引用，另一个函数的参数为非 <code>const</code> 引用。 </p><h2 id="默认拷贝构造函数"><a href="#默认拷贝构造函数" class="headerlink" title="默认拷贝构造函数"></a>默认拷贝构造函数</h2><p>​        在前面的教程中，我们还没有讲解拷贝构造函数，但是却已经在使用拷贝的方式创建对象了，并且也没有引发什么错误。这是因为，如果程序员没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数。这个默认的拷贝构造函数很简单，就是使用“老对象”的成员变量对“新对象”的成员变量进行一一赋值，和上面  Student 类的拷贝构造函数非常类似。</p><p>​        对于简单的类，默认拷贝构造函数一般是够用的，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认拷贝构造函数就不能拷贝这些资源，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据</p><h2 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h2><p>​        当以拷贝的方式初始化对象时会调用拷贝构造函数。这里有两个关键点，分别是<strong>「以拷贝的方式」</strong>和<strong>「初始化对象」</strong>。 </p><h3 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h3><p>​        初始化对象是指，为对象分配内存后第一次向内存中填充数据，这个过程会调用构造函数。对象被创建后必须立即被初始化，换句话说，只要创建对象，就会调用构造函数。</p><h3 id="初始化和赋值的区别"><a href="#初始化和赋值的区别" class="headerlink" title="初始化和赋值的区别"></a>初始化和赋值的区别</h3><p>​        <strong>初始化</strong>和<strong>赋值</strong>都是将数据写入内存中，并且从表面上看起来，初始化在很多时候都是以赋值的方式来实现的，所以很容易混淆。请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;  <span class="comment">//以赋值的方式初始化</span></span><br><span class="line">a = <span class="number">200</span>;  <span class="comment">//赋值</span></span><br><span class="line">a = <span class="number">300</span>;  <span class="comment">//赋值</span></span><br><span class="line"><span class="keyword">int</span> b;  <span class="comment">//默认初始化</span></span><br><span class="line">b = <span class="number">29</span>;  <span class="comment">//赋值</span></span><br><span class="line">b = <span class="number">39</span>;  <span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><p>​        <strong>在定义的同时进行赋值叫做初始化（Initialization）</strong>，<strong>定义完成以后再赋值（不管在定义的时候有没有赋值）就叫做赋值（Assignment）</strong>。<strong>初始化只能有一次，赋值可以有多次</strong>。</p><p>​        对于基本类型的数据，我们很少会区分「初始化」和「赋值」这两个概念，即使将它们混淆，也不会出现什么错误。但是对于类，它们的区别就非常重要了，因为初始化时会调用构造函数（以拷贝的方式初始化时会调用拷贝构造函数），而赋值时会调用重载过的赋值运算符。请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name = <span class="string">""</span>, <span class="keyword">int</span> age = <span class="number">0</span>, <span class="keyword">float</span> score = <span class="number">0.0f</span>);  <span class="comment">//普通构造函数</span></span><br><span class="line">    Student(<span class="keyword">const</span> Student &amp;stu);  <span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Student &amp;stu);  <span class="comment">//重载=运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line">Student::Student(<span class="keyword">const</span> Student &amp;stu)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_name = stu.m_name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_age = stu.m_age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_score = stu.m_score;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy constructor was called."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载=运算符</span></span><br><span class="line">Student &amp; Student::<span class="keyword">operator</span>=(<span class="keyword">const</span> Student &amp;stu)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_name = stu.m_name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_age = stu.m_age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_score = stu.m_score;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"operator=() was called."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Student::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//stu1、stu2、stu3都会调用普通构造函数Student(string name, int age, float score)</span></span><br><span class="line">    <span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">stu2</span><span class="params">(<span class="string">"王城"</span>, <span class="number">17</span>, <span class="number">89.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">stu3</span><span class="params">(<span class="string">"陈晗"</span>, <span class="number">18</span>, <span class="number">98.0</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">    Student stu4 = stu1;  <span class="comment">//调用拷贝构造函数Student(const Student &amp;stu)</span></span><br><span class="line">    stu4 = stu2;  <span class="comment">//调用operator=()</span></span><br><span class="line">    stu4 = stu3;  <span class="comment">//调用operator=()</span></span><br><span class="line">   </span><br><span class="line">    Student stu5;  <span class="comment">//调用普通构造函数Student()</span></span><br><span class="line">    stu5 = stu1;  <span class="comment">//调用operator=()</span></span><br><span class="line">    stu5 = stu2;  <span class="comment">//调用operator=()</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>运行结果：</code></pre> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copy constructor was called.</span><br><span class="line"><span class="keyword">operator</span>=() was called.</span><br><span class="line"><span class="keyword">operator</span>=() was called.</span><br><span class="line"><span class="keyword">operator</span>=() was called.</span><br><span class="line"><span class="keyword">operator</span>=() was called.</span><br></pre></td></tr></table></figure><h3 id="以拷贝的方式初始化对象"><a href="#以拷贝的方式初始化对象" class="headerlink" title="以拷贝的方式初始化对象"></a>以拷贝的方式初始化对象</h3><p>​    初始化对象时会调用构造函数，不同的初始化方式会调用不同的构造函数： </p><ul><li><strong>如果用传递进来的实参初始化对象，那么会调用普通的构造函数，我们不妨将此称为普通初始化；</strong></li><li><strong>如果用其它对象（现有对象）的数据来初始化对象，那么会调用拷贝构造函数，这就是以拷贝的方式初始化。</strong></li></ul><p>在实际编程中，具体有哪些情况是以拷贝的方式来初始化对象呢？ </p><h4 id="1-将其它对象作为实参"><a href="#1-将其它对象作为实参" class="headerlink" title="1) 将其它对象作为实参"></a>1) 将其它对象作为实参</h4><p>​        以上面的 Student 类为例，我们可以这样来创建一个新的对象： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;  <span class="comment">//普通初始化</span></span><br><span class="line"><span class="function">Student <span class="title">stu2</span><span class="params">(stu1)</span></span>;  <span class="comment">//以拷贝的方式初始化</span></span><br></pre></td></tr></table></figure><p>​        即使我们不在类中显式地定义拷贝构造函数，这种初始化方式也是有效的，因为编译器会生成默认的拷贝构造函数。 </p><h4 id="2-在创建对象的同时赋值"><a href="#2-在创建对象的同时赋值" class="headerlink" title="2) 在创建对象的同时赋值"></a>2) 在创建对象的同时赋值</h4><p>​        接着使用 Student 类，请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;  <span class="comment">//普通初始化</span></span><br><span class="line">Student stu2 = stu1;  <span class="comment">//以拷贝的方式初始化</span></span><br></pre></td></tr></table></figure><p>​        这是最常见的一种以拷贝的方式初始化对象的情况，非常容易理解，我们也已经多次使用。 </p><h4 id="3-函数的形参为类类型"><a href="#3-函数的形参为类类型" class="headerlink" title="3) 函数的形参为类类型"></a>3) 函数的形参为类类型</h4><p>​        如果函数的形参为类类型（也就是一个对象），那么调用函数时要将另外一个对象作为实参传递进来赋值给形参，这也是以拷贝的方式初始化形参对象。请看下面的代码： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Student s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;  <span class="comment">//普通初始化</span></span><br><span class="line">func(stu);  <span class="comment">//以拷贝的方式初始化</span></span><br></pre></td></tr></table></figure><pre><code>`func() `函数有一个 Student 类型的形参 s，将实参 `stu `传递给形参 s 就是以拷贝的方式初始化的过程。</code></pre><p>​        函数是一段可以重复使用的代码，只有等到真正调用函数时才会为局部数据（形参和局部变量）在栈上分配内存。对于上面的<code>func()</code>，虽然它的形参 s  是一个对象，但在定义函数时 s 对象并没有被创建，只有等到调用函数时才会真正地创建 s 对象，并在栈上为它分配内存。而创建 s  对象，就是以拷贝的方式进行的，它等价于下面的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student s = stu;</span><br></pre></td></tr></table></figure></p><h4 id="4-函数返回值为类类型"><a href="#4-函数返回值为类类型" class="headerlink" title="4) 函数返回值为类类型"></a>4) 函数返回值为类类型</h4><p>​        当函数的返回值为类类型时，return  语句会返回一个对象，不过为了防止局部对象被销毁，也为了防止通过返回值修改原来的局部对象，编译器并不会直接返回这个对象，而是根据这个对象先创建出一个临时对象（匿名对象），再将这个临时对象返回。而创建临时对象的过程，就是以拷贝的方式进行的，会调用拷贝构造函数。</p><p> 下面的代码演示了返回一个对象的情形： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student stu = func();</span><br></pre></td></tr></table></figure><p>​        理论上讲，运行代码后会调用两次拷贝构造函数，一次是返回 s 对象时，另外一次是创建 stu 对象时。</p><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>​        对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存。例如： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(): m_a(<span class="number">0</span>), m_b(<span class="number">0</span>)&#123; &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = a;  <span class="comment">//拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Base <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    Base obj2 = obj1;  <span class="comment">//拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        b 和 <code>obj2</code>都是以拷贝的方式初始化的，具体来说，就是将 a 和 <code>obj1</code>所在内存中的数据按照二进制位（Bit）复制到 b 和 <code>obj2</code> 所在的内存，这种默认的拷贝行为就是浅拷贝，这和调用 <code>memcpy()</code>函数的效果非常类似。</p><p>​        对于简单的类，默认的拷贝构造函数一般就够用了，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，例如动态分配的内存、指向其他数据的指针等，默认的拷贝构造函数就不能拷贝这些资源了，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。</p><p>​        下面我们通过一个具体的例子来说明显式定义拷贝构造函数的必要性。我们知道，有些较老的编译器不支持变长数组，例如 <code>VC6.0</code>、<code>VS2010</code> 等，这有时候会给编程带来不便，下面我们通过自定义的 Array 类来实现变长数组。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变长数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> len);</span><br><span class="line">    Array(<span class="keyword">const</span> Array &amp;arr);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~Array();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（读取）</span></span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（写入）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_len; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">int</span> len): m_len(len)&#123;</span><br><span class="line">    m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">const</span> Array &amp;arr)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::~Array()&#123; <span class="built_in">free</span>(m_p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">const</span> Array &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">arr1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        arr1[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    Array arr2 = arr1;</span><br><span class="line">    arr2[<span class="number">5</span>] = <span class="number">100</span>;</span><br><span class="line">    arr2[<span class="number">3</span>] = <span class="number">29</span>;</span><br><span class="line">   </span><br><span class="line">    printArray(arr1);</span><br><span class="line">    printArray(arr2);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>​        本例中我们显式地定义了拷贝构造函数，它除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来。这样做的结果是，原有对象和新对象所持有的动态内存是相互独立的，更改一个对象的数据不会影响另外一个对象，本例中我们更改了  <code>arr2</code>的数据，就没有影响 <code>arr1</code>。</p><p>​        <strong>这种将对象所持有的其它资源一并拷贝的行为叫做深拷贝，我们必须显式地定义拷贝构造函数才能达到深拷贝的目的</strong>。</p><p>​        深拷贝的例子比比皆是，除了上面的变长数组类，标准模板库（<code>STL</code>）中的 string、vector、stack、set、map 等也都必须使用深拷贝。</p><p>​        读者如果希望亲眼目睹不使用深拷贝的后果，可以将上例中的拷贝构造函数删除，那么运行结果将变为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>​        可以发现，更改<code>arr2</code> 的数据也影响到了 <code>arr1</code>。这是因为，在创建 <code>arr2</code> 对象时，默认拷贝构造函数将 <code>arr1.m_p</code> 直接赋值给了 <code>arr2.m_p</code>，导致 <code>arr2.m_p</code>和 <code>arr1.m_p</code> 指向了同一块内存，所以会相互影响。</p><p>​        另外需要注意的是，<code>printArray()</code>函数的形参为引用类型，这样做能够避免在传参时调用拷贝构造函数；又因为 <code>printArray()</code> 函数不会修改任何数组元素，所以我们添加了<code>const</code> 限制，以使得语义更加明确。</p><h3 id="到底是浅拷贝还是深拷贝"><a href="#到底是浅拷贝还是深拷贝" class="headerlink" title="到底是浅拷贝还是深拷贝"></a>到底是浅拷贝还是深拷贝</h3><p>​        <strong>如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深拷贝，因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。如果类的成员变量没有指针，一般浅拷贝足以。</strong></p><p>​        <strong>另外一种需要深拷贝的情况就是在创建对象时进行一些预处理工作，比如统计创建过的对象的数目、记录对象创建的时间等</strong>，请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;  //在Linux和Mac下要换成 unistd.h 头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>);</span><br><span class="line">    Base(<span class="keyword">const</span> Base &amp;obj);  <span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_count; &#125;</span><br><span class="line">    <span class="keyword">time_t</span> getTime() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_time; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">    <span class="keyword">time_t</span> m_time;  <span class="comment">//对象创建时间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_count;  <span class="comment">//创建过的对象的数目</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Base::Base(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123;</span><br><span class="line">    m_count++;</span><br><span class="line">    m_time = time((<span class="keyword">time_t</span>*)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base::Base(<span class="keyword">const</span> Base &amp;obj)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_a = obj.m_a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_b = obj.m_b;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_count++;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_time = time((<span class="keyword">time_t</span>*)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj1: count = "</span>&lt;&lt;obj1.getCount()&lt;&lt;<span class="string">", time = "</span>&lt;&lt;obj1.getTime()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    Sleep(<span class="number">3000</span>);  <span class="comment">//在Linux和Mac下要写作 sleep(3);</span></span><br><span class="line">   </span><br><span class="line">    Base obj2 = obj1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj2: count = "</span>&lt;&lt;obj2.getCount()&lt;&lt;<span class="string">", time = "</span>&lt;&lt;obj2.getTime()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj1: count = <span class="number">1</span>, time = <span class="number">1488344372</span></span><br><span class="line"></span><br><span class="line">obj2: count = <span class="number">2</span>, time = <span class="number">1488344375</span></span><br></pre></td></tr></table></figure></p><p>​        运行程序，先输出第一行结果，等待 3 秒后再输出第二行结果。Base 类中的 m_time 和 m_count  分别记录了对象的创建时间和创建数目，它们在不同的对象中有不同的值，所以需要在初始化对象的时候提前处理一下，这样浅拷贝就不能胜任了，就必须使用深拷贝了。</p><h2 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h2><p>​        我们讲解了初始化和赋值的区别：<strong>在定义的同时进行赋值叫做初始化（Initialization），定义完成以后再赋值（不管在定义的时候有没有赋值）就叫做赋值（Assignment）。初始化只能有一次，赋值可以有多次。</strong></p><p>​        <strong>当以拷贝的方式初始化一个对象时，会调用拷贝构造函数；当给一个对象赋值时，会调用重载过的赋值运算符。</strong></p><p>​        即使我们没有显式的重载赋值运算符，编译器也会以默认地方式重载它。默认重载的赋值运算符功能很简单，就是将原有对象的所有成员变量一一赋值给新对象，这和默认拷贝构造函数的功能类似。</p><p>​        对于简单的类，默认的赋值运算符一般就够用了，我们也没有必要再显式地重载它。但是当类持有其它资源时，例如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认的赋值运算符就不能处理了，我们必须显式地重载它，这样才能将原有对象的所有数据都赋值给新对象。</p><p>​        仍然以上节的 Array 类为例，该类拥有一个指针成员，指向动态分配的内存。为了让 Array 类的对象之间能够正确地赋值，我们必须重载赋值运算符。请看下面的代码： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变长数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> len);</span><br><span class="line">    Array(<span class="keyword">const</span> Array &amp;arr);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~Array();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（读取）</span></span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（写入）</span></span><br><span class="line">    Array &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array &amp;arr);  <span class="comment">//重载赋值运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_len; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">int</span> len): m_len(len)&#123;</span><br><span class="line">    m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">const</span> Array &amp;arr)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::~Array()&#123; <span class="built_in">free</span>(m_p); &#125;</span><br><span class="line"></span><br><span class="line">Array &amp;Array::<span class="keyword">operator</span>=(<span class="keyword">const</span> Array &amp;arr)&#123;  <span class="comment">//重载赋值运算符</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">this</span> != &amp;arr)&#123;  <span class="comment">//判断是否是给自己赋值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;m_p);  <span class="comment">//释放原来的内存</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">        <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">const</span> Array &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">arr1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        arr1[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    printArray(arr1);</span><br><span class="line">   </span><br><span class="line">    <span class="function">Array <span class="title">arr2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">        arr2[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    printArray(arr2);</span><br><span class="line">    arr2 = arr1;  <span class="comment">//调用operator=()</span></span><br><span class="line">    printArray(arr2);</span><br><span class="line">    arr2[<span class="number">3</span>] = <span class="number">234</span>;  <span class="comment">//修改arr1的数据不会影响arr2</span></span><br><span class="line">    arr2[<span class="number">7</span>] = <span class="number">920</span>;</span><br><span class="line">    printArray(arr1);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, </span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>​        将 <code>arr1</code> 赋值给 <code>arr2</code>后，修改 <code>arr2</code> 的数据不会影响 <code>arr1</code>。如果把 operator=() 注释掉，那么运行结果将变为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">234</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">920</span>, <span class="number">8</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure></p><blockquote><p> 去掉operator=()后，由于 m_p 指向的堆内存会被 free() 两次，所以还会导致内存错误。</p></blockquote><p>下面我们就来分析一下重载过的赋值运算符。</p><p>​     1) operator=() 的返回值类型为<code>Array &amp;</code>，这样不但能够避免在返回数据时调用拷贝构造函数，还能够达到连续赋值的目的。下面的语句就是连续赋值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr4 = arr3 = arr2 = arr1;</span><br></pre></td></tr></table></figure></p><p>​    2) <code>if( this != &amp;arr)</code>语句的作用是「判断是否是给同一个对象赋值」：如果是，那就什么也不做；如果不是，那就将原有对象的所有成员变量一一赋值给新对象，并为新对象重新分配内存。下面的语句就是给同一个对象赋值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1 = arr1;</span><br><span class="line">arr2 = arr2;</span><br></pre></td></tr></table></figure></p><p>​    3) <code>return *this</code>表示返回当前对象（新对象）。</p><p>​    4) <code>operator=()</code> 的形参类型为<code>const Array &amp;</code>，这样不但能够避免在传参时调用拷贝构造函数，还能够同时接收<code>const</code> 类型和非 <code>const</code> 类型的实参。</p><p>​    5) 赋值运算符重载函数除了能有对象引用这样的参数之外，也能有其它参数。但是其它参数必须给出默认值，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array &amp;arr, <span class="keyword">int</span> a = <span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  &lt;strong&gt;拷贝&lt;/strong&gt;和&lt;strong&gt;复制&lt;/strong&gt;是一个意思，对应的英文单词都是&lt;code&gt;copy&lt;/code&gt;。对于计算机来说，&lt;strong&gt;拷贝是指用一份原有的、已经存在的数据创建出一份新的数据，最终的结果是多了一份相同的数据&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="c++_language" scheme="http://yoursite.com/categories/c-language/"/>
    
    
      <category term="c++_language" scheme="http://yoursite.com/tags/c-language/"/>
    
  </entry>
  
  <entry>
    <title>c++运算符重载</title>
    <link href="http://yoursite.com/2019/05/25/c++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/05/25/c++运算符重载/</id>
    <published>2019-05-25T09:21:02.000Z</published>
    <updated>2019-10-21T02:41:11.283Z</updated>
    
    <content type="html"><![CDATA[<p>  所谓重载，就是赋予新的含义。<strong>函数重载（Function Overloading）</strong>可以让一个函数名有多种功能，在不同情况下进行不同的操作。运算符重载（Operator Overloading）也是一个道理，同一个运算符可以有不同的功能。</p><a id="more"></a><h2 id="成员函数重载运算符"><a href="#成员函数重载运算符" class="headerlink" title="成员函数重载运算符"></a>成员函数重载运算符</h2><p>​        实际上，我们已经在不知不觉中使用了运算符重载。例如，<code>+</code>号可以对不同类型（int、float 等）的数据进行加法操作；<code>&lt;&lt;</code>既是位移运算符，又可以配合 <code>cout</code> 向控制台输出数据。C++ 本身已经对这些运算符进行了重载。 C++ 也允许程序员自己重载运算符，这给我们带来了很大的便利。</p><p>​        下面的代码定义了一个复数类，通过运算符重载，可以用<code>+</code>号实现复数的加法运算： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">complex</span>();</span><br><span class="line">    <span class="keyword">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明运算符重载</span></span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">complex</span> &amp;A) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">complex</span>::<span class="keyword">complex</span>(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line"><span class="keyword">complex</span>::<span class="keyword">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现运算符重载</span></span><br><span class="line"><span class="keyword">complex</span> <span class="keyword">complex</span>::<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">complex</span> &amp;A) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">complex</span> B;</span><br><span class="line">    B.m_real = <span class="keyword">this</span>-&gt;m_real + A.m_real;</span><br><span class="line">    B.m_imag = <span class="keyword">this</span>-&gt;m_imag + A.m_imag;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">complex</span>::display() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_real&lt;&lt;<span class="string">" + "</span>&lt;&lt;m_imag&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">5.8</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">c2</span><span class="params">(<span class="number">2.4</span>, <span class="number">3.7</span>)</span></span>;</span><br><span class="line">    <span class="keyword">complex</span> c3;</span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    c3.display();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.7</span> + <span class="number">9.5</span>i</span><br></pre></td></tr></table></figure></p><p>​        本例中义了一个复数类 complex，<code>m_real</code> 表示实部，<code>m_imag</code> 表示虚部，第 10 行声明了运算符重载，第 21 行进行了实现（定义）。认真观察这两行代码，可以发现运算符重载的形式与函数非常类似。</p><p>​        运算符重载其实就是定义一个函数，在函数体内实现想要的功能，当用到该运算符时，编译器会自动调用这个函数。也就是说，<strong>运算符重载是通过函数实现的，它本质上是函数重载</strong>。</p><p>​         运算符重载的格式为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 <span class="keyword">operator</span> 运算符名称 (形参表列)&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​        <code>operator</code>是关键字，专门用于定义重载运算符的函数。我们可以将<code>operator 运算符名称</code>这一部分看做函数名，对于上面的代码，函数名就是<code>operator+</code>。<strong>运算符重载函数除了函数名有特定的格式，其它地方和普通函数并没有区别</strong>。</p><p>​        上面的例子中，我们在 complex 类中重载了运算符<code>+</code>，该重载只对 complex 对象有效。当执行<code>c3 = c1 + c2;</code>语句时，编译器检测到<code>+</code>号左边（<code>+</code>号具有左结合性，所以先检测左边）是一个 complex 对象，就会调用成员函数<code>operator+()</code>，也就是转换为下面的形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c3 = c1.<span class="keyword">operator</span>+(c2);</span><br></pre></td></tr></table></figure></p><blockquote><p><code>c1</code> 是要调用函数的对象，<code>c2</code> 是函数的实参。</p></blockquote><p>​        上面的运算符重载还可以有更加简练的定义形式： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">complex</span> <span class="keyword">complex</span>::<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">complex</span> &amp;A)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">complex</span>(<span class="keyword">this</span>-&gt;m_real + A.m_real, <span class="keyword">this</span>-&gt;m_imag + A.m_imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        return 语句中的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">complex</span>(<span class="keyword">this</span>-&gt;m_real + A.m_real, <span class="keyword">this</span>-&gt;m_imag + A.m_imag)</span><br></pre></td></tr></table></figure><p>​        会创建一个临时对象，这个对象没有名称，是一个匿名对象。在创建临时对象过程中调用构造函数，return 语句将该临时对象作为函数返回值。 </p><h2 id="全局范围内重载运算符"><a href="#全局范围内重载运算符" class="headerlink" title="全局范围内重载运算符"></a>全局范围内重载运算符</h2><p>​        运算符重载函数不仅可以作为类的成员函数，还可以作为全局函数。</p><p>​        更改上面的代码，在全局范围内重载<code>+</code>，实现复数的加法运算： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">complex</span>();</span><br><span class="line">    <span class="keyword">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//声明为友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">complex</span> &amp;A, <span class="keyword">const</span> <span class="keyword">complex</span> &amp;B);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;</span><br><span class="line">    <span class="keyword">double</span> m_imag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">complex</span> &amp;A, <span class="keyword">const</span> <span class="keyword">complex</span> &amp;B);</span><br><span class="line"></span><br><span class="line"><span class="keyword">complex</span>::<span class="keyword">complex</span>(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line"><span class="keyword">complex</span>::<span class="keyword">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">complex</span>::display() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_real&lt;&lt;<span class="string">" + "</span>&lt;&lt;m_imag&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在全局范围内重载+</span></span><br><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">complex</span> &amp;A, <span class="keyword">const</span> <span class="keyword">complex</span> &amp;B)&#123;</span><br><span class="line">    <span class="keyword">complex</span> C;</span><br><span class="line">    C.m_real = A.m_real + B.m_real;</span><br><span class="line">    C.m_imag = A.m_imag + B.m_imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">5.8</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">c2</span><span class="params">(<span class="number">2.4</span>, <span class="number">3.7</span>)</span></span>;</span><br><span class="line">    <span class="keyword">complex</span> c3;</span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    c3.display();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        运算符重载函数不是 complex 类的成员函数，但是却用到了 complex 类的 private 成员变量，所以必须在 complex 类中将该函数声明为友元函数。</p><p>​        当执行<code>c3 = c1 + c2;</code>语句时，编译器检测到<code>+</code>号两边都是 complex 对象，就会转换为类似下面的函数调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c3 = <span class="keyword">operator</span>+(c1, c2);</span><br></pre></td></tr></table></figure></p><h2 id="运算符重载注意事项"><a href="#运算符重载注意事项" class="headerlink" title="运算符重载注意事项"></a>运算符重载注意事项</h2><p>​        <strong>运算符重载</strong>是通过函数重载实现的，概念上大家都很容易理解，这节我们来说一下运算符重载的注意事项。</p><pre><code>1) 并不是所有的运算符都可以重载。能够重载的运算符包括：</code></pre><p>​        <code>\+  -  *  /  %  ^  &amp;  |  ~  !  =  &lt;  &gt;  +=  -=  *=  /=  %=  ^=   &amp;=  |=  &lt;&lt;  &gt;&gt;  &lt;&lt;=  &gt;&gt;=  ==  !=  &lt;=   &gt;=  &amp;&amp;  ||  ++  --  ,  -&gt;*  -&gt;  ()  []  new  new[]   delete  delete[]</code></p><p>​        上述运算符中，<code>[]</code>是下标运算符，<code>()</code>是函数调用运算符。自增自减运算符的前置和后置形式都可以重载。长度运算符<code>sizeof</code>、条件运算符<code>: ?</code>、成员选择符<code>.</code>和域解析运算符<code>::</code>不能被重载。</p><pre><code>2) 重载不能改变运算符的优先级和结合性。假设上一节的 complex 类中重载了`+`号和`*`·号，并且 `c1`、`c2`、`c3`、`c4` 都是 complex 类的对象，那么下面的语句： </code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c4 = c1 + c2 * c3;</span><br></pre></td></tr></table></figure><p>​     等价于：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c4 = c1 + ( c2 * c3 );</span><br></pre></td></tr></table></figure></p><p>​     乘法的优先级仍然高于加法，并且它们仍然是二元运算符。</p><pre><code>3) 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变。例如`~`号右边只有一个操作数，`+`号总是出现在两个操作数之间，重载后也必须如此。4) 运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的。</code></pre><p>​     5) 运算符重载函数既可以作为类的成员函数，也可以作为全局函数。<strong>将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数</strong>。之所以少一个参数，是因为这个参数是隐含的。</p><p>​     例如，上节的 complex 类中重载了加法运算符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">complex</span> &amp; A) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure></p><p>​     当执行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c3 = c1 + c2;</span><br></pre></td></tr></table></figure></p><p>​     会被转换为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c3 = c1.<span class="keyword">operator</span>+(c2);</span><br></pre></td></tr></table></figure></p><p>​    通过 this 指针隐式的访问 <code>c1</code> 的成员变量。</p><p>​        <strong>将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要一个参数，而且其中必须有一个参数是对象，好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质</strong>。</p><p> 例如，下面这样是不对的： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span> + (<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> (a-b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <code>+</code>号原来是对两个数相加，现在企图通过重载使它的作用改为两个数相减， 如果允许这样重载的话，那么表达式<code>4+3</code>的结果是 7 还是 1 呢？显然，这是绝对禁止的。</p><p>​        如果有两个参数，这两个参数可以都是对象，也可以一个是对象，一个是C ++内置类型的数据，例如： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">int</span> a, <span class="keyword">complex</span> &amp;c)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">complex</span>(a+c.real, c.imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        它的作用是使一个整数和一个复数相加。另外，将运算符重载函数作为全局函数时，一般都需要在类中将该函数声明为友元函数。原因很简单，该函数大部分情况下都需要使用类的 private 成员。</p><p>​        上节的最后一个例子中，我们在全局范围内重载了<code>+</code>号，并在 complex 类中将运算符重载函数声明为友元函数，因为该函数使用到了 complex 类的 <code>m_real</code> 和 <code>m_imag</code> 两个成员变量，它们都是 private 属性的，默认不能在类的外部访问。</p><p>​     6) 箭头运算符<code>-&gt;</code>、下标运算符<code>[ ]</code>、函数调用运算符<code>( )</code>、赋值运算符<code>=</code>只能以成员函数的形式重载。</p><h2 id="重载数学运算符"><a href="#重载数学运算符" class="headerlink" title="重载数学运算符"></a>重载数学运算符</h2><p>​        四则运算符（<code>+、-、*、/、+=、-=、*=、/=</code>）和关系运算符（<code>&gt;、&lt;、&lt;=、&gt;=、==、!=</code>）都是数学运算符，它们在实际开发中非常常见，被重载的几率也很高，并且有着相似的重载格式。本节以复数类  Complex 为例对它们进行重载，重在演示运算符重载的语法以及规范。</p><p>​        复数能够进行完整的四则运算，但不能进行完整的关系运算：我们只能判断两个复数是否相等，但不能比较它们的大小，所以不能对 &gt;、&lt;、&lt;=、&gt;= 进行重载。下面是具体的代码： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//构造函数</span></span><br><span class="line">    Complex(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//运算符重载</span></span><br><span class="line">    <span class="comment">//以全局函数的形式重载</span></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>/(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="comment">//以成员函数的形式重载</span></span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>-=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>/=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_real; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_imag; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载+运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real + c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag + c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载-运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real - c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag - c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*运算符  (a+bi) * (c+di) = (ac-bd) + (bc+ad)i</span></span><br><span class="line">Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real * c2.m_real - c1.m_imag * c2.m_imag;</span><br><span class="line">    c.m_imag = c1.m_imag * c2.m_real + c1.m_real * c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载/运算符  (a+bi) / (c+di) = [(ac+bd) / (c²+d²)] + [(bc-ad) / (c²+d²)]i</span></span><br><span class="line">Complex <span class="keyword">operator</span>/(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = (c1.m_real*c2.m_real + c1.m_imag*c2.m_imag) / (<span class="built_in">pow</span>(c2.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c2.m_imag, <span class="number">2</span>));</span><br><span class="line">    c.m_imag = (c1.m_imag*c2.m_real - c1.m_real*c2.m_imag) / (<span class="built_in">pow</span>(c2.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c2.m_imag, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载==运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">if</span>( c1.m_real == c2.m_real &amp;&amp; c1.m_imag == c2.m_imag )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载!=运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">if</span>( c1.m_real != c2.m_real || c1.m_imag != c2.m_imag )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载+=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real += c.m_real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag += c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载-=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>-=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real -= c.m_real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag -= c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real = <span class="keyword">this</span>-&gt;m_real * c.m_real - <span class="keyword">this</span>-&gt;m_imag * c.m_imag;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag = <span class="keyword">this</span>-&gt;m_imag * c.m_real + <span class="keyword">this</span>-&gt;m_real * c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载/=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>/=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real = (<span class="keyword">this</span>-&gt;m_real*c.m_real + <span class="keyword">this</span>-&gt;m_imag*c.m_imag) / (<span class="built_in">pow</span>(c.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c.m_imag, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag = (<span class="keyword">this</span>-&gt;m_imag*c.m_real - <span class="keyword">this</span>-&gt;m_real*c.m_imag) / (<span class="built_in">pow</span>(c.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c.m_imag, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">25</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c4</span><span class="params">(<span class="number">4</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c5</span><span class="params">(<span class="number">34</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c6</span><span class="params">(<span class="number">80</span>, <span class="number">90</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">    Complex c7 = c1 + c2;</span><br><span class="line">    Complex c8 = c1 - c2;</span><br><span class="line">    Complex c9 = c1 * c2;</span><br><span class="line">    Complex c10 = c1 / c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c7 = "</span>&lt;&lt;c7.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c7.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c8 = "</span>&lt;&lt;c8.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c8.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c9 = "</span>&lt;&lt;c9.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c9.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c10 = "</span>&lt;&lt;c10.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c10.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    c3 += c1;</span><br><span class="line">    c4 -= c2;</span><br><span class="line">    c5 *= c2;</span><br><span class="line">    c6 /= c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c3 = "</span>&lt;&lt;c3.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c3.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c4 = "</span>&lt;&lt;c4.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c4.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c5 = "</span>&lt;&lt;c5.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c5.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c6 = "</span>&lt;&lt;c6.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c6.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(c1 == c2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 == c2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c1 != c2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 != c2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c7 = <span class="number">35</span> + <span class="number">55</span>i</span><br><span class="line">c8 = <span class="number">15</span> + <span class="number">15</span>i</span><br><span class="line">c9 = <span class="number">-450</span> + <span class="number">850</span>i</span><br><span class="line">c10 = <span class="number">1.9</span> + <span class="number">-0.3</span>i</span><br><span class="line">c3 = <span class="number">26</span> + <span class="number">37</span>i</span><br><span class="line">c4 = <span class="number">-6</span> + <span class="number">-11</span>i</span><br><span class="line">c5 = <span class="number">220</span> + <span class="number">4460</span>i</span><br><span class="line">c6 = <span class="number">5.2</span> + <span class="number">1.592</span>i</span><br><span class="line">c1 != c2</span><br></pre></td></tr></table></figure></p><p>​        需要注意的是，我们以全局函数的形式重载了 +、-、<em>、/、==、!=，以成员函数的形式重载了 +=、-=、</em>=、/=，而且应该坚持这样做，不能一股脑都写作成员函数或者全局函数，具体原因我们将在下节讲解。</p><p>​        在上节的例子中，我们以全局函数的形式重载了 +、-、<em>、/、==、!=，以成员函数的形式重载了 +=、-=、</em>=、/=，而没有一股脑都写成全局函数或者成员函数，这样做是有原因的，这节我们就来分析一下。</p><h2 id="简单地了解转换构造函数"><a href="#简单地了解转换构造函数" class="headerlink" title="简单地了解转换构造函数"></a>简单地了解转换构造函数</h2><p>在分析以前，我们先来了解一个概念，叫做「转换构造函数」。</p><p>请大家先看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real): m_real(real), m_imag(<span class="number">0.0</span>)&#123; &#125;  <span class="comment">//转换构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_real; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_imag; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载+运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real + c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag + c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">25</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    Complex c2 = c1 + <span class="number">15.6</span>;</span><br><span class="line">    Complex c3 = <span class="number">28.23</span> + c1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c2.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c2.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c3.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c3.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>运行结果：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">40.6</span> + <span class="number">35</span>i</span><br><span class="line"><span class="number">53.23</span> + <span class="number">35</span>i</span><br></pre></td></tr></table></figure><p>​        请读者留意第 30、31 行代码，它说明 Complex 类型可以和 double 类型相加，这很奇怪，因为我们并没有对针对这两个类型重载 +，这究竟是怎么做到的呢？</p><p>​        其实，编译器在检测到 Complex 和 double（小数默认为 double 类型）相加时，会先尝试将 double 转换为  Complex，或者反过来将 Complex 转换为 double（只有类型相同的数据才能进行 +  运算），如果都转换失败，或者都转换成功（产生了二义性），才报错。本例中，编译器会先通过构造函数<code>Complex(double real);</code>将 double 转换为 Complex，再调用重载过的 + 进行计算，整个过程类似于下面的形式：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1F20910091BJ.png" alt></p><p>​        也就是说，小数被转换成了匿名的 Complex 对象。在这个转换过程中，构造函数<code>Complex(double real);</code>起到了至关重要的作用，如果没有它，转换就会失败，Complex 也不能和 double 相加。</p><p>​        <strong><code>Complex(double real);</code>在作为普通构造函数的同时，还能将  <code>double</code> 类型转换为 <code>Complex</code>  类型，集合了“构造函数”和“类型转换”的功能，所以被称为「转换构造函数」。换句话说，转换构造函数用来将其它类型（可以是  <code>bool</code>、<code>int</code>、<code>double</code> 等基本类型，也可以是数组、指针、结构体、类等构造类型）转换为当前类类型。</strong></p><h2 id="为什么要以全局函数的形式重载"><a href="#为什么要以全局函数的形式重载" class="headerlink" title="为什么要以全局函数的形式重载 +"></a>为什么要以全局函数的形式重载 +</h2><p>​        上面的例子中，我们定义的<code>operator+</code>是一个全局函数（一个友元函数），而不是成员函数，<strong>这样做是为了保证 + 运算符的操作数能够被对称的处理</strong>；换句话说，小数（double 类型）在 + 左边和右边都是正确的。第 30 行代码中，15.6 在 + 的右边，第 31 行代码中，28.23 在 + 的左边，它们都能够被顺利地转换为 Complex 类型，所以不会出错。</p><p>​        如果将<code>operator+</code>定义为成员函数，根据“+ 运算符具有左结合性”这条原则，<code>Complex c2 = c1 + 15.6;</code>会被转换为下面的形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex c2 = c1.<span class="keyword">operator</span>+(Complex(<span class="number">15.6</span>));</span><br></pre></td></tr></table></figure></p><p>​        这就是通过对象调用成员函数，是正确的。而对于<code>Complex c3 = 28.23 + c1;</code>，编译器会尝试转换为不同的形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex c3 = (<span class="number">28.23</span>).<span class="keyword">operator</span>+(c1);</span><br></pre></td></tr></table></figure></p><p>​        很显然这是错误的，因为 double 类型并没有以成员函数的形式重载 <code>+</code>。也就是说，以成员函数的形式重载 +，只能计算<code>c1 + 15.6</code>，不能计算<code>28.23 + c1</code>，这是不对称的</p><p>​        有读者可能会问，编译器明明可以把 28.23 先转换成 Complex 类型再相加呀，也就是下面的形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex c3 = Complex(<span class="number">28.23</span>).<span class="keyword">operator</span>+(c1);</span><br></pre></td></tr></table></figure></p><p>​        为什么就是不转换呢？没错，编译器不会转换，原因在于，<strong>C++ 只会对成员函数的参数进行类型转换，而不会对调用成员函数的对象进行类型转换</strong>。以下面的语句为例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.func(params);</span><br></pre></td></tr></table></figure></p><p>​        编译器不会尝试对 obj 进行任何类型转换，它有 <code>func()</code> 成员函数就调用，没有就报错。而对于实参 <code>params</code>，编译器会“拼命地”将它转换为形参的类型。</p><h2 id="为什么要以成员函数的形式重载"><a href="#为什么要以成员函数的形式重载" class="headerlink" title="为什么要以成员函数的形式重载 +="></a>为什么要以成员函数的形式重载 +=</h2><p>​        <strong>我们首先要明白，运算符重载的初衷是给类添加新的功能，方便类的运算，它作为类的成员函数是理所应当的，是首选的。</strong></p><p>​        不过，类的成员函数不能对称地处理数据，程序员必须在（参与运算的）所有类型的内部都重载当前的运算符。以上面的情况为例，我们必须在  Complex 和 double 内部都重载 +  运算符，这样做不但会增加运算符重载的数目，还要在许多地方修改代码，这显然不是我们所希望的，所以 C++  进行了折中，允许以全局函数（友元函数）的形式重载运算符。</p><p>​        C++ 创始人 <code>Bjarne Stroustrup</code> 也曾考虑过为内部类型（<code>bool</code>、<code>int</code>、<code>double</code>  等）定义额外运算符的问题，但后来还是放弃了这种想法，因为 <code>Bjarne Stroustrup</code> 不希望改变现有规则：任何类型（无论是内部类型还是用户自定义类型）都不能在其定义完成以后再增加额外的操作。这里还有另外的一个原因，C内部类型之间的转换已经够肮脏了，决不能再向里面添乱。而通过成员函数为已存在的类型提供混合运算的方式，从本质上看，比我们所采用的全局函数（友元函数）加转换构造函数的方式还要肮脏许多。</p><p>​        采用全局函数能使我们定义这样的运算符，它们的参数具有逻辑的对称性。与此相对应的，把运算符定义为成员函数能够保证在调用时对第一个（最左的）运算对象不出现类型转换，也就是上面提到的「C++ 不会对调用成员函数的对象进行类型转换」。</p><p>​        总起来说，有一部分运算符重载既可以是成员函数也可以是全局函数，虽然没有一个必然的、不可抗拒的理由选择成员函数，但我们应该优先考虑成员函数，这样更符合运算符重载的初衷；另外有一部分运算符重载必须是全局函数，这样能保证参数的对称性；除了  C++ 规定的几个特定的运算符外，暂时还没有发现必须以成员函数的形式重载的运算符。 </p><blockquote><pre><code>C++ 规定，箭头运算符`-&gt;`、下标运算符`[ ]`、函数调用运算符`( )`、赋值运算符`=`只能以成员函数的形式重载。</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  所谓重载，就是赋予新的含义。&lt;strong&gt;函数重载（Function Overloading）&lt;/strong&gt;可以让一个函数名有多种功能，在不同情况下进行不同的操作。运算符重载（Operator Overloading）也是一个道理，同一个运算符可以有不同的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="c++_language" scheme="http://yoursite.com/categories/c-language/"/>
    
    
      <category term="c++_language" scheme="http://yoursite.com/tags/c-language/"/>
    
  </entry>
  
  <entry>
    <title>c语言-引用和指针的异同</title>
    <link href="http://yoursite.com/2019/05/25/c%E8%AF%AD%E8%A8%80-%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%82%E5%90%8C/"/>
    <id>http://yoursite.com/2019/05/25/c语言-引用和指针的异同/</id>
    <published>2019-05-25T09:17:02.000Z</published>
    <updated>2019-10-21T02:31:05.179Z</updated>
    
    <content type="html"><![CDATA[<p>  引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样。</p><a id="more"></a><h2 id="引用和指针的异同"><a href="#引用和指针的异同" class="headerlink" title="引用和指针的异同"></a>引用和指针的异同</h2><h3 id="引用的含义"><a href="#引用的含义" class="headerlink" title="引用的含义"></a>引用的含义</h3><p>​        通过上节的讲解，相信各位读者对引用都有了一个概念上的认识，能够简单地使用引用编程了，但又感觉糊里糊涂，不明白它到底是什么，它和指针有点相似，但又不是一个东西。</p><p>​        首先来回顾一下上节的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b = a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">", "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">", "</span>&lt;&lt;&amp;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">99</span>, <span class="number">99</span></span><br><span class="line"><span class="number">0x28ff44</span>, <span class="number">0x28ff44</span></span><br></pre></td></tr></table></figure></p><p>​        我们知道，变量是要占用内存的，虽然我们称 b 为变量，但是通过<code>&amp;b</code>获取到的却不是 b 的地址，而是 a 的地址，这会让我们觉得 b 这个变量不占用独立的内存，它和 a 指代的是同一份内存。</p><h3 id="引用和指针的联系"><a href="#引用和指针的联系" class="headerlink" title="引用和指针的联系"></a>引用和指针的联系</h3><p>​        请读者再继续看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> &amp;r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::A(): n(<span class="number">0</span>), r(num)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//输出A类型的大小</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;hex&lt;&lt;showbase&lt;&lt;*((<span class="keyword">int</span>*)a + <span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//输出r的内容</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;num&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//输出num变量的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">0x442000</span></span><br><span class="line"><span class="number">0x442000</span></span><br></pre></td></tr></table></figure></p><p>​        成员变量 r 是 private 属性的，不能直接通过对象来访问，但是借助强大的指针和类型转换，我们依然可以得到它的内容，只不过这种方法有点蹩脚。</p><p>​        第 20 行代码中，<code>hex</code>表示以十六进制输出，<code>showbase</code>表示添加十六进制前缀<code>0x</code>。</p><p>​    从运行结果可以看出： </p><ul><li>成员变量 r 是占用内存的，如果不占用的话，<code>sizeof(A)</code>的结果应该为 4。</li><li>r 存储的内容是<code>0x442000</code>，也即变量 num 的地址。</li></ul><p>​       这说明 r 的实现和指针非常类似。如果将 r 定义为<code>int *</code>类型的指针，并在构造函数中让它指向 num，那么 r 占用的内存也是 4 个字节，存储的内容也是 num 的地址。</p><p>​        其实引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样，在 32 位环境下是 4 个字节，在 64 位环境下是 8 个字节，之所以不能获取引用的地址，是因为编译器进行了内部转换。</p><p>​    以下面的语句为例： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = a;</span><br><span class="line">r = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;r&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>​    编译时会被转换成如下的形式： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">int</span> *r = &amp;a;</span><br><span class="line">*r = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>​        使用<code>&amp;r</code>取地址时，编译器会对代码进行隐式的转换，使得代码输出的是 r 的内容（a 的地址），而不是 r 的地址，这就是为什么获取不到引用变量的地址的原因。</p><p>​        也就是说，不是变量 r 不占用内存，而是编译器不让获取它的地址。</p><p>​    当引用作为函数参数时，也会有类似的转换。以下面的代码为例： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>, num2 = <span class="number">20</span>;</span><br><span class="line">swap(num1, num2);</span><br></pre></td></tr></table></figure><p>​    编译时会被转换成如下的形式： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>, num2 = <span class="number">20</span>;</span><br><span class="line">swap(&amp;num1, &amp;num2);</span><br></pre></td></tr></table></figure><p>​        引用虽然是基于指针实现的，但它比指针更加易用，从上面的两个例子也可以看出来，通过指针获取数据时需要加<code>*</code>，书写麻烦，而引用不需要，它和普通变量的使用方式一样。</p><p>​        C++ 的发明人 <code>Bjarne Stroustrup</code> 也说过，他在 C++ 中引入引用的直接目的是为了让代码的书写更加漂亮，尤其是在运算符重载中，不借助引用有时候会使得运算符的使用很麻烦。 </p><h3 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h3><p>​    1) 引用必须在定义时初始化，并且以后也要从一而终，不能再指向其他数据；而指针没有这个限制，指针在定义时不必赋值，以后也能指向任意数据。</p><p>​    2) 可以有 const 指针，但是没有 const 引用。也就是说，引用变量不能定义为下面的形式： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;<span class="keyword">int</span> &amp; <span class="keyword">const</span> r = a;</span><br></pre></td></tr></table></figure><p>​    因为 r 本来就不能改变指向，加上 const 是多此一举。</p><p>​    3) 指针可以有多级，但是引用只能有一级，例如，<code>int **p</code>是合法的，而<code>int &amp;&amp;r</code>是不合法的。如果希望定义一个引用变量来指代另外一个引用变量，那么也只需要加一个<code>&amp;</code>，如下所示： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = a;</span><br><span class="line"><span class="keyword">int</span> &amp;rr = r;</span><br></pre></td></tr></table></figure><p>​    4) 指针和引用的自增（++）自减（–）运算意义不一样。对指针使用 ++ 表示指向下一份数据，对引用使用 ++ 表示它所指代的数据本身加 1；自减（–）也是类似的道理。请看下面的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;r = a;</span><br><span class="line">    r++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">2</span>] = &#123; <span class="number">27</span>, <span class="number">84</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = arr;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">84</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样。&lt;/p&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>c语言-整数在内存的存储</title>
    <link href="http://yoursite.com/2019/05/25/c%E8%AF%AD%E8%A8%80-%E6%95%B4%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2019/05/25/c语言-整数在内存的存储/</id>
    <published>2019-05-25T09:12:02.000Z</published>
    <updated>2019-10-21T02:31:08.965Z</updated>
    
    <content type="html"><![CDATA[<p>  加法和减法是计算机中最基本的运算，计算机时时刻刻都离不开它们，所以它们由硬件直接支持。为了提高加减法的运算效率，硬件电路要设计得尽量简单。<br>  对于有符号数，内存要区分符号位和数值位，对于人脑来说，很容易辨别，但是对于计算机来说，就要设计专门的电路，这无疑增加了硬件的复杂性，增加了计算的时间。要是能把符号位和数值位等同起来，让它们一起参与运算，不再加以区分，这样硬件电路就变得简单了。</p><a id="more"></a><h3 id="整数在内存的存储"><a href="#整数在内存的存储" class="headerlink" title="整数在内存的存储"></a>整数在内存的存储</h3><p> 另外，加法和减法也可以合并为一种运算，就是加法运算，因为减去一个数相当于加上这个数的相反数，例如，<code>5 - 3</code>等价于 <code>5 + (-3)</code>，<code>10 - (-9)</code>等价于<code>10 + 9</code>。 </p><blockquote><pre><code>相反数是指数值相同，符号不同的两个数，例如，10 和 -10 就是一对相反数，-98 和 98 也是一对相反数。</code></pre></blockquote><p> 如果能够实现上面的两个目标，那么只要设计一种简单的、不用区分符号位和数值位的加法电路，就能同时实现加法和减法运算，并且非常高效。实际上，这两个目标都已经实现了，真正的计算机硬件电路就是如此简单。</p><p> 然而，简化硬件电路是有代价的，这个代价就是有符号数在存储和读取时都要进行转化。那么，这个转换过程究竟是怎样的呢？接下来我们就详细地讲解一下。</p><p> 首先，请读者先记住下面的几个概念。 </p><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p> 将一个整数转换成二进制形式，就是其原码。例如<code>short a = 6;</code>，a 的原码就是<code>0000 0000 0000 0110</code>；更改 a 的值<code>a = -18;</code>，此时 a 的原码就是<code>1000 0000 0001 0010</code>。</p><p> 通俗的理解，原码就是一个整数本来的二进制形式。</p><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p> 谈到反码，正数和负数要区别对待，因为它们的反码不一样。</p><p> 对于正数，它的反码就是其原码（原码和反码相同）；负数的反码是将原码中除符号位以外的所有位（数值位）取反，也就是 0 变成 1，1 变成 0。例如<code>short a = 6;</code>，a 的原码和反码都是<code>0000 0000 0000 0110</code>；更改 a 的值<code>a = -18;</code>，此时 a 的反码是<code>1111 1111 1110 1101</code>。</p><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p> 正数和负数的补码也不一样，也要区别对待。</p><p> 对于正数，它的补码就是其原码（原码、反码、补码都相同）；负数的补码是其反码加 1。例如<code>short a = 6;</code>，a 的原码、反码、补码都是<code>0000 0000 0000 0110</code>；更改 a 的值<code>a = -18;</code>，此时 a 的补码是<code>1111 1111 1110 1110</code>。</p><p> 可以认为，补码是在反码的基础上打了一个补丁，进行了一下修正，所以叫“补码”。</p><p> 原码、反码、补码的概念只对负数有实际意义，对于正数，它们都一样。</p><p> 最后我们总结一下 6 和 -18 从原码到补码的转换过程： </p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1-1G01G5120I49.jpg" alt></p><p>在计算机内存中，整数一律采用补码的形式来存储。这意味着，当读取整数时还要采用逆向的转换，也就是将补码转换为原码。</p><p>将补码转换为原码也很简单：先减去 1，再将数值位取反即可。</p><h4 id="补码如何简化硬件电路"><a href="#补码如何简化硬件电路" class="headerlink" title="补码如何简化硬件电路"></a>补码如何简化硬件电路</h4><p> 假设 6 和 18 都是 short 类型的，现在我们要计算 6 - 18 的结果，根据运算规则，它等价于<code>6 + (-18)</code>。</p><p> 如果采用原码计算，那么运算过程为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> - <span class="number">18</span> = <span class="number">6</span> + (<span class="number">-18</span>)</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0110</span>]原 + [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0010</span>]原</span><br><span class="line">= [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1000</span>]原</span><br><span class="line">= <span class="number">-24</span></span><br></pre></td></tr></table></figure></p><p> 直接用原码表示整数，让符号位也参与运算，对于类似上面的减法来说，结果显然是不正确的。</p><p> 于是人们开始继续探索，不断试错，后来设计出了反码。下面就演示了反码运算的过程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> - <span class="number">18</span> = <span class="number">6</span> + (<span class="number">-18</span>)</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0110</span>]反 + [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1110</span> <span class="number">1101</span>]反</span><br><span class="line">= [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0011</span>]反</span><br><span class="line">= [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span>]原</span><br><span class="line">= <span class="number">-12</span></span><br></pre></td></tr></table></figure></p><p> 这样一来，计算结果就正确了。</p><p> 然而，这样还不算万事大吉，我们不妨将减数和被减数交换一下位置，也就是计算<code>18 - 6</code> 的结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span> - <span class="number">6</span> = <span class="number">18</span> + (<span class="number">-6</span>)</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0010</span>]反 + [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1001</span>]反</span><br><span class="line">= [<span class="number">1</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1011</span>]反</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1011</span>]反</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1011</span>]原</span><br><span class="line">= <span class="number">11</span></span><br></pre></td></tr></table></figure></p><p> 按照反码计算的结果是 11，而真实的结果应该是 12 才对，它们相差了 1。 </p><blockquote><pre><code>蓝色的 **1** 是加法运算过程中的进位，它溢出了，内存容纳不了了，所以直接截掉。</code></pre></blockquote><p><code>6 - 18</code> 的结果正确，<code>18 - 6</code> 的结果就不正确，相差 1。按照反码来计算，是不是小数减去大数正确，大数减去小数就不对了，始终相差 1 呢？我们不妨再看两个例子，分别是 <code>5 - 13</code> 和 <code>13 - 5</code>。</p><p> 5 - 13 的运算过程为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> - <span class="number">13</span> = <span class="number">5</span> + (<span class="number">-13</span>)</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0101</span>]原 + [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1101</span>]原</span><br><span class="line">=  [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0101</span>]反 + [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0010</span>]反</span><br><span class="line">= [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0111</span>]反</span><br><span class="line">= [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span>]原</span><br><span class="line">= <span class="number">-8</span></span><br></pre></td></tr></table></figure></p><p><code>13 - 5</code>的运算过程为： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span> - <span class="number">5</span> = <span class="number">13</span> + (<span class="number">-5</span>)</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1101</span>]原 + [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0101</span>]原</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1101</span>]反 + [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1010</span>]反</span><br><span class="line">= [<span class="number">1</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span>]反 </span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span>]反</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span>]原</span><br><span class="line">= <span class="number">7</span></span><br></pre></td></tr></table></figure><p> 这足以证明，刚才的猜想是正确的：小数减去大数不会有问题，而大数减去小数的就不对了，结果始终相差 1。</p><p> 相差的这个 1 要进行纠正，但是又不能影响小数减去大数，怎么办呢？于是人们又绞尽脑汁设计出了补码，给反码打了一个“补丁”，终于把相差的 1 给纠正过来了。</p><p> 下面演示了按照补码计算的过程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> - <span class="number">18</span> = <span class="number">6</span> + (<span class="number">-18</span>)</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0110</span>]补 + [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1110</span> <span class="number">1110</span>]补</span><br><span class="line">= [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0100</span>]补</span><br><span class="line">=  [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0011</span>]反</span><br><span class="line">= [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span>]原</span><br><span class="line">= <span class="number">-12</span></span><br><span class="line"> </span><br><span class="line"><span class="number">18</span> - <span class="number">6</span> = <span class="number">18</span> + (<span class="number">-6</span>)</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0010</span>]补 + [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1010</span>]补</span><br><span class="line">= [<span class="number">1</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span>]补</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span>]补</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span>]反</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span>]原</span><br><span class="line">= <span class="number">12</span></span><br><span class="line"> </span><br><span class="line"><span class="number">5</span> - <span class="number">13</span> = <span class="number">5</span> + (<span class="number">-13</span>)</span><br><span class="line">=  [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0101</span>]补 + [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0011</span>]补</span><br><span class="line">= [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1000</span>]补</span><br><span class="line">= [<span class="number">1000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0111</span>]反</span><br><span class="line">= [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span>]原</span><br><span class="line">= <span class="number">-8</span></span><br><span class="line"> </span><br><span class="line"><span class="number">13</span> - <span class="number">5</span> = <span class="number">13</span> + (<span class="number">-5</span>)</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1101</span>]补 + [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1011</span>]补</span><br><span class="line">= [<span class="number">1</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span>]补 </span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span>]补</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span>]反</span><br><span class="line">= [<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span>]原</span><br><span class="line">= <span class="number">8</span></span><br></pre></td></tr></table></figure></p><p> 你看，采用补码的形式正好把相差的 1 纠正过来，也没有影响到小数减去大数，这个“补丁”真是巧妙。</p><p> 小数减去大数，结果为负数，之前（负数从反码转换为补码要加 1）加上的 1，后来（负数从补码转换为反码要减 1）还要减去，正好抵消掉，所以不会受影响。</p><p> 而大数减去小数，结果为正数，之前（负数从反码转换为补码要加 1）加上的 1，后来（正数的补码和反码相同，从补码转换为反码不用减 1）就没有再减去，不能抵消掉，这就相当于给计算结果多加了一个 1。</p><p>补码这种天才般的设计，一举达成了本文开头提到的两个目标，简化了硬件电路。</p><h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p> 上一节我们还留下了一个谜团，就是有符号数以无符号的形式输出，或者无符号数以有符号的形式输出时，会得到一个奇怪的值，请看下面的代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> a = <span class="number">0100</span>;  <span class="comment">//八进制</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">-0x1</span>;  <span class="comment">//十六进制</span></span><br><span class="line">    <span class="keyword">long</span> c = <span class="number">720</span>;  <span class="comment">//十进制</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> m = <span class="number">0xffff</span>;  <span class="comment">//十六进制</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = <span class="number">0x80000000</span>;  <span class="comment">//十六进制</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> p = <span class="number">100</span>;  <span class="comment">//十进制</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//以无符号的形式输出有符号数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%#ho, b=%#x, c=%ld\n"</span>, a, b, c);</span><br><span class="line">    <span class="comment">//以有符号数的形式输出无符号类型（只能以十进制形式输出）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"m=%hd, n=%d, p=%ld\n"</span>, m, n, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">0100</span>, b=<span class="number">0xffffffff</span>, c=<span class="number">720</span></span><br><span class="line"></span><br><span class="line">m=<span class="number">-1</span>, n=<span class="number">-2147483648</span>, p=<span class="number">100</span></span><br></pre></td></tr></table></figure></p><p> 其中，b、m、n 的输出结果看起来非常奇怪。</p><p> b 是有符号数，它在内存中的存储形式（也就是补码）为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">-0x1</span></span><br><span class="line">= [<span class="number">1000</span> <span class="number">0000</span> …… <span class="number">0000</span> <span class="number">0001</span>]原</span><br><span class="line">= [<span class="number">1111</span> <span class="number">1111</span> …… <span class="number">1111</span> <span class="number">1110</span>]反</span><br><span class="line">= [<span class="number">1111</span> <span class="number">1111</span> …… <span class="number">1111</span> <span class="number">1111</span>]补</span><br><span class="line">= [<span class="number">0xffffffff</span>]补</span><br></pre></td></tr></table></figure></p><p><code>%#x</code>表示以无符号的形式输出，而无符号数的补码和原码相同，所以不用转换了，直接输出 <code>0xffffffff</code> 即可。</p><p> <code>m</code> 和<code>n</code> 是无符号数，它们在内存中的存储形式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="number">0xffff</span></span><br><span class="line">= [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>]补</span><br><span class="line"> </span><br><span class="line">n = <span class="number">0x80000000</span></span><br><span class="line">= [<span class="number">1000</span> <span class="number">0000</span> …… <span class="number">0000</span> <span class="number">0000</span>]补</span><br></pre></td></tr></table></figure></p><p><code>%hd</code>和<code>%d</code>表示以有符号的形式输出，所以还要经过一个逆向的转换过程： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>]补</span><br><span class="line">= [<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1110</span>]反</span><br><span class="line">= [<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span>]原</span><br><span class="line">= <span class="number">-1</span></span><br><span class="line"> </span><br><span class="line">[<span class="number">1000</span> <span class="number">0000</span> …… <span class="number">0000</span> <span class="number">0000</span>]补</span><br><span class="line">= <span class="number">-231</span></span><br><span class="line">= <span class="number">-2147483648</span></span><br></pre></td></tr></table></figure><p> 由此可见，<code>-1</code> 和<code>-2147483648</code>才是最终的输出值。 </p><blockquote><pre><code>注意，`[1000 0000 …… 0000 0000]补`是一个特殊的补码，无法按照本节讲到的方法转换为原码，所以计算机直接规定这个补码对应的值就是 -231，至于为什么，下节我们会详细分析。</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  加法和减法是计算机中最基本的运算，计算机时时刻刻都离不开它们，所以它们由硬件直接支持。为了提高加减法的运算效率，硬件电路要设计得尽量简单。&lt;br&gt;  对于有符号数，内存要区分符号位和数值位，对于人脑来说，很容易辨别，但是对于计算机来说，就要设计专门的电路，这无疑增加了硬件的复杂性，增加了计算的时间。要是能把符号位和数值位等同起来，让它们一起参与运算，不再加以区分，这样硬件电路就变得简单了。&lt;/p&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言存储空间布局</title>
    <link href="http://yoursite.com/2019/05/08/c%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"/>
    <id>http://yoursite.com/2019/05/08/c语言-内存分区/</id>
    <published>2019-05-08T14:26:02.000Z</published>
    <updated>2019-10-21T02:30:14.915Z</updated>
    
    <content type="html"><![CDATA[<p>  不管是在Linux下C程序，是由代码区、数据区、BSS区、堆区、栈区构成的，正文段在低地址。</p><a id="more"></a><h4 id="存储空间组成"><a href="#存储空间组成" class="headerlink" title="存储空间组成"></a>存储空间组成</h4><ul><li><p><strong>代码区（text）</strong><br>加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的，具有只读特性和共享性。</p></li><li><p><strong>未初始化数据区（BSS）</strong><br>加载的是可执行文件 BSS 段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。</p></li><li><p><strong>全局初始化数据区/静态数据区（data）</strong><br>加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。</p></li><li><p><strong>栈区（stack）</strong><br>栈又称堆栈，是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等，也就是我们函数大括号”{}”中定义的变量(不包括static声明的变量)。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。由于栈的先进先出特性，所有栈特别方便用来保存/恢复调用现场。从这个意义上讲，把堆栈看成一个寄存、交换临时数据的内存区。</p></li><li><p><strong>堆区（heap）</strong><br>堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于 BSS 区和栈区之间。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上(堆被扩张)；当利用free等函数释放内存时，被释放的内存从堆上被剔除(堆被缩减)。</p></li></ul><h4 id="详解数据段"><a href="#详解数据段" class="headerlink" title="详解数据段"></a>详解数据段</h4><h5 id="全局静态区"><a href="#全局静态区" class="headerlink" title="全局静态区"></a>全局静态区</h5><p>全局静态区分为<strong>全局区</strong>、<strong>静态区</strong>、<strong>常量区</strong></p><h6 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h6><p>​        处于该区域的数据属于<strong>外部链接</strong>，可以被<strong>其他文件</strong>使用。</p><h6 id="静态区"><a href="#静态区" class="headerlink" title="静态区"></a>静态区</h6><p>​        静态区分为静态全局变量和静态局部变量</p><ul><li><p>静态全局变量</p><p>由<strong>static</strong>修饰的<strong>全局变量</strong>，属于<strong>内部链接</strong>，只能在<strong>本文件</strong>中使用</p></li><li><p>静态局部变量</p><p>由<strong>static</strong>修饰的<strong>局部变量</strong>，当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为<strong>静态存储区</strong>。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。</p></li></ul><h6 id="常量区"><a href="#常量区" class="headerlink" title="常量区"></a>常量区</h6><p>​        常量区分为<strong>字符串常量</strong>和<strong>常变量</strong></p><ul><li><p>字符串常量</p></li><li><p>常变量</p><ol><li><strong>全局常变量</strong>存放在静态存储区，不可以间接修改。</li><li><strong>局部常变量</strong>存放于栈，实际可间接通过指针或者引用进行修改。</li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//全局变量，在全局区,默认外部链接</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">20</span>; <span class="comment">//全局静态变量，在静态区,是内部链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量和全局静态变量有什么区别？</span></span><br><span class="line"><span class="comment">//全局变量是外部链接</span></span><br><span class="line"><span class="comment">//静态全局变量是内部链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内部链接和外部链接有什么区别？</span></span><br><span class="line"><span class="comment">//1. 如果变量是内部链接的话，那么此变量只能在当前文件内访问</span></span><br><span class="line"><span class="comment">//2. 如果是变量是外部链接的话，那么此变量可以被其他文件使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局静态变量和局部静态变量有什么区别？</span></span><br><span class="line"><span class="comment">//1. 全局静态变量和局部静态变量都存储在静态区，都是在程序运行期间都是合法有效</span></span><br><span class="line"><span class="comment">//2. 局部静态变量符号的可见范围仅限于当前函数内部，全局静态变量可见范围从定义到文件结尾</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> v1 = <span class="number">20</span>; <span class="comment">//全局常变量，一旦初始化，不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> arr[] = <span class="string">"hello world!"</span>; <span class="comment">//局部静态变量，在静态区存储可读可写</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">'c'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> v2 = <span class="number">20</span>; <span class="comment">//局部常变量，可以通过指针或者引用进行间接修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* p = <span class="string">"hello world!"</span>; <span class="comment">//字符串"hello world!"在常量区，p局部变量：stack(栈)</span></span><br><span class="line"><span class="comment">//p[2] = 'c'; //只读，不可修改</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">test01();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h5><p>​        <strong>栈(stack)</strong>是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函数，没有局部变量，也就没有我们如今能见到的所有计算机的语言。 </p><p>​        在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中(入栈，push)，也可以将压入栈中的数据弹出(出栈，pop),但是栈容器必须遵循一条规则：<strong>先入后出</strong>(First In First Out,FIFO). </p><p>​        在经典的操作系统中，栈总是<strong>向下增长</strong>的。压栈的操作使得栈顶的地址减小，弹出操作使得栈顶地址增大。</p><p>栈的增长方向如下图：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/QQ截图20190507202235.png" alt></p><p>思考一下下列函数的调用过程： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t_a = a;</span><br><span class="line"><span class="keyword">int</span> t_b = b;</span><br><span class="line"><span class="keyword">return</span> t_a + t_b;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = func(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  不管是在Linux下C程序，是由代码区、数据区、BSS区、堆区、栈区构成的，正文段在低地址。&lt;/p&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言之enum枚举</title>
    <link href="http://yoursite.com/2019/05/08/c%E8%AF%AD%E8%A8%80-enum%E6%9E%9A%E4%B8%BE/"/>
    <id>http://yoursite.com/2019/05/08/c语言-enum枚举/</id>
    <published>2019-05-08T14:17:02.000Z</published>
    <updated>2019-10-21T02:31:14.237Z</updated>
    
    <content type="html"><![CDATA[<p>  了解C语言enum枚举类型定义变量</p><a id="more"></a><h4 id="一次定义多个常量"><a href="#一次定义多个常量" class="headerlink" title="一次定义多个常量"></a>一次定义多个常量</h4><p>​        比如说我们的程序中处理问题时与星期几有关，可能要将星期一转换为数字1，星期二转换为数字2，一直到数字7，在不用enum关键字的情况下，可以使用define来定义，但是大家会觉得很麻烦，因为你要一个一个的定义，星期的还好说，只有7天，如果是月份呢，一年有12个月份，那就要写12个define，非常的不方面，如果利用enum的话就会非常的方便。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> week &#123;Mon=<span class="number">1</span>,Tue,Wed,Thu,Fri,Sat,Sun&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,Tue);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这样定义以后，Mon的值为1，Tue的值为2，Wed的值为3，一次类推。 然后就可以像使用define之后的常量一样的使用定义的7个值了。</p><p>​    如果开头不写Mon=1的话，Mon的<strong>默认值为0</strong>，然后从0开始增长。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123;red,blue,green,yellow&#125;;</span><br></pre></td></tr></table></figure><p>​    如果这样定义的话，red的值为0，blue的值为1，然后一次增长。</p><p>​    如果从中间开始赋值的话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123;red,blue,green=<span class="number">5</span>,yellow&#125;;</span><br></pre></td></tr></table></figure><p>​    那么<strong>red到blue是按照默认的从0开始增长的</strong>，green就是定义的值5，<strong>green之后的值都是从5开始增长的</strong>。</p><p>​    当然你也可以为每个枚举的变量都赋值，这样就和全都用define定义是一样的了，如果枚举中有某个值没有被赋值，那么它将是从前一个赋值的变 量开始，一次增加1.</p><h4 id="限定变量的范围"><a href="#限定变量的范围" class="headerlink" title="限定变量的范围"></a>限定变量的范围</h4><p>​    比如我们的应用程序中要处理有关月份的东西，显然月份只能取1-12中的某个数字，为了保证程序的正确性和健壮性，我们应该使用enum。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Month &#123;Jan=<span class="number">1</span>,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">enum</span> Month a =  Feb;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如像这样，定义的枚举类型 a 的取值只能是那12个变量中的一个，如果赋予了其他的变量，编译器就会报错。</p><h5 id="enum另几种用法"><a href="#enum另几种用法" class="headerlink" title="enum另几种用法"></a>enum另几种用法</h5><ul><li>在定义enum的同时，声明变量：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Month &#123;Jan=<span class="number">1</span>,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125; a,b;</span><br></pre></td></tr></table></figure><p>​    这样就声明了两个枚举类型a和b</p><ul><li>定义完enum之后再声明变量：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Month &#123;Jan=<span class="number">1</span>,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125;;</span><br><span class="line"><span class="keyword">enum</span> Month a =  Feb;</span><br></pre></td></tr></table></figure><ul><li>定义匿名的枚举变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>  &#123;Jan=<span class="number">1</span>,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125; a;</span><br></pre></td></tr></table></figure><p>​    这样的话，只能使用a这一个枚举类型的变量，不能再定义其他的枚举类型。</p><ul><li>typedef  enum则是用来定义一个数据类型，那么该类型的变量值只能在enum定义的范围内取</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>  &#123;Jan=<span class="number">1</span>,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125; Day;</span><br><span class="line">Day a, b;</span><br></pre></td></tr></table></figure><p><strong>注意与宏定义区别：</strong></p><p>enum用来定义一系列宏定义常量区别用，相当于一系列的#define xx xx，当然它后面的标识符也可当作一个类型标识符；</p><p>typedef  enum则是用来定义一个数据类型，那么该类型的变量值只能在enum定义的范围内取。两者在这点上是没有差别的。</p><p><strong>注意：同一个程序中不能定义同名的枚举类型，不同的枚举类型中也不能存在同名的命名常量</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  了解C语言enum枚举类型定义变量&lt;/p&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>hexo腾讯云COS部署+Markdown图床</title>
    <link href="http://yoursite.com/2019/05/08/hexo%E8%85%BE%E8%AE%AF%E4%BA%91cos%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2019/05/08/hexo腾讯云cos部署/</id>
    <published>2019-05-08T14:16:02.000Z</published>
    <updated>2019-05-09T01:27:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>静态博客网站的需求就是一片足够大的空间，而腾讯云COS提供免费50G的存储空间，无疑是一个不错的选择。</p><p>同时也可以用腾讯云cos制作Markdown的图床，这样网站访问速度会比较快</p><a id="more"></a><h2 id="hexo部署腾讯云cos"><a href="#hexo部署腾讯云cos" class="headerlink" title="hexo部署腾讯云cos"></a>hexo部署腾讯云cos</h2><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>​        域名注册与备案</p><blockquote><p>注意：腾讯云cos绑定cdn域名加速时需要备案域名，而域名的备案需要购买腾讯云的服务器。这点比较坑！</p><p>根据个人情况选择，也可以选择上篇博文，采用<code>hexo双站点部署</code></p></blockquote><h3 id="创建存储桶-Bucket"><a href="#创建存储桶-Bucket" class="headerlink" title="创建存储桶(Bucket)"></a>创建存储桶(Bucket)</h3><ul><li><strong>创建存储桶</strong> <a href="http://console.cloud.tencent.com/cos5/bucket" target="_blank" rel="noopener">COS地址</a></li></ul><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-141726@2x.png" alt></p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-141825@2x.png" alt></p><p>填写名称后，选择权限为<strong>公有读私有写</strong>。</p><h3 id="配置存储桶"><a href="#配置存储桶" class="headerlink" title="配置存储桶"></a>配置存储桶</h3><ul><li><p><strong>选择基础配置</strong><br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-141924@2x.png" alt></p></li><li><p><strong>编辑静态网站</strong><br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-141947@2x.png" alt></p></li><li><p><strong>打开设置</strong><br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-142142@2x.png" alt></p></li></ul><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><ul><li>域名管理，添加域名，选择<strong>静态网站源站</strong><br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-142336@2x.png" alt></li></ul><ul><li>域名解析，添加记录<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-142950@2x.png" alt></li></ul><ul><li>第一个框为<strong>二级域名</strong>，第二个框为<strong>记录值</strong>。<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-143210@2x.png" alt></li></ul><h3 id="上传文件测试"><a href="#上传文件测试" class="headerlink" title="上传文件测试"></a>上传文件测试</h3><ul><li>在test存储桶上传<code>CNAME</code>文件和<code>index.html</code>进行测试。</li><li><p>CANME文件的内容为（域名换成自己的域名）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.fiftykg.com</span><br></pre></td></tr></table></figure></li><li><p><code>index.html</code>的内容为：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>测试主页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">测试主页内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在浏览器中查看结果：<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-183101@2x.png" alt></li></ul><h3 id="刷新CDN缓存"><a href="#刷新CDN缓存" class="headerlink" title="刷新CDN缓存"></a>刷新CDN缓存</h3><ul><li><p>上图的效果是不能立刻看到的，大部分时候需要等待。</p><p>有可能你会看到以下的效果：<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-182126@2x.png" alt></p></li></ul><ul><li>首先请确认你的网站类型为<code>静态网站源站</code>。如果设置正确，那么可能需要手动刷新以下cdn的缓存：</li></ul><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-182852@2x.png" alt></p><h3 id="hexo部署"><a href="#hexo部署" class="headerlink" title="hexo部署"></a>hexo部署</h3><p>安装cos部署插件：</p><p><code>npm install hexo-deployer-cos --save</code></p><ul><li>在根目录的<code>_config.yml</code>配置：<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-184622@2x.png" alt></li></ul><ul><li><p>region等参数可以在下图位置查看：<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/WX20180902-184118@2x.png" alt></p><p>秘钥可以在<code>访问管理</code>中<code>云API秘密钥</code>中找到。</p></li></ul><h2 id="Markdown图床"><a href="#Markdown图床" class="headerlink" title="Markdown图床"></a>Markdown图床</h2><h3 id="创建存储桶-Bucket-1"><a href="#创建存储桶-Bucket-1" class="headerlink" title="创建存储桶(Bucket)"></a>创建存储桶(Bucket)</h3><ul><li><strong>创建存储桶</strong> <a href="http://console.cloud.tencent.com/cos5/bucket" target="_blank" rel="noopener">COS地址</a></li></ul><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1557315247262.png" alt></p><p>填写名称后，选择权限为<strong>公有读写</strong>。</p><h3 id="PicGo-客户端配置"><a href="#PicGo-客户端配置" class="headerlink" title="PicGo 客户端配置"></a>PicGo 客户端配置</h3><h4 id="下载-amp-安装"><a href="#下载-amp-安装" class="headerlink" title="下载&amp;安装"></a>下载&amp;安装</h4><p>​    PicGo （目前 2.0.4）是一个开源的图床工具，非常优秀。可以到 git 上下载，但下载速度太慢，所以我放了一个百度云的链接，速度快很多。</p><ul><li>git的地址：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo</a></li><li>Win版下载链接：<a href="https://pan.baidu.com/s/1sr7DKuP7p0WQ1WNBK3Zkow" target="_blank" rel="noopener">https://pan.baidu.com/s/1sr7DKuP7p0WQ1WNBK3Zkow</a>  提取码：d4cx</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1557315547061.png" alt></p><ul><li><p>存储空间名：所存储图片的桶名称</p></li><li><p>存储路径：选择的地区，例如：<code>ap-guangzhou</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态博客网站的需求就是一片足够大的空间，而腾讯云COS提供免费50G的存储空间，无疑是一个不错的选择。&lt;/p&gt;
&lt;p&gt;同时也可以用腾讯云cos制作Markdown的图床，这样网站访问速度会比较快&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
      <category term="Markdown" scheme="http://yoursite.com/categories/Hexo/Markdown/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>ceph部署难题</title>
    <link href="http://yoursite.com/2019/05/08/ceph-%E9%83%A8%E7%BD%B2%E9%9A%BE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/05/08/ceph-部署难题（一）/</id>
    <published>2019-05-08T14:16:02.000Z</published>
    <updated>2019-05-09T01:26:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章总结了搭建ceph集群过程中遇到的各种问题，以及相应的原理过程</p><a id="more"></a><h3 id="Q1-环境预准备"><a href="#Q1-环境预准备" class="headerlink" title="Q1. 环境预准备**"></a>Q1. 环境预准备**</h3><p>​        绝大多数MON创建的失败都是由于防火墙没有关导致的，亦或是SeLinux没关闭导致的。一定一定一定要关闭每个每个每个节点的防火墙(执行一次就好，没安装报错就忽视)：</p><p><strong>CentOS</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/SELINUX=.*/SELINUX=disabled/'</span> /etc/selinux/config</span><br><span class="line">setenforce <span class="number">0</span></span><br><span class="line">systemctl stop firewalld </span><br><span class="line">systemctl disable firewalld</span><br><span class="line"># iptables -F</span><br><span class="line">service iptables stop</span><br></pre></td></tr></table></figure><h3 id="Q2-清理环境"><a href="#Q2-清理环境" class="headerlink" title="Q2. 清理环境"></a><strong>Q2. 清理环境</strong></h3><p>​        MON部署不上的第二大问题就是在旧的节点部署MON，或者在这个节点部署MON失败了，然后重新<code>new</code>再<code>mon create-initial</code>，请查看要部署MON的节点上的<code>/var/lib/ceph/mon/</code>目录下是否为空，如果不为空，说明已经在这个目录部署过MON，再次部署会检测子目录下的<code>done</code>文件，由于有了这个文件，就不会再建立新的MON数据库，并且不会覆盖之，导致了部署时的各种异常，这里就不赘述了，直接给出万能清理大法：</p><p><strong>对于任何需要新部署MON的节点，请到这个节点下执行如下指令，确保环境已经清理干净：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep ceph |awk <span class="string">'&#123;print $2&#125;'</span>|xargs kill <span class="number">-9</span></span><br><span class="line">ps -ef|grep ceph</span><br><span class="line">#确保此时所有ceph进程都已经关闭！！！如果没有关闭，多执行几次。</span><br><span class="line">rm -rf /<span class="keyword">var</span>/lib/ceph/mon<span class="comment">/*</span></span><br><span class="line"><span class="comment">rm -rf /var/lib/ceph/bootstrap-mds/*</span></span><br><span class="line"><span class="comment">rm -rf /var/lib/ceph/bootstrap-osd/*</span></span><br><span class="line"><span class="comment">rm -rf /var/lib/ceph/bootstrap-rgw/*</span></span><br><span class="line"><span class="comment">rm -rf /etc/ceph/*</span></span><br><span class="line"><span class="comment">rm -rf /var/run/ceph/*</span></span><br></pre></td></tr></table></figure><p>请直接复制粘贴，遇到过好些个自己打错打漏删了目录的。</p><h3 id="Q3-部署前最后的确认"><a href="#Q3-部署前最后的确认" class="headerlink" title="Q3. 部署前最后的确认"></a><strong>Q3. 部署前最后的确认</strong></h3><p>这里介绍的都是个案，不过还是需要提一下：</p><ul><li>确保每个节点的<code>hostname</code>都设置正确，并且添加至<code>/etc/hosts</code>文件中，然后同步到所有节点下。克隆出来的虚拟机或者批量建的虚拟机有可能发生此情形。</li><li>确保以下目录在各个节点都存在：</li><li><code>/var/lib/ceph/</code></li><li><code>/var/lib/ceph/mon/</code></li><li><code>/var/lib/ceph/osd/</code></li><li><code>/etc/ceph/</code></li><li><code>/var/run/ceph/</code></li><li>上面的目录，如果Ceph版本大于等于<code>jewel</code>,请确认权限均为<code>ceph:ceph</code>，如果是<code>root:root</code>，请自行<code>chown</code>。</li></ul><h3 id="Q4-安装Ceph"><a href="#Q4-安装Ceph" class="headerlink" title="Q4. 安装Ceph"></a><strong>Q4. 安装Ceph</strong></h3><p>​        官网指导方法是使用<code>ceph-deploy install nodeX</code>,但是因为是国外的源，速度慢得令人发指，所以我们换到阿里的源，并且使用<code>yum install</code>的方式安装，没差啦其实，这样反而还快点，毕竟多个节点一起装。</p><p><strong>很多安装失败的都是因为没有添加epel源请在每个存储节点都执行以下指令，来安装Ceph:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">rm -rf /etc/yum.repos.d<span class="comment">/*.repo</span></span><br><span class="line"><span class="comment">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"><span class="comment">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span></span><br><span class="line"><span class="comment">sed -i '/aliyuncs/d' /etc/yum.repos.d/CentOS-Base.repo</span></span><br><span class="line"><span class="comment">sed -i '/aliyuncs/d' /etc/yum.repos.d/epel.repo</span></span><br><span class="line"><span class="comment">sed -i 's/$releasever/7.2.1511/g' /etc/yum.repos.d/CentOS-Base.repo</span></span><br><span class="line"><span class="comment">echo "</span></span><br><span class="line"><span class="comment">[ceph]</span></span><br><span class="line"><span class="comment">name=ceph</span></span><br><span class="line"><span class="comment">baseurl=http://mirrors.aliyun.com/ceph/rpm-hammer/el7/x86_64/</span></span><br><span class="line"><span class="comment">gpgcheck=0</span></span><br><span class="line"><span class="comment">[ceph-noarch]</span></span><br><span class="line"><span class="comment">name=cephnoarch</span></span><br><span class="line"><span class="comment">baseurl=http://mirrors.aliyun.com/ceph/rpm-hammer/el7/noarch/</span></span><br><span class="line"><span class="comment">gpgcheck=0</span></span><br><span class="line"><span class="comment">" &gt; /etc/yum.repos.d/ceph.repo</span></span><br><span class="line"><span class="comment">yum install ceph ceph-radosgw -y</span></span><br></pre></td></tr></table></figure><p>这里是安装的<code>hammer</code>版本的Ceph，如果需要安装<code>jewel</code>版本的，请执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/hammer/jewel/'</span> /etc/yum.repos.d/ceph.repo</span><br><span class="line">yum install ceph ceph-radosgw -y</span><br></pre></td></tr></table></figure><p>如果安装了<code>jewel</code>版本的Ceph，想要换回<code>hammer</code>版本的Ceph，可以执行下面的指令：</p><p><strong>卸载Ceph客户端</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa |grep <span class="string">`ceph -v |awk '&#123;print $3&#125;'`</span> |xargs rpm -e --nodeps</span><br></pre></td></tr></table></figure><p><strong>更改ceph.repo里面的Ceph版本</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/jewel/hammer/'</span> /etc/yum.repos.d/ceph.repo</span><br><span class="line">yum install ceph ceph-radosgw -y</span><br></pre></td></tr></table></figure><h3 id="Q5-ceph-deploy"><a href="#Q5-ceph-deploy" class="headerlink" title="Q5. ceph-deploy"></a><strong>Q5. ceph-deploy</strong></h3><p>这里我要开启话唠模式：</p><p><strong>① Ceph-deploy 是什么？</strong></p><p>​        Ceph-deploy是Ceph官方给出的用于<strong>部署Ceph</strong>的一个工具，这个工具几乎全部是Python写的脚本，其代码位于<code>/usr/lib/python2.7/site-packages/ceph_deploy</code>目录下(<code>1.5.36</code>版本)。最主要的功能就是用几个简单的指令部署好一个集群，而不是手动部署操碎了心，敲错一个地方就可能失败。所以对于新人来说，或者说以我的经验，接触Ceph少于一个月的，又或者说，集群规模不上PB的，都没有必要手动部署，Ceph-deploy完全足够了。</p><p><strong>② Ceph-deploy怎么装?</strong></p><p>​        这个包在ceph的源里面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ceph-deploy -y</span><br></pre></td></tr></table></figure><p><strong>③Ceph-deploy装在哪？</strong></p><p>​        既然Ceph-deploy只是个部署Ceph的脚本工具而已，那么这个工具随便装在哪个节点都可以，<strong>并不需要单独为了装这个工具再搞个节点</strong>，我一般习惯放在第一个节点，以后好找部署目录。</p><p><strong>④Ceph-deploy怎么用？</strong></p><p>​        详细的指令暂时不介绍，下面会有，在安装好后，需要在这个节点新建一个目录，用作<code>部署目录</code>，这里是强烈建议建一个单独的目录的，比如我习惯在集群的第一个节点下建一个<code>/root/cluster</code>目录，为了以后好找。<strong>Ceph-deploy的所有的指令都需要在这个目录下执行</strong>。包括<code>new,mon,osd</code>等等一切ceph-deploy的指令都需要在这个部署目录下执行！最后一遍，所有的<code>ceph-deploy</code>的指令都要在部署目录下执行！否则就会报下面的错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ceph_deploy][ERROR ] ConfigError: Cannot load config: [Errno <span class="number">2</span>] No such file or directory: <span class="string">'ceph.conf'</span>; has ceph-deploy <span class="keyword">new</span> been run <span class="keyword">in</span> <span class="keyword">this</span> directory?</span><br></pre></td></tr></table></figure><p><strong>⑤ Ceph-deploy怎么部署集群?</strong></p><p>​        我们暂且把<strong>部署目录</strong>所在的节点叫做<strong>部署节点</strong>。Ceph-deploy通过SSH到各个节点，然后再在各个节点执行本机的Ceph指令来创建MON或者OSD等。所以在部署之前，你需要从<code>部署节点ssh-copy-id</code>到各个集群节点，使其可以免秘钥登陆。</p><p><strong>⑥Ceph-deploy部署的日志在哪里?</strong></p><p>​        就在部署目录下面的<code>ceph-deploy-ceph.log</code>文件，部署过程中产生的所有的日志都会保存在里面，比如你大半年前敲的创建OSD的指令。在哪个目录下执行ceph-deploy指令，就会在这个目录下生成log，如果你跑到别的目录下执行，就会在执行目录里生成log再记下第四点的错。当然，这个LOG最有用的地方还是里面记录的部署指令，你可以通过<code>cat ceph-deploy-ceph.log |grep &quot;Running command&quot;</code>查看到创建一个集群所需的所有指令，这对你手动建立集群或者创建秘钥等等等等有着很大的帮助！！！</p><p><strong>⑦ Ceph-deploy版本</strong></p><p>​        写这段时的最新的版本号为<code>1.5.36</code>，下载链接为ceph-deploy-1.5.36-0.noarch.rpm， 之前的<code>1.5.35</code>里面有点bug在这个版本被修复了，如果使用<code>1.5.25</code>部署遇到了问题，可以更新至这个版本，会绕过一些坑。更新到<code>1.5.36</code>之后，腰也不酸了,退了不疼了，Ceph也能部署上了。</p><h3 id="Q6-ceph-deploy-new-做了什么"><a href="#Q6-ceph-deploy-new-做了什么" class="headerlink" title="Q6. ceph-deploy new 做了什么"></a><strong>Q6. ceph-deploy new 做了什么</strong></h3><p>​        <strong>进入部署目录</strong>，执行<code>ceph-deploy new node1 node2 node3</code>，会生成两个文件（第三个是<code>ceph-deploy-ceph.log</code>，忽视之）:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@blog cluster]# ls</span><br><span class="line">ceph.conf  ceph-deploy-ceph.log  ceph.mon.keyring</span><br></pre></td></tr></table></figure><p>​        <code>new</code>后面跟的是你即将部署MON的节点的<code>hostname</code>，推荐三个就够了，需要是奇数个MON节点。不要因为只有两个节点就搞两个MON，两个节点请用一个MON，因为两个MON挂掉一个，集群也就挂了，和一个MON挂掉一个效果是一样的。生成的<code>ceph.conf</code>默认情况下长成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@blog cluster]# cat ceph.conf </span><br><span class="line">[global]</span><br><span class="line">fsid = <span class="number">13</span>b5d863<span class="number">-75</span>aa<span class="number">-479</span>d<span class="number">-84</span>ba<span class="number">-9e5</span>edd881ec9</span><br><span class="line">mon_initial_members = blog</span><br><span class="line">mon_host = <span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span></span><br><span class="line">auth_cluster_required = cephx</span><br><span class="line">auth_service_required = cephx</span><br><span class="line">auth_client_required = cephx</span><br></pre></td></tr></table></figure><p>​        会调用<code>uuidgen</code>生成一个<code>fsid</code>，用作集群的唯一ID，再将<code>new</code>后面的主机加入到<code>mon_initial_members</code>和<code>mon_host</code>里面，剩下的三行大家都是一样的，默认开启CephX认证。下面有一节会专门介绍这个，需要注意的是，<strong>部署的时候，千万不要动这三行</strong> 下面会有一节介绍之。还有一个文件<code>ceph.mon.keyring</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@blog cluster]# cat ceph.mon.keyring </span><br><span class="line">[mon.]</span><br><span class="line">key = AQB1yWRYAAAAABAAhMoAcadfCdy9VtAaY79+Sw==</span><br><span class="line">caps mon = allow *</span><br></pre></td></tr></table></figure><p>​        除了<code>key</code>的内容不一样，剩下的都会是一样的。因为是开启了CephX认证了，所以MON直接的通讯是需要一个秘钥的，<code>key</code>的内容就是秘钥。是不是对Ceph里面的明文认证感到吃惊，有总比没有强。如果，你再次执行<code>new</code>，会生成新的<code>ceph.conf</code>和新的<code>ceph.mon.keyring</code>，并将之前的这两个文件给覆盖掉，新旧文件唯一不同的就是<code>fsid</code>和<code>key</code>的内容，但是对Ceph来说，这就是两个集群了。这里说一下我个人非常非常非常反感的一个问题，有的朋友喜欢在<code>/etc/ceph/</code>目录下面执行ceph-deploy的命令，这么做和在<strong>部署目录</strong>下面做一般是没有差别的，因为这两个目录下面都有<code>ceph.conf</code>和<code>ceph.client.admin.keyring</code>，但是我还是强烈推荐创建独立的<strong>部署目录</strong>，因为<code>/etc/ceph</code>目录是Ceph节点的运行目录，为了体现各自的功能性，也为了安全性，<strong>请不要在</strong><code>**/etc/ceph**</code><strong>目录下部署集群！！！</strong></p><h3 id="Q7-为ceph-deploy添加参数"><a href="#Q7-为ceph-deploy添加参数" class="headerlink" title="Q7. 为ceph-deploy添加参数"></a><strong>Q7. 为ceph-deploy添加参数</strong></h3><p>​        Ceph-deploy的log还是很有看头的，查看<code>ceph-deploy new blog</code>(blog是我的一台主机)的log：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@blog cluster]# ceph-deploy new blog</span><br><span class="line">[ceph_deploy.conf][DEBUG ] found configuration file at: <span class="regexp">/root/</span>.cephdeploy.conf</span><br><span class="line">[ceph_deploy.cli][INFO  ] Invoked (<span class="number">1.5</span><span class="number">.36</span>): <span class="regexp">/usr/</span>bin/ceph-deploy <span class="keyword">new</span> blog</span><br><span class="line">[ceph_deploy.cli][INFO  ] ceph-deploy options:</span><br><span class="line">[ceph_deploy.cli][INFO  ]  username                      : None</span><br><span class="line">[ceph_deploy.cli][INFO  ]  func                          : <span class="xml"><span class="tag">&lt;<span class="name">function</span> <span class="attr">new</span> <span class="attr">at</span> <span class="attr">0x288e2a8</span>&gt;</span></span></span><br><span class="line"><span class="xml">[ceph_deploy.cli][INFO  ]  verbose                       : False</span></span><br><span class="line"><span class="xml">[ceph_deploy.cli][INFO  ]  overwrite_conf                : False</span></span><br><span class="line"><span class="xml">[ceph_deploy.cli][INFO  ]  quiet                         : False</span></span><br><span class="line">[ceph_deploy.cli][INFO  ]  cd_conf                       : &lt;ceph_deploy.conf.cephdeploy.Conf instance at 0x28eccf8&gt;</span><br><span class="line">[ceph_deploy.cli][INFO  ]  cluster                       : ceph</span><br><span class="line">[ceph_deploy.cli][INFO  ]  ssh_copykey                   : True</span><br><span class="line">[ceph_deploy.cli][INFO  ]  mon                           : ['blog']</span><br><span class="line">[ceph_deploy.cli][INFO  ]  public_network                : None</span><br><span class="line">[ceph_deploy.cli][INFO  ]  ceph_conf                     : None</span><br><span class="line">[ceph_deploy.cli][INFO  ]  cluster_network               : None</span><br><span class="line">[ceph_deploy.cli][INFO  ]  default_release               : False</span><br><span class="line">[ceph_deploy.cli][INFO  ]   fsid                          : None</span><br><span class="line">[ceph_deploy.new][DEBUG ] Creating new cluster named ceph</span><br></pre></td></tr></table></figure><p>​        可以看到有很多的参数被列出来了，比如：<code>mon : [&#39;blog&#39;]</code>，也有很多参数是False或者None， 这些参数能否被设置呢? 因为这里我们可以看到有<code>fsid : None</code> 这个参数，难道集群的<code>fsid</code>可以被指定吗？抱着这些疑惑，我就去看完了ceph-deploy的所有代码，答案是：可以设置。所有上面的参数都可以使用参数的形式进行设置，只需要在前面加上两个<code>--</code>，比如对于<code>fsid</code>可以执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy  <span class="keyword">new</span> blog --fsid xx-xx-xx-xxxx</span><br></pre></td></tr></table></figure><p>​        如果想要查看每个执行可指定的参数，可以<code>-h</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@blog cluster]# ceph-deploy new -h</span><br><span class="line">usage: ceph-deploy <span class="keyword">new</span> [-h] [--no-ssh-copykey] [--fsid FSID]</span><br><span class="line">                      [--cluster-network CLUSTER_NETWORK]</span><br><span class="line">                      [--public-network PUBLIC_NETWORK]</span><br><span class="line">                      MON [MON ...]</span><br><span class="line">...</span><br><span class="line">optional <span class="built_in">arguments</span>:</span><br><span class="line">  -h, --help            show <span class="keyword">this</span> help message and exit</span><br><span class="line">  --no-ssh-copykey      <span class="keyword">do</span> not attempt to copy SSH keys</span><br><span class="line">  --fsid FSID           provide an alternate FSID <span class="keyword">for</span> ceph.conf generation</span><br><span class="line">  --cluster-network CLUSTER_NETWORK</span><br><span class="line">                        specify the (internal) cluster network</span><br><span class="line">  --public-network PUBLIC_NETWORK</span><br><span class="line">                        specify the public network <span class="keyword">for</span> a cluster</span><br></pre></td></tr></table></figure><p>​        这里就可以看到可以指定<code>--cluster-network</code>，<code>--public-network</code>，等等，如果<code>optional arguments</code>里面没有介绍这个参数，可以直接使用<code>--xxarg</code>的方式指定，比如<code>--overwrite-conf</code>，<code>--verbose</code>等等，能不能设置这些参数，自己动手试一下就知道了。需要注意的是，参数的位置根据指令而异，比如<code>--overwrite-conf</code>参数是跟在<code>ceph-deploy</code>后面的，而<code>--public-network</code>是跟在<code>new</code>后面的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy --overwrite-conf --verbose <span class="keyword">new</span> blog --fsid a-a-a-a</span><br><span class="line">[root@blog cluster]# cat ceph.conf |grep fsid</span><br><span class="line">fsid = a-a-a-a</span><br></pre></td></tr></table></figure><h3 id="Q8-Public-VS-Cluster"><a href="#Q8-Public-VS-Cluster" class="headerlink" title="Q8. Public VS Cluster"></a><strong>Q8. Public VS Cluster</strong></h3><p>​        如果非要在刚刚生成的ceph.conf里面添加什么的话，那么可能就要加public_network或者cluster_network了。那么这两个配置项有什么用呢？这里简单得介绍下Ceph的Public(外网或者叫公网或者前端网)和Cluster(内网或者叫集群网或者叫后端网)这两个网络，在Ceph中，存在以下三种主要的网络通讯关系：</p><ul><li>client-&gt; mon =&gt;public : 也就是客户端获取集群状态，或者叫客户端与MON通讯走的网络，是走的外网。</li><li>client-&gt; osd =&gt; public : 也就是客户端向OSD直接写入数据走的也是外网。</li><li>osd<-> osd =&gt; cluster ：也就是OSD之间的数据克隆，恢复走的是内网，客户端写第一份数据时通过外网写，对于三副本剩下的两个副本OSD之间通过内网完成数据复制。当OSD挂掉之后产生的recover,走的也是内网。</-></li></ul><p>通常，我们会将外网配置为千兆网，而内网配置成万兆网，这是有一定原因的：</p><ul><li>客户端可能由成百上千的计算节点组成，外网配成万兆成本太高。</li><li>存储节点一般只有几个到几十个节点，配置了万兆内网可以大大加快故障恢复速度，而且剩余的两副本写速度会大大加快，万兆网的性价比极高。举个例子，集群坏掉一个OSD千兆需要一小时，那么万兆网只需要五六分钟，一定程度上增加了集群的安全性。</li></ul><p>借用官网的这张图来说明集群的网络走势：再假设你的节点有两个网段172.23.0.1和3.3.4.1，还记得我们上一节<code>ceph-deploy new</code>的时候是可以指定<code>public_network</code>和<code>cluster_network</code>的吗！如果不指定这两个参数，那么ceph-deploy怎么知道用哪个IP作为这个节点的<code>mon_host</code>的IP呢，其实他是随便选的，如果它选了172网段但是你想使用3.3网段作为这个节点的<code>mon_host</code>的IP，那么只需要指定<code>--public-network 172.23.0.0/24</code> 就可以了，其中的<code>/24</code>就相当于一个掩码，表示前面的IP的前24位，也就是<code>172.23.0.XXX</code>，只要你的主机上有一个处于这个范围内的IP，那么就会选择这个IP作为公网IP。类似的，<code>/16</code>表示范围：<code>172.23.XXX.XXX</code>。 如果想指定内网IP，那么只要指定<code>--cluster-network 3.3.4.1/24</code>就可以了。</p><p>​        <strong>一般情况下，会在new生成的ceph.conf文件里加入public_network配置项以指定公网IP。当然你的MON主机上需要有至少一个IP在公网范围内。</strong>除了在生成的<code>ceph.conf</code>文件中加入公网IP的方式，我们还可以使用参数的方式来指定公网IP：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-1 cluster]# ceph-deploy new ceph-1 --public-network 172.23.0.0/24</span><br><span class="line">[ceph_deploy.cli][INFO  ] Invoked (<span class="number">1.5</span><span class="number">.36</span>): <span class="regexp">/usr/</span>bin/ceph-deploy <span class="keyword">new</span> ceph<span class="number">-1</span> --public-network <span class="number">172.23</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">24</span></span><br><span class="line">[ceph_deploy.cli][INFO  ] ceph-deploy options:</span><br><span class="line">...</span><br><span class="line">[ceph_deploy.cli][INFO  ]  public_network                : <span class="number">172.23</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">24</span></span><br><span class="line">...</span><br><span class="line">[ceph<span class="number">-1</span>][DEBUG ] IP addresses found: [u<span class="string">'172.23.0.101'</span>, u<span class="string">'10.0.2.15'</span>]</span><br><span class="line">[ceph_deploy.new][DEBUG ] Resolving host ceph<span class="number">-1</span></span><br><span class="line">[ceph_deploy.new][DEBUG ] Monitor ceph<span class="number">-1</span> at <span class="number">172.23</span><span class="number">.0</span><span class="number">.101</span></span><br><span class="line">[ceph_deploy.new][DEBUG ] Monitor initial members are [<span class="string">'ceph-1'</span>]</span><br><span class="line">[ceph_deploy.new][DEBUG ] Monitor addrs are [u<span class="string">'172.23.0.101'</span>]</span><br><span class="line">[ceph_deploy.new][DEBUG ] Writing monitor keyring to ceph.mon.keyring...</span><br><span class="line">[ceph_deploy.new][DEBUG ] Writing initial config to ceph.conf...</span><br><span class="line">[root@ceph-1 cluster]# cat ceph.conf </span><br><span class="line">[global]</span><br><span class="line">fsid = d2a2bccc-b215<span class="number">-4</span>f3e<span class="number">-922</span>b-cf6019068e76</span><br><span class="line">public_network = <span class="number">172.23</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">24</span></span><br><span class="line">mon_initial_members = ceph<span class="number">-1</span></span><br><span class="line">mon_host = <span class="number">172.23</span><span class="number">.0</span><span class="number">.101</span></span><br><span class="line">auth_cluster_required = cephx</span><br><span class="line">auth_service_required = cephx</span><br><span class="line">auth_client_required = cephx</span><br></pre></td></tr></table></figure><p>​        查看部署log可以发现参数配置已经生效，而这个节点有两个IP，<code>public_nwtwork</code>这个参数限定了公网IP的搜索范围，生成的ceph.conf文件内也包含了<code>public_network</code>这个参数。</p><h3 id="Q9-参数是下划线还是空格分隔"><a href="#Q9-参数是下划线还是空格分隔" class="headerlink" title="Q9. 参数是下划线还是空格分隔"></a><strong>Q9. 参数是下划线还是空格分隔</strong></h3><p>​        这里只是简单的提一下这个小困惑，对于以下的两个参数书写方式，哪种会有问题呢：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public_network = <span class="number">172.23</span><span class="number">.0</span><span class="number">.1</span>/<span class="number">24</span></span><br><span class="line">public network = <span class="number">172.23</span><span class="number">.0</span><span class="number">.1</span>/<span class="number">24</span></span><br><span class="line">osd_journal_size = <span class="number">128</span></span><br><span class="line">osd journal size = <span class="number">128</span></span><br></pre></td></tr></table></figure><p>​        这两种参数的书写方式其实都是正确的，说到底是因为底层调用的是Python的<code>argparse</code>模块。这两种方式都是等效的，所以不需要担心。</p><h3 id="Q10-ceph-deploy-mon-create-initial如何一次性通过"><a href="#Q10-ceph-deploy-mon-create-initial如何一次性通过" class="headerlink" title="Q10. ceph-deploy mon create-initial如何一次性通过"></a><strong>Q10. ceph-deploy mon create-initial如何一次性通过</strong></h3><p>​        这一步坑哭了多少迫切加入Ceph世界的新人，看到的最多的就是5s，10s，10s, 15s，20s。。。然后报了错。再执行，再报错。所以这里给出以下的预检清单，如果被报错失败所烦恼，请认真执行各个子项，尤其是失败后要执行清理环境：</p><ol><li>请确保所有节点都安装了Ceph。</li><li>请确保所有节点的防火墙等都关闭了。参考<strong>环境预准备</strong>一节</li><li>请前往各个MON节点清理干净，不论你是否相信这个节点是干净的。参考<strong>清理环境</strong>一节。</li><li>请确保各个MON节点下存在以下目录，并且对于Jewel版本及之后的请确保目录权限为<code>ceph:ceph</code>。参考<strong>部署前最后的确认</strong>一节。</li><li>请在<code>ceph-deploy new</code>生成的<code>ceph.conf</code>内添加<code>public_network</code>配置项，参考<strong>Public VS Cluster</strong>一节。</li></ol><p>这些总结来之不易，我帮过上百个人解决过部署问题和集群故障。我相信在<strong>认真确认</strong>过之后是肯定可以通过的(反正前三点如果有问题一般是不会建好MON的，为什么不认真确认下呢)，我遇到过绝大多数都是因为防火墙没关，或者手动删除了一些目录，或者没有修改权限导致的问题。</p><p>​        相对来说，新环境只要关了防火墙就可以一次性通过，旧环境或者失败的环境只要清理环境就可以通过了。</p><p><strong>Q11. mon create-initial 做了什么</strong></p><p>简单介绍下流程：</p><ul><li><p>ceph-deploy读取配置文件中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mon_initial_members</span><br></pre></td></tr></table></figure><p>的各个主机，然后依次SSH前往各个主机：</p><ol><li>将<strong>部署目录</strong>下的ceph.conf推送到新节点的<code>/etc/ceph/</code>目录下。</li><li>创建<code>/var/lib/ceph/mon/$cluster-$hostname/</code>目录。</li><li>检查MON目录下是否有<code>done</code>文件，如果有则直接跳到第6步。</li><li>将<code>ceph.mon.keyring</code>拷贝到新节点，并利用该秘钥在MON目录下建立MON数据库。</li><li>在MON目录下建立done文件，防止重新建立MON。</li><li>启动MON进程。</li><li>查看<code>/var/run/ceph/$cluster-mon.$hostname.asok</code>SOCKET文件，这个是由MON进程启动后生成的，输出MON状态。</li></ol></li><li><p>在所有的MON都建立好后，再次前往各个主机，查看所有主机是否运行并且到达法定人群(quorum)。如果有没到到的，直接结束报错。如果都到达了，执行下一步。</p></li><li><p>调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth get-or-create</span><br></pre></td></tr></table></figure><p>方法创建(如果不存在)或者拉取(已经存在)MON节点上的以下几个keyring到</p><p>部署目录</p><p>中：</p><ul><li><code>ceph.bootstrap-mds.keyring</code></li><li><code>ceph.bootstrap-osd.keyring</code></li><li><code>ceph.bootstrap-rgw.keyring</code></li><li><code>ceph.client.admin.keyring</code></li></ul></li><li><p>指令结束。</p></li></ul><h3 id="Q12-mon-create-initial-为什么会失败"><a href="#Q12-mon-create-initial-为什么会失败" class="headerlink" title="Q12. mon create-initial 为什么会失败"></a><strong>Q12. mon create-initial 为什么会失败</strong></h3><p>​        我不喜欢讲怎么做，我愿意花很大的篇幅介绍为什么会造成各种各样的问题，如果知道了原因，你自然知道该怎么做，所以才会理解Ceph，而不是机械的去敲指令。</p><p>综合上面的所有小节，我来总结下这一步失败的基本上所有可能的原因：</p><ul><li>所谓MON的quorum，相当于多个MON形成的一个群体，它们之间需要通过网络发送数据包来通讯达成某种协议，如果打开了防火墙，会阻断数据交流。所以不能构成群体，一直等待(5s-&gt;10s-&gt;10s-&gt;15s-&gt;20s)其他MON的数据包，既然被阻断了这样的等待是没有意义的，等了30s还没有正常，就可以直接<code>ctrl+z</code>去检查了。</li><li>我在配置文件里面添加了<code>pubilc_network</code>，但是有个主机的所有IP都不在公网IP段内，那么这个MON是建不好的，因为没有IP用作MON使用，<code>public_network</code>相当于一个<strong>过滤器</strong>。</li><li>搭好了一台虚拟机后，直接克隆了两台，没有修改主机名，导致socket文件路径名识别错误，报了异常，不过这很少发生。</li><li>如果在旧的MON节点上再次部署新的MON，再又没有清理环境，之前的MON数据库会保留着<code>done</code>文件，MON数据库里面还是记录着之前fsid，keyring等等，和新集群是两套完全不同的，所以这个节点的MON自然到达不了MON群体。</li><li>即使你单单删除了<code>/var/lib/ceph/mon</code>下的东西，而没有清理那些keyring，也有可能会因为收集了旧集群的秘钥而发生稀奇古怪的问题。</li><li>对于Jewel，你一不小心删除了<code>/var/lib/ceph/mon</code>目录，或者其他的OSD目录或者<code>/var/run/ceph</code>目录，然后又重建了目录，依然部署不上，是因为Jewel的所有Ceph指定都是运行在<code>ceph:ceph</code>用户下的，自然不能在root权限目录下建立任何文件，修改权限即可。</li><li>Ceph生成MON数据库是依照主机的<code>hostname</code>来命名至目录<code>/var/lib/ceph/mon/${cluster}-${hostname}</code>的，而检测SOCKET文件则是用<code>ceph.conf</code>里面的<code>mon_initial_members</code>里面的名字来检测的 ，如果<code>mon_initial_members</code>里面的名字和真是的主机名不一致，就会报错。</li></ul><p>​      一旦你运行了<code>ceph-deploy mon create-initial</code>指令，并且失败了，有极大的可能性已经在某些节点建立好了MON的数据库，再次执行可能会因为旧的环境导致再次失败，所以如果失败了，执行一下第二节中的<code>清理环境</code>即可。清理完毕后，再执行<code>ceph-deploy mon create-initial</code>。</p><h3 id="Q13-ceph-s-的全称以及报错原因"><a href="#Q13-ceph-s-的全称以及报错原因" class="headerlink" title="Q13. ceph -s 的全称以及报错原因**"></a>Q13. ceph -s 的全称以及报错原因**</h3><p>​        开开心心过了<code>mon create-initial</code>，这个时候执行<code>ceph -s</code>，如果你恰好在monitor节点执行，那就会显示正常的信息，但是如果你在别的节点执行<code>ceph -s</code>，很有可能会报下面的错，但是有的节点又不会，所以这里花一点篇幅介绍<code>ceph -s</code>到底是怎么工作的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@root cluster]# ceph -s</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-17</span> <span class="number">13</span>:<span class="number">47</span>:<span class="number">34.190226</span> <span class="number">7</span>f446ccde700 <span class="number">-1</span> auth: unable to find a keyring on /etc/ceph/ceph.client.admin.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin: (<span class="number">2</span>) No such file or directory</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-17</span> <span class="number">13</span>:<span class="number">47</span>:<span class="number">34.190393</span> <span class="number">7</span>f446ccde700 <span class="number">-1</span> monclient(hunting): ERROR: missing keyring, cannot use cephx <span class="keyword">for</span> authentication</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-17</span> <span class="number">13</span>:<span class="number">47</span>:<span class="number">34.190443</span> <span class="number">7</span>f446ccde700  <span class="number">0</span> librados: client.admin initialization error (<span class="number">2</span>) No such file or directory</span><br></pre></td></tr></table></figure><p>​        首先，如果你要执行<code>ceph</code>开头的任何指令，你当然要安装好Ceph客户端！（<code>yum install ceph</code>）而<code>ceph -s</code>的全称是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ceph \</span><br><span class="line">--name client.admin \</span><br><span class="line">--keyring /etc/ceph/ceph.client.admin.keyring \</span><br><span class="line">--conf /etc/ceph/ceph.conf</span><br><span class="line">--cluster ceph \</span><br><span class="line">-s</span><br></pre></td></tr></table></figure><p>​        上面两个参数很好理解，Ceph内部自身使用<code>CephX</code>进行认证，和普通的认证没什么区别，同样需要用户名和密码进行认证，那么这里默认的用户名就叫做<code>client.admin</code>，而默认的秘钥保存位置就位于以下几个位置任一：</p><ul><li>/etc/ceph/ceph.client.admin.keyring</li><li>/etc/ceph/ceph.keyring</li><li>/etc/ceph/keyring</li><li>/etc/ceph/keyring.bin</li></ul><p>一般我们选择第一个，因为秘钥的命名规则采用<code>/etc/ceph/$cluster.$name.keyring</code>也就是集群名加上用户名再加上keyring的后缀组成。所以在我们执行<code>ceph -s</code>的时候，默认使用的是<code>client.admin</code>用户，同时会去那四个默认位置搜索该用户的秘钥，如果和集群保存的认证信息一致，那么就会显示出集群的状态。如果在那四个位置下面无法找到秘钥文件，就会报上面的<code>unable to find a keyring</code>这样的错误，解决方法后面再说。如果这个位置下面的秘钥文件保存了错误的秘钥值，就会报下面的错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-17</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">07.625018</span> <span class="number">7</span>f8757577700  <span class="number">0</span> librados: client.admin authentication error (<span class="number">1</span>) Operation not permitted</span><br><span class="line"><span class="built_in">Error</span> connecting to cluster: PermissionError</span><br></pre></td></tr></table></figure><p>​        翻译过来很简单，就是认证不通过，就好比你使用了错误的密码，去登陆系统不通过一样。这可能是由于这个节点保存了旧的集群的秘钥信息导致的。</p><p>​        那么正确的秘钥信息保存在哪里呢？还记得部署目录吗，在<code>mon create-initial</code>正确通过后，就会自动收集所有的秘钥，并保存在部署目录下面，眼疾手快的把部署目录的<code>ceph.client.admin.keyring</code>拷贝到<code>/etc/ceph</code>下面就会发现<code>ceph -s</code>正常显示了，不过，这不是<strong>授权</strong>的正确的姿势。</p><p>如果我们想要给一个节点admin权限，也就是执行所有Ceph指令的权限，我们可以前往部署目录，然后调用下面的指令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy admin xxNode</span><br></pre></td></tr></table></figure><p>​        这样就会把部署目录下的<code>ceph.client.admin.keyring</code>和<code>ceph.conf</code>拷贝到xxNode的<code>/etc/ceph</code>目录下，并覆盖掉原先的秘钥文件，虽然实际上也就是scp了这两个文件，但是管理Ceph遵循一定的规则是一个很好的习惯。所以，想要得到<code>ceph -s</code>的正确输出，你需要确认在<code>/etc/ceph</code>目录下有<code>ceph.conf</code>和<code>ceph.client.admin.keyring</code>这两个文件，并且和集群认证信息相同即可。如果认证失败，可以前往部署目录<strong>授权</strong>该节点。</p><h3 id="Q14-ceph-s-卡住了"><a href="#Q14-ceph-s-卡住了" class="headerlink" title="Q14. ceph -s 卡住了"></a><strong>Q14. ceph -s 卡住了</strong></h3><p>简单介绍下<code>ceph -s</code>的流程:</p><ul><li>每当你敲下一个Ceph指令时，相当于建立了一个Ceph的客户端进程去连接集群。</li><li>连接集群需要知道MON的IP地址，这个地址从<code>/etc/ceph/ceph.conf</code>里面的<code>mon_host</code>读取。</li><li>有了IP客户端就拿着自己用户名和秘钥向MON进行认证，认证通过执行指令返回输出。</li></ul><p>如果你只有一个MON，然后这个MON挂掉了，那么执行指令会返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@blog ceph]# ceph -s</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-19</span> <span class="number">17</span>:<span class="number">49</span>:<span class="number">45.437748</span> <span class="number">7</span>f02f44e1700  <span class="number">0</span> -- :<span class="regexp">/1314350745 &gt;&gt; 139.224.0.251:6789/</span><span class="number">0</span> pipe(<span class="number">0x7f02f0063e80</span> sd=<span class="number">3</span> :<span class="number">0</span> s=<span class="number">1</span> pgs=<span class="number">0</span> cs=<span class="number">0</span> l=<span class="number">1</span> c=<span class="number">0x7f02f005c4f0</span>).fault</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-19</span> <span class="number">17</span>:<span class="number">49</span>:<span class="number">48.442946</span> <span class="number">7</span>f02f43e0700  <span class="number">0</span> -- :<span class="regexp">/1314350745 &gt;&gt; 139.224.0.251:6789/</span><span class="number">0</span> pipe(<span class="number">0x7f02e4000c80</span> sd=<span class="number">3</span> :<span class="number">0</span> s=<span class="number">1</span> pgs=<span class="number">0</span> cs=<span class="number">0</span> l=<span class="number">1</span> c=<span class="number">0x7f02e4001f90</span>).fault</span><br></pre></td></tr></table></figure><p><strong>Tips: MON的端口号为6789，所以一般看到IP:6789时，就可以判断这个IP的MON可能挂了，或者MON的防火墙开开了。</strong>上面的报错还好处理， 前往MON节点，检查<code>ceph-mon</code>进程是否正常运行，正确启动MON进程就可以了。</p><p>​        如果你有两个MON，挂了一个，指令会返回和上面一样的信息，所以，两个MON只能坏一个，一般MON个数都是<strong>奇数个</strong>。如果你有三个MON，挂了一个，那么会返回下面信息，集群还是会有输出的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@st001 ~]# ceph -s</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-19</span> <span class="number">17</span>:<span class="number">59</span>:<span class="number">40.753370</span> <span class="number">7</span>f72ac31c700  <span class="number">0</span> -- :<span class="regexp">/4173548806 &gt;&gt; 10.8.0.101:6789/</span><span class="number">0</span> pipe(<span class="number">0x7f72a805e9d0</span> sd=<span class="number">3</span> :<span class="number">0</span> s=<span class="number">1</span> pgs=<span class="number">0</span> cs=<span class="number">0</span> l=<span class="number">1</span> c=<span class="number">0x7f72a805fce0</span>).fault</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-19</span> <span class="number">17</span>:<span class="number">59</span>:<span class="number">49.754198</span> <span class="number">7</span>f72ac21b700  <span class="number">0</span> -- <span class="number">10.8</span><span class="number">.0</span><span class="number">.101</span>:<span class="number">0</span>/<span class="number">4173548806</span> &gt;&gt; <span class="number">10.8</span><span class="number">.0</span><span class="number">.101</span>:<span class="number">6789</span>/<span class="number">0</span> pipe(<span class="number">0x7f729c000b90</span> sd=<span class="number">4</span> :<span class="number">0</span> s=<span class="number">1</span> pgs=<span class="number">0</span> cs=<span class="number">0</span> l=<span class="number">1</span> c=<span class="number">0x7f729c0041e0</span>).fault</span><br><span class="line">    cluster <span class="number">810</span>eaecb<span class="number">-2</span>b15<span class="number">-4</span>a97<span class="number">-84</span>ad<span class="number">-7340e6</span>cbe969</span><br><span class="line">    health HEALTH_WARN</span><br><span class="line">            <span class="number">1</span> mons down, quorum <span class="number">1</span>,<span class="number">2</span> st002,st003</span><br><span class="line">    monmap e1: <span class="number">3</span> mons at &#123;st001=<span class="number">10.8</span><span class="number">.0</span><span class="number">.101</span>:<span class="number">6789</span>/<span class="number">0</span>,st002=<span class="number">10.8</span><span class="number">.0</span><span class="number">.102</span>:<span class="number">6789</span>/<span class="number">0</span>,st003=<span class="number">10.8</span><span class="number">.0</span><span class="number">.103</span>:<span class="number">6789</span>/<span class="number">0</span>&#125;</span><br><span class="line">            election epoch <span class="number">18</span>, quorum <span class="number">1</span>,<span class="number">2</span> st002,st003</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>​        客户端会去连挂掉的MON，如果过一秒钟左右连不上，就会连接剩下的MON，剩下的还有两个在运行，就连到了运行中的MON，一切输出照旧，就是多了那个连不上的MON报错输出。</p><p>​        而<code>ceph -s</code>卡住有一种可能是：对于有三个MON的集群，挂掉了两个MON之后 ，手动去<code>/etc/ceph/ceph.conf</code>里面把挂掉的MON的IP给删除了， 只留下一个，这时候<code>ceph -s</code>的指令就会一直卡在那里，查看MON的log可以发现，那个活着的MON一直处于<code>probing</code>状态，这样的MON是不会给客户端返回信息的，所以会卡在那里。有一点需要知道的是，MON的删除比较复杂，不能仅仅通过修改配置文件里面的IP值修改MON，所以，这里正确的做法就是，将删除的IP加回去，然后<code>ceph -s</code>就会报出6789之类的错误，然后再去对应的IP的MON去启动MON服务。</p><p>​        那么一个集群能坏多少MON呢 ，简单的计算法法就是：</p><p>​        <strong>(mon个数 -1 )/ 2 取整数位</strong></p><p>​        也就是说三个能坏一个，两个和一个不能坏，四个坏一个，五个坏两个等等等。当你坏的MON个数大于可以坏的个数，那么所有的指令是不能返回的。</p><h3 id="Q15-Monitor-clock-skew-detected"><a href="#Q15-Monitor-clock-skew-detected" class="headerlink" title="Q15. Monitor clock skew detected"></a><strong>Q15. Monitor clock skew detected</strong></h3><p>​        如果你部署了多个monitor，比如三个MON，而这三个MON的时间不是严格相同的，那么就会报这个错，而Ceph需要MON节点之间的时间差在0.05秒之内，所以一般会选择配置一个内部的NTP server。剩余节点指向该Server节点。</p><p>​        千万一定不要小看了时间对其这个问题，如果各个节点时间不对其的话，有可能会导致某些OSD无法启动，而校准后，OSD立马就启动成功了，亦或导致OSD异常挂掉等等一系列的奇怪现象，十分不利于故障排查。</p><p>​        然而，简单的增加<code>mon_clock_drift_allowed</code>的时间偏移大小，是治标不治本的方法，并且OSD节点的时间偏移并不会报告在<code>ceph -s</code>里面，所以根本的节点方法还是配置NTP，具体方法请参考我之前写的配置NTP一段，这里就不重复了。</p><h3 id="Q16-CephX是什么，以及CephX的开启与关闭"><a href="#Q16-CephX是什么，以及CephX的开启与关闭" class="headerlink" title="Q16. CephX是什么，以及CephX的开启与关闭"></a><strong>Q16. CephX是什么，以及CephX的开启与关闭</strong></h3><p>在默认生成的<code>ceph.conf</code>里面有三行包含CephX的配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auth_cluster_required = cephx</span><br><span class="line">auth_service_required = cephx</span><br><span class="line">auth_client_required = cephx</span><br></pre></td></tr></table></figure><p>Ceph提供认证功能，想要连接集群，是需要提供用户名和密码的，这三个配置的值只有两种：</p><ul><li><code>cephx</code>: 开启CephX，即需要提供用户名和密码才能连接集群。</li><li><code>none</code>: 关闭CephX，即不需要提供，任何人都可以连接集群。</li></ul><p><strong>注意</strong>：如果关闭了CephX，那么任何一个客户端只要拥有了MON的IP和集群的fsid，就可以连接到集群中，然后执行所有的Ceph的指令，这是相当危险的，所以对于一个非局域网的集群，是需要开启的。</p><p>之所以写这一节，是因为见过好几个在部署集群时就关闭了CephX而遇到了奇怪的现象的情形，他们一般的操作步骤是：</p><ol><li><code>ceph-deploy new node1 node2 node3</code></li><li>将生成的<code>ceph.conf</code>中的三个<code>cephx</code>改成了<code>none</code></li><li><code>ceph-deploy mon create-initial</code> 这一步报错如下:</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ceph_deploy.mon][INFO  ] mon.blog monitor has reached quorum!</span><br><span class="line">[ceph_deploy.mon][INFO  ] all initial monitors are running and have formed quorum</span><br><span class="line">[ceph_deploy.mon][INFO  ] Running gatherkeys...</span><br><span class="line">.......</span><br><span class="line">[blog][DEBUG ] fetch remote file</span><br><span class="line">[ceph_deploy.gatherkeys][WARNIN] No mon key found <span class="keyword">in</span> host: blog</span><br><span class="line">[ceph_deploy.gatherkeys][ERROR ] Failed to connect to host:blog</span><br><span class="line">[ceph_deploy.gatherkeys][INFO  ] Destroy temp directory /tmp/tmpyGDe4r</span><br><span class="line">[ceph_deploy][ERROR ] RuntimeError: Failed to connect any mon</span><br></pre></td></tr></table></figure><p>​        先介绍下这里报错的原因，在Ceph中，除了需要使用Ceph的普通用户之外，Ceph的基本组件：MON，OSD，MDS再到RGW等都可以看做一个用户，而在使用<code>ceph-deploy</code>部署的时候，会默认为这些用户生成秘钥文件，在<code>ceph-deploy new</code>的时候，除了生成了<code>ceph.conf</code>，还生成了<code>ceph.mon.keyring</code>，顾名思义这个就是为MON用户生成的秘钥文件。查看该文件的内容可以看到如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mon.]</span><br><span class="line">key = AQCUXIRYAAAAABAAOi6Cxnvm+zFzd5gi+hrt+A==</span><br><span class="line">caps mon = allow *</span><br></pre></td></tr></table></figure><p>一个秘钥文件一般由三部分组成：</p><ul><li><code>[mon.]</code> ： 也就是用户名，在方括号里面的就是用户名，这里为<code>mon.</code>，注意是有个<strong>点号</strong>的。</li><li><code>key = AQCUXIRYAAAAABAAOi6Cxnvm+zFzd5gi+hrt+A==</code> : 顾名思义，这就是<code>mon.</code>用户的密码。</li><li><code>caps</code> ： 后面的就是权限，这里可以简单理解成，该用户可以对所有的MON进行所有操作。</li></ul><p>也就是说，Ceph中的Monitor也会像一个用户一样，拥有自己的用户名和秘钥以及操作MON的权限。简单理解了CephX之后，我们再来看上面修改了<code>none</code>之后报的错。</p><p>​        在<code>ceph-deploy mon create-initial</code>执行的时候，它会去读取<code>ceph.conf</code>里面的<code>auth_cluster_required</code>配置，当被修改为<code>none</code>之后， 就不会在创建MON的时候，为其生成对应的<code>keyring</code>，但是有一点要注意的是，尽管没有为MON生成秘钥文件，但是，MON是正确生成的，这时候执行<code>ceph -s</code>是可以得到集群状态的，说明MON已经正确建立。但是在所有的MON建立成功之后，<code>mon create-initial</code>指令内部会执行<code>gatherkeys</code>指令，这个指令会首先去MON的目录下面查找<code>/var/lib/ceph/mon/ceph-$HOSTNAME/keyring</code>文件，由于关闭了CephX，在创建MON的时候不会为其生成该文件，所以<code>gatherkeys</code>指令报错：<code>No mon key found in host: blog</code>。这里只要清理下MON环境然后开启CephX重新部署MON就可以通过了。所以在我们<strong>部署集群</strong>的时候，<strong>强烈建议开启CephX</strong>，这样除了可以正确通过<code>mon create-initial</code>，还可以在后续的添加OSD时，为每个OSD生成对应的秘钥。在<strong>集群部署完毕后</strong>，可以关闭CephX认证，具体方法如下：</p><ul><li>修改部署目录内<code>ceph.conf</code>的<code>cephx-&gt;none</code>,将配置推送到所有节点。</li><li>重启所有的MON和OSD。如果只重启MON，过一段时间(几个小时)，所有的OSD就会挂掉。。。</li></ul><p>在<code>ceph-deploy mon create-initial</code>正确通过之后，我们可以在部署目录下面看到多出了几个文件，都是以<code>keyring</code>结尾：</p><ul><li><code>ceph.client.admin.keyring</code>： 这个是超级用户<code>client.admin</code>的秘钥文件，查看其对应的权限，可以发现全部都是<code>allow *</code>，所以有了这个秘钥之后，相当于有了Linux系统的<code>root</code>用户，可以为所欲为了。</li><li><code>ceph.bootstrap-osd.keyring</code>: 类似的还有两个<code>mds</code>和<code>rgw</code>，<code>bootstrap</code>的意思是引导，查看其权限<code>mon = &quot;allow profile bootstrap-osd&quot;</code>，简单解释就是，这个用户可以用于创建OSD(or MDS or RGW)用户。也就是说，后续的OSD的用户的生成是由该用户引导生成的。</li></ul><p>最后再说一点，对于秘钥文件，其实我们只需要提供<code>key= xxxxxxxx</code>和用户名<code>[xxx]</code>就好了，不需要提供权限部分，因为权限已经在Ceph集群中保存了，秘钥文件说了不算的。具体权限可以通过<code>ceph auth list</code>来查看。</p><h3 id="Q17-–overwrite-conf参数"><a href="#Q17-–overwrite-conf参数" class="headerlink" title="Q17. –overwrite-conf参数"></a><strong>Q17. –overwrite-conf参数</strong></h3><p>这是个经常会遇到的问题，修改配置文件内的某些参数后，再执行<code>ceph-deploy</code>指令，会报如下的错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[blog][DEBUG ] write cluster configuration to /etc/ceph/&#123;cluster&#125;.conf</span><br><span class="line">[ceph_deploy.mon][ERROR ] RuntimeError: config file /etc/ceph/ceph.conf exists <span class="keyword">with</span> different content; use --overwrite-conf to overwrite</span><br><span class="line">[ceph_deploy][ERROR ] GenericError: Failed to create <span class="number">1</span> monitors</span><br></pre></td></tr></table></figure><p>​        报错信息提示得很明确，部署目录内的<code>ceph.conf</code>和集群的配置文件<code>/etc/ceph/ceph.conf</code>内容不一致，使用<code>--overwrite-conf</code>参数来覆盖集群的配置文件，也就是用部署目录的<code>ceph.conf</code>覆盖之。使用<code>ceph-deploy --overwrite-conf xxxCMD</code>来达到这一效果，当然，你也可以直接<code>cp</code>覆盖之。但是这不是一个好习惯。</p><p>正确的修改集群配置文件的姿势应该是：</p><ul><li>修改<strong>部署目录下的<code>ceph.conf</code></strong>。</li><li><code>ceph-deploy --overwrite-conf config push NodeA NodeB ... NodeZ</code>将部署目录下的配置文件推送到各个节点。</li><li><strong>强烈建议使用上面的方法</strong></li></ul><p>有的朋友可能喜欢直接去某个节点下的<code>/etc/ceph/ceph.conf</code>去改配置文件，这样有很多坏处：</p><ul><li>过了一周你可能忘了你改过这个节点的配置文件。</li><li>这个节点的配置和集群其他节点的配置不一样，会带来一些安全隐患。</li><li>如果再来一个不知情的同事，他使用了正确的姿势推送配置文件，你改过的参数很容易被覆盖掉。</li></ul><p>所以，从一开始，大家都使用同样的方式去修改集群的配置，是一个很好的习惯，对集群对同事有利无害。</p><p>​        如果你觉得可以接受这种推送配置的方式，但是又不喜欢每次都敲<code>--overwrite-conf</code>这么长的参数，你可以修改<code>~/.cephdeploy.conf</code>这个文件，增加一行<code>overwrite_conf = true</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy configuration file</span><br><span class="line">[ceph-deploy-global]</span><br><span class="line"># Overrides for some of ceph-deploy's global flags, like verbosity or cluster</span><br><span class="line"># name</span><br><span class="line">overwrite_conf = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>​        打开文件你就会发现，这个是<code>ceph-deploy</code>的配置文件，里面的配置项是对<code>ceph-deploy</code>生效的，在加了那一行之后，我们再去执行<code>ceph-deploy</code>的任何指令，都会默认带上了<code>--overwrite-conf</code>参数，这样就可以不打这个参数还能覆盖节点的配置文件。好处是少打了一些参数，坏处是你可能会不知不觉就覆盖了配置文件，各中利弊自行取舍。</p><p>​        <code>~/.cephdeploy.conf</code>这个文件的用处是很大的，可以为不同的<code>ceph-deploy xxxCMD</code>添加参数，刚刚添加在<code>[ceph-deploy-global]</code>下的参数对全局都会生效，如果你希望只对<code>xxxCMD</code>比如<code>new</code>，<code>osd</code>，<code>mon</code>指定对应的参数，可以添加<code>[ceph-deploy-xxxCMD]</code>域，同时在对应的域下添加对应的参数。</p><p>​        比如给<code>ceph-deploy osd 添加参数--zap-disk</code>，可以在<code>~/.cephdeploy.conf</code>中添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ceph-deploy-osd]</span><br><span class="line">zap_disk = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="Q18-PG卡在creating状态"><a href="#Q18-PG卡在creating状态" class="headerlink" title="Q18. PG卡在creating状态"></a><strong>Q18. PG卡在creating状态</strong></h3><p>​        这时候，Monitor已经建好了，可以执行<code>ceph -s</code>的指令了，然而我们看到集群的健康状态却是：<code>health HEALTH_ERR</code>。之所以是ERROR状态，是因为目前还没有建立OSD，PG处于creating状态，在建好了OSD之后，自然会解决这一问题。然而我要说的重点是<code>creating</code>这个状态的几个产生原因。</p><p>​        <code>creating</code>字面意思很好理解，正在创建，那么怎么理解PG正在创建呢？ 用最简单的方式解释PG就是： <strong>PG等于目录</strong>。如果我们使用磁盘做OSD的话，那么这个OSD上的PG就相当于，在这个磁盘上建立的目录。那么现在的问题就可以简化成，我们尚未添加任何磁盘，那么需要落盘的目录无处可建，所以就会长时间处于<code>creating</code>状态。在添加了一些OSD后，PG就可以建立了。</p><p>​        还有一种可能的原因是，刚入门的同学在配置文件中加了<code>osd_crush_update_on_start = false</code> 参数，这个参数的具体意义会有专门的小节介绍，这个参数的默认值是<code>true</code>，在使用这个参数后不论创建多少OSD，PG都依旧卡在<code>creating</code>状态。原因是所添加的OSD均不在默认的<code>root=default</code>根节点下。CRUSH在<code>default</code>下无法找到OSD，所以效果就和没有创建OSD一样，再解释就过于深入了，这里只简单介绍下解决方法：</p><ul><li>将部署目录里的<code>ceph.conf</code>的<code>osd_crush_update_on_start = false</code>去掉，或者将false改为true。</li><li>将配置文件推送到各个节点。</li><li>重启所有的OSD。</li></ul><p>这样OSD在启动时，就会自动加到对应的主机名下的host下方，并将主机名加到<code>default</code>下方。这样CRUSH就可以找到OSD了。当然，对于新入门的同学，一点建议就是，不知道意义的参数都不用加上，Ceph有自己一套默认参数，而这些参数不用修改就可以正常运行集群。如果添加了某些参数，最好知道其作用再使用。</p><h3 id="Q19-osd-crush-update-on-start-参数的使用和注意点"><a href="#Q19-osd-crush-update-on-start-参数的使用和注意点" class="headerlink" title="Q19. osd_crush_update_on_start 参数的使用和注意点"></a><strong>Q19. osd_crush_update_on_start 参数的使用和注意点</strong></h3><p>​        这是一个很有趣的参数，使用得当会省去很多事情，使用不当可能会造成灾难(亲身体验)。这个参数在<code>ceph --show-config</code>中并不能查询到，所以这并不是Ceph进程的一个配置项。实际上，这个配置相当于一个启动配置项。也就是说在OSD启动的时候会加载这个参数。由于Jewel将OSD的启动方式做了修改，所以针对Hammer及其之前和Jewel两种启动方式，分别在下面的两个文件使用到了这个参数，实际上，加载的方式还是一样的，只是启动文件有所变化：</p><ul><li>Hammer 及其之前 : <code>0.94.9 -&gt; /etc/init.d/ceph -&gt; line 370 -&gt; get_conf update_crush &quot;&quot; &quot;osd crush update on start&quot;</code></li><li>Jewel : <code>10.2.3 -&gt;/usr/lib/ceph/ceph-osd-prestart.sh -&gt; line 23 -&gt; update=&quot;$(ceph-conf --cluster=${cluster:-ceph} --name=osd.$id --lookup osd_crush_update_on_start || :)&quot;</code></li></ul><p>在OSD启动的时候，都会去配置文件中读取<code>osd_crush_update_on_start</code>。然后启动脚本根据是否存在以及配置值来决定是否将该OSD按照一定的方式(CRUSH位置，OSD的ID，OSD的weight)将这个OSD添加到CRUSH中。</p><p>​        简单点说，如果这个值为false，那么OSD在启动的时候不会去修改你的CRUSH树，也就是说OSD不会自动填加到对应的主机名下再自己添加到<code>root=default</code>下。</p><p>​        如果这个值为true，或者不添加该配置项(也就是说，默认为true)，OSD在启动时(任何一次启动)都会将自己添加到CRUSH树下。默认的位置为：<code>/usr/bin/ceph-crush-location -&gt; line 86 -&gt; host=$(hostname -s) root=default</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章总结了搭建ceph集群过程中遇到的各种问题，以及相应的原理过程&lt;/p&gt;
    
    </summary>
    
      <category term="Ceph" scheme="http://yoursite.com/categories/Ceph/"/>
    
    
      <category term="ceph" scheme="http://yoursite.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客教程</title>
    <link href="http://yoursite.com/2019/05/08/hexo%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/05/08/hexo搭建流程/</id>
    <published>2019-05-08T14:16:02.000Z</published>
    <updated>2020-06-30T03:25:16.906Z</updated>
    
    <content type="html"><![CDATA[<p>​        现在越来越多的人喜欢利用Github搭建静态网站，原因不外乎简单省钱。本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。</p><a id="more"></a><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>下载<code>node.js</code>并安装（官网下载安装），默认会安装<code>npm</code>。</li><li>下载安装<code>git</code>（官网下载安装）</li><li>下载安装<code>hexo</code>。方法：打开<code>cmd</code> 运行<code>*npm install -g hexo</code>*（要翻墙） </li></ul><h3 id="本地搭建hexo静态博客"><a href="#本地搭建hexo静态博客" class="headerlink" title="本地搭建hexo静态博客"></a>本地搭建hexo静态博客</h3><ul><li>新建一个文件夹，如<code>MyBlog</code></li><li>进入该文件夹内，右击运行<code>git</code>，输入：<code>*hexo init</code>*（生成hexo模板，可能要翻墙）</li><li>生成完模板，运行<code>*npm install</code>*（目前貌似不用运行这一步）</li><li>最后运行：<em><code>hexo server</code></em> （运行程序，访问本地localhost:4000可以看到博客已经搭建成功）</li></ul><h3 id="创建一个新仓库"><a href="#创建一个新仓库" class="headerlink" title="创建一个新仓库"></a>创建一个新仓库</h3><p>​       新建一个名为你的<code>github用户名.github.io</code>的仓库，比如说，如果你的github用户名是code-hly(这个是我的用户名)，那么你就新建<code>code-hly.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="https://code-hly.github.io" target="_blank" rel="noopener">https://code-hly.github.io</a> 了，是不是很方便</p><p>​     由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库，所以访问的地址也是唯一的，方便github服务器管理。</p><h3 id="设置仓库的参数"><a href="#设置仓库的参数" class="headerlink" title="设置仓库的参数"></a>设置仓库的参数</h3><p>​       相信大多数人都知道，要想使用git命令来和github进行提交部署等操作，需要进行一些配置，大概就是下面一些命令，如不明白请自行搜索.  </p><ul><li>右键鼠标选择<code>git Base here</code>,输入如下命令：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email xxx@qq.com   </span><br><span class="line">git config --global user.name xxx  </span><br><span class="line">ssh-keygen -t rsa -C xxx@qq.com(邮箱地址)  <span class="comment">// 生成ssh</span></span><br></pre></td></tr></table></figure><p>​       <strong>注：<code>email</code>和<code>name</code>分别为注册<code>github</code>时的邮箱和用户名，生成ssh时会提示让你选择存储地址，可直接按enter下一步存储为默认地址。</strong></p><ul><li><p>找到<code>.ssh</code>文件夹，找到<code>id_rsa.pub</code>文件打开复制<code>SSH</code></p></li><li><p>登陆<code>github</code>，<code>settings</code>-&gt;<code>Deploy keys</code>-&gt;<code>add deploy key</code>（把复制的SSH添加进去即可）</p></li></ul><h3 id="将博客与Github关联"><a href="#将博客与Github关联" class="headerlink" title="将博客与Github关联"></a>将博客与<code>Github</code>关联</h3><ul><li>打开本地的<code>MyBlog</code>文件夹项目内的<code>_config.yml</code>配置文件，将其中的type设置为git</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:code-hly/code-hly.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><strong>repository为对应仓库的地址。注意仓库地址有两种形式。一种是<code>https</code>，一种是<code>SSH</code>。此处应该使用SSH形式的地址。</strong>   </p><ul><li>运行：<em><code>npm install hexo-deployer-git –save</code></em></li><li>运行：<em><code>hexo g</code></em>（本地生成静态文件）</li><li>运行：<em><code>hexo d</code></em>（将本地静态文件推送至Github）</li></ul><p>此时，打开浏览器，访问<em><a href="https://code-hly.github.io" target="_blank" rel="noopener">https://code-hly.github.io</a></em></p><h4 id="可能问题"><a href="#可能问题" class="headerlink" title="可能问题"></a>可能问题</h4><blockquote><p>错误提示：FATAL bad indentation of a mapping entry at line 72, column 7:</p></blockquote><p>可以hexo g 但是不可以hexo d<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">错误提示：</span><br><span class="line">You should configure deployment settings in _config.yml first!</span><br><span class="line">Available deployer plugins:</span><br><span class="line">  git</span><br><span class="line">For more help, you can check the online docs: http://hexo.io/</span><br></pre></td></tr></table></figure></p><p>天真的我，被他俩坑死了。</p><p>​        问题一：(上图)type: git这里的分号后面没有空格（纳尼，手动黑人问号脸）。所有的配置项目分号（你输入的<code>http:</code>这个分号不用）后面有参数的都要有一个空格</p><p>​        问题二：(上图)deploy和下面的那几项我从网上复制了一下，（不知为啥我的配置里没生成<code>repo</code>和<code>branch</code>）结果就因为后三个没有缩进，我又白白躺了几个小时</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>　　因为<code>Hexo</code>个人博客是托管在<code>github</code>之上，每次访问都要使用<a href="http://penglei.top" target="_blank" rel="noopener">githubname.github.io</a>这么一个长串的域名来访问，会显得非常繁琐。这个时候我们可以购买一个域名，设置<code>DNS</code>跳转，以达到通过域名即可访问我们的个人博客，我就是在阿里的万网购买的域名。</p><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><ul><li>点击对应域名的”解析”</li></ul><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1557307304760.png" alt></p><ul><li><p>点击添加解析，记录类型选<code>A</code>或<code>CNAME</code></p><blockquote><p><code>A</code>记录的记录值就是<code>ip</code>地址，<code>github</code>(官方文档)提供了两个IP地址，<code>192.30.252.153和192.30.252.154</code>，这两个<code>IP</code>地址为<code>github</code>的服务器地址，两个都要填上，解析记录设置两个<code>@</code>，线路就默认就行了，<br><code>CNAME</code>记录值填你的<code>github</code>博客网址。如我的是<code>code-hly.github.io</code></p></blockquote></li></ul><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1557307617094.png" alt></p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/1557307781856.png" alt></p><p>​        这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建<code>CNAME</code>文件，不带任何后缀，里面添加你的域名信息，如：<code>penglei.com</code>。实践证明如果此时你填写的是<code>www.penglei.top</code> 那么以后你只能用<code>www.penglei.top</code> 访问，而如果你填写的是<code>penglei.top</code>。那么用<code>www.penglei.top</code> 和 <code>penglei.top</code> 访问都是可以的。重新清理hexo,并发布即可用新的域名访问。</p><ul><li><p>运行：<em>hexo g</em></p></li><li><p>运行：<em>hexo d</em></p></li></ul><h3 id="更新博客内容"><a href="#更新博客内容" class="headerlink" title="更新博客内容"></a>更新博客内容</h3><p>　　至此博客已经搭建完毕，域名也已经正常解析，那么剩下的问题就是更新内容了。</p><h4 id="更新文章"><a href="#更新文章" class="headerlink" title="更新文章"></a>更新文章</h4><ul><li>在<code>MyBlog</code>目录下执行：<em><code>hexo new “我的第一篇文章”</code></em>，会在<code>source-&gt;_posts</code>文件夹内生成一个.md文件。</li><li>编辑该文件（遵循Markdown规则）</li><li>修改起始字段<ul><li>title    文章的标题  </li><li>date    创建日期    （文件的创建日期 ）</li><li>updated    修改日期   （ 文件的修改日期）   </li><li>comments    是否开启评论    true  </li><li>tags    标签   </li><li>categories    分类   </li><li>permalink    url中的名字（文件名）</li></ul></li><li>编写正文内容（MakeDown）</li><li><code>hexo clean</code> 删除本地静态文件（Public目录），可不执行。</li><li><code>hexo g</code> 生成本地静态文件（Public目录）</li><li><code>hexo deploy</code> 将本地静态文件推送至github（hexo d）</li></ul><h4 id="添加菜单"><a href="#添加菜单" class="headerlink" title="添加菜单"></a>添加菜单</h4><p>进入<code>theme</code>目录，编辑<code>_config_yml</code>文件，找到<code>menu:</code>字段，在该字段下添加一个字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  about: /about</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>然后找到<code>lanhuages</code>目录，编辑<code>zh-Hans.yml</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  about: 关于作者</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>更新页面显示的中文字符，最后进入<code>theme</code>目录下的<code>Source</code>目录，新增一个<code>about</code>目录，里面写一个<code>index.html</code>文件。</p><h4 id="文章内插入图片"><a href="#文章内插入图片" class="headerlink" title="文章内插入图片"></a>文章内插入图片</h4><p>在文章中写入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](/upload_image/1.jpg)</span><br></pre></td></tr></table></figure><p>　　然后进入<code>themes-主题名-source-upload_image</code>目录下(自己创建)，将图片放到这个目录下，就可以了。</p><p>说明：当执行<code>hexo g</code>命令时，会自动把图片复制到 <code>public</code>文件的<code>upload_image</code>目录下。</p><h3 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h3><h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><p>　　在根目录下的<code>_config.yml</code>文件中，可以修改标题，作者等信息。打开编辑该文件，注意：每一个值的冒号后面都有一个半角空格！</p><ul><li>未生效的写法：<code>title:nMask</code>的博客</li><li>能生效的写法：<code>title:[空格]nMask</code>的博客</li></ul><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>访问<a href="http://www.zhihu.com/question/24422335" target="_blank" rel="noopener">主题列表</a>，获取主题代码。</p><p>进入themes目录，进入以下操作：</p><ul><li><p>下载主题 (以next主题为例)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/iissnan/hexo-theme-next.git（主题的地址）</span></span><br></pre></td></tr></table></figure></li><li><p>打开<code>__config.yml</code>文件，将<code>themes</code>修改为<code>next</code>（下载到的主题文件夹的名字）</p></li><li><p><code>hexo g</code></p></li><li><p><code>hexo d</code></p></li></ul><p>关于hexo-next主题下的一些个性化配置，参考：<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next主题配置</a></p><h3 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h3><h4 id="文章中添加居中模块"><a href="#文章中添加居中模块" class="headerlink" title="文章中添加居中模块"></a>文章中添加居中模块</h4><p>文章Markdown中填写如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;blockquote <span class="class"><span class="keyword">class</span></span>=<span class="string">"blockquote-center"</span>&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;<span class="regexp">/blockquote&gt;</span></span><br></pre></td></tr></table></figure><h4 id="在文章底部增加版权信息"><a href="#在文章底部增加版权信息" class="headerlink" title="在文章底部增加版权信息"></a>在文章底部增加版权信息</h4><ul><li>在目录<code>next/layout/_macro/</code>下添加<code>my-copyright.swig</code>：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> page.copyright %&#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"my_post_copyright"</span>&gt;</span><br><span class="line">  &lt;script src=<span class="string">"//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  &lt;!-- JS库 sweetalert 可修改路径 --&gt;</span><br><span class="line">  &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;script src=<span class="string">"http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"</span>&gt;</span><br><span class="line">  &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>本文标题:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(page.path) &#125;&#125;"</span>&gt;</span>&#123;&#123; page.title &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>文章作者:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span> <span class="attr">title</span>=<span class="string">"访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"</span>&gt;</span>&#123;&#123; theme.author &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>发布时间:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#123;&#123; page.date.format(<span class="string">"YYYY年MM月DD日 - HH:MM"</span>) &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;&lt;span&gt;最后更新:&lt;/</span>span&gt;&#123;&#123; page.updated.format(<span class="string">"YYYY年MM月DD日 - HH:MM"</span>) &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;&lt;span&gt;原始链接:&lt;/</span>span&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(page.path) &#125;&#125;"</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; page.title &#125;&#125;"</span>&gt;</span>&#123;&#123; page.permalink &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"copy-path"</span>  title=<span class="string">"点击复制文章链接"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-clipboard"</span> <span class="attr">data-clipboard-text</span>=<span class="string">"&#123;&#123; page.permalink &#125;&#125;"</span>  <span class="attr">aria-label</span>=<span class="string">"复制成功！"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;&lt;span&gt;许可协议:&lt;/</span>span&gt;<span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-creative-commons"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">rel</span>=<span class="string">"license"</span> <span class="attr">href</span>=<span class="string">"https://creativecommons.org/licenses/by-nc-nd/4.0/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">title</span>=<span class="string">"Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"</span>&gt;</span>署名-非商业性使用-禁止演绎 4.0 国际<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span> 转载请保留原文链接及作者。&lt;<span class="regexp">/p&gt;  </span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;script&gt; </span><br><span class="line">    <span class="keyword">var</span> clipboard = <span class="keyword">new</span> Clipboard(<span class="string">'.fa-clipboard'</span>);</span><br><span class="line">    clipboard.on(<span class="string">'success'</span>, $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      $(<span class="string">".fa-clipboard"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        swal(&#123;   </span><br><span class="line">          title: <span class="string">""</span>,   </span><br><span class="line">          text: <span class="string">'复制成功'</span>,   </span><br><span class="line">          html: <span class="literal">false</span>,</span><br><span class="line">          timer: <span class="number">500</span>,   </span><br><span class="line">          showConfirmButton: <span class="literal">false</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));  </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure><ul><li>在目录<code>next/source/css/_common/components/post/</code>下添加<code>my-post-copyright.styl</code>：</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.my_post_copyright</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">85%</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">45em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2.8em</span> auto <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1.0em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d3d3d3</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.93rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.6em</span>;</span><br><span class="line">  <span class="attribute">word-break</span>: break-all;</span><br><span class="line">  <span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> p&#123;<span class="attribute">margin</span>:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5.2em</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#b5b5b5</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-class">.raw</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#808080</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-tag">a</span>:hover &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#a3d2a3</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span>:hover <span class="selector-class">.fa-clipboard</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-class">.post-url</span>:hover &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-class">.copy-path</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  +mobile()&#123;<span class="attribute">display</span>:none;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-class">.copy-path</span>:hover &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#808080</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改<code>next/layout/_macro/post.swig</code>，在代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">      &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &#123;% include <span class="string">'wechat-subscriber.swig'</span> %&#125;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><ul><li>之前添加增加如下代码：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">      &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &#123;% include <span class="string">'my-copyright.swig'</span> %&#125;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><ul><li>修改<code>next/source/css/_common/components/post/post.styl</code>文件，在最后一行增加代码：</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import <span class="string">"my-post-copyright"</span></span><br></pre></td></tr></table></figure><ul><li>如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加<code>copyright: true</code>的设置，类似：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">tags: </span><br><span class="line">categories: </span><br><span class="line">copyright: <span class="literal">true</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="自定义hexo-new生成md文件的选项"><a href="#自定义hexo-new生成md文件的选项" class="headerlink" title="自定义hexo new生成md文件的选项"></a>自定义hexo new生成md文件的选项</h4><p>在<code>/scaffolds/post.md</code>文件中添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories: </span><br><span class="line">copyright: <span class="literal">true</span></span><br><span class="line">permalink: <span class="number">01</span></span><br><span class="line">top: <span class="number">0</span></span><br><span class="line">password:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="隐藏网页底部powered-By-Hexo-强力驱动"><a href="#隐藏网页底部powered-By-Hexo-强力驱动" class="headerlink" title="隐藏网页底部powered By Hexo / 强力驱动"></a>隐藏网页底部powered By Hexo / 强力驱动</h4><p>打开<code>themes/next/layout/_partials/footer.swig</code>,使用””隐藏之间的代码即可，或者直接删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"powered-by"</span>&gt;</span><br><span class="line">  &#123;&#123; __(<span class="string">'footer.powered'</span>, <span class="string">'&lt;a class="theme-link" rel="external nofollow" href="https://hexo.io"&gt;Hexo&lt;/a&gt;'</span>) &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;div class="theme-info"&gt;</span></span><br><span class="line"><span class="regexp">  &#123;&#123; __('footer.theme') &#125;&#125; -</span></span><br><span class="line"><span class="regexp">  &lt;a class="theme-link" rel="external nofollow" href="https:/</span><span class="regexp">/github.com/ii</span>ssnan/hexo-theme-next<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    NexT.&#123;&#123; theme.scheme &#125;&#125;</span></span><br><span class="line"><span class="string">  &lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="文章加密访问"><a href="#文章加密访问" class="headerlink" title="文章加密访问"></a>文章加密访问</h4><p>打开<code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code>文件,在<code>meta</code>标签后面插入这样一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">'&#123;&#123; page.password &#125;&#125;'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (prompt(<span class="string">'请输入文章密码'</span>) !== <span class="string">'&#123;&#123; page.password &#125;&#125;'</span>)&#123;</span><br><span class="line">                alert(<span class="string">'密码错误！'</span>);</span><br><span class="line">                history.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>然后文章中添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password: nmask</span><br></pre></td></tr></table></figure><p>如果<code>password</code>后面为空，则表示不用密码。</p><h4 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h4><p>修改 <code>hero-generator-index</code> 插件，把文件：<code>node_modules/hexo-generator-index/lib/generator.js</code> 内的代码替换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">            <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top; <span class="comment">// 否则按照top值降序排</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">  <span class="keyword">return</span> pagination(<span class="string">''</span>, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在文章中添加 <code>top</code> 值，数值越大文章越靠前，如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">......</span><br><span class="line">copyright: <span class="literal">true</span></span><br><span class="line">top: <span class="number">100</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>默认不设置则为0，数值相同时按时间排序。</p><h4 id="添加顶部加载条"><a href="#添加顶部加载条" class="headerlink" title="添加顶部加载条"></a>添加顶部加载条</h4><p>打开<code>/themes/next/layout/_partials/head.swig</code>文件，在<code>maximum-scale=1”/&gt;</code>后添加如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"//cdn.bootcss.com/pace/1.0.2/pace.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;link href=<span class="string">"//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br></pre></td></tr></table></figure><p>但是，默认的是粉色的，要改变颜色可以在<code>/themes/next/layout/_partials/head.swig</code>文件中添加如下代码（接在刚才link的后面）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .pace .pace-progress &#123;</span><br><span class="line">        background: #1E92FB; /*进度条颜色*/</span><br><span class="line">        height: <span class="number">3</span>px;</span><br><span class="line">    &#125;</span><br><span class="line">    .pace .pace-progress-inner &#123;</span><br><span class="line">         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/</span><br><span class="line">    &#125;</span><br><span class="line">    .pace .pace-activity &#123;</span><br><span class="line">        border-top-color: #1E92FB;    /*上边框颜色*/</span><br><span class="line">        border-left-color: #1E92FB;    /*左边框颜色*/</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><h4 id="添加热度"><a href="#添加热度" class="headerlink" title="添加热度"></a>添加热度</h4><p>next主题集成<code>leanCloud</code>，打开<code>/themes/next/layout/_macro/post.swig</code><br>在<code>”leancloud-visitors-count”&gt;</code>标签后面添加<code>℃</code>。<br>然后打开，<code>/themes/next/languages/zh-Hans.yml</code>，将<code>visitors</code>内容改为<em><code>热度</code></em>即可。</p><h4 id="主页文章添加阴影效果"><a href="#主页文章添加阴影效果" class="headerlink" title="主页文章添加阴影效果"></a>主页文章添加阴影效果</h4><p>打开<code>\themes\next\source\css_custom\custom.styl</code>,向里面加入：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主页文章添加阴影效果</span></span><br><span class="line"> <span class="selector-class">.post</span> &#123;</span><br><span class="line">   <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="修改文章底部的那个带-号的标签"><a href="#修改文章底部的那个带-号的标签" class="headerlink" title="修改文章底部的那个带#号的标签"></a>修改文章底部的那个带#号的标签</h4><p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=”tag”&gt;#</code>，将 <code>#</code> 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p><h4 id="鼠标点击小红心的设置"><a href="#鼠标点击小红心的设置" class="headerlink" title="鼠标点击小红心的设置"></a>鼠标点击小红心的设置</h4><p>将 <a href="https://github.com/Neveryu/Neveryu.github.io/blob/master/js/src/love.js" target="_blank" rel="noopener">love.js</a> 文件添加到 <code>\themes\next\source\js\src</code> 文件目录下。<br>找到 <code>\themes\next\layout_layout.swing</code> 文件， 在文件的后面， 标签之前 添加以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/love.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="背景的设置"><a href="#背景的设置" class="headerlink" title="背景的设置"></a>背景的设置</h4><p>将 <a href="https://github.com/Neveryu/Neveryu.github.io/blob/master/js/src/particle.js" target="_blank" rel="noopener">particle.js</a> 文件添加到 <code>\themes\next\source\js\src</code> 文件目录下。<br>找到 <code>\themes\next\layout_layout.swing</code> 文件， 在文件的后面，标签之前 添加以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 背景动画 --&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/particle.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h4><p>将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。<br>找到文件 <code>themes\next\source\css\_custom\custom.styl</code> ，添加如下 <code>css</code> 样式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0477ab</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="博文压缩"><a href="#博文压缩" class="headerlink" title="博文压缩"></a>博文压缩</h4><p>在站点的根目录下执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install gulp -g</span><br><span class="line"><span class="meta">$</span> npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save</span><br></pre></td></tr></table></figure><p>在博客根目录下新建 <code>gulpfile.js</code> ，并填入以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"><span class="comment">// 压缩 public 目录 css</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩 public 目录 html</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">    .pipe(htmlclean())</span><br><span class="line">    .pipe(htmlmin(&#123;</span><br><span class="line">         removeComments: <span class="literal">true</span>,</span><br><span class="line">         minifyJS: <span class="literal">true</span>,</span><br><span class="line">         minifyCSS: <span class="literal">true</span>,</span><br><span class="line">         minifyURLs: <span class="literal">true</span>,</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩 public/js 目录 js</span></span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [</span><br><span class="line">    <span class="string">'minify-html'</span>,<span class="string">'minify-css'</span>,<span class="string">'minify-js'</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>生成博文是执行 <code>hexo g &amp;&amp; gulp</code> 就会根据 <code>gulpfile.js</code> 中的配置，对 <code>public</code> 目录中的静态资源文件进行压缩。</p><h4 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h4><p>安装 <code>hexo-generator-searchdb</code>，在站点的根目录下执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>编辑 站点配置文件，新增以下内容到任意位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: <span class="number">10000</span></span><br></pre></td></tr></table></figure><h4 id="增加阅读排行统计页面"><a href="#增加阅读排行统计页面" class="headerlink" title="增加阅读排行统计页面"></a>增加阅读排行统计页面</h4><p>首先我们可以使用<code>leancloud</code>来统计页面阅读数量，以及储存这些信息，然后通过<code>leancloud</code>提供的<code>api</code>编写<code>js</code>脚本来获取阅读数量信息，并展示在页面上。<br>首先新建一个<code>page</code>页面，<code>hexo new page “”</code>,然后编辑此<code>.md</code>文件，写下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;AV.initialize(<span class="string">""</span>, <span class="string">""</span>);<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> <span class="comment">//需要写上leancloud的key</span></span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="keyword">var</span> time=<span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> title=<span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> url=<span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(<span class="string">'Counter'</span>);<span class="comment">//表名</span></span><br><span class="line">  query.notEqualTo(<span class="string">'id'</span>,<span class="number">0</span>); <span class="comment">//id不为0的结果</span></span><br><span class="line">  query.descending(<span class="string">'time'</span>); <span class="comment">//结果按阅读次数降序排序</span></span><br><span class="line">  query.limit(<span class="number">20</span>);  <span class="comment">//最终只返回10条结果</span></span><br><span class="line">  query.find().then(<span class="function"><span class="keyword">function</span> (<span class="params">todo</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123; </span><br><span class="line">      <span class="keyword">var</span> result=todo[i].attributes;</span><br><span class="line">      time=result.time;  <span class="comment">//阅读次数</span></span><br><span class="line">      title=result.title; <span class="comment">//文章标题</span></span><br><span class="line">      url=result.url;     <span class="comment">//文章url</span></span><br><span class="line">      <span class="keyword">var</span> content=<span class="string">"&lt;p&gt;"</span>+<span class="string">"&lt;font color='#0477ab'&gt;"</span>+<span class="string">"【阅读次数:"</span>+time+<span class="string">"】"</span>+<span class="string">"&lt;a href='"</span>+<span class="string">"http://thief.one"</span>+url+<span class="string">"'&gt;"</span>+title+<span class="string">"&lt;/font&gt;"</span>+<span class="string">"&lt;/a&gt;"</span>+<span class="string">"&lt;/p&gt;"</span>;</span><br><span class="line">      <span class="comment">// document.write("&lt;a href='"+"http://thief.one/"+url+"'&gt;"+title+"&lt;/a&gt;"+"    Readtimes:"+time+"&lt;br&gt;");</span></span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">"heheda"</span>).innerHTML+=content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>最终的效果查看：<a href="http://thief.one/count" target="_blank" rel="noopener">http://thief.one/count</a></p><h4 id="多说替换成来必力评论"><a href="#多说替换成来必力评论" class="headerlink" title="多说替换成来必力评论"></a>多说替换成来必力评论</h4><p>更新于@2017年5月18日<br>多说已经宣布下线了，因此我找了个来必力评论系统来替换，以下是替换的教程，教程内容来自：<a href="https://blog.smoker.cc/web/add-comments-livere-for-hexo-theme-next.html" target="_blank" rel="noopener">https://blog.smoker.cc/web/add-comments-livere-for-hexo-theme-next.html</a></p><p>来必力评价<br>优点：界面美观<br>缺点：不支持数据导入，加载慢</p><p>首先在 <code>_config.yml</code> 文件中添加如下配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">livere_uid: your uid</span><br></pre></td></tr></table></figure><p>其中 <code>livere_uid</code> 即注册来必力获取到的 <code>uid</code>。<br>在 <code>layout/_scripts/third-party/comments/</code> 目录中添加 <code>livere.swig</code>，文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125;</span><br><span class="line">  &#123;% <span class="keyword">if</span> theme.livere_uid %&#125;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params">d, s</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> j, e = d.getElementsByTagName(s)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> LivereTower === <span class="string">'function'</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        j = d.createElement(s);</span><br><span class="line">        j.src = <span class="string">'https://cdn-city.livere.com/js/embed.dist.js'</span>;</span><br><span class="line">        j.async = <span class="literal">true</span>;</span><br><span class="line">        e.parentNode.insertBefore(j, e);</span><br><span class="line">      &#125;)(<span class="built_in">document</span>, <span class="string">'script'</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &#123;% endif %&#125;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure><p>​        优先使用其他评论插件，如果其他评论插件没有开启，且<code>LiveRe</code>评论插件配置开启了，则使用<code>LiveRe</code>。其中脚本代码为上一步管理页面中获取到的。在<code>layout/_scripts/third-party/comments.swig</code>文件中追加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include <span class="string">'./comments/livere.swig'</span> %&#125;</span><br></pre></td></tr></table></figure><p>引入 <code>LiveRe</code> 评论插件。<br>最后，在 <code>layout/_partials/comments.swig</code> 文件中条件最后追加<code>LiveRe</code>插件是否引用的判断逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.livere_uid %&#125;</span><br><span class="line">      &lt;div id=<span class="string">"lv-container"</span> data-id=<span class="string">"city"</span> data-uid=<span class="string">"&#123;&#123; theme.livere_uid &#125;&#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>最后打开博客瞧瞧吧！</p><h4 id="多说替换成网易云跟贴"><a href="#多说替换成网易云跟贴" class="headerlink" title="多说替换成网易云跟贴"></a>多说替换成网易云跟贴</h4><p>最好的方法就是更新next主题，因为最新版本的主题已经支持这几种评论。<br>如果不想更新主题，则往下看：</p><p>网易云跟贴评价：<br>性能稳定，功能中规中矩，支持数据导入</p><p>首先在 <code>_config.yml</code> 文件中添加如下配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gentie_productKey: #your-gentie-product-key</span><br></pre></td></tr></table></figure><p>其中 <code>gentie_productKey</code> 即注册网易云跟贴获取到的<code>key</code>。<br>在 <code>layout/_scripts/third-party/comments/</code> 目录中添加 <code>gentie.swig</code>，文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% <span class="keyword">if</span> theme.gentie_productKey %&#125;</span><br><span class="line">    &#123;% <span class="keyword">set</span> gentie_productKey = theme.gentie_productKey %&#125;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      var cloudTieConfig = &#123;</span><br><span class="line">        url: <span class="built_in">document</span>.location.href, </span><br><span class="line">        sourceId: <span class="string">""</span>,</span><br><span class="line">        productKey: <span class="string">"&#123;&#123;gentie_productKey&#125;&#125;"</span>,</span><br><span class="line">        target: <span class="string">"cloud-tie-wrapper"</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script src="https:/</span><span class="regexp">/img1.ws.126.net/</span>f2e/tie/yun/sdk/loader.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">  &#123;% endif %&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure><p>在<code>layout/_scripts/third-party/comments.swig</code>文件中追加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include <span class="string">'./comments/gentie.swig'</span> %&#125;</span><br></pre></td></tr></table></figure><p>最后，在 <code>layout/_partials/comments.swig</code> 文件中条件最后追加网易云跟帖插件引用的判断逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.gentie_productKey %&#125;</span><br><span class="line">      &lt;div id=<span class="string">"cloud-tie-wrapper"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cloud-tie-wrapper"</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><h3 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h3><h4 id="（一）Deployer-not-found-git"><a href="#（一）Deployer-not-found-git" class="headerlink" title="（一）Deployer not found: git"></a>（一）Deployer not found: git</h4><p>当编辑<code>__config.yml</code>文件，将<code>type: git</code>设置完成后，运行<code>hexo g</code> 报错：<em><code>git not found</code></em><br>解决方案：可以在<code>MyBlog</code>目录下运行: <em><code>npm install hexo-deployer-git –save</code></em>。</p><h4 id="（二）permission-denied"><a href="#（二）permission-denied" class="headerlink" title="（二）permission denied"></a>（二）permission denied</h4><p>当执行: <code>hexo  deploy</code> 报错时，把<code>__config.yml</code>中的<code>github</code>连接形式从<code>ssh</code>改成<code>http</code>。</p><h4 id="（三）当在themes目录下载主题时，报错。"><a href="#（三）当在themes目录下载主题时，报错。" class="headerlink" title="（三）当在themes目录下载主题时，报错。"></a>（三）当在themes目录下载主题时，报错。</h4><p>将该目录只读属性取消。</p><h4 id="（四）genrnate-报错"><a href="#（四）genrnate-报错" class="headerlink" title="（四）genrnate 报错"></a>（四）genrnate 报错</h4><p>检查<code>_config.yml</code>配置中，键值对冒号后面是否已经预留了一个半角空格。</p><h4 id="（五）ERROR-Plugin-load-failed-hexo-generator-feed"><a href="#（五）ERROR-Plugin-load-failed-hexo-generator-feed" class="headerlink" title="（五）ERROR Plugin load failed: hexo-generator-feed"></a>（五）ERROR Plugin load failed: hexo-generator-feed</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><h4 id="（六）fatal-The-remote-end-hung-up-unexpectedly"><a href="#（六）fatal-The-remote-end-hung-up-unexpectedly" class="headerlink" title="（六）fatal: The remote end hung up unexpectedly"></a>（六）fatal: The remote end hung up unexpectedly</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config https.postBuffer 524288000</span><br><span class="line"><span class="meta">$</span> git config http.postBuffer 524288000</span><br><span class="line"><span class="meta">$</span> git config ssh.postBuffer 524288000</span><br></pre></td></tr></table></figure><h4 id="（七）hero-d推送的内容有问题"><a href="#（七）hero-d推送的内容有问题" class="headerlink" title="（七）hero d推送的内容有问题"></a>（七）hero d推送的内容有问题</h4><p>　　首先检查下<code>.deploy_git</code>文件夹下的<code>.git</code>文件是否存在，此<code>.git</code>文件指定了<code>hexo d</code>时推送public文件夹，而不是所有的内容。如果此<code>.git</code>文件不存在，则会出现推送内容错误。<br>　　用<code>npm  install hexo-deployer-git  –save</code>生成的<code>.deploy_git</code>不包含.git文件，因此正确的做法是<code>.deploy_git</code>文件夹也需要备份，然后再用<code>npm install  hexo-deployer-git –save</code>更新一下其内容即可。<br>　　如果已经出现这个错误，则删除<code>.deploy_git</code>，重新<code>hexo d</code>。</p><h4 id="（八）hexo-s报错"><a href="#（八）hexo-s报错" class="headerlink" title="（八）hexo s报错"></a>（八）hexo s报错</h4><p>在新版本的mac上，安装运行<code>hexo</code>会报此错误，但不影响使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">Error</span>: Cannot find <span class="built_in">module</span></span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --no-optional</span><br></pre></td></tr></table></figure><h3 id="Local-Search错误"><a href="#Local-Search错误" class="headerlink" title="Local Search错误"></a>Local Search错误</h3><p>　　最近发现Local Search搜索出来的连接有错误，到不是说连接不对，而是当我在/aaa/目录下搜索一个页面时，跳转到了/aaa/正确的连接/，这样明显是正确的，应该是跟目录+跳转的目录。<br>　　网上搜索了下，没有类似的案例，那么自己动手修改吧，打开<code>node_modules/hexo-generator-searchdb/templates</code>下的<code>xml.ejs</code>文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;url&gt;<span class="xml"><span class="tag">&lt;<span class="name">%-</span> ("<span class="attr">..</span>/<span class="attr">..</span>/<span class="attr">..</span>/<span class="attr">..</span>/<span class="attr">..</span>/<span class="attr">..</span>/<span class="attr">..</span>/<span class="attr">..</span>/"+<span class="attr">post.path</span>) %&gt;</span><span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>说明：将这个文件的两处url都改成这样就可以了。</p><h3 id="异地同步博客内容"><a href="#异地同步博客内容" class="headerlink" title="异地同步博客内容"></a>异地同步博客内容</h3><p>　　现在电脑已经很普及了，因为一般来说我们都是公司一台电脑，家里一台电脑，那么如何将两台电脑上博客的内容同步内，即两台电脑上都可以编辑更新博客？<br>要解决这个问题，首先我们要清楚我们博客文件的组成：</p><ul><li>node_modules</li><li>public</li><li>scaffolds</li><li>source</li><li>themes</li><li>_config_yml</li><li>db.json</li><li>package.json</li><li>.deploy_git</li></ul><p>　　以上为利用hexo生成的博客全部内容，那么当我们执行hexo d时，正真被推送到github上的又有哪些内容呢？<br>　　我们可以看下github上的<code>code-hly.github.io</code>项目，发现里面只有<code>Public</code>目录下的内容。也就是说，我们博客上呈现的内容，其实就是<code>public</code>下的文件内容。那么这个Pulic目录是怎么生成的呢？<br>　　一开始<code>hexo  init</code>的时候是没有<code>public</code>目录的，而当我们运行<code>hexo g</code>命令时，<code>public`</code>目录被生成了，换句话说hexo  g<code>命令就是用来生成博客文件的（会根据</code>_config.yml<code>，</code>source<code>目录文件以及</code>themes<code>目录下文件生成）。同样当我们运行</code>hexo  clean<code>命令时，</code>public<code>目录被删除了。　　好了，既然我们知道了决定博客显示内容的只有一个</code>Public<code>目录，而</code>public<code>目录又是可以动态生成的，那么其实我们只要在不同电脑上同步可以生成</code>Public`目录的文件即可。</p><p>以下文件以及目录是必须要同步的：</p><ul><li>source</li><li>themes</li><li>_config.yml</li><li>db.json</li><li>package.json</li><li>.deploy_git</li></ul><p>　　同步的方式有很多种，可以每次更新后都备份到一个地址。我采用<code>github</code>去备份，也就是新建一个项目用来存放以上文件，每次更新后推送到github上，用作备份同步。<br>　　同步完必须的文件后，怎么再其他电脑上也可以更新博客呢？<br>　　前提假设我们现在配置了一台新电脑，里面没有安装任何有关博客的东西，那么我们开始吧：</p><ul><li>下载<code>node.js</code>并安装（官网下载安装），默认会安装npm。</li><li>下载安装<code>git</code>（官网下载安装）</li><li>下载安装<code>hexo</code>。方法：打开<code>cmd</code> 运行<em><code>npm install -g hexo</code></em>（要翻墙） </li><li>新建一个文件夹，如<code>MyBlog</code></li><li>进入该文件夹内，右击运行<code>git</code>，输入：<em><code>hexo init</code></em>（生成hexo模板，可能要翻墙)</li></ul><p>　　我们重复了一开始搭建博客的步骤，重新生成了一个新的模板，这个模板中包含了hexo生成的一些文件。</p><ul><li><code>git clone</code> 我们备份的项目，生成一个文件夹，如：<code>MyBlogData</code></li><li>将<code>MyBlog</code>里面的<code>node_modules</code>、<code>scaffolds</code>文件夹复制到<code>MyBlogData</code>里面。</li></ul><p>　　做完这些，从表面上看，两台电脑上MyBlogData目录下的文件应该都是一样的了。那么我们运行hexo g<br>hexo d试试，如果会报错，则往下看。</p><ul><li>这是因为<code>.deploy_git</code>没有同步，在<code>MyBlogData</code>目录内运行:<em><code>npm install hexo-deployer-git –save</code></em>后再次推送即可</li></ul><p>　　总结流程：当我们每次更新<code>MyBlog</code>内容后，先利用<code>hexo</code>将<code>public</code>推送到<code>github</code>，然后再将其余必须同步的文件利用<code>git</code>推送到<code>github</code>。</p><h3 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h3><p>seo优化对于网站是否能被搜索引擎快速收录有很大帮助，因此适当做一些seo还是有必要的，以下内容参考：<a href="https://lancelot_lewis.coding.me/2016/08/16/blog/Hexo-NexT-SEO/" target="_blank" rel="noopener">https://lancelot_lewis.coding.me/2016/08/16/blog/Hexo-NexT-SEO/</a></p><h4 id="添加sitemap文件"><a href="#添加sitemap文件" class="headerlink" title="添加sitemap文件"></a>添加sitemap文件</h4><p>安装以下2个插件，然后重启<code>hexo</code>后，网站根目录（source）下会生成<code>sitemap.xml</code>与<code>baidusitemap.xml</code>文件，搜索引擎在爬取时会参照文件中的url去收录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save-dev</span><br><span class="line">hexo d -g</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save-dev</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><h4 id="添加robots-txt"><a href="#添加robots-txt" class="headerlink" title="添加robots.txt"></a>添加robots.txt</h4><p>新建<code>robots.txt</code>文件，添加以下文件内容，把<code>robots.txt</code>放在<code>hexo</code>站点的<code>source</code>文件下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">User-agent: * Allow: <span class="regexp">/</span></span><br><span class="line"><span class="regexp">Allow: /</span>archives/</span><br><span class="line">Disallow: <span class="regexp">/vendors/</span></span><br><span class="line">Disallow: <span class="regexp">/js/</span></span><br><span class="line">Disallow: <span class="regexp">/css/</span></span><br><span class="line">Disallow: <span class="regexp">/fonts/</span></span><br><span class="line">Disallow: <span class="regexp">/vendors/</span></span><br><span class="line">Disallow: <span class="regexp">/fancybox/</span></span><br><span class="line"></span><br><span class="line">Sitemap: http:<span class="comment">//thief.one/sitemap.xml</span></span><br><span class="line">Sitemap: http:<span class="comment">//thief.one/baidusitemap.xml</span></span><br></pre></td></tr></table></figure><h4 id="首页title的优化"><a href="#首页title的优化" class="headerlink" title="首页title的优化"></a>首页title的优化</h4><p>更改<code>index.swig</code>文件，文件路径是<code>your-hexo-site\themes\next\layout</code>，将下面代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block title %&#125;  &#123;&#123; config.title &#125;&#125;  &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block title %&#125;  &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125;  &#123;% endblock</span><br></pre></td></tr></table></figure><p>观察首页title就是标题+描述了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        现在越来越多的人喜欢利用Github搭建静态网站，原因不外乎简单省钱。本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo双站点部署github和coding</title>
    <link href="http://yoursite.com/2019/05/08/hexo%E5%8F%8C%E7%AB%99%E7%82%B9%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2019/05/08/hexo双站点部署/</id>
    <published>2019-05-08T14:16:02.000Z</published>
    <updated>2020-06-30T03:10:26.590Z</updated>
    
    <content type="html"><![CDATA[<p>​        这是搭建博客系列的第二篇，至于为什么要托管到<code>coding</code>上，原因大家也应该能猜到，就是<code>github</code>访问速度偏慢，体验不是很好。</p><a id="more"></a><h3 id="注册coding-net账号并创建项目"><a href="#注册coding-net账号并创建项目" class="headerlink" title="注册coding.net账号并创建项目"></a>注册<code>coding.net</code>账号并创建项目</h3><p>项目名最好跟用户名一样<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/QQ截图20190508182436.png" alt></p><h3 id="设置coding-SSH-KEY"><a href="#设置coding-SSH-KEY" class="headerlink" title="设置coding SSH KEY"></a>设置<code>coding SSH KEY</code></h3><p>这个就用当时设置<code>github</code>的一样就行了<br><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/QQ截图20190508182512.png" alt></p><h3 id="config-yml配置"><a href="#config-yml配置" class="headerlink" title="_config.yml配置"></a><code>_config.yml</code>配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: </span><br><span class="line">        github: git@github.com:code-hly/code-hly.github.io.git,master</span><br><span class="line">        coding: git@git.coding.net:huliaoyuan/huliaoyuan.git,master</span><br></pre></td></tr></table></figure><blockquote><p>替换你的项目名，注意空格，我这儿用的是<code>ssh</code>，而不是<code>https</code></p></blockquote><h3 id="部署项目到coding上"><a href="#部署项目到coding上" class="headerlink" title="部署项目到coding上"></a>部署项目到<code>coding</code>上</h3><ul><li><p>进入<code>myblog</code>根目录下，先敲如下命令。为了使用<code>hexo d</code>来部署到<code>git</code>上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用部署命令就能把博客同步到<code>coding</code>上面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy -g</span><br></pre></td></tr></table></figure></li></ul><h3 id="pages服务方式部署"><a href="#pages服务方式部署" class="headerlink" title="pages服务方式部署"></a><code>pages</code>服务方式部署</h3><p>​        部署博客方式有两种，第一种就是<code>pages</code>服务的方式，也推荐这种方式，因为可以绑定域名，而第二种演示的方式必须升级会员才能绑定自定义域名。<code>pages</code>方式也很简单就是在<code>source/</code>需要创建一个空白文件，至于原因，是因为<code>coding.net</code>需要这个文件来作为以静态文件部署的标志。就是说看到这个<code>Staticfile</code>就知道按照静态文件来发布。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd source/</span><br><span class="line">touch Staticfile  #名字必须是Staticfile</span><br></pre></td></tr></table></figure><h3 id="个人域名绑定"><a href="#个人域名绑定" class="headerlink" title="个人域名绑定"></a>个人域名绑定</h3><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/QQ截图20190508183145.png" alt></p><blockquote><p>注意<code>github</code>绑定需要在 <code>myblog/source</code>目录下建一 <code>CNAME</code> 文件，并写上你购买的域名，域名我是在阿里万网买的</p><p>我当时按照别人的做法写的默认和海外，这样发现只能访问<code>coding</code>上的博客而不能访问 <code>github</code> 上的博客了</p></blockquote><h3 id="coding绑定私有域名"><a href="#coding绑定私有域名" class="headerlink" title="coding绑定私有域名"></a><code>coding</code>绑定私有域名</h3><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/QQ截图20190508183721.png" alt></p><h3 id="发布博客新文章后直接部署到github和coding"><a href="#发布博客新文章后直接部署到github和coding" class="headerlink" title="发布博客新文章后直接部署到github和coding"></a>发布博客新文章后直接部署到<code>github</code>和<code>coding</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        这是搭建博客系列的第二篇，至于为什么要托管到&lt;code&gt;coding&lt;/code&gt;上，原因大家也应该能猜到，就是&lt;code&gt;github&lt;/code&gt;访问速度偏慢，体验不是很好。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>ceph-deploy部署ceph12集群</title>
    <link href="http://yoursite.com/2019/05/07/ceph-12%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2019/05/07/ceph-12部署/</id>
    <published>2019-05-07T09:11:02.000Z</published>
    <updated>2019-05-28T08:13:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h1><h2 id="1-1-硬件"><a href="#1-1-硬件" class="headerlink" title="1.1 硬件"></a>1.1 硬件</h2><p>4台 Linux虚拟机： server0, server1, server2, server3<br> 每台有两块磁盘 ： /dev/vdb, /dev/vdc<br> 每台有两块网卡 ：eth0, ens9</p><h2 id="1-2-软件"><a href="#1-2-软件" class="headerlink" title="1.2 软件"></a>1.2 软件</h2><p>linux版本： CentOS 7.2.1511<br> 内核版本 ：  3.10.0-327.el7.x86_64<br> ceph版本：  12.2.12<br> ceph-deploy版本： 2.0.0</p><a id="more"></a><h1 id="2-准备工作-所有server"><a href="#2-准备工作-所有server" class="headerlink" title="2. 准备工作(所有server)"></a>2. 准备工作(所有server)</h1><h2 id="2-1-配置静态IP"><a href="#2-1-配置静态IP" class="headerlink" title="2.1 配置静态IP"></a>2.1 配置静态IP</h2><p>每台server有两个interface, 分别配置在如下两个网段：</p><ul><li>192.168.122.0/24</li><li>192.168.100.0/24</li></ul><p>具体如下表：</p><table><thead><tr><th>Server</th><th>Interface</th><th>IPADDR</th></tr></thead><tbody><tr><td>server0</td><td>eth0</td><td>192.168.122.160</td></tr><tr><td>server0</td><td>ens9</td><td>192.168.100.160</td></tr><tr><td>server1</td><td>eth0</td><td>192.168.122.161</td></tr><tr><td>server1</td><td>ens9</td><td>192.168.100.161</td></tr><tr><td>server2</td><td>eth0</td><td>192.168.122.162</td></tr><tr><td>server2</td><td>ens9</td><td>192.168.100.162</td></tr><tr><td>server3</td><td>eth0</td><td>192.168.122.163</td></tr><tr><td>server3</td><td>ens9</td><td>192.168.100.163</td></tr></tbody></table><h2 id="2-2-生成ssh-key"><a href="#2-2-生成ssh-key" class="headerlink" title="2.2 生成ssh key"></a>2.2 生成ssh key</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ssh-keygen</span><br></pre></td></tr></table></figure><h2 id="2-3-配置主机名解析"><a href="#2-3-配置主机名解析" class="headerlink" title="2.3 配置主机名解析"></a>2.3 配置主机名解析</h2><p>把如下内容追加到/etc/hosts:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.100.160 server0</span><br><span class="line">192.168.100.161 server1</span><br><span class="line">192.168.100.162 server2</span><br><span class="line">192.168.100.163 server3</span><br></pre></td></tr></table></figure><h2 id="2-4-配置ntp"><a href="#2-4-配置ntp" class="headerlink" title="2.4 配置ntp"></a>2.4 配置ntp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># yum install  -y  ntp ntpdate ntp-doc</span><br><span class="line"># vim /etc/ntp.conf  （一般不需要修改）</span><br><span class="line"># systemctl start ntpd.service</span><br><span class="line"># systemctl enable ntpd.service</span><br></pre></td></tr></table></figure><h2 id="2-5-关闭防火墙"><a href="#2-5-关闭防火墙" class="headerlink" title="2.5 关闭防火墙"></a>2.5 关闭防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl stop firewalld</span><br><span class="line"># systemctl disable firewalld</span><br></pre></td></tr></table></figure><h2 id="2-6-安装yum源epel"><a href="#2-6-安装yum源epel" class="headerlink" title="2.6 安装yum源epel"></a>2.6 安装yum源epel</h2><p>为了方便yum安装一些常用的软件包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br></pre></td></tr></table></figure><h1 id="3-安装ceph软件包"><a href="#3-安装ceph软件包" class="headerlink" title="3. 安装ceph软件包"></a>3. 安装ceph软件包</h1><h2 id="3-1-添加yum源-所有server"><a href="#3-1-添加yum源-所有server" class="headerlink" title="3.1 添加yum源(所有server)"></a>3.1 添加yum源(所有server)</h2><p>在<strong>所有server</strong>上添加ceph.repo，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/yum.repos.d/ceph.repo </span><br><span class="line">[Ceph]</span><br><span class="line">name=Ceph packages for $basearch</span><br><span class="line">baseurl=http://mirrors.163.com/ceph/rpm-luminous/el7/$basearch</span><br><span class="line">enabled=1</span><br><span class="line">priority=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://download.ceph.com/keys/release.asc</span><br><span class="line"></span><br><span class="line">[Ceph-noarch]</span><br><span class="line">name=Ceph noarch packages</span><br><span class="line">baseurl=http://mirrors.163.com/ceph/rpm-luminous/el7/noarch</span><br><span class="line">enabled=1</span><br><span class="line">priority=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://download.ceph.com/keys/release.asc</span><br><span class="line"></span><br><span class="line">[ceph-source]</span><br><span class="line">name=Ceph source packages</span><br><span class="line">baseurl=http://mirrors.163.com/ceph/rpm-luminous/el7/SRPMS</span><br><span class="line">enabled=0</span><br><span class="line">priority=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://download.ceph.com/keys/release.asc</span><br></pre></td></tr></table></figure><p><strong>[Ceph]</strong>： ceph软件包的yum源，所有server都需要添加。<br><strong>[Ceph-noarch]</strong>：ceph-deploy的yum源。admin server (见3.2节)  需要安装ceph-deploy，所以它需要这个yum源。admin  server控制其他server的时候，也需要被控server添加这个yum源。最终，所有server都需要添加。<br><strong>[ceph-source]</strong>： admin server控制其他server的时候，也需要被控server添加这个yum源。所以，所有server都需要添加。</p><h2 id="3-2-选择admin-server"><a href="#3-2-选择admin-server" class="headerlink" title="3.2 选择admin server"></a>3.2 选择admin server</h2><p>选择server0作为admin server。官网上建议admin server使用一个单独的user来进行ceph-deploy操作，这里避免麻烦，还用root账户。<br> admin server需要免密登录所有server（包括自己），所以在admin server上配置免密登录（其他server不必配置）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ssh-copy-id root@server0</span><br><span class="line"># ssh-copy-id root@server1</span><br><span class="line"># ssh-copy-id root@server2</span><br><span class="line"># ssh-copy-id root@server3</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># for i in &#123;0..3&#125; ; do ssh server$i hostname ; done </span><br><span class="line">server0</span><br><span class="line">server1</span><br><span class="line">server2</span><br><span class="line">server3</span><br></pre></td></tr></table></figure><h2 id="3-3-安装ceph-deploy-在admin-server上"><a href="#3-3-安装ceph-deploy-在admin-server上" class="headerlink" title="3.3 安装ceph-deploy(在admin server上)"></a>3.3 安装ceph-deploy(在admin server上)</h2><p>在3.1节已经添加了ceph-deploy的yum源，这里直接通过yum安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install ceph-deploy</span><br></pre></td></tr></table></figure><p>然后测试一下，发现报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy --version</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/bin/ceph-deploy&quot;, line 18, in &lt;module&gt;</span><br><span class="line">    from ceph_deploy.cli import main</span><br><span class="line">  File &quot;/usr/lib/python2.7/site-packages/ceph_deploy/cli.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    import pkg_resources</span><br><span class="line">ImportError: No module named pkg_resources</span><br></pre></td></tr></table></figure><p>原因是缺python-setuptools，安装它即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># yum install python-setuptools</span><br><span class="line"></span><br><span class="line"># ceph-deploy --version</span><br><span class="line">2.0.0</span><br></pre></td></tr></table></figure><h2 id="3-4-安装ceph包-在admin-server上执行"><a href="#3-4-安装ceph包-在admin-server上执行" class="headerlink" title="3.4 安装ceph包(在admin server上执行)"></a>3.4 安装ceph包(在admin server上执行)</h2><p>这一步的目标是：admin server通过远程控制在所有server上安装ceph包。它需要在所有server上添加yum源：[Ceph], [Ceph-noarch]和[ceph-source]，见3.1节。</p><p>另外注意：在所有server上安装deltarpm (yum install -y deltarpm)， 否则会报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[server0][DEBUG ] Delta RPMs disabled because /usr/bin/applydeltarpm not installed.</span><br><span class="line">[server0][WARNIN] No data was received after 300 seconds, disconnecting...</span><br><span class="line">[server0][INFO  ] Running command: ceph --version</span><br><span class="line">[server0][ERROR ] Traceback (most recent call last):</span><br><span class="line">[server0][ERROR ]   File &quot;/usr/lib/python2.7/site-packages/ceph_deploy</span><br></pre></td></tr></table></figure><p>下面就是安装了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy install --release=luminous server0 server1 server2 server3</span><br></pre></td></tr></table></figure><p>成功之后，每台server都安装了ceph包，在任意sever上检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># ceph -v</span><br><span class="line">ceph version 12.2.5 (cad919881333ac92274171586c827e01f554a70a) luminous (stable)</span><br><span class="line"></span><br><span class="line"># ceph -v</span><br><span class="line">ceph version 12.2.5 (cad919881333ac92274171586c827e01f554a70a) luminous (stable)</span><br><span class="line">[root@server1 ~]# rpm -qa | grep ceph</span><br><span class="line">ceph-common-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-mds-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-release-1-1.el7.noarch</span><br><span class="line">libcephfs2-12.2.5-0.el7.x86_64</span><br><span class="line">python-cephfs-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-base-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-mon-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-osd-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-mgr-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-radosgw-12.2.5-0.el7.x86_64</span><br><span class="line">ceph-selinux-12.2.5-0.el7.x86_64</span><br></pre></td></tr></table></figure><h1 id="4-部署ceph集群（在admin-server上执行）"><a href="#4-部署ceph集群（在admin-server上执行）" class="headerlink" title="4. 部署ceph集群（在admin server上执行）"></a>4. 部署ceph集群（在admin server上执行）</h1><p>为了演示，我们</p><ol><li>创建一个集群：1 mon + 1 mgr。这个是initial monitor。</li><li>添加 osd</li><li>添加 2 mon + 2 mgr</li><li>创建一个mds</li></ol><p>实际上，我们完全可以在第1步中直接创建 3 mon + 3 mgr的集群 (3个都是initial monitor)，然后添加osd就行了。这里分作1和3两步，是为了演示添加mon和mgr。</p><p>另外，ceph-deploy在部署集群的过程中，会产生一些文件(log，keyring，ceph.conf等)，所以，我们在一个新目录下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir test-ceph-deploy</span><br><span class="line"># cd test-ceph-deploy/</span><br></pre></td></tr></table></figure><p>若部署出现错误，需要重头开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy purge server0 server1 server2 server3</span><br><span class="line">ceph-deploy purgedata server0 server1 server2 server3</span><br><span class="line">ceph-deploy forgetkeys</span><br><span class="line">rm ceph.*</span><br></pre></td></tr></table></figure><h2 id="4-1-创建集群：1-mon-1-mgr"><a href="#4-1-创建集群：1-mon-1-mgr" class="headerlink" title="4.1 创建集群：1 mon + 1 mgr"></a>4.1 创建集群：1 mon + 1 mgr</h2><p><strong>A. 以server2为initial monitor创建集群</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy new server2</span><br></pre></td></tr></table></figure><p>这里指定server2作为initial monitor。这一步完成之后，在当前目录下会产生如下文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph.conf               </span><br><span class="line">ceph.mon.keyring        </span><br><span class="line">ceph-deploy-ceph.log</span><br></pre></td></tr></table></figure><p>ceph.conf是ceph的配置文件。它将会被分发到所有server的/etc/ceph/目录下。在后续的ceph运维中，若需要做某些配置，可以在所有server上修改/etc/ceph/ceph.conf。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># cat ceph.conf </span><br><span class="line">[global]</span><br><span class="line">fsid = 744f59b7-c403-48e6-a1c6-2c74901a4d0b</span><br><span class="line">mon_initial_members = server2</span><br><span class="line">mon_host = 192.168.100.162</span><br><span class="line">auth_cluster_required = cephx</span><br><span class="line">auth_service_required = cephx</span><br><span class="line">auth_client_required = cephx</span><br></pre></td></tr></table></figure><p>ceph.mon.keyring是monitor的keyring，它定义了monitor的key，以及monitor有什么权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cat ceph.mon.keyring </span><br><span class="line">[mon.]</span><br><span class="line">key = AQDf7O9aAAAAABAAX4qmBiNsPhvK43wnpNCtLA==</span><br><span class="line">caps mon = allow *</span><br></pre></td></tr></table></figure><p><strong>B. 配置ceph网络</strong></p><p>ceph集群使用两个网络：public network和cluster network。前者用于服务client；后者用于集群内部通信，例如osd之间迁移数据。另外，两个网络上都有heartbeat。</p><p>注意：若只有一个网络，也可以部署ceph。这个网络同时担任public network和cluster network。<strong>这种情况下，跳过本小节</strong>。</p><p>我们有两个网络（见第2.1节），所以在ceph.conf中，增加如下两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vim ceph.conf</span><br><span class="line">......</span><br><span class="line">public network  = 192.168.100.0/24</span><br><span class="line">cluster network = 192.168.122.0/24</span><br></pre></td></tr></table></figure><p>注意以下两点：</p><ul><li>在2.3节，我们配置主机名解析的时候，把主机名解析为public  network的地址。这是因为，ceph-deploy是作为client (见下文D小节：client.admin,  client.bootstrap-mds,client.bootstrap-mgr,client.bootstrap-osd,client.bootstrap-rgw)来操作集群的，ceph集群通过public  network服务于client。</li><li>monitor是运行于public network上的。这也很容易理解，ceph的client都需要访问monitor，若monitor运行于cluster network上，client无法访问。</li></ul><p><strong>C. 部署initial monitor</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy mon create server2</span><br></pre></td></tr></table></figure><p>这时候，server2上，monitor已经运行起来了。可以到server2上检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server2 ~]# ps -ef | grep ceph</span><br><span class="line">ceph       18240       1  1 14:24 ?        00:00:00 /usr/bin/ceph-mon -f --cluster ceph --id server2 --setuser ceph --setgroup ceph</span><br></pre></td></tr></table></figure><p>如前文B小节所述，monitor运行于public network之上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server2 ~]# netstat -anpl | grep 6789 | grep LISTEN</span><br><span class="line">tcp        0      0 192.168.100.162:6789    0.0.0.0:*               LISTEN      18240/ceph-mon</span><br></pre></td></tr></table></figure><p><strong>D. 创建ceph keyring</strong></p><p>经过前一步，server2上的monitor已经运行起来了。但这时候ceph -s失败，因为ceph -s是admin的命令，我们还没有admin的权限信息呢。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> ceph -c ceph.conf -s </span><br><span class="line">2018-05-07 14:25:46.127163 7f76e1834700 -1 auth: unable to find a keyring on /etc/ceph/ceph.client.admin.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin,: (2) No such file or directory</span><br><span class="line">2018-05-07 14:25:46.127199 7f76e1834700 -1 monclient: ERROR: missing keyring, cannot use cephx for authentication</span><br><span class="line">2018-05-07 14:25:46.127201 7f76e1834700  0 librados: client.admin initialization error (2) No such file or directory</span><br></pre></td></tr></table></figure><p>下面使用gatherkeys来创建各个角色（包括admin）的权限信息。gatherkeys 依次对角色 admin,  bootstrap-mds, bootstrap-mgr, bootstrap-osd,  bootstrap-rgw作如下操作（问题：为什么没有bootstrap-rbd？）：</p><ol><li>使用 ceph auth get 来获取角色的key和权限；</li><li>若不存在，则使用auth get-or-create {角色} {权限}来创建角色的key和权限；</li><li>把角色的key保存到 {角色}.keyring文件；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy gatherkeys server2</span><br><span class="line">[ceph_deploy.conf][DEBUG ] found configuration file at: /root/.cephdeploy.conf</span><br><span class="line">[ceph_deploy.cli][INFO  ] Invoked (2.0.0): /usr/bin/ceph-deploy gatherkeys server2</span><br><span class="line">......</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.admin</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.admin osd allow * mds allow * mon allow * mgr allow *</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.bootstrap-mds</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.bootstrap-mds mon allow profile bootstrap-mds</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.bootstrap-mgr</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.bootstrap-mgr mon allow profile bootstrap-mgr</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.bootstrap-osd</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.bootstrap-osd mon allow profile bootstrap-osd</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get client.bootstrap-rgw</span><br><span class="line">[server2][INFO  ] Running command: /usr/bin/ceph --connect-timeout=25 --cluster=ceph --name mon. --keyring=/var/lib/ceph/mon/ceph-server2/keyring auth get-or-create client.bootstrap-rgw mon allow profile bootstrap-rgw</span><br><span class="line">[ceph_deploy.gatherkeys][INFO  ] Storing ceph.client.admin.keyring</span><br><span class="line">[ceph_deploy.gatherkeys][INFO  ] Storing ceph.bootstrap-mds.keyring</span><br><span class="line">[ceph_deploy.gatherkeys][INFO  ] Storing ceph.bootstrap-mgr.keyring</span><br><span class="line">[ceph_deploy.gatherkeys][INFO  ] keyring &apos;ceph.mon.keyring&apos; already exists</span><br><span class="line">[ceph_deploy.gatherkeys][INFO  ] Storing ceph.bootstrap-osd.keyring</span><br><span class="line">[ceph_deploy.gatherkeys][INFO  ] Storing ceph.bootstrap-rgw.keyring</span><br><span class="line">[ceph_deploy.gatherkeys][INFO  ] Destroy temp directory /tmp/tmpCHsfbU</span><br></pre></td></tr></table></figure><p>创建之后，各个角色的key和权限就存在于集群中了。某个角色（例如admin）要对集群的某个组件（例如osd）进行读写操作时，要提供自己的key；集群根据它的key找到它的权限，然后鉴定它是否能够对这个组件进行读写操作。</p><p>上面gatherkeys在生成各个角色的key+权限的同时，把角色的key保存成keyring文件，供各个角色读写集群组件时使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># ll</span><br><span class="line">total 120</span><br><span class="line">-rw-------. 1 root root    71 May  7 14:28 ceph.bootstrap-mds.keyring</span><br><span class="line">-rw-------. 1 root root    71 May  7 14:28 ceph.bootstrap-mgr.keyring</span><br><span class="line">-rw-------. 1 root root    71 May  7 14:28 ceph.bootstrap-osd.keyring</span><br><span class="line">-rw-------. 1 root root    71 May  7 14:28 ceph.bootstrap-rgw.keyring</span><br><span class="line">-rw-------. 1 root root    63 May  7 14:28 ceph.client.admin.keyring</span><br><span class="line"></span><br><span class="line"># cat ceph.client.admin.keyring </span><br><span class="line">[client.admin]</span><br><span class="line">    key = AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==</span><br><span class="line"></span><br><span class="line"># cat ceph.bootstrap-osd.keyring </span><br><span class="line">[client.bootstrap-osd]</span><br><span class="line">    key = AQD+8e9aFC9+LxAApTnB/DImy5ZjoRbQhYoiVA==</span><br></pre></td></tr></table></figure><p>现在就可以执行ceph的admin命令了（admin的key保存在ceph.client.admin.keyring文件里，通过–keyring提供）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># ceph --keyring ceph.client.admin.keyring -c ceph.conf -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     744f59b7-c403-48e6-a1c6-2c74901a4d0b</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 1 daemons, quorum server2</span><br><span class="line">    mgr: no daemons active</span><br><span class="line">    osd: 0 osds: 0 up, 0 in</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   0 pools, 0 pgs</span><br><span class="line">    objects: 0 objects, 0 bytes</span><br><span class="line">    usage:   0 kB used, 0 kB / 0 kB avail</span><br><span class="line">    pgs:     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ceph --keyring ceph.client.admin.keyring -c ceph.conf auth get client.admin</span><br><span class="line">exported keyring for client.admin</span><br><span class="line">[client.admin]</span><br><span class="line">    key = AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==</span><br><span class="line">    caps mds = &quot;allow *&quot;</span><br><span class="line">    caps mgr = &quot;allow *&quot;</span><br><span class="line">    caps mon = &quot;allow *&quot;</span><br><span class="line">    caps osd = &quot;allow *&quot;</span><br></pre></td></tr></table></figure><p><strong>E. 分发keyring</strong></p><p>如前所示，我们执行admin的命令，要提供admin的key（–keyring  ceph.client.admin.keyring）以及配置文件(-c  ceph.conf)。在后续的运维中，我们经常需要在某个server上执行admin命令。每次都提供这些参数比较麻烦。实际上，ceph会默认地从/etc/ceph/中找keyring和ceph.conf。因此，我们可以把ceph.client.admin.keyring和ceph.conf放到每个server的/etc/ceph/。ceph-deploy可以帮我做这些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy admin server0 server1 server2 server3</span><br></pre></td></tr></table></figure><p>检查每个server，发现/etc/ceph/下都多了ceph.client.admin.keyring和ceph.conf这两个文件。现在就不用提供那些参数了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line"># ceph auth get client.admin</span><br></pre></td></tr></table></figure><p><strong>F. 创建mgr</strong></p><p>从ceph 12（luminous）开始，需要为每个monitor创建一个mgr（其功能待研究，之前的版本都没有这个组件）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy mgr create server2</span><br><span class="line"></span><br><span class="line"># ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     744f59b7-c403-48e6-a1c6-2c74901a4d0b</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 1 daemons, quorum server2</span><br><span class="line">    mgr: server2(active)    ----------------------新加的mgr</span><br><span class="line">    osd: 0 osds: 0 up, 0 in</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   0 pools, 0 pgs</span><br><span class="line">    objects: 0 objects, 0 bytes</span><br><span class="line">    usage:   0 kB used, 0 kB / 0 kB avail</span><br><span class="line">    pgs:</span><br></pre></td></tr></table></figure><h2 id="4-2-添加OSD"><a href="#4-2-添加OSD" class="headerlink" title="4.2 添加OSD"></a>4.2 添加OSD</h2><p>ceph-deploy osd create通过调用ceph-volume来创建OSD。使用bluestore时(默认)，需要指定3个device：</p><table><thead><tr><th>device</th><th>如何指定</th><th>说明</th></tr></thead><tbody><tr><td>block</td><td>–data</td><td>主要存储，必选。可以是磁盘，分区或者lv</td></tr><tr><td>block.db</td><td>–block-db</td><td>可选。若不指定，则对应内容存储于block。可以是分区或者lv</td></tr><tr><td>block.wal</td><td>–block-wal</td><td>可选。若不指定，则对应内容存储于block。可以是分区或者lv</td></tr></tbody></table><p>注意： </p><ol><li>不可以使用磁盘作为block.db或者block.wal，否则会报错：blkid could not detect a PARTUUID for device； </li><li>若使用磁盘或者分区作block，则ceph-volume会在其上创建lv来使用。若使用分区作block.db或block.wal，则直接使用分区而不创建lv。</li></ol><p>在使用磁盘之前，我们先把磁盘清空。若已经创建了volume group，需要先删掉（vgremove），然后通过ceph-deploy的disk zap进行清空。ceph-deploy disk zap会发生如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy disk zap server0 /dev/vdb</span><br><span class="line">[ceph_deploy.conf][DEBUG ] found configuration file at: /root/.cephdeploy.conf</span><br><span class="line">[ceph_deploy.cli][INFO  ] Invoked (2.0.0): /usr/bin/ceph-deploy disk zap </span><br><span class="line">[ceph_deploy.osd][DEBUG ] zapping /dev/vdb on server0</span><br><span class="line">......</span><br><span class="line">[server0][DEBUG ] find the location of an executable</span><br><span class="line">[ceph_deploy][ERROR ] Traceback (most recent call last):</span><br><span class="line">[ceph_deploy][ERROR ]   File &quot;/usr/lib/python2.7/site-packages/ceph_deploy/util/decorators.py&quot;, line 69, in newfunc</span><br><span class="line">[ceph_deploy][ERROR ]     return f(*a, **kw)</span><br><span class="line">[ceph_deploy][ERROR ]   File &quot;/usr/lib/python2.7/site-packages/ceph_deploy/cli.py&quot;, line 164, in _main</span><br><span class="line">[ceph_deploy][ERROR ]     return args.func(args)</span><br><span class="line">[ceph_deploy][ERROR ]   File &quot;/usr/lib/python2.7/site-packages/ceph_deploy/osd.py&quot;, line 438, in disk</span><br><span class="line">[ceph_deploy][ERROR ]     disk_zap(args)</span><br></pre></td></tr></table></figure><p>修改ceph-deploy的 osd.py的disk_zap函数，即可成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vim /usr/lib/python2.7/site-packages/ceph_deploy/osd.py</span><br><span class="line">ceph_volume_executable = system.executable_path(distro.conn, &apos;ceph-volume&apos;)</span><br><span class="line">#if args.debug:</span><br><span class="line">if False:</span><br></pre></td></tr></table></figure><p><strong>A. 添加osd.0（磁盘作block，无block.db，无block.wal）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy osd create server0 --data /dev/vdb</span><br><span class="line"></span><br><span class="line"># ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     744f59b7-c403-48e6-a1c6-2c74901a4d0b</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 1 daemons, quorum server2</span><br><span class="line">    mgr: server2(active)</span><br><span class="line">    osd: 1 osds: 1 up, 1 in</span><br><span class="line"></span><br><span class="line"># mount | grep ceph</span><br><span class="line">tmpfs on /var/lib/ceph/osd/ceph-0 type tmpfs (rw,relatime,seclabel)</span><br><span class="line"></span><br><span class="line"># ll /var/lib/ceph/osd/ceph-0  </span><br><span class="line">total 48</span><br><span class="line">-rw-r--r--. 1 ceph ceph 189 May  7 15:19 activate.monmap</span><br><span class="line">lrwxrwxrwx. 1 ceph ceph  93 May  7 15:19 block -&gt; /dev/ceph-012c2043-33ef-4219-af69-34c7ed389d41/osd-block-5beb22d5-891c-4d6e-affe-87eb4bc083b2</span><br><span class="line">-rw-r--r--. 1 ceph ceph   2 May  7 15:19 bluefs</span><br><span class="line">-rw-r--r--. 1 ceph ceph  37 May  7 15:19 ceph_fsid</span><br><span class="line">-rw-r--r--. 1 ceph ceph  37 May  7 15:19 fsid</span><br><span class="line">-rw-------. 1 ceph ceph  55 May  7 15:19 keyring</span><br><span class="line">-rw-r--r--. 1 ceph ceph   8 May  7 15:19 kv_backend</span><br><span class="line">-rw-r--r--. 1 ceph ceph  21 May  7 15:19 magic</span><br><span class="line">-rw-r--r--. 1 ceph ceph   4 May  7 15:19 mkfs_done</span><br><span class="line">-rw-r--r--. 1 ceph ceph  41 May  7 15:19 osd_key</span><br><span class="line">-rw-r--r--. 1 ceph ceph   6 May  7 15:19 ready</span><br><span class="line">-rw-r--r--. 1 ceph ceph  10 May  7 15:19 type</span><br><span class="line">-rw-r--r--. 1 ceph ceph   2 May  7 15:19 whoami</span><br></pre></td></tr></table></figure><p>可见： </p><ol><li>使用磁盘vdb创建lv供block使用；  </li><li>osd是mount到tmpfs的（bluefs, ceph_fsid, fsid, keyring等等都存于集群中）；</li></ol><p><strong>B. 添加osd.1（分区作block，分区作block.db，无block.wal）</strong></p><p>把server0的vdc分成两个分区（分区过程省略，注意，要是有gpt分区格式）：vdc1作block.db，vdc2作block。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy osd create server0 --data /dev/vdc2 --block-db /dev/vdc1</span><br><span class="line"></span><br><span class="line"># ll  /var/lib/ceph/osd/ceph-1 </span><br><span class="line">total 52</span><br><span class="line">-rw-r--r--. 1 ceph ceph 189 May  7 15:25 activate.monmap</span><br><span class="line">lrwxrwxrwx. 1 ceph ceph  93 May  7 15:25 block -&gt; /dev/ceph-ae408599-db16-4028-914d-4006594c5cd8/osd-block-1edeced4-e5e9-45ac-a5d3-ddd238d720d4</span><br><span class="line">lrwxrwxrwx. 1 root root   9 May  7 15:25 block.db -&gt; /dev/vdc1</span><br><span class="line">-rw-r--r--. 1 ceph ceph   2 May  7 15:25 bluefs</span><br><span class="line">-rw-r--r--. 1 ceph ceph  37 May  7 15:25 ceph_fsid</span><br><span class="line">-rw-r--r--. 1 ceph ceph  37 May  7 15:25 fsid</span><br><span class="line">-rw-------. 1 ceph ceph  55 May  7 15:25 keyring</span><br><span class="line">-rw-r--r--. 1 ceph ceph   8 May  7 15:25 kv_backend</span><br><span class="line">-rw-r--r--. 1 ceph ceph  21 May  7 15:25 magic</span><br><span class="line">-rw-r--r--. 1 ceph ceph   4 May  7 15:25 mkfs_done</span><br><span class="line">-rw-r--r--. 1 ceph ceph  41 May  7 15:25 osd_key</span><br><span class="line">-rw-r--r--. 1 ceph ceph  10 May  7 15:25 path_block.db</span><br><span class="line">-rw-r--r--. 1 ceph ceph   6 May  7 15:25 ready</span><br><span class="line">-rw-r--r--. 1 ceph ceph  10 May  7 15:25 type</span><br><span class="line">-rw-r--r--. 1 ceph ceph   2 May  7 15:25 whoami</span><br></pre></td></tr></table></figure><p>可见，使用分区vdc2创建lv供block使用； block.db直接使用vdc1;</p><p><strong>C. 添加osd.2（分区作block，分区作block.db，分区作block.wal）</strong></p><p>把serve1的vdb分成3个分区：vdb3作block，vdb2作block.db，vdb1作block-wal：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy osd create server1 --data /dev/vdb3 --block-db /dev/vdb2 --block-wal /dev/vdb1</span><br></pre></td></tr></table></figure><p>到server1上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># ll /var/lib/ceph/osd/ceph-2 </span><br><span class="line">total 56</span><br><span class="line">-rw-r--r--. 1 ceph ceph 189 May  7 15:34 activate.monmap</span><br><span class="line">lrwxrwxrwx. 1 ceph ceph  93 May  7 15:34 block -&gt; /dev/ceph-c2f66dc2-076b-46cd-a1cd-e3ef9511a38a/osd-block-7bf0f953-2feb-4064-8d19-873495cae7f5</span><br><span class="line">lrwxrwxrwx. 1 root root   9 May  7 15:34 block.db -&gt; /dev/vdb2</span><br><span class="line">lrwxrwxrwx. 1 root root   9 May  7 15:34 block.wal -&gt; /dev/vdb1</span><br><span class="line">-rw-r--r--. 1 ceph ceph   2 May  7 15:34 bluefs</span><br><span class="line">-rw-r--r--. 1 ceph ceph  37 May  7 15:34 ceph_fsid</span><br><span class="line">-rw-r--r--. 1 ceph ceph  37 May  7 15:34 fsid</span><br><span class="line">-rw-------. 1 ceph ceph  55 May  7 15:34 keyring</span><br><span class="line">-rw-r--r--. 1 ceph ceph   8 May  7 15:34 kv_backend</span><br><span class="line">-rw-r--r--. 1 ceph ceph  21 May  7 15:34 magic</span><br><span class="line">-rw-r--r--. 1 ceph ceph   4 May  7 15:34 mkfs_done</span><br><span class="line">-rw-r--r--. 1 ceph ceph  41 May  7 15:34 osd_key</span><br><span class="line">-rw-r--r--. 1 ceph ceph  10 May  7 15:34 path_block.db</span><br><span class="line">-rw-r--r--. 1 ceph ceph  10 May  7 15:34 path_block.wal</span><br><span class="line">-rw-r--r--. 1 ceph ceph   6 May  7 15:34 ready</span><br><span class="line">-rw-r--r--. 1 ceph ceph  10 May  7 15:34 type</span><br><span class="line">-rw-r--r--. 1 ceph ceph   2 May  7 15:34 whoami</span><br></pre></td></tr></table></figure><p><strong>D. 添加osd.3（lv作block，lv作block.db，lv作block.wal）</strong></p><p>首先，在server1上，使用vdc创建出3个lv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># pvcreate /dev/vdc</span><br><span class="line">  Physical volume &quot;/dev/vdc&quot; successfully created</span><br><span class="line"></span><br><span class="line"># vgcreate myvg /dev/vdc   </span><br><span class="line">  Volume group &quot;myvg&quot; successfully created</span><br><span class="line"></span><br><span class="line"># lvcreate -n block-lv -L 30G myvg  </span><br><span class="line">  Logical volume &quot;block-lv&quot; created.</span><br><span class="line"></span><br><span class="line"># lvcreate -n db-lv -L 10G myvg</span><br><span class="line">  Logical volume &quot;db-lv&quot; created.</span><br><span class="line"></span><br><span class="line"># lvcreate -n wal-lv -L 10G myvg</span><br><span class="line">  Logical volume &quot;wal-lv&quot; created.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ls /dev/myvg/</span><br><span class="line">block-lv  db-lv  wal-lv</span><br></pre></td></tr></table></figure><p>然后，在admin server上创建osd.3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy osd create server1 --data myvg/block-lv --block-db myvg/db-lv  --block-wal myvg/wal-lv</span><br></pre></td></tr></table></figure><p>到server1上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># ll /var/lib/ceph/osd/ceph-3  </span><br><span class="line">total 56</span><br><span class="line">-rw-r--r--. 1 ceph ceph 189 May  7 15:47 activate.monmap</span><br><span class="line">lrwxrwxrwx. 1 ceph ceph  18 May  7 15:47 block -&gt; /dev/myvg/block-lv</span><br><span class="line">lrwxrwxrwx. 1 root root  15 May  7 15:47 block.db -&gt; /dev/myvg/db-lv</span><br><span class="line">lrwxrwxrwx. 1 root root  16 May  7 15:47 block.wal -&gt; /dev/myvg/wal-lv</span><br><span class="line">-rw-r--r--. 1 ceph ceph   2 May  7 15:47 bluefs</span><br><span class="line">-rw-r--r--. 1 ceph ceph  37 May  7 15:47 ceph_fsid</span><br><span class="line">-rw-r--r--. 1 ceph ceph  37 May  7 15:47 fsid</span><br><span class="line">-rw-------. 1 ceph ceph  55 May  7 15:47 keyring</span><br><span class="line">-rw-r--r--. 1 ceph ceph   8 May  7 15:47 kv_backend</span><br><span class="line">-rw-r--r--. 1 ceph ceph  21 May  7 15:47 magic</span><br><span class="line">-rw-r--r--. 1 ceph ceph   4 May  7 15:47 mkfs_done</span><br><span class="line">-rw-r--r--. 1 ceph ceph  41 May  7 15:47 osd_key</span><br><span class="line">-rw-r--r--. 1 ceph ceph  16 May  7 15:47 path_block.db</span><br><span class="line">-rw-r--r--. 1 ceph ceph  17 May  7 15:47 path_block.wal</span><br><span class="line">-rw-r--r--. 1 ceph ceph   6 May  7 15:47 ready</span><br><span class="line">-rw-r--r--. 1 ceph ceph  10 May  7 15:47 type</span><br><span class="line">-rw-r--r--. 1 ceph ceph   2 May  7 15:47 whoami</span><br></pre></td></tr></table></figure><p>注意： lv应写作 myvg/xx-lv，而不是/dev/myvg/xx-lv。否则会报错。</p><p><strong>E. 添加其他osd</strong></p><p>为了方便，block, block.db和block.wal都使用分区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy osd create server3 --data /dev/vdb3  --block-db /dev/vdb2  --block-wal /dev/vdb1</span><br><span class="line"># ceph-deploy osd create server3 --data /dev/vdc3  --block-db /dev/vdc2  --block-wal /dev/vdc1</span><br><span class="line"># ceph-deploy osd create server2 --data /dev/vdb3  --block-db /dev/vdb2  --block-wal /dev/vdb1</span><br><span class="line"># ceph-deploy osd create server2 --data /dev/vdc3  --block-db /dev/vdc2  --block-wal /dev/vdc1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     744f59b7-c403-48e6-a1c6-2c74901a4d0b</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 1 daemons, quorum server2</span><br><span class="line">    mgr: server2(active)</span><br><span class="line">    osd: 8 osds: 8 up, 8 in    &lt;-------- 8 个 osd</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   0 pools, 0 pgs</span><br><span class="line">    objects: 0 objects, 0 bytes</span><br><span class="line">    usage:   8226 MB used, 339 GB / 347 GB avail</span><br><span class="line">    pgs:</span><br></pre></td></tr></table></figure><h2 id="4-3-添加-2-mon-2-mgr"><a href="#4-3-添加-2-mon-2-mgr" class="headerlink" title="4.3 添加 2 mon + 2 mgr"></a>4.3 添加 2 mon + 2 mgr</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy mon add server0</span><br><span class="line"># ceph-deploy mgr create server0</span><br><span class="line"># ceph-deploy mon add server1</span><br><span class="line"># ceph-deploy mgr create server1</span><br></pre></td></tr></table></figure><p>注意：貌似新版的ceph-deploy一次只能增加一个mon.</p><p>现在集群就有3个mon和3个mgr了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     744f59b7-c403-48e6-a1c6-2c74901a4d0b</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 3 daemons, quorum server0,server1,server2</span><br><span class="line">    mgr: server2(active), standbys: server0, server1</span><br><span class="line">    osd: 8 osds: 8 up, 8 in</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   0 pools, 0 pgs</span><br><span class="line">    objects: 0 objects, 0 bytes</span><br><span class="line">    usage:   8230 MB used, 339 GB / 347 GB avail</span><br><span class="line">    pgs:</span><br></pre></td></tr></table></figure><h2 id="4-4-创建一个mds"><a href="#4-4-创建一个mds" class="headerlink" title="4.4 创建一个mds"></a>4.4 创建一个mds</h2><p>为了支持cephfs，我们在server2上创建一个mds：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy mds create server2</span><br></pre></td></tr></table></figure><p>成功之后，到server2上可以看见mds进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server2 ~]# ps -ef | grep ceph-mds</span><br><span class="line">ceph       19995       1  0 16:35 ?        00:00:00 /usr/bin/ceph-mds -f --cluster ceph --id server2 --setuser ceph --setgroup ceph</span><br></pre></td></tr></table></figure><p>但这个时候，mds并没有active，如下，我们通过ceph -s看不到mds服务。直到创建ceph filesystem的时候，mds才进入active状态（见6.1节）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     744f59b7-c403-48e6-a1c6-2c74901a4d0b</span><br><span class="line">    health: HEALTH_WARN</span><br><span class="line">            too few PGs per OSD (12 &lt; min 30)</span><br><span class="line"></span><br><span class="line">  services:    -----------------&gt; 看不到mds</span><br><span class="line">    mon: 3 daemons, quorum server0,server1,server2</span><br><span class="line">    mgr: server2(active), standbys: server0, server1</span><br><span class="line">    osd: 8 osds: 8 up, 8 in</span><br><span class="line">    rgw: 2 daemons active</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   4 pools, 32 pgs</span><br><span class="line">    objects: 187 objects, 1113 bytes</span><br><span class="line">    usage:   8239 MB used, 339 GB / 347 GB avail</span><br><span class="line">    pgs:     32 active+clean</span><br></pre></td></tr></table></figure><p>至此，ceph集群就完全部署起来了。下面，我们为ceph集群增加一些client。</p><h1 id="5-增加rgw-（在admin-server上操作）"><a href="#5-增加rgw-（在admin-server上操作）" class="headerlink" title="5. 增加rgw （在admin server上操作）"></a>5. 增加rgw （在admin server上操作）</h1><p>我们可以使用ceph集群之外的server来部署rgw。部署之前，需要保证默认端口（7480）没有被防火墙禁止。并且需要安装ceph-radosgw包机器依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy install --rgw &lt;client-node&gt; [&lt;client-node&gt; ...]</span><br></pre></td></tr></table></figure><p>为了方便起见，我们复用集群内的server1和server3来部署rgw。由于ceph-radosgw已经安装（见3.4节），并且防火墙已经被停掉（见2.5节），所以，直接部署即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy rgw create server1 server3</span><br></pre></td></tr></table></figure><p>成功之后，在server1和server3上rgw进程就运行起来了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@server1 ~]# ps -ef | grep ceph</span><br><span class="line">......</span><br><span class="line">ceph       15884       1  2 16:23 ?        00:00:00 /usr/bin/radosgw -f --cluster ceph --name client.rgw.server1 --setuser ceph --setgroup ceph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@server3 ~]# ps -ef | grep ceph</span><br><span class="line">......</span><br><span class="line">ceph       14107       1  2 16:23 ?        00:00:00 /usr/bin/radosgw -f --cluster ceph --name client.rgw.server3 --setuser ceph --setgroup ceph</span><br></pre></td></tr></table></figure><p>并且我们可以通过http来访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># curl server1:7480</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;ListAllMyBucketsResult xmlns=&quot;http://s3.amazonaws.com/doc/2006-03-01/&quot;&gt;</span><br><span class="line">&lt;Owner&gt;</span><br><span class="line">    &lt;ID&gt;anonymous&lt;/ID&gt;</span><br><span class="line">    &lt;DisplayName&gt;&lt;/DisplayName&gt;</span><br><span class="line">&lt;/Owner&gt;</span><br><span class="line">&lt;Buckets&gt;&lt;/Buckets&gt;</span><br><span class="line">&lt;/ListAllMyBucketsResult&gt;</span><br></pre></td></tr></table></figure><h1 id="6-增加cephfs"><a href="#6-增加cephfs" class="headerlink" title="6. 增加cephfs"></a>6. 增加cephfs</h1><p>ceph filesystem需要mds（我们在4.4节已经部署）。并且，有两种方式来挂载：ceph fuse和ceph kernel driver。在这一节，我们:</p><ol><li>创建一个ceph filesystem</li><li>通过ceph fuse挂载</li><li>通过ceph kernel driver挂载</li></ol><h2 id="6-1-创建ceph-filesystem（在集群内任意server上）"><a href="#6-1-创建ceph-filesystem（在集群内任意server上）" class="headerlink" title="6.1 创建ceph filesystem（在集群内任意server上）"></a>6.1 创建ceph filesystem（在集群内任意server上）</h2><p><strong>A. 创建所需的pool</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd pool create cephfs_data 80</span><br><span class="line">pool &apos;cephfs_data&apos; created</span><br><span class="line"># ceph osd pool create cephfs_metadata 40</span><br><span class="line">pool &apos;cephfs_metadata&apos; created</span><br></pre></td></tr></table></figure><p><strong>B. 创建filesystem</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph fs new mycephfs cephfs_metadata cephfs_data</span><br><span class="line">new fs with metadata pool 6 and data pool 5</span><br></pre></td></tr></table></figure><p>如第4.4节所示，在没有创建filesystem之前，mds没有active。现在mds就进入active状态了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     744f59b7-c403-48e6-a1c6-2c74901a4d0b</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 3 daemons, quorum server0,server1,server2</span><br><span class="line">    mgr: server2(active), standbys: server0, server1</span><br><span class="line">    mds: mycephfs-1/1/1 up  &#123;0=server2=up:active&#125;  ---------&gt;mds已经active</span><br><span class="line">    osd: 8 osds: 8 up, 8 in</span><br><span class="line">    rgw: 2 daemons active</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   6 pools, 152 pgs</span><br><span class="line">    objects: 208 objects, 3359 bytes</span><br><span class="line">    usage:   8248 MB used, 339 GB / 347 GB avail</span><br><span class="line">    pgs:     152 active+clean</span><br></pre></td></tr></table></figure><h2 id="6-2-通过ceph-fuse挂载（在server2上）"><a href="#6-2-通过ceph-fuse挂载（在server2上）" class="headerlink" title="6.2 通过ceph fuse挂载（在server2上）"></a>6.2 通过ceph fuse挂载（在server2上）</h2><p>和rgw一样，原则上我们在ceph集群之外的某台server上挂载ceph filesystem。但为了方便起见，我们还是在server2上挂载。</p><p>首先，要在server2上安装ceph-fuse（<strong>若使用ceph集群外的server，也只需这一个包</strong>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y ceph-fuse.x86_64</span><br></pre></td></tr></table></figure><p>然后，创建一个挂载点，就可以挂载了。注意，ceph-fuse挂载使用的是admin的权限，所以，通过-k选项传入admin的key。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /mnt/cephfs</span><br><span class="line"></span><br><span class="line"># ceph-fuse -k /etc/ceph/ceph.client.admin.keyring -m server0:6789 /mnt/cephfs</span><br><span class="line">2018-05-07 17:27:07.205147 7f501e11f040 -1 init, newargv = 0x7f502968cb80 newargc=9</span><br><span class="line">ceph-fuse[20080]: starting ceph client</span><br><span class="line">ceph-fuse[20080]: starting fuse</span><br></pre></td></tr></table></figure><p>这时候，一个全新的ceph filesystem就可以使用了。注意：这时cephfs_data是空的，但cephfs_metadata不空：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ceph df</span><br><span class="line">GLOBAL:</span><br><span class="line">    SIZE     AVAIL     RAW USED     %RAW USED </span><br><span class="line">    347G      339G        8248M          2.32 </span><br><span class="line">POOLS:</span><br><span class="line">    NAME                    ID     USED     %USED     MAX AVAIL     OBJECTS </span><br><span class="line">    ......</span><br><span class="line">    cephfs_data             5         0         0          106G           0 </span><br><span class="line">    cephfs_metadata         6      2624         0          106G          21</span><br></pre></td></tr></table></figure><p>往里拷贝一些东西，就会发现cephfs_data也不空了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># cp /boot/vmlinuz-3.10.0-327.el7.x86_64  /mnt/cephfs/</span><br><span class="line"></span><br><span class="line"># ls /mnt/cephfs/</span><br><span class="line">vmlinuz-3.10.0-327.el7.x86_64</span><br><span class="line"></span><br><span class="line"># ceph df</span><br><span class="line">GLOBAL:</span><br><span class="line">    SIZE     AVAIL     RAW USED     %RAW USED </span><br><span class="line">    347G      339G        8263M          2.32 </span><br><span class="line">POOLS:</span><br><span class="line">    NAME                    ID     USED      %USED     MAX AVAIL     OBJECTS </span><br><span class="line">    ......</span><br><span class="line">    cephfs_data             5      5035k         0          106G           2 </span><br><span class="line">    cephfs_metadata         6       7541         0          106G          21</span><br></pre></td></tr></table></figure><h2 id="6-3-通过ceph-kernel-driver挂载"><a href="#6-3-通过ceph-kernel-driver挂载" class="headerlink" title="6.3 通过ceph kernel driver挂载"></a>6.3 通过ceph kernel driver挂载</h2><p>首先，我们尝试在server3上测试ceph kernel driver挂载。</p><p>和ceph-fuse一样，通过ceph kernel driver挂载也需要admin的权限。不同的是，不需要admin的keyring文件，而是直接需要admin的key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server3 ~]# mkdir /mnt/kcephfs</span><br><span class="line">[root@server3 ~]# mount -t ceph server0:6789:/ /mnt/kcephfs/  -o name=admin,secret=AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==</span><br></pre></td></tr></table></figure><p>这个命令卡了一段时间后，报出如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount error 5 = Input/output error</span><br></pre></td></tr></table></figure><p>在/var/log/messages中，有如下错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server3 ~]# tail /var/log/messages</span><br><span class="line">May  7 17:41:29 server3 kernel: libceph: mon0 192.168.100.160:6789 feature set mismatch, my 103b84a842aca &lt; server&apos;s 40103b84a842aca, missing 400000000000000</span><br><span class="line">May  7 17:41:29 server3 kernel: libceph: mon0 192.168.100.160:6789 missing required protocol features</span><br></pre></td></tr></table></figure><p>就是说：ceph集群需要的feature set，我们的ceph kernel driver没能够全部提供，缺失的是400000000000000。</p><p>从<a href="http://cephnotes.ksperis.com/blog/2014/01/21/feature-set-mismatch-error-on-ceph-kernel-client" target="_blank" rel="noopener">CephNotes</a>里，我们可以看到，缺失有些feature，可以通过两种办法解决：</p><ol><li>升级内核  （从客户端入手解决）</li><li>对集群做某些设置 （从server端入手解决）</li></ol><p>例如：</p><ul><li>missing 2040000 (CEPH_FEATURE_CRUSH_TUNABLES 和CEPH_FEATURE_CRUSH_TUNABLES2 )： <pre><code>把客户server（cephfs挂载机）的内核升到3.9（或以上） ； 把tunables设置为legacy : ceph osd crush tunables legacy；</code></pre></li><li>missing 40000000 (CEPH_FEATURE_OSDHASHPSPOOL)： <pre><code>把客户server（rbd客户机？）的内核升到3.9（或以上） ； ceph osd pool set rbd hashpspool false</code></pre></li><li>missing 800000000 (CEPH_FEATURE_OSD_CACHEPOOL)： <pre><code>把客户server的内核升到3.14（或以上） ； 删除cache pool并reload monitors；</code></pre></li></ul><p>悲剧的是，我们缺失的400000000000000 (CEPH_FEATURE_NEW_OSDOPREPLY_ENCODING)，无法通过设置集群来解决，也就是说必须升级内核（到4.5以上）。</p><p>参考：<a href="http://cephnotes.ksperis.com/blog/2014/01/21/feature-set-mismatch-error-on-ceph-kernel-client" target="_blank" rel="noopener">http://cephnotes.ksperis.com/blog/2014/01/21/feature-set-mismatch-error-on-ceph-kernel-client</a></p><p>刚好，我有个开发server（devbuild：192.168.100.150），已经编译安装过内核  4.14.39。去试试。如4.1.B节所述，monitor运行于public  network上（192.168.100.0/24），devbuild能够访问这个网络。这就足够了。<strong>注意：这个server不需安装任何ceph包</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># ping 192.168.100.160</span><br><span class="line">PING 192.168.100.160 (192.168.100.160) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.100.160: icmp_seq=1 ttl=64 time=4.12 ms</span><br><span class="line">64 bytes from 192.168.100.160: icmp_seq=2 ttl=64 time=0.557 ms</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[root@devbuild ~]# uname -a</span><br><span class="line">Linux devbuild 4.14.39.hyg.20180503  ......</span><br><span class="line"></span><br><span class="line">[root@devbuild ~]# mkdir /mnt/kcephfs</span><br><span class="line"></span><br><span class="line">[root@devbuild ~]# mount -t ceph 192.168.100.162:6789:/ /mnt/kcephfs/  -o name=admin,secret=AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==</span><br><span class="line"></span><br><span class="line">[root@devbuild ~]# ls /mnt/kcephfs/</span><br><span class="line">vmlinuz-3.10.0-327.el7.x86_64</span><br></pre></td></tr></table></figure><p>已经mount成功，并且能看到第6.2节拷贝过去的文件。再测试拷贝一个文件，可见读写正常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@devbuild ~]# cp linux-4.14.39.tar.xz /mnt/kcephfs/</span><br><span class="line"></span><br><span class="line">[root@devbuild ~]# ll /mnt/kcephfs/</span><br><span class="line">total 103560</span><br><span class="line">-rw-r--r-- 1 root root 100888428 May  7 18:27 linux-4.14.39.tar.xz</span><br><span class="line">-rwxr-xr-x 1 root root   5156528 May  7 17:30 vmlinuz-3.10.0-327.el7.x86_64</span><br></pre></td></tr></table></figure><p>另外，根据官方文档，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount -t ceph 192.168.100.162:6789:/ /mnt/kcephfs/  -o name=admin,secret=AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==</span><br></pre></td></tr></table></figure><p>也可以换做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cat admin.secret </span><br><span class="line">AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==</span><br><span class="line"></span><br><span class="line"># mount -t ceph 192.168.100.162:6789:/ /mnt/kcephfs/  -o name=admin,secretfile=admin.secret</span><br></pre></td></tr></table></figure><p>但是，我这样尝试，一直报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@devbuild ~]# cat admin.secret</span><br><span class="line">AQD88e9aAwlyBRAAVwhjmH8GGVmG+JFYs/3MAA==</span><br><span class="line">[root@devbuild ~]# mount -t ceph 192.168.100.162:6789:/ /mnt/kcephfs/  -o name=admin,secretfile=admin.secret</span><br><span class="line">mount: wrong fs type, bad option, bad superblock on 192.168.100.162:6789:/,</span><br><span class="line">       missing codepage or helper program, or other error</span><br><span class="line"></span><br><span class="line">       In some cases useful info is found in syslog - try</span><br><span class="line">       dmesg | tail or so.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@devbuild ~]# dmesg | tail   </span><br><span class="line">[   66.850589] random: 7 urandom warning(s) missed due to ratelimiting</span><br><span class="line">[  140.953833] Key type dns_resolver registered</span><br><span class="line">[  141.096210] Key type ceph registered</span><br><span class="line">[  141.097950] libceph: loaded (mon/osd proto 15/24)</span><br><span class="line">[  141.160712] ceph: loaded (mds proto 32)</span><br><span class="line">[  141.163762] libceph: bad option at &apos;secretfile=admin.secret&apos;</span><br></pre></td></tr></table></figure><p>原因是，我的这个server没有安装任何ceph包，所以没有/usr/sbin/mount.ceph这个文件。解决办法：<br> \1. 从别的server拷贝这个文件;<br> \2. 安装ceph-common；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y ceph-common-12.2.5-0.el7.x86_64</span><br></pre></td></tr></table></figure><p>前文说过，devbuild server不需安装任何ceph包，但若使用secretfile的方式，还是安装这个ceph-common为好。</p><h1 id="7-增加rbd"><a href="#7-增加rbd" class="headerlink" title="7. 增加rbd"></a>7. 增加rbd</h1><h2 id="7-1-准备rbd-pool"><a href="#7-1-准备rbd-pool" class="headerlink" title="7.1 准备rbd pool"></a>7.1 准备rbd pool</h2><p>在集群内的任意server上创建一个pool，并init：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd pool create rbd_pool 100 100</span><br><span class="line">pool &apos;rbd_pool&apos; created</span><br><span class="line"></span><br><span class="line"># rbd pool init rbd_pool</span><br></pre></td></tr></table></figure><h2 id="7-2-创建块设备"><a href="#7-2-创建块设备" class="headerlink" title="7.2 创建块设备"></a>7.2 创建块设备</h2><p>首先我们尝试在集群内的一个server（server0）上创建块设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># rbd create foo --size 4096 --image-feature layering -m 192.168.100.160  -K admin.secret -p rbd_pool</span><br><span class="line"># rbd map foo --name client.admin -m 192.168.100.160 -K admin.secret -p rbd_pool</span><br><span class="line"></span><br><span class="line">rbd: sysfs write failed</span><br><span class="line">rbd: error opening default pool &apos;rbd&apos;</span><br><span class="line">Ensure that the default pool has been created or specify an alternate pool name.</span><br><span class="line">In some cases useful info is found in syslog - try &quot;dmesg | tail&quot;.</span><br><span class="line">rbd: map failed: (5) Input/output error</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># dmesg | tail </span><br><span class="line">......</span><br><span class="line">[527394.031762] libceph: mon0 192.168.100.160:6789 feature set mismatch, my 102b84a842a42 &lt; server&apos;s 40102b84a842a42, missing 400000000000000</span><br><span class="line">[527394.034677] libceph: mon0 192.168.100.160:6789 missing required protocol features</span><br></pre></td></tr></table></figure><p>和6.3节遇到的问题一样，内核版本低，缺feature 400000000000000。还是到devbuild这个server上创建吧，要求：</p><ul><li>devbuild server能够访问monitor (public network)；</li><li>安装ceph-common；</li><li>admin.secret；</li></ul><p>如6.3节所述，都已满足。可以创建块设备了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># rbd create foo --size 4096 --image-feature layering -m 192.168.100.160  -K admin.secret -p rbd_pool</span><br><span class="line"></span><br><span class="line"># rbd map foo --name client.admin -m 192.168.100.160  -K admin.secret -p rbd_pool</span><br></pre></td></tr></table></figure><p>选项-K admin.secret也可以换成-k ceph.client.admin.keyring。成功之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ll /dev/rbd0</span><br><span class="line">brw-rw----. 1 root disk 251, 0 May 10 16:31 /dev/rbd0</span><br><span class="line"></span><br><span class="line"># ls /dev/rbd/</span><br><span class="line">rbd_pool</span><br><span class="line"></span><br><span class="line"># ls /dev/rbd/rbd_pool</span><br><span class="line">foo</span><br></pre></td></tr></table></figure><p>这时候，我们可以使用/dev/rbd0了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkfs.ext4  /dev/rbd0 </span><br><span class="line"># mount  /dev/rbd0 /mnt/rbd/</span><br></pre></td></tr></table></figure><h1 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h1><p>本文实践了使用ceph-deploy安装部署ceph集群的过程，给集群添加了三种类型的客户端，并且解决了一些部署中常见的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-环境&quot;&gt;&lt;a href=&quot;#1-环境&quot; class=&quot;headerlink&quot; title=&quot;1. 环境&quot;&gt;&lt;/a&gt;1. 环境&lt;/h1&gt;&lt;h2 id=&quot;1-1-硬件&quot;&gt;&lt;a href=&quot;#1-1-硬件&quot; class=&quot;headerlink&quot; title=&quot;1.1 硬件&quot;&gt;&lt;/a&gt;1.1 硬件&lt;/h2&gt;&lt;p&gt;4台 Linux虚拟机： server0, server1, server2, server3&lt;br&gt; 每台有两块磁盘 ： /dev/vdb, /dev/vdc&lt;br&gt; 每台有两块网卡 ：eth0, ens9&lt;/p&gt;
&lt;h2 id=&quot;1-2-软件&quot;&gt;&lt;a href=&quot;#1-2-软件&quot; class=&quot;headerlink&quot; title=&quot;1.2 软件&quot;&gt;&lt;/a&gt;1.2 软件&lt;/h2&gt;&lt;p&gt;linux版本： CentOS 7.2.1511&lt;br&gt; 内核版本 ：  3.10.0-327.el7.x86_64&lt;br&gt; ceph版本：  12.2.12&lt;br&gt; ceph-deploy版本： 2.0.0&lt;/p&gt;
    
    </summary>
    
      <category term="Ceph" scheme="http://yoursite.com/categories/Ceph/"/>
    
    
      <category term="ceph" scheme="http://yoursite.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title>Ceph存储引擎之FileStore</title>
    <link href="http://yoursite.com/2019/05/07/Ceph-FileStore%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/05/07/Ceph-FileStore详解/</id>
    <published>2019-05-07T09:11:02.000Z</published>
    <updated>2019-05-07T09:25:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>​        Ceph作为一个高可用和强一致性的软件定义存储实现，去使用它非常重要的就是了解其内部的IO路径和存储实现。这篇文章主要介绍在IO路径中最底层的ObjectStore的实现之一FileStore。</p><a id="more"></a><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/图片1.png" alt></p><h2 id="ObjectStore"><a href="#ObjectStore" class="headerlink" title="ObjectStore"></a>ObjectStore</h2><p>​        ObjectStore是Ceph OSD中最重要的概念之一，它封装了所有对底层存储的IO操作。从上图中可以看到所有IO请求在Clieng端发出，在Message层统一解析后会被OSD层分发到各个PG，每个PG都拥有一个队列，一个线程池会对每个队列进行处理。</p><p>​        当一个在PG队列里的IO被提出后，该IO请求会被根据类型和相关附带参数进行处理。如果是读请求会通过ObjectStore提供的API获得相应的内容，如果是写请求也会利用ObjectStore提供的事务API将所有写操作组合成一个原子事务提交给ObjectStore。ObjectStore通过接口对上层提供不同的隔离级别，目前PG层只采用了Serializable级别,保证读写的顺序性。</p><p>​        ObjectStore主要接口分为三部分，第一部分是Object的读写操作，类似于POSIX的部分接口，第二部分是Object的属性(xattr)读写操作，这类操作的特征是kv对并且与某一个Object关联。第三部分是关联Object的kv操作(在Ceph中称为omap)，这个其实与第二部分非常类似，但是在实现上可能会有所变化。</p><p>​        目前ObjectStore的主要实现是FileStore，也就是利用文件系统的POSIX接口实现ObjectStore  API。每个Object在FileStore层会被看成是一个文件，Object的属性(xattr)会利用文件的xattr属性存取，因为有些文件系统(如Ext4)对xattr的长度有限制，因此超出长度的Metadata会被存储在DBObjectMap里。而Object的omap则直接利用DBObjectMap实现。因此，可以看出xattr和omap操作是互通的，在用户角度来说，前者可以看作是受限的长度，后者更宽泛(API没有对这些做出硬性要求)。</p><h2 id="FileJournal"><a href="#FileJournal" class="headerlink" title="FileJournal"></a>FileJournal</h2><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/图片2.png" alt></p><p>为了缩小写事务的处理时间，提高写事务的处理能力并且实现事务的原子性，FileStore引入了FileJournal，所有写事务在被FileJournal处理以后都会立即返回(上图中的第二步)。FileJournal类似于数据库的writeahead日志，使用O_DIRECT和O_DSYNC每次同步写入到journal文件，完成后该事务会被塞到FileStore的op  queue。事务通常有若干个写操作组成，当在中间过程进程crash时，journal会OSD  recover提供了完备的输入。FileStore会存在多个thread从op  queue里获取op，然后真正apply到文件系统上对应的Object(Buffer  IO)。当FileStore将事务落到disk上之后，后续的该Object的读请求才会继续(上图中的第五步)。当FileStore完成一个op后，对应的Journal可以丢弃这部分日志。</p><p>​        实际上并不是所有的文件系统都按照这个顺序，一般来说如Ceph推荐的Ext4和XFS文件系统会先写入Journal，然后再写入Filesystem，而COW(Copy  on Write)文件系统如Btrfs和ZFS会同时写入Journal和FileSystem。</p><h2 id="DBObjectMap"><a href="#DBObjectMap" class="headerlink" title="DBObjectMap"></a>DBObjectMap</h2><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/图片3.png" alt></p><p>​        DBObjectMap是FileStore的一部分，利用KeyValue数据库实现了ObjectStore的第三部分API，DBObjectMap主要复杂在其实现了clone操作的no-copy。因为ObjectStore提供了clone   API，提供对一个Object的完全clone(包括Object的属性和omap)。DBObjectMap对每一个Object有一个Header，每个Object联系的omap(kv   pairs)对会与该Header联系，当clone时，会产生两个新的Header，原来的Header作为这两个新Header的parent，这时候无论是原来的Object还是cloned  Object在查询或者写操作时都会查询parent的情况，并且实现copy-on-write。那么Header如何与omap(kv  pairs)联系呢，首先每个Header有一个唯一的seq，然后所有属于该Header的omap的key里面都会包含该seq，因此，利用KeyValueDB的提供的有序prefix检索来实现对omap的遍历。</p><p>​        上面提到FileStore会将每个Object作为一个文件，那么Object的一些属性会与Object  Name一起作为文件名，Object  所属的PG会作为文件目录，当一个PG内所包含的文件超过一定程度时(在目录内文件太多会造成文件系统的lookup性能损耗)，PG会被分裂成两个PG。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        Ceph作为一个高可用和强一致性的软件定义存储实现，去使用它非常重要的就是了解其内部的IO路径和存储实现。这篇文章主要介绍在IO路径中最底层的ObjectStore的实现之一FileStore。&lt;/p&gt;
    
    </summary>
    
      <category term="Ceph" scheme="http://yoursite.com/categories/Ceph/"/>
    
    
      <category term="ceph" scheme="http://yoursite.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title>ceph存储引擎之bluestore</title>
    <link href="http://yoursite.com/2019/05/07/Ceph-bluestore%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/05/07/Ceph-bluestore详解/</id>
    <published>2019-05-07T09:11:02.000Z</published>
    <updated>2019-05-08T14:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>​        ceph后端支持多种存储引擎，以插件式的方式来进行管理使用，目前支持filestore，kvstore，memstore以及最新的bluestore，本文介绍的是bluestore的存储方法。</p><a id="more"></a><p>​        目前ceph10版本默认使用的filestore，但是因为filestore在写数据前需要先写journal，会有一倍的写放大，并且filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑，因此诞生的bluestore初衷就是为了减少写放大，并针对ssd做优化，而且直接管理裸盘，从理论上进一步减少文件系统如ext4/xfs等部分的开销，目前bluestore还处于开发优化阶段，在jewel版本还是试用版本，并且最新的master相比jewel已经做了大的重构，预期会在后续的大版本中稳定下来成为默认的存储引擎。本文基于master分支对bluestore存储引擎进行分析。</p><h4 id="bluestore整体架构"><a href="#bluestore整体架构" class="headerlink" title="bluestore整体架构"></a>bluestore整体架构</h4><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEB8.tmp.jpg" alt></p><p>​        bluestore直接管理裸设备，抛弃了ext4/xfs等本地文件系统，BlockDevice实现在用户态下使用linux aio直接对裸设备进行I/O操作。既然是直接管理裸设备就必然需要进行裸设备的空间管理，对应的就是<strong>Allocator</strong>，目前支持<strong>StupidAllocator</strong>和<strong>BitmapAllocator</strong>两种分配器。</p><p>​        相关的元数据以kv的形式保存到<strong>kv数据库</strong>里，默认使用的是rocksdb，由于rocksdb本身是基于文件系统的，不是直接操作裸设备，但是rocksdb也比较灵活，将系统相关的处理抽象成Env，用户可用实现相应的接口，rocksdb默认的Env是<strong>PosixEnv</strong>，直接对接本地文件系统，为此，bluestore实现了一个BlueRocksEnv，继承自EnvWrapper，来为rocksdb提供底层系统的封装，为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口，在系统启动mount这个文件系统的时候将所有的元数据都加载到内存中，BluesFS的数据和日志文件都通过BlockDevice保存到裸设备上，BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备。</p><h4 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h4><p>​        <strong>RocksDB</strong>： 存储预写式日志、数据对象元数据、Ceph的omap数据信息、以及分配器的元数据（分配器负责决定真正的数据应在什么地方存储）<br>​        <strong>BlueRocksEnv</strong>： 与RocksDB交互的接口<br>​        <strong>BlueFS</strong>： 小的文件系统，解决元数据、文件空间及磁盘空间的分配和管理，并实现了rocksdb::Env 接口(存储RocksDB日志和sst文件)。因为rocksdb常规来说是运行在文件系统的顶层，下面是BlueFS。 它是数据存储后端层，RocksDB的数据和BlueStore中的真正数据被存储在同一个块物理设备<br>​        <strong>HDD/SSD</strong>： 物理块设备，存储实际的数据</p><p>​        rocksdb本身是基于文件系统的，不是直接操作裸设备。它将系统相关的处理抽象成Env，用户可用实现相应的接口（rocksdb默认的Env是PosixEnv，直接对接本地文件系统）。BlueRocksEnv是bluestore实现的一个类，继承自rocksdb::EnvWrapper，来为rocksdb提供底层系统的封装。</p><p>​        为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口。所有的元数据的修改都记录在BlueFS的日志中，也就是对于BlueFS，元数据的持久化保存在日志中。在系统启动mount这个文件系统时，只需replay日志，就可将所有的元数据都加载到内存中。BluesFS的数据和日志文件都通过块设备保存到裸设备上（BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备）。</p><p>​        bluestore不使用本地文件系统，直接接管裸设备，并且只使用一个原始分区，HDD/SSD所在的物理块设备实现在用户态下使用linux aio直接对裸设备进行I/O操作。由于操作系统支持的aio操作只支持directIO，所以对BlockDevice的写操作直接写入磁盘，并且需要按照page对齐。其内部有一个aio_thread 线程，用来检查aio是否完成。其完成后，通过回调函数aio_callback 通知调用方。</p><h4 id="wal-amp-db"><a href="#wal-amp-db" class="headerlink" title="wal &amp; db"></a>wal &amp; db</h4><p>BlueFs将整个BlueStore的存储空间分为三个层次 ：</p><ul><li><p><strong>慢速(Slow)空间</strong> </p><p>主要用于存储对象数据，可由普通大容量机械盘提供，由BlueStore自行管理</p></li><li><p><strong>高速(DB)空间</strong> </p><p>存储BlueStore内部产生的元数据，可由普通SSD提供，需求小于（慢速空间）。</p></li><li><p><strong>超高速(WAL)空间</strong> </p><p>主要存储RocksDB内部产生的.log文件，可由ＳＳＤ或者ＮＶＲＡＭ等时延相较普通ＳＳＤ更小的设备充当。容量需求和（高速空间）相当，同样由ＢｌｕｅＦｓ直接管理。</p></li></ul><h5 id="wal-amp-db-的大小问题"><a href="#wal-amp-db-的大小问题" class="headerlink" title="wal &amp; db 的大小问题"></a>wal &amp; db 的大小问题</h5><p>​        在 ceph bluestore 的情况下，wal 是 RocksDB 的 write-ahead log, 相当于之前的 journal  数据，db 是 RocksDB 的 metadata 信息。在磁盘选择原则是 block.wal &gt; block.db &gt;  block。当然所有的数据也可以放到同一块盘上。</p><p>​        默认情况下， wal 和 db 的大小分别是 512 MB 和 1GB, 现在没有一个好的理论值，好像和 ceph 本身承载的数据类型有关系。</p><p>​        值得注意的是，如果所有的数据都在单块盘上，那是没有必要指定 wal &amp; db 的大小的。如果 wal &amp; db  是在不同的盘上，由于 wal/db 一般都会分的比较小，是有满的可能性的。如果满了，这些数据会迁移到下一个快的盘上(wal - db -  main)。所以最少不会因为数据满了，而造成无法写入。</p><h4 id="bluestore元数据"><a href="#bluestore元数据" class="headerlink" title="bluestore元数据"></a>bluestore元数据</h4><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEB9.tmp.jpg" alt></p><p>​        在之前的存储引擎filestore里，对象的表现形式是对应到文件系统里的文件，默认4MB大小的文件，但是在bluestore里，已经没有传统的文件系统，而是自己管理裸盘，因此需要有元数据来管理对象，对应的就是Onode，Onode是常驻内存的数据结构，持久化的时候会以kv的形式存到rocksdb里。</p><p>​        在onode里又分为lextent，表示逻辑的数据块，用一个map来记录，一个onode里会存在多个lextent，lextent通过blob的id对应到blob（bluestore_blob_t ），blob里通过pextent对应到实际物理盘上的区域（pextent里就是offset和length来定位物理盘的位置区域）。一个onode里的多个lextent可能在同一个blob里，而一个blob也可能对应到多个pextent。</p><p>​        另外还有Bnode这个元数据，它是用来表示多个object可能共享extent，目前在做了快照后写I/O触发的cow进行clone的时候会用到。</p><h4 id="I-O读写映射逻辑"><a href="#I-O读写映射逻辑" class="headerlink" title="I/O读写映射逻辑"></a>I/O读写映射逻辑</h4><h5 id="写I-O处理"><a href="#写I-O处理" class="headerlink" title="写I/O处理"></a>写I/O处理</h5><p>​        到达bluestore的I/O的offset和length都是对象内（onode）的，offset是相对于这个对象起始位置的偏移，在_do_write里首先就会根据最小分配单位min_alloc_size进行判断，从而将I/O分为对齐和非对齐的。如下图所示：</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEBA.tmp.png" alt></p><p>​        当一个写请求按照min_alloc_size进行拆分后，就会分为对齐写，对应到do_write_big，非对齐写（即落到某一个min_alloc_size区间的写I/O（对应到do_write_small）。</p><h6 id="do-write-big"><a href="#do-write-big" class="headerlink" title="do_write_big"></a>do_write_big</h6><p>​        对齐到min_alloc_size的写请求处理起来比较简单，有可能是多个min_alloc_size的大小，在处理时会根据实际大小新生成lextent和blob，这个lextent跨越的区域是min_alloc_size的整数倍，如果这段区间是之前写过的，会将之前的lextent记录下来便于后续的空间回收。</p><h6 id="do-write-small"><a href="#do-write-small" class="headerlink" title="do_write_small"></a>do_write_small</h6><p>​        在处理落到某个min_alloc_size区间的写请求时，会首先根据offset去查找有没有可以复用的blob，因为最小分配单元是min_alloc_size，默认64KB，如果一个4KB的写I/O就只会用到blob的一部分，blob里剩余的还能放其他的。</p><h6 id="1）没有找到可以复用的blob，新生成blob"><a href="#1）没有找到可以复用的blob，新生成blob" class="headerlink" title="1）没有找到可以复用的blob，新生成blob"></a>1）没有找到可以复用的blob，新生成blob</h6><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCECB.tmp.jpg" alt></p><p>​        在处理还还需要根据offset和len是否对齐到block_size（默认是4KB）进行补零对齐的操作，之所以需要补齐是与后续的写盘操作有关，真正写盘时有两种方式，一种是Direct I/O的方式，这种要求偏移和缓冲区都对齐的，另外一种非Direct I/O，即Buffered I/O，这种可以不对齐，但是是写到cache里，然后再sync刷到磁盘上，比如只写了100字节，在内核里是需要先从设备上读出来补齐成一个完整的扇区，然后再刷的，这样反而降低了效率。因此在bluestore里直接处理好对齐，对于后面的写盘来说比较有利，这里对齐到block_size，是个可配置的参数。</p><p>​        进行对齐补零时就是按照如上图那样把前后对齐到block_size，然后再把对齐后的offset和len作为lextent，进而放到blob里。</p><h6 id="2）找到可以复用的blob"><a href="#2）找到可以复用的blob" class="headerlink" title="2）找到可以复用的blob"></a>2）找到可以复用的blob</h6><p>​        对于可以复用的blob，也是先按照block_size进行对齐补零的动作，然后再判断是否可以直接使用blob里空闲的空间进行区分做不同的处理。</p><h6 id="a）直接写在blob未使用的空间上"><a href="#a）直接写在blob未使用的空间上" class="headerlink" title="a）直接写在blob未使用的空间上"></a>a）直接写在blob未使用的空间上</h6><p>​        这种情况下直接新生成lextent放到blob里。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCECC.tmp.png" alt></p><h6 id="b）覆盖写的情况"><a href="#b）覆盖写的情况" class="headerlink" title="b）覆盖写的情况"></a>b）覆盖写的情况</h6><p>​        比如下面的这种情况，写I/O会覆盖部分已经写过的数据。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCECD.tmp.jpg" alt></p><p>​        对于这种情况的处理如下图：也是需要先处理对齐补零的情况，如果覆盖的区域刚好是已经对齐到block_size，那么就不需要从磁盘读数据，但是如果覆盖的区域没有对齐到block_size，那么就需要把不对齐的那部分读出来，拼成一个对齐的buffer，然后新生成lextent，并且会对原来那个lextent进行调整，会记录需要回收的那部分区域。对于覆盖写的情况，都不是直接写盘，而是通过wal写到rocksdb。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEDD.tmp.jpg" alt></p><h6 id="整体写I-O的逻辑"><a href="#整体写I-O的逻辑" class="headerlink" title="整体写I/O的逻辑"></a>整体写I/O的逻辑</h6><p>​        之前组内同事画过一个流程图，这里借用一下算是一个简单的总结。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEDE.tmp.png" alt></p><h5 id="读I-O的处理"><a href="#读I-O的处理" class="headerlink" title="读I/O的处理"></a>读I/O的处理</h5><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEEF.tmp.jpg" alt></p><p>​        读I/O请求的处理时也是通过寻找相关联的lextent，可能会存在空洞的情况，即读到未写过的数据，这部分就直接补零。</p><h4 id="clone及extent共享"><a href="#clone及extent共享" class="headerlink" title="clone及extent共享"></a>clone及extent共享</h4><p>前面说到Bnode就是用来记录共享的lextent，目前是在做完快照后对原卷进行写I/O会触发cow，从而产生clone操作。clone时就是将原对象的blob从onode-&gt;blob_map移到onode-&gt;bnode-&gt;blob_map，并且将blob id置为负的，并设置共享标记，然后将新的快照对象的onode-&gt;bnode指向原对象的onode-&gt;bnode，并且用原onode里的lextents里的值赋给新的onode的lextents，从而达到共享extent的目的，图示仅供参考。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEF0.tmp.jpg" alt></p><p>​        在clone完之后，继续对原对象进行写I/O操作时，当碰到共享的blob时就需要跳过，新生成blob，并且取消对原来那部分lextent的引用，在后续的空间释放时的判断依据就是否还有引用。</p><p><img src="https://blog-picture-1259089570.cos.ap-guangzhou.myqcloud.com/wpsCEF1.tmp.png" alt></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>​        从BlueStore 的设计和实现上看，可以将其理解为用户态下的一个文件系统，同时使用RocksDB来实现BlueStore所有元数据的管理，简化实现。</p><p>​        对于整块数据的写入，数据直接以aio的方式写入磁盘，再更新RocksDB中数据对象的元数据，避免了filestore的先写日志，后apply到实际磁盘的两次写盘。同时避免了日志元数据的冗余存储占用，因为传统文件系统有他们自己内部的日志和元数据管理机制。</p><p>​        对于随机IO，直接WAL的形式，写入RocksDB 高性能的KV存储中。</p><p>​        本文总体上介绍了bluestore的架构、相关元数据及内部I/O映射的逻辑，这还只是bluestore的冰山一角，后续会陆续对bluestore的处理流程、空间分配器、缓存管理、压缩等实现进行分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        ceph后端支持多种存储引擎，以插件式的方式来进行管理使用，目前支持filestore，kvstore，memstore以及最新的bluestore，本文介绍的是bluestore的存储方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Ceph" scheme="http://yoursite.com/categories/Ceph/"/>
    
    
      <category term="ceph" scheme="http://yoursite.com/tags/ceph/"/>
    
  </entry>
  
</feed>
